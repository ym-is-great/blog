{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/site_title.png","path":"images/site_title.png","modified":0,"renderable":0},{"_id":"source/fonts/PermanentMarker-Regular.ttf","path":"fonts/PermanentMarker-Regular.ttf","modified":0,"renderable":0},{"_id":"themes/freestyle/source/css/app.styl","path":"css/app.styl","modified":1,"renderable":1},{"_id":"source/images/posts/2015/11/android_fragment.png","path":"images/posts/2015/11/android_fragment.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_intent_1.png","path":"images/posts/2015/11/android_intent_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_intent_2.png","path":"images/posts/2015/11/android_intent_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_json_1.png","path":"images/posts/2015/11/android_json_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_json_2.png","path":"images/posts/2015/11/android_json_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_sqlite.png","path":"images/posts/2015/11/android_sqlite.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_toast_1.png","path":"images/posts/2015/11/android_toast_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_toast_2.png","path":"images/posts/2015/11/android_toast_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_view_pager_1.png","path":"images/posts/2015/11/android_view_pager_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_view_pager_2.png","path":"images/posts/2015/11/android_view_pager_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/11/android_view_pager_3.png","path":"images/posts/2015/11/android_view_pager_3.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/12/android_list_view_1.png","path":"images/posts/2015/12/android_list_view_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/12/android_list_view_2.png","path":"images/posts/2015/12/android_list_view_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/12/android_list_view_3.png","path":"images/posts/2015/12/android_list_view_3.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/12/android_system_version_1.png","path":"images/posts/2015/12/android_system_version_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2015/12/android_system_version_2.png","path":"images/posts/2015/12/android_system_version_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_1.png","path":"images/posts/2016/01/android_toolbar_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_2.png","path":"images/posts/2016/01/android_toolbar_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_3.png","path":"images/posts/2016/01/android_toolbar_3.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_popover_1.png","path":"images/posts/2016/01/android_toolbar_popover_1.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_popover_2.png","path":"images/posts/2016/01/android_toolbar_popover_2.png","modified":0,"renderable":0},{"_id":"source/images/posts/2016/01/android_toolbar_popover_3.png","path":"images/posts/2016/01/android_toolbar_popover_3.png","modified":0,"renderable":0},{"_id":"source/images/posts/2017/02/https_installed.png","path":"images/posts/2017/02/https_installed.png","modified":0,"renderable":0},{"_id":"source/images/posts/2017/05/gulp_efficiency.png","path":"images/posts/2017/05/gulp_efficiency.png","modified":0,"renderable":0},{"_id":"source/images/posts/2017/11/lets_encrypt_logo.png","path":"images/posts/2017/11/lets_encrypt_logo.png","modified":0,"renderable":0},{"_id":"source/images/posts/2017/12/apidoc_ui.png","path":"images/posts/2017/12/apidoc_ui.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/05/vim_comment_after.png","path":"images/posts/2018/05/vim_comment_after.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/05/vim_comment_before.png","path":"images/posts/2018/05/vim_comment_before.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_layers.jpg","path":"images/posts/2018/11/pixi_practice_layers.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2018/12/android_project_structure.png","path":"images/posts/2018/12/android_project_structure.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/12/swift_logo.png","path":"images/posts/2018/12/swift_logo.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/12/wechat_block.png","path":"images/posts/2018/12/wechat_block.png","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_intro.jpg","path":"images/posts/2019/11/serverless_intro.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_practice.jpg","path":"images/posts/2019/11/serverless_practice.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_serverless_framework_deploy.jpg","path":"images/posts/2019/11/serverless_serverless_framework_deploy.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_adblock.png","path":"images/posts/2019/12/chrome_extension_adblock.png","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_debug_background.png","path":"images/posts/2019/12/chrome_extension_debug_background.png","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_popup.png","path":"images/posts/2019/12/chrome_extension_popup.png","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_structure.png","path":"images/posts/2019/12/chrome_extension_structure.png","modified":0,"renderable":0},{"_id":"source/images/posts/2017/08/shadowsocks_youtube.png","path":"images/posts/2017/08/shadowsocks_youtube.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/open_graph.jpg","path":"images/posts/2018/11/open_graph.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_camera.jpg","path":"images/posts/2018/11/pixi_practice_camera.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_brands.jpg","path":"images/posts/2019/11/serverless_brands.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_faas.jpg","path":"images/posts/2019/11/serverless_faas.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_openwhisk.jpg","path":"images/posts/2019/11/serverless_openwhisk.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_openwhisk_principle.jpg","path":"images/posts/2019/11/serverless_openwhisk_principle.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_scf_trigger.jpg","path":"images/posts/2019/11/serverless_scf_trigger.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_serverless_framework.jpg","path":"images/posts/2019/11/serverless_serverless_framework.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_management.jpg","path":"images/posts/2019/12/chrome_extension_management.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/12/chrome_extension_management.png","path":"images/posts/2019/12/chrome_extension_management.png","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_animated_sprite.jpg","path":"images/posts/2018/11/pixi_practice_animated_sprite.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2019/11/serverless_pizza_as_a_service.jpg","path":"images/posts/2019/11/serverless_pizza_as_a_service.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_candy_house_sign.gif","path":"images/posts/2018/11/pixi_practice_candy_house_sign.gif","modified":0,"renderable":0},{"_id":"source/images/posts/2017/03/mini_program_practice.gif","path":"images/posts/2017/03/mini_program_practice.gif","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_design.jpg","path":"images/posts/2018/11/pixi_practice_design.jpg","modified":0,"renderable":0},{"_id":"source/images/posts/2018/11/pixi_practice_preview.gif","path":"images/posts/2018/11/pixi_practice_preview.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/index.html","hash":"2704c1d8c3fc215c38ee176f6cc30e434a22b7d7","modified":1593401626430},{"_id":"themes/freestyle/_config.yml","hash":"7beb6cf984c2939dbff85cce0410ec19607f25ee","modified":1593401626468},{"_id":"source/_posts/2015-11-02@Android 使用 Fragment 构造页面.md","hash":"41045bcd8080e397c18c27dde71eba6344b00677","modified":1593401562128},{"_id":"source/_posts/2015-10-30@搭建 Android 开发环境.md","hash":"1fb6c2e18bfa8ed41680c1a89bb94f9a9063d544","modified":1593401562128},{"_id":"source/_posts/2015-11-04@Android 使用 Toast 显示提示消息.md","hash":"3637bbefbb8b480baff2be0f7fa4ee50226b7e93","modified":1593401562129},{"_id":"source/_posts/2015-11-05@使用 ViewPager 实现页面滑动.md","hash":"e903e004034f9e51daacc2f8987bc0539b80df60","modified":1593401562129},{"_id":"source/_posts/2015-11-08@原生 SQL 语句操作 SQLite 数据库.md","hash":"83db10c8c5e4537280515c4e437ecb27ec598254","modified":1593401562129},{"_id":"source/_posts/2015-11-10@Android 存储和解析 JSON 数据.md","hash":"0d225cbed6ce3396a761f3a73b4134694b1c91bc","modified":1593401562129},{"_id":"source/_posts/2015-11-29@Android 实现“再按一次退出程序”.md","hash":"796870f4b6c7ec4a5aacf0edf6ce0c1e38cfee03","modified":1593401562130},{"_id":"source/_posts/2015-11-11@使用 Intent 实现页面跳转与传值.md","hash":"2eea0c5c85ac23dd308df6e5c8e5373824fda9a9","modified":1593401562130},{"_id":"source/_posts/2015-12-05@Android 判断系统版本.md","hash":"249fa925d36b04cd01e28315bd04982d0ffcf73e","modified":1593401562130},{"_id":"source/_posts/2015-12-05@Android 应用中使用外部字体.md","hash":"5b56eb54634fb216a0a009d6e6aff0cc71eb156e","modified":1593401562130},{"_id":"source/_posts/2015-12-05@使用 layer-list 实现控件阴影.md","hash":"d50cf485a5c4be3f0a9e1715e3a728e65a495726","modified":1593401562130},{"_id":"source/_posts/2015-12-07@Android 使用 ListView 实现列表.md","hash":"3e345d073a4b266cb386c5cc0f422b4eb0c2176d","modified":1593401562131},{"_id":"source/_posts/2015-12-07@使用隐式 Intent 调用其他应用.md","hash":"eb4f2e2483d20f695a532d020b4c85e7f4871a5a","modified":1593401562131},{"_id":"source/_posts/2015-12-15@使用 DatePickerDialog 选择日期.md","hash":"4de531dae9f305d9cd7dc6d48e4b4141031ecddd","modified":1593401562131},{"_id":"source/_posts/2015-12-15@根据系统版本设置不同的主题.md","hash":"c82ce6e8537830d4f4a5013ccf7466a6138b8bc3","modified":1593401562131},{"_id":"source/_posts/2016-01-08@Android 监听设备的开屏与锁屏事件.md","hash":"c83d9facf1657eeded14381d64399b981ee5b2a0","modified":1593401562132},{"_id":"source/_posts/2016-01-27@阻止键盘自动弹出 点击空白处结束输入.md","hash":"d659f2d32311426c31d6393b01a6150f2e9f64b3","modified":1593401562132},{"_id":"source/_posts/2016-01-28@Android 实现导航栏下拉菜单.md","hash":"7310db0fc570183988b09d7ee3e28c81d5dc4621","modified":1593401562132},{"_id":"source/_posts/2016-01-28@使用 ToolBar 实现自定义导航栏.md","hash":"53943581693be9be247dbc27115aa743d8a43abc","modified":1593401562132},{"_id":"source/_posts/2016-01-29@Android 客户端发送 GET 请求.md","hash":"f40fcf09b62059bff004fdfa092779eb6175cbec","modified":1593401562133},{"_id":"source/_posts/2016-01-31@Android 与服务端的 Session 保持.md","hash":"dcfb705d741230afc0bcb9bbdcd17cc008c69e75","modified":1593401562133},{"_id":"source/_posts/2016-02-06@解决 SQLite 把空值转为字符串.md","hash":"314217fda70b71ce69c3afe2100b2f7a100c08ef","modified":1593401562133},{"_id":"source/_posts/2016-02-07@Android 上传文件到 PHP 服务端.md","hash":"e20f90368aeeab96b8f94c01dbe6010dc4ba0023","modified":1593401562133},{"_id":"source/_posts/2016-02-07@Fragment onResume 方法无效问题.md","hash":"35a6b2029746a2e1a3cb52624d5e1cd57a39e03d","modified":1593401562133},{"_id":"source/_posts/2016-02-08@PHP 中正确计算中文字数.md","hash":"a2b61d17ea5bae4d4a4b601b44c83697b91caab5","modified":1593401562134},{"_id":"source/_posts/2016-02-08@使用 AlertDialog 实现自定义对话框.md","hash":"13cf5ffd5673d34182ec7f896cf3439a5e579cd9","modified":1593401562134},{"_id":"source/_posts/2016-02-08@使用 shape 实现矢量圆角背景.md","hash":"c8360ca23864fc005482e95672bb36f335cea62d","modified":1593401562134},{"_id":"source/_posts/2016-02-13@EditText 光标定位到最后.md","hash":"20d0337afc2d7024af2a586c3f0c865e6412ff6f","modified":1593401562135},{"_id":"source/_posts/2016-02-13@全局获取 Context 的两种方法.md","hash":"76793ef4ef4c4b086ea4083e2eea6b4990be6da4","modified":1593401562135},{"_id":"source/_posts/2016-04-07@修改 Tomcat 服务器默认字符.md","hash":"00a47f0ec3171dfe662a3dc965495900f6898d79","modified":1593401562135},{"_id":"source/_posts/2016-08-10@通过 CSS 引用外部字体.md","hash":"b94367a3b47110267a45b087c1e043756defdea3","modified":1593401562135},{"_id":"source/_posts/2016-08-02@获取浏览器可视区域的尺寸.md","hash":"f89d3fe5a791c2a938edb16b531401bf5a60f297","modified":1593401562135},{"_id":"source/_posts/2016-08-11@JS 倒计时代码.md","hash":"aba291dbd928da3d57c66075e5cc69254f11072d","modified":1593401562136},{"_id":"source/_posts/2016-08-11@jQuery 使用 AJAX 实现异步请求.md","hash":"cf33267f1e3f9d27e8f6426b31aad445ab355b50","modified":1593401562136},{"_id":"source/_posts/2016-08-14@PHP 中实现 URL 跳转.md","hash":"8d24a03827705c9ad9886261b562ad0094bee467","modified":1593401562136},{"_id":"source/_posts/2016-08-21@Textarea 的换行符处理.md","hash":"61eb6efdad357226b036875ce4660970275916a3","modified":1593401562136},{"_id":"source/_posts/2016-08-28@Canvas 不支持使用 CSS 设置尺寸.md","hash":"cd15d6c46523e312fb49f3a42ade548c34952277","modified":1593401562137},{"_id":"source/_posts/2016-08-28@Cropper + Canvas 实现用户头像裁剪与上传.md","hash":"4b626d5daf3fb3a8594a7bd6bbbacd03f233d534","modified":1593401562137},{"_id":"source/_posts/2016-08-28@检测浏览器是否支持 H5.md","hash":"8c6f055c422c75a4be32186d381df4aef5b3dbc0","modified":1593401562137},{"_id":"source/_posts/2016-08-30@CSS3 实现全屏背景图片.md","hash":"85b28bdc770590d2eef9f029d2cc9d8e6fc16c98","modified":1593401562137},{"_id":"source/_posts/2016-08-30@WampServer 局域网访问配置.md","hash":"c764f15ba1dc6e710e379cf583830046f280f4ac","modified":1593401562137},{"_id":"source/_posts/2016-09-01@判断页面是否在 iFrame 中.md","hash":"e792e656c82cf68e0118656eea95f16663605fc7","modified":1593401562138},{"_id":"source/_posts/2016-09-03@一个小技巧强制刷新浏览器缓存的图片.md","hash":"7a72e9eadac878845ef7534a6b7075ecb4ffb3c3","modified":1593401562138},{"_id":"source/_posts/2016-09-09@PHP中 使用 JSON 数据.md","hash":"b7b454275c44da90e232913ef14266725358970c","modified":1593401562138},{"_id":"source/_posts/2016-09-10@Textarea 禁用回车换行.md","hash":"6a433bf7b81b0e3f97cf85c3d5cdfe7bf2c97c9d","modified":1593401562138},{"_id":"source/_posts/2016-09-10@解决 json_encode 中文乱码.md","hash":"fc4a3a4b3f9f00f3568e2d6b5e540545d16743e1","modified":1593401562139},{"_id":"source/_posts/2016-09-12@Rewrite 后 GET 参数丢失的处理.md","hash":"f283416d81fc3fddb4b38c5276dd898c6536748b","modified":1593401562139},{"_id":"source/_posts/2016-09-12@Rewrite 禁止访问某种文件.md","hash":"29f87bad2c72f72413addfbf8a498de6b832ecaa","modified":1593401562139},{"_id":"source/_posts/2016-09-13@文字溢出时隐藏并加省略号.md","hash":"cc59f52c28213c289952a9faeaa2cd78968451c6","modified":1593401562139},{"_id":"source/_posts/2016-09-19@CSS3 文字阴影效果.md","hash":"c2cca4c906d6b3d907ecde42f0b47012be1e1af9","modified":1593401562139},{"_id":"source/_posts/2016-09-19@PHP 删除数组中的元素.md","hash":"0ffd6f4095c9e3b012daa0047afb0af66e1ece14","modified":1593401562140},{"_id":"source/_posts/2016-09-19@Textarea 限制字符长度.md","hash":"53b2a3887a48a0c5caa94e2c414e7142bb80c82e","modified":1593401562140},{"_id":"source/_posts/2016-09-29@使用 PHP 设置 Cookie.md","hash":"42f998c0d2e9a33d773fe4ecca282306d3deb7c7","modified":1593401562140},{"_id":"source/_posts/2016-10-22@Wordpress 创建子主题.md","hash":"8787fddfbb3c75c0302773473c10422828eaab47","modified":1593401562140},{"_id":"source/_posts/2016-10-23@Git、Shell、Git Shell、Git Bash.md","hash":"9809c037aff24888e60c79b6354dc453104f0034","modified":1593401562141},{"_id":"source/_posts/2016-10-23@Homestead 开发环境配置.md","hash":"71786d2be17c4107c159cfaed45aa9b5c3f77438","modified":1593401562141},{"_id":"source/_posts/2016-10-24@手动下载和安装 Homestead.md","hash":"5914f30dfb55668161e8003f748418303d6b7aed","modified":1593401562141},{"_id":"source/_posts/2016-10-27@局域网访问 Homestead 站点.md","hash":"8e0fbe33717daf8fe19d079e664abead40ab9b4b","modified":1593401562141},{"_id":"source/_posts/2016-10-29@在 Homestead 上安装 phpMyAdmin.md","hash":"e992d8edf4472994e21da4e2f9ea85fab8f658d3","modified":1593401562141},{"_id":"source/_posts/2016-10-30@使用 Vue.js 实现模态窗口.md","hash":"dc63c003b944a7e474d11b0ebcdd3d25634e25b7","modified":1593401562142},{"_id":"source/_posts/2016-11-05@Laravel 框架操作数据库.md","hash":"c5f415cb9d9c8a916534821d428eb3be269217dc","modified":1593401562142},{"_id":"source/_posts/2016-11-06@Laravel 使用 SMTP 发送邮件.md","hash":"1da680db07ac39ab6ddc012cc987f4ff0599539b","modified":1593401562142},{"_id":"source/_posts/2016-11-21@WampServer 配置虚拟主机.md","hash":"85ffc65247af9e79eae953938e4a76e6d0e83c0a","modified":1593401562142},{"_id":"source/_posts/2016-11-28@解决 iOS 下 click 点击事件失效.md","hash":"db924fa65b985d1e2f85f4f67a590f2e67453edb","modified":1593401562142},{"_id":"source/_posts/2016-12-02@使用 CSS 实现 DIV 垂直居中.md","hash":"5dbcccd48989d801cd4b26cffe7eba13620ef62c","modified":1593401562143},{"_id":"source/_posts/2016-12-03@SSH 登录 VirtualBox 虚拟机.md","hash":"8a29ffd38cb1815978ff0e1e9b10d3f40422ce92","modified":1593401562143},{"_id":"source/_posts/2016-12-03@VirtualBox 创建 Linux 虚拟机.md","hash":"8408f42ca1d201070bd9b0f983c026f60c844ef0","modified":1593401562143},{"_id":"source/_posts/2016-12-13@Linux 编译安装 Apache2.4.md","hash":"166cb3091d456f4305bfb7373f2156abd30c28af","modified":1593401562143},{"_id":"source/_posts/2016-12-13@解决 jQuery 事件重复绑定.md","hash":"cc9ec8eb6666b7a0e9e7ac992b605daa18c0f993","modified":1593401562144},{"_id":"source/_posts/2016-12-15@Linux 编译安装 MySQL5.66.md","hash":"fb810a866788ac9c016538a13c1d45c617b531a2","modified":1593401562144},{"_id":"source/_posts/2016-12-15@Linux 编译安装 PHP7.1.md","hash":"86b87480b2d95455f75098c37ba7560ef0539465","modified":1593401562144},{"_id":"source/_posts/2016-12-18@Apache 禁止使用 IP 访问网站.md","hash":"44272dd1c84cd9099fdeaa130e180c79d02bddf4","modified":1593401562144},{"_id":"source/_posts/2016-12-20@编译安装 PHP 拓展.md","hash":"762b22ee3ec7468d0e93490786b74e68344e6257","modified":1593401562144},{"_id":"source/_posts/2016-12-23@解决无法用 localhost 连接 MySQL.md","hash":"fa06e04500531e8cb37a9c28436dfb675c88cee3","modified":1593401562145},{"_id":"source/_posts/2016-12-29@使 Nginx 支持 WordPress 固定链接.md","hash":"00b3c7f84916eda6aaeeebaad60054d9330d7fc8","modified":1593401562145},{"_id":"source/_posts/2017-01-23@生成与管理 SSH Key.md","hash":"35ec91b35dd3cffce343fe344df0e91c5696ce41","modified":1593401562145},{"_id":"source/_posts/2017-02-12@使用 Intervention Image 库处理图片.md","hash":"a45f51d1b3e809168febdbdd008637ecb1cdc52c","modified":1593401562146},{"_id":"source/_posts/2017-02-16@使用 Laravel Excel 导入导出 Excel & CSV.md","hash":"b84d549219460241d55f7503a9ce939c6b4ec2e0","modified":1593401562146},{"_id":"source/_posts/2017-02-17@为你的网站开启 HTTPS.md","hash":"3b43d6b3895e15f6936b693d1cb216c0e973dc80","modified":1593401562146},{"_id":"source/_posts/2017-02-23@不用 JSSDK 自定义微信分享标题和缩略图.md","hash":"407f155a189b268ab1380ada71c9e22e305da830","modified":1593401562146},{"_id":"source/_posts/2017-03-03@解决移动端 ES6 兼容问题.md","hash":"e80bd816cdf3f3e2c43166f6b0cab39d28b3c044","modified":1593401562147},{"_id":"source/_posts/2017-03-13@将 WordPress 移动到子目录.md","hash":"3b3f7512de8d298b5404d75068959b0e543d0c96","modified":1593401562147},{"_id":"source/_posts/2017-03-16@Sass 快速入门.md","hash":"aad57fb69b5acb8a45aad08515f40f537115da05","modified":1593401562147},{"_id":"source/_posts/2017-03-28@手把手教你开发一个微信小程序.md","hash":"80bf0808eac21d0ff3425f83a1f6f7f16426ec84","modified":1593401562147},{"_id":"source/_posts/2017-04-17@BAE 实现 WordPress 固定链接.md","hash":"d52c1fe04c824c3d040a145f5cb4a212117a9096","modified":1593401562148},{"_id":"source/_posts/2017-04-23@Git 使用命令方式实现免密码操作.md","hash":"41f799e570f31ef9fea963cd84821f186a42b31e","modified":1593401562148},{"_id":"source/_posts/2017-04-28@使用 JavaScript 清空上传控件的值.md","hash":"ae81a36a42d51cfdfdb9a3b5702b86ac6d978a7c","modified":1593401562148},{"_id":"source/_posts/2017-05-03@PHP 使用 Guzzle 发送 http 请求.md","hash":"33f764442fa81b8ae772d5707b3ba819d719b57f","modified":1593401562148},{"_id":"source/_posts/2017-05-14@使用 Hexo 搭建静态博客.md","hash":"64ab925ab2e00a8b7d7354a879e75aa08198c22f","modified":1593401562149},{"_id":"source/_posts/2017-05-18@JavaScript 实现回到顶部.md","hash":"ee74780d02360ff4f5cb29d6ff4b0f06e3e906f6","modified":1593401562149},{"_id":"source/_posts/2017-05-20@gulp 小教程.md","hash":"aeeed908d3dce3d33826af101a05ee469cf4002d","modified":1593401562149},{"_id":"source/_posts/2017-06-11@Laravel 使用 JWT 实现用户认证.md","hash":"8e89714c163271ec6885d6125da30fce7ad9a85c","modified":1593401562149},{"_id":"source/_posts/2017-06-27@移动端实现0.5像素细边框.md","hash":"9ba36f1fd7dfd7a7ceaa59ddda7f076073631520","modified":1593401562150},{"_id":"source/_posts/2017-09-03@CSS3 自定义滚动条样式.md","hash":"16db02b1e08392092bebe1694b4cb24118c4c812","modified":1593401562150},{"_id":"source/_posts/2017-09-28@解决 iOS 下日期对象 Invalid Date 错误.md","hash":"96ee37a8d82d34d6ed8b48dbc52c10e976f01c22","modified":1593401562150},{"_id":"source/_posts/2017-11-03@JavaScript 或 Vue.js 实现时分秒倒计时.md","hash":"d4e559c69e021ce97769eee21978fb34c4ae6632","modified":1593401562150},{"_id":"source/_posts/2017-12-04@阻止微信浏览器下拉查看网址.md","hash":"7d32630570d326fd55d6c03e4cf19d7cc797c3f7","modified":1593401562151},{"_id":"source/_posts/2017-11-15@Let's Encrypt：免费 SSL 证书申请与部署.md","hash":"8cfae6d83e9159c6d4dd6235950e58512efe0927","modified":1593401562151},{"_id":"source/_posts/2017-12-27@使用 apiDoc 自动生成 API 文档.md","hash":"c6f05337057e07c0534b191c61a7bcdf2568099d","modified":1593401562151},{"_id":"source/_posts/2018-02-21@使用 Certbot 申请和部署 SSL 证书.md","hash":"06a54fd27b8d9955556cfc2a03372944714885b7","modified":1593401562151},{"_id":"source/_posts/2018-03-20@记博客更换域名并迁移至 GitHub Pages.md","hash":"23449091fd51c60b0dbceb19c8c8c902dd337fb6","modified":1593401562151},{"_id":"source/_posts/2018-04-03@使用 Node.js 部署静态资源到七牛云.md","hash":"cb8f98c17bb6ff48d71d90f422e0697c7e1b4e24","modified":1593401562152},{"_id":"source/_posts/2018-05-09@自定义 Vim 编辑器的注释颜色.md","hash":"9a9425516a9949934216e9d33fa8a4614e7b1aa0","modified":1593401562152},{"_id":"source/_posts/2018-06-10@如何优雅地和译者协作开发多语言 WebApp.md","hash":"14118d96d3547730c62fd11bb7bb1d5cc05bcc3e","modified":1593401562152},{"_id":"source/_posts/2018-09-02@Laravel 快速入门.md","hash":"980be27428e3ec59ce56a41e2846f76055ea2606","modified":1593401562152},{"_id":"source/_posts/2018-10-10@PixiJS 实战万圣节主题横版 H5.md","hash":"fc858bf348831a2a73bcae148e95dacbf5c78e70","modified":1593485709836},{"_id":"source/_posts/2018-12-18@Swift 语言入门学习笔记.md","hash":"397dffcd5caa530e73afd5de43083eb4fbd1def3","modified":1593401562153},{"_id":"source/_posts/2018-11-15@海外主流社交 APP 分享指南.md","hash":"46d1613d798e9a5dd2caaa6845533498ec7c38cb","modified":1593401562153},{"_id":"source/_posts/2018-12-22@Android 应用接入微信分享.md","hash":"f126f310ce93849ba0411b1414e512eabc011596","modified":1593401562153},{"_id":"source/_posts/2019-03-15@Promise 的原理与简单实现.md","hash":"f5bfdcdaee4ee0112f08b201397b19a8970efbe4","modified":1593401562153},{"_id":"source/_posts/2019-05-27@混合开发：Android 与 JavaScript 的相互通信.md","hash":"3a18c52436c801c13bd72a0fbbe3c9bd527e0cb4","modified":1593401562154},{"_id":"source/_posts/2019-11-24@Serverless 上车指南.md","hash":"37a6889530dd1a1193f9dd3d4512159dc92584a0","modified":1593401562154},{"_id":"source/_posts/2019-12-21@Chrome 扩展从入门到 HelloWorld.md","hash":"96e32fc98062aaab40f5a121608a2b35f94f07a1","modified":1593483011508},{"_id":"source/images/site_title.png","hash":"b0806741b9be5f55668972fe4e501e58f5e04921","modified":1593401626430},{"_id":"themes/freestyle/layout/index.ejs","hash":"f06be187e6bc160d26233600b345205b3f3b824c","modified":1593483011508},{"_id":"themes/freestyle/layout/layout.ejs","hash":"00258d226d3bdea9654d4482bf82f2c2dcee91e5","modified":1593487729374},{"_id":"themes/freestyle/layout/page.ejs","hash":"cf276bc103cc5c3a439e4484653797969e87c80b","modified":1593401626470},{"_id":"themes/freestyle/layout/post.ejs","hash":"fb9e98f74b335081c1e7c789a60f49e4ed5e0ae5","modified":1593483011509},{"_id":"source/fonts/PermanentMarker-Regular.ttf","hash":"6d0bcddcb32c60bb9c75eacdffb5deef7913ebf2","modified":1593401626430},{"_id":"themes/freestyle/source/css/app.styl","hash":"f8557529e73f35859c0083939969313d587bf274","modified":1593497883328},{"_id":"themes/freestyle/source/css/_common/variables.styl","hash":"a20e485e48f5fad1081dfd1b3ee0d104e1ebb8fe","modified":1593489760957},{"_id":"source/images/posts/2015/11/android_fragment.png","hash":"a9e91e6d083cb5883c2d9bdde15b94963e1df6e8","modified":1593401562157},{"_id":"source/images/posts/2015/11/android_intent_1.png","hash":"81d1635fea8083119aef523eb441e4bc09b22f76","modified":1593401562157},{"_id":"source/images/posts/2015/11/android_intent_2.png","hash":"e5e5ba44028acd56de60d63b684beb24e222198a","modified":1593401562157},{"_id":"source/images/posts/2015/11/android_json_1.png","hash":"be4ec594b19d1fd84eb7218af41483ed535df91b","modified":1593401562157},{"_id":"source/images/posts/2015/11/android_json_2.png","hash":"bc1e8108dda305954addc61e6625f78aeea71217","modified":1593401562158},{"_id":"source/images/posts/2015/11/android_sqlite.png","hash":"0683d92840c5b6e3e1c110cbc9dcecc4956b7b00","modified":1593401562158},{"_id":"source/images/posts/2015/11/android_toast_1.png","hash":"526d14eb316583dd33048547c1bda4a95343ce37","modified":1593401562158},{"_id":"source/images/posts/2015/11/android_toast_2.png","hash":"ee4a2ab57b869d4652528b065039204a3cfd6a08","modified":1593401562158},{"_id":"source/images/posts/2015/11/android_view_pager_1.png","hash":"65d802b14534b57dd529518f1f6e01498ea3462f","modified":1593401562158},{"_id":"source/images/posts/2015/11/android_view_pager_2.png","hash":"52dc55130810ddb765715a43dffea630fffbfa12","modified":1593401562159},{"_id":"source/images/posts/2015/11/android_view_pager_3.png","hash":"82a3bef437c75966c032b225e622450cfc7455a2","modified":1593401562159},{"_id":"source/images/posts/2015/12/android_list_view_1.png","hash":"5ef997f1f3f2384a3ad9c74a808467f0c553d495","modified":1593401562159},{"_id":"source/images/posts/2015/12/android_list_view_2.png","hash":"d70bde0bf9e5beea6bedcff0faf12ec2cac02d84","modified":1593401562160},{"_id":"source/images/posts/2015/12/android_list_view_3.png","hash":"5e019680daa4b1ddf397e6b937ee61605a1701d9","modified":1593401562160},{"_id":"source/images/posts/2015/12/android_system_version_1.png","hash":"10da993495e0086da1b2afd60cf123ac83b81f23","modified":1593401562160},{"_id":"source/images/posts/2015/12/android_system_version_2.png","hash":"d4c638e4efce2c655106253acff76284ee77fb25","modified":1593401562161},{"_id":"source/images/posts/2016/01/android_toolbar_1.png","hash":"044b99489d3d4f586ddf82f94cf338ef41c7b206","modified":1593401562161},{"_id":"source/images/posts/2016/01/android_toolbar_2.png","hash":"07725feac80d325c7af678c24a8de752edf8772c","modified":1593401562161},{"_id":"source/images/posts/2016/01/android_toolbar_3.png","hash":"48fbb7914ed1eb59cf440d32d028e68ed0c437a5","modified":1593401562162},{"_id":"source/images/posts/2016/01/android_toolbar_popover_1.png","hash":"283b425664d5ac6e82333400b14aed2e742e3281","modified":1593401562162},{"_id":"source/images/posts/2016/01/android_toolbar_popover_2.png","hash":"c4104671573dc34abc0e96ceb2578e6178e8e81c","modified":1593401562162},{"_id":"source/images/posts/2016/01/android_toolbar_popover_3.png","hash":"bb60bd1be3899541e341cbbb2d6ba9f2220c36eb","modified":1593401562163},{"_id":"source/images/posts/2017/02/https_installed.png","hash":"273a13e494dd36b55b5d86903817ac08ba71894c","modified":1593401562163},{"_id":"source/images/posts/2017/05/gulp_efficiency.png","hash":"60ce6a85e93124e44831aeb72afe32e60f23d1b2","modified":1593401562165},{"_id":"source/images/posts/2017/11/lets_encrypt_logo.png","hash":"b9fd0889826b5f21c7e366a492a6d2bf27622080","modified":1593401562166},{"_id":"source/images/posts/2017/12/apidoc_ui.png","hash":"70bf70bbb00f1e11eb4d7ea8468beacdd96ae644","modified":1593401562167},{"_id":"source/images/posts/2018/05/vim_comment_after.png","hash":"2ba1abd49c63d89a40d8f500e5e5db8e9256ed4a","modified":1593401562167},{"_id":"source/images/posts/2018/05/vim_comment_before.png","hash":"c4c68e225c4d6a06c3d42ce01877d963d8f22d0c","modified":1593401562167},{"_id":"source/images/posts/2018/11/pixi_practice_layers.jpg","hash":"ddc6080b445867648aa669906f2b8f1aab6e5352","modified":1593401562175},{"_id":"source/images/posts/2018/12/android_project_structure.png","hash":"fdee69f3a8333148e623ac5d9b7e14360ea20e48","modified":1593401562188},{"_id":"source/images/posts/2018/12/swift_logo.png","hash":"6d41f11113d34a10b03955596356b07f4a878d1e","modified":1593401562188},{"_id":"source/images/posts/2018/12/wechat_block.png","hash":"c6bd12efde9f4f2b69949b87dc0656670f813779","modified":1593401562189},{"_id":"source/images/posts/2019/11/serverless_intro.jpg","hash":"3af8131e4456f5ba26123fa32bfbb0e7da3b78b0","modified":1593401562191},{"_id":"source/images/posts/2019/11/serverless_practice.jpg","hash":"24fbeb0363949a50b23ca5d6e4625470947ec521","modified":1593401562194},{"_id":"source/images/posts/2019/11/serverless_serverless_framework_deploy.jpg","hash":"cf0a280102b284cb88222cd6b11941c00c13e4e5","modified":1593401562197},{"_id":"source/images/posts/2019/12/chrome_extension_adblock.png","hash":"11a54f1e8ba8d5ac7c5a58996352cfd09bd2a056","modified":1593401562197},{"_id":"source/images/posts/2019/12/chrome_extension_debug_background.png","hash":"69b9f5cce08d383ae8318288873207a3c27c7d9f","modified":1593401562197},{"_id":"source/images/posts/2019/12/chrome_extension_popup.png","hash":"4008ade0300ebed5124a39008af1077f241c0669","modified":1593401562199},{"_id":"source/images/posts/2019/12/chrome_extension_structure.png","hash":"a282066378eecddd6cd3997e1921cdf7542e8aea","modified":1593401562200},{"_id":"source/images/posts/2017/08/shadowsocks_youtube.png","hash":"ff5ab3de82580340753013274394af43b32419e3","modified":1593401562166},{"_id":"source/images/posts/2018/11/open_graph.jpg","hash":"1321a6efb0306b6a70f60196795331d2f832c8da","modified":1593401562168},{"_id":"source/images/posts/2018/11/pixi_practice_camera.jpg","hash":"6eb95b93a95ac0d1465ea65fa3f9eca5ee58375a","modified":1593401562171},{"_id":"source/images/posts/2019/11/serverless_brands.jpg","hash":"5b3b90837bc0b3ed396bb387d343ce595cf97dde","modified":1593401562189},{"_id":"source/images/posts/2019/11/serverless_faas.jpg","hash":"f30c8723f8b82d1cda63facf0b2b60a4f62b0366","modified":1593401562190},{"_id":"source/images/posts/2019/11/serverless_openwhisk.jpg","hash":"65d37cb79b363a4eae721ac2d1b53093c2f8ef1e","modified":1593401562192},{"_id":"source/images/posts/2019/11/serverless_openwhisk_principle.jpg","hash":"cbbc2dbdcf8734ddd8ee2dda82cb62393ba323f4","modified":1593401562193},{"_id":"source/images/posts/2019/11/serverless_scf_trigger.jpg","hash":"aa8e7202f6eeec8491d7dd3f31de14ddf7cc74c9","modified":1593401562195},{"_id":"source/images/posts/2019/11/serverless_serverless_framework.jpg","hash":"bb69418ef16971667b8d2abb5d1ed5fe38c2705a","modified":1593401562196},{"_id":"source/images/posts/2019/12/chrome_extension_management.jpg","hash":"000fae21feca9bb7680ededb0519354be21c51c6","modified":1593401562198},{"_id":"source/images/posts/2019/12/chrome_extension_management.png","hash":"4e6c0fb5ab55a23a45cf86f7e6dfab1c72371b78","modified":1593401562199},{"_id":"source/images/posts/2018/11/pixi_practice_animated_sprite.jpg","hash":"46b892009a417464df0e242dc55ba28a8baf7b15","modified":1593401562170},{"_id":"source/images/posts/2019/11/serverless_pizza_as_a_service.jpg","hash":"86ee327e00dd3b491f233c99775ab575bd260e45","modified":1593401562194},{"_id":"source/images/posts/2018/11/pixi_practice_candy_house_sign.gif","hash":"cab0d25c333763fd6c532751782695424edd832b","modified":1593401562172},{"_id":"source/images/posts/2017/03/mini_program_practice.gif","hash":"b4222f4097634b70071f7a44c8809729c8dbc251","modified":1593401562165},{"_id":"source/images/posts/2018/11/pixi_practice_design.jpg","hash":"b05aed76d3cbdc8952ad57ac251c78d9b25651ee","modified":1593401562174},{"_id":"source/images/posts/2018/11/pixi_practice_preview.gif","hash":"52fce231461e95e6a44ffa1ca24463b58d6fa659","modified":1593401562187},{"_id":"public/index.html","hash":"43192f748f48ab66a76621467cbd857ab4cb19ab","modified":1593487265774},{"_id":"public/blog/201912210126/index.html","hash":"6ccef583decb7ebee6611b40f414207b3196a0a8","modified":1593485162167},{"_id":"public/blog/201905270037/index.html","hash":"c69a6ca613dd49dec45df3f9daf6c9272f07d981","modified":1593485162167},{"_id":"public/blog/201903152149/index.html","hash":"3abae7c259bee3cbee1ca30838d58b3742ba0e90","modified":1593485162167},{"_id":"public/blog/201812221835/index.html","hash":"3b0c15908ccfcfdc231ad31d6d75d873892b6b6f","modified":1593485162167},{"_id":"public/blog/201812182120/index.html","hash":"b9e1153afc31f7c599bff24104bbfb7af73e6935","modified":1593485162167},{"_id":"public/blog/201811151317/index.html","hash":"b7190166140802b41896c1bb43e7983392a137ab","modified":1593485162167},{"_id":"public/blog/201811112150/index.html","hash":"a0924c89ed825b550b0c8d5c0c9945f33be50477","modified":1593485162167},{"_id":"public/blog/201809022300/index.html","hash":"67ca60b258f1e517fe8371f2d8047e62964b52f3","modified":1593485162167},{"_id":"public/blog/201806102124/index.html","hash":"e37b684e6ec8617c3498233767fac6bce32f6b71","modified":1593485162167},{"_id":"public/blog/201805091633/index.html","hash":"c58e093b450e136e820f898ee6974f793a73897d","modified":1593485162167},{"_id":"public/blog/201804032248/index.html","hash":"97555bb70bc94b6d7fb4f6910e4619b49c2c7526","modified":1593485162167},{"_id":"public/blog/201803201114/index.html","hash":"175cc8bf5697a28b774608754eedc5f49985bcec","modified":1593485162167},{"_id":"public/blog/201802211638/index.html","hash":"3149f18f86ff54fc35a1793788955e7147adbe4c","modified":1593485162167},{"_id":"public/blog/201712270023/index.html","hash":"14d4c5ee05656e9a26fde80d3cfefcdad0480ae0","modified":1593485162167},{"_id":"public/blog/201712042239/index.html","hash":"c5a21ebca1f2ca52cb27198de1e29360066f6602","modified":1593485162167},{"_id":"public/blog/201711151432/index.html","hash":"8d9c6807c2f5a823753529f979223005b88e29bc","modified":1593485162167},{"_id":"public/blog/201711032345/index.html","hash":"81a2c7e0ba364a56b9f4e459d6dce96768b23431","modified":1593485162167},{"_id":"public/blog/201709282141/index.html","hash":"0f3ff5c6bbb239d63da4764caf0f6c9f8dc5a43a","modified":1593485162167},{"_id":"public/blog/201709031318/index.html","hash":"bd6f8ab2aaea854beb6e6000cc17880d0aa93334","modified":1593485162167},{"_id":"public/blog/201706270002/index.html","hash":"6e0f535d7a8a19a07542d56955f5b931c5a77538","modified":1593485162167},{"_id":"public/blog/201706111300/index.html","hash":"886232e0a21bb53e3b3a59a1120d4ee1ea65fa47","modified":1593485162167},{"_id":"public/blog/201705201637/index.html","hash":"203f55033d7471ae9a767b258330d2dce42d7bab","modified":1593485162167},{"_id":"public/blog/201705181334/index.html","hash":"692abbbecfc4cabafbdf0aafe955ece7ace23f32","modified":1593485162167},{"_id":"public/blog/201705141050/index.html","hash":"9cd83a853f6fb8a47eacdff9928684b889aceb92","modified":1593485162167},{"_id":"public/blog/201705031841/index.html","hash":"759e21998523c068625dd5e02f4f4ecc02e9caf0","modified":1593485162167},{"_id":"public/blog/201704280003/index.html","hash":"699f02f3a749ac3a37851156713555986b50488d","modified":1593485162167},{"_id":"public/blog/201704231552/index.html","hash":"d494d4c7c43d61fe91d5ca3eefd26c2d95be19b0","modified":1593485162167},{"_id":"public/blog/201704170054/index.html","hash":"49f67cc10e26e583323c14098077f42987754994","modified":1593485162167},{"_id":"public/blog/201703281144/index.html","hash":"cd4a5a0a464a179fbd6a7855c322eb9fa7881b18","modified":1593485162167},{"_id":"public/blog/201703161308/index.html","hash":"711cb908f7a58d11651986871d8b7f7f1c15e768","modified":1593485162167},{"_id":"public/blog/201703131746/index.html","hash":"a1abb07e8524cee0eba0a8a9e11380ca03aff436","modified":1593485162167},{"_id":"public/blog/201703031619/index.html","hash":"7ef9b75d2cb88c0c3b4681b14fea81773c853834","modified":1593485162167},{"_id":"public/blog/201702231619/index.html","hash":"c7163552f903827b5be49d9ca193dfa4ed68ea3b","modified":1593485162167},{"_id":"public/blog/201702172359/index.html","hash":"b24693f129817734b9557e1617114f4ea800811d","modified":1593485162167},{"_id":"public/blog/201702162332/index.html","hash":"431c28272231d2059a0f35dc62b3100e2df98eda","modified":1593485162167},{"_id":"public/blog/201702121305/index.html","hash":"9a786aa747e4e05b2bd71f42ce666eb0d15f456c","modified":1593485162167},{"_id":"public/blog/201701232204/index.html","hash":"16f70b986f06048cea068fec010bf90e3840b884","modified":1593485162167},{"_id":"public/blog/201612291329/index.html","hash":"f699106673ca5f6bbbd4dfa6c0ad4543bb00660c","modified":1593485162167},{"_id":"public/blog/201612230017/index.html","hash":"ed461b46c7175afdd22984199665ed16856e19d8","modified":1593485162167},{"_id":"public/blog/201612202327/index.html","hash":"7b90710e453f3a179bd7f160b3a7e5f2f1539088","modified":1593485162167},{"_id":"public/blog/201612182314/index.html","hash":"2cb7f61ede2cfc8701ed3c892aa97e042dccacb1","modified":1593485162167},{"_id":"public/blog/201612151602/index.html","hash":"5acc1119e85f6ea4e4c3e71b08100db70a42183f","modified":1593485162167},{"_id":"public/blog/201612151531/index.html","hash":"29f6f0e636ed276da9fdb8d89e557add8daa8b64","modified":1593485162167},{"_id":"public/blog/201612131510/index.html","hash":"e927effbe889856524074ee0c0abb53a97a07440","modified":1593485162167},{"_id":"public/blog/201612131044/index.html","hash":"a193f2577ae169632fcc7335d54b4e692c79d8d1","modified":1593485162167},{"_id":"public/blog/201612031812/index.html","hash":"730eb8bdfb887d217b87b2967e53af5ec48dc1b4","modified":1593485162167},{"_id":"public/blog/201612031245/index.html","hash":"4fb123872b8d77650a02d9d62a8b29e17f1450aa","modified":1593485162167},{"_id":"public/blog/201612022308/index.html","hash":"44fb1c6b2b0dbf86ea9069dfba8d9bfe74fe12f0","modified":1593485162167},{"_id":"public/blog/201611282340/index.html","hash":"b72366695a94c0b595e407a96135bb49ae6fa1e6","modified":1593485162167},{"_id":"public/blog/201611211414/index.html","hash":"703a298ea98d3230a0f775032377a7f3e80ddae9","modified":1593485162167},{"_id":"public/blog/201611061601/index.html","hash":"8d0087352bc01b9255796eb0325f40e106bea52d","modified":1593485162167},{"_id":"public/blog/201611051552/index.html","hash":"a87dab3629b0f4317261ec614f88e8ed3f9e71dc","modified":1593485162167},{"_id":"public/blog/201610301718/index.html","hash":"c9e115a9c202e1ff536786c6b74c3b5c2b2bfbe9","modified":1593485162167},{"_id":"public/blog/201610291236/index.html","hash":"d97a562b2fa411dfd190e803448c5edc51723ae0","modified":1593485162167},{"_id":"public/blog/201610271424/index.html","hash":"d210284373c0b024c77f8387b38f289dc1bd78da","modified":1593485162167},{"_id":"public/blog/201610241409/index.html","hash":"8173e14df19e21aec468d12d1949318e286f8cd0","modified":1593485162167},{"_id":"public/blog/201610231443/index.html","hash":"0df841910d14487a42f91a27dcb363b9a7779ecc","modified":1593485162167},{"_id":"public/blog/201610231047/index.html","hash":"38773f5141eed541c706b44549754055d4615cfe","modified":1593485162167},{"_id":"public/blog/201610221606/index.html","hash":"f38bc22159b07d9e446e9e904dc4729b0993dd53","modified":1593485162167},{"_id":"public/blog/201609291442/index.html","hash":"701bada517692d0b659ee4e1e6d4976df306d3a5","modified":1593485162167},{"_id":"public/blog/201609191337/index.html","hash":"b1012a780b4f2b8e0e437d22e3b5983d9ad70833","modified":1593485162167},{"_id":"public/blog/201609191328/index.html","hash":"099a7a20a5865c649c9108c14e00936c1bf2ccb3","modified":1593485162167},{"_id":"public/blog/201609191314/index.html","hash":"86a3b8650951a061ce84292ca4099e33906cd527","modified":1593485162167},{"_id":"public/blog/201609130236/index.html","hash":"64028f94e5dfba2b897b1cfdb1f0c25898f0d2b6","modified":1593485162167},{"_id":"public/blog/201609121450/index.html","hash":"53e8ed8c126ea19dd9dbafc8fc5bf60379eeb727","modified":1593485162167},{"_id":"public/blog/201609120010/index.html","hash":"3bc9d1ec1d4d73fe9aff667c8786d01d67595dac","modified":1593485162167},{"_id":"public/blog/201609101729/index.html","hash":"5dab7851b60ad8889627190361c52addb553a5d3","modified":1593485162167},{"_id":"public/blog/201609101555/index.html","hash":"3dad18aae8ffcbf3489fc4be83e584fb77fc67de","modified":1593485162167},{"_id":"public/blog/201609091146/index.html","hash":"f0b7e80a5312f2e2a6a6d6386908fa677a8b4693","modified":1593485162167},{"_id":"public/blog/201609031820/index.html","hash":"49ed10c494fe2b411740bc2247461599b56c932f","modified":1593485162167},{"_id":"public/blog/201609011252/index.html","hash":"438ec7955165d893c704f4110dd637083f4b8a11","modified":1593485162167},{"_id":"public/blog/201608301340/index.html","hash":"65eab0ad2f6e6b7eb9629eed9a503f7140c609ae","modified":1593485162167},{"_id":"public/blog/201608301211/index.html","hash":"c17f9f9691a042e0cce7d895b354b52e1e89e28f","modified":1593485162167},{"_id":"public/blog/201608282347/index.html","hash":"e7034df2074255ce65b9c876085396f939fb30be","modified":1593485162167},{"_id":"public/blog/201608282314/index.html","hash":"52a4e75d93f3d821e0ed0fe03518875e72fbd097","modified":1593485162167},{"_id":"public/blog/201608282310/index.html","hash":"7927e362593bc8b9eb17cc27d6dad0d37e6d95eb","modified":1593485162167},{"_id":"public/blog/201608211150/index.html","hash":"dde6b74d6de2f65a34b0fb8d7b093d9b8c669b48","modified":1593485162167},{"_id":"public/blog/201608141814/index.html","hash":"c74d376aa1ef5318cd1187f29185c197ce61ccaf","modified":1593485162167},{"_id":"public/blog/201608112242/index.html","hash":"fee8ba79683096094ea66d9ca20f6f3678783050","modified":1593485162167},{"_id":"public/blog/201608112105/index.html","hash":"a158e7f2b5664d4db05c6a32e1ff156b985775ca","modified":1593485162167},{"_id":"public/blog/201608101917/index.html","hash":"f54252512185a8ec5dddc9de1b795a3bd84bef55","modified":1593485162167},{"_id":"public/blog/201608021503/index.html","hash":"5b2666fec5767b0e71fab266cc6b0452b554c1f6","modified":1593485162167},{"_id":"public/blog/201604072243/index.html","hash":"569a9e294ca265a932d7108b7c36c716d15c87a6","modified":1593485162167},{"_id":"public/blog/201602131217/index.html","hash":"321f7f73acffadbeda68567d32cb275597c16cd3","modified":1593485162167},{"_id":"public/blog/201602130101/index.html","hash":"f4af488e5f3080e68061eff836b6573c08883583","modified":1593485162167},{"_id":"public/blog/201602082011/index.html","hash":"3b90988dc4fcde69770ee8edfda3d1d8e8811c86","modified":1593485162167},{"_id":"public/blog/201602081955/index.html","hash":"da198dfcfd86ca39ab919572ab9b5c14d0880f05","modified":1593485162167},{"_id":"public/blog/201602081412/index.html","hash":"6b922bf61e9e0fd8319b08e9802a77c400c4ea8d","modified":1593485162167},{"_id":"public/blog/201602071410/index.html","hash":"66f3e9ecf81be840f7cf0c7c9b805757eeb5101d","modified":1593485162167},{"_id":"public/blog/201602071317/index.html","hash":"515fb437f4bffba9af592674de7203ddee0099a9","modified":1593485162167},{"_id":"public/blog/201602062240/index.html","hash":"cd70676d5cd7de739eefc5fcb3241d955f74b781","modified":1593485162167},{"_id":"public/blog/201601312007/index.html","hash":"f4deef4b3fd005cdb6cafe15c1ce636d0fd58af0","modified":1593485162167},{"_id":"public/blog/201601292210/index.html","hash":"a4a9afe3ca24dbf68546a2fc142fab8050d89f43","modified":1593485162167},{"_id":"public/blog/201601281943/index.html","hash":"8de7bcfb29cba448691938f2ae69a04e8f33dc75","modified":1593485162167},{"_id":"public/blog/201601281912/index.html","hash":"b5d681addb236d5bc585c9a3d05eadec8f97216e","modified":1593485162167},{"_id":"public/blog/201601271719/index.html","hash":"b00105c2326d45dd175f30cc7143f9f8b54f8256","modified":1593485162167},{"_id":"public/blog/201601081723/index.html","hash":"fb535ba8948fc0c00caaf0b240e4729f7e9fdee3","modified":1593485162167},{"_id":"public/blog/201512151559/index.html","hash":"1ea8dba2f0be20ba43df7c7ce460a98b1b0b9b81","modified":1593485162167},{"_id":"public/blog/201512151459/index.html","hash":"80d7d9eebba8ea47831170f6636a7e18d7e0e0e3","modified":1593485162167},{"_id":"public/blog/201512071550/index.html","hash":"ba815ca035f8029e1bf85dbc99ecefcbb78c3af7","modified":1593485162167},{"_id":"public/blog/201512071519/index.html","hash":"f4fe2f182b704215ba694f22d78aa9d48736f63e","modified":1593485162167},{"_id":"public/blog/201512052105/index.html","hash":"7dde45d6866c4079b957abb85f8591236ea461dc","modified":1593485162167},{"_id":"public/blog/201512052039/index.html","hash":"b8c4e670a3450a2b2999eaaa81ccca40a7015610","modified":1593485162167},{"_id":"public/blog/201512051642/index.html","hash":"8a1a9fff06e916880552c19c1ebdfc88d21ec0e2","modified":1593485162167},{"_id":"public/blog/201511292049/index.html","hash":"b817a6754a1af3de487177a0d57f83c12c8dfc7f","modified":1593485162167},{"_id":"public/blog/201511111947/index.html","hash":"3d919174a6d567d927dadc12b73ba1038293f04b","modified":1593485162167},{"_id":"public/blog/201511100107/index.html","hash":"120601636fdb771bc012ebcc2591b955bfaaa517","modified":1593485162167},{"_id":"public/blog/201511081215/index.html","hash":"e7dac24a56a5b3ab8691a6f7d4a37b912198bf52","modified":1593485162167},{"_id":"public/blog/201511052235/index.html","hash":"73bfc9e7062c3bfdf1b9e6caf2ad336d25659090","modified":1593485162167},{"_id":"public/blog/201511041034/index.html","hash":"ff8e57072f520804ebf1cb5a5a3473c1625b4c73","modified":1593485162167},{"_id":"public/blog/201511022234/index.html","hash":"a566fa9269582e21b24382f0f05abc4331470689","modified":1593485162167},{"_id":"public/blog/201510300114/index.html","hash":"54d712250b779b46e4f823f039bf11531c050121","modified":1593485162167},{"_id":"public/archives/index.html","hash":"1edca3568184520528916a51547d59c1f244cc9f","modified":1593487220078},{"_id":"public/archives/page/2/index.html","hash":"413ef256dd14de98da53bf1b7ea7e8327352f8ad","modified":1593487220078},{"_id":"public/archives/page/3/index.html","hash":"ce688b144e0b79b563f6a8c3da22e49c8a078d1f","modified":1593487220078},{"_id":"public/archives/page/4/index.html","hash":"d439756bafa260560c44e98473f12dfdbc21d4c5","modified":1593487220078},{"_id":"public/archives/page/5/index.html","hash":"a0eff5c04f4f244156ef81a481e760d578d7e9d5","modified":1593487220078},{"_id":"public/archives/page/6/index.html","hash":"9e7ca6c3fa647fc175bf1789ccd15713a36c4d6b","modified":1593487220078},{"_id":"public/archives/page/7/index.html","hash":"9f0b0da1093561b778a7b44d01abbf9351d3c668","modified":1593487220078},{"_id":"public/archives/page/8/index.html","hash":"d72b024948f22284e8bff62120e79329f705ff75","modified":1593487220078},{"_id":"public/archives/page/9/index.html","hash":"36c69d2c911ab1d5839c43d5fb2c18066f3642b8","modified":1593487220078},{"_id":"public/archives/page/10/index.html","hash":"d6baa15a9b481fd11e41fd14e950101f6dc3120e","modified":1593487220078},{"_id":"public/archives/page/11/index.html","hash":"8c28e5ed7e8de32bb0559e41ae7d0704037ec632","modified":1593487220078},{"_id":"public/archives/page/12/index.html","hash":"28c78fbee54839d3765f3253bfe409a290cd07ae","modified":1593487220078},{"_id":"public/archives/2015/index.html","hash":"996e342528e34d61b6de37396dc08cc36d75c118","modified":1593487220078},{"_id":"public/archives/2015/page/2/index.html","hash":"c46b58795c97cb237559deb4eca641ea5eeee62d","modified":1593487220078},{"_id":"public/archives/2015/10/index.html","hash":"0e6bd359372d833b1cf210651ea51db15426350e","modified":1593487220078},{"_id":"public/archives/2015/11/index.html","hash":"c045863107537f7fa4800b61d3c5621b7b5a33ef","modified":1593487220078},{"_id":"public/archives/2015/12/index.html","hash":"beaa48c5acd3383819179c95ce505381adf1fc28","modified":1593487220078},{"_id":"public/archives/2016/index.html","hash":"c5e6958a3889bb02d1271b2718659481ecffc6fc","modified":1593487220078},{"_id":"public/archives/2016/page/2/index.html","hash":"eb0f64dab8fff27f41fd9bb8fe34bc3d02e918c4","modified":1593487220078},{"_id":"public/archives/2016/page/3/index.html","hash":"9d2b55426c4f894beefad9284e8146aa61556dd1","modified":1593487220078},{"_id":"public/archives/2016/page/4/index.html","hash":"fa137a18a8ac927f341196c0bfc01b27503d71d0","modified":1593487220078},{"_id":"public/archives/2016/page/5/index.html","hash":"fd1821957a7ee51765e14ac8ff5ffda417c522d6","modified":1593487220078},{"_id":"public/archives/2016/page/6/index.html","hash":"105a9c6982ad94d4258d313f3f71139a576dd4c3","modified":1593487220078},{"_id":"public/archives/2016/01/index.html","hash":"85f398a5d96c0a7b627513ff4fe997293996a7df","modified":1593487220078},{"_id":"public/archives/2016/02/index.html","hash":"a3d9948b24950038c4cfca189d1b6cfc01877fee","modified":1593487220078},{"_id":"public/archives/2016/04/index.html","hash":"cd43fb1d837d465f0def9572667f881d6536717b","modified":1593487220078},{"_id":"public/archives/2016/08/index.html","hash":"7010291f9aeabb3425131fe4094a1fa0c26d303c","modified":1593487220078},{"_id":"public/archives/2016/08/page/2/index.html","hash":"5e9640beb90bd00273e0a374e2f4644232481eb9","modified":1593487220078},{"_id":"public/archives/2016/09/index.html","hash":"90da501b112b187e5dbc0c502a002a9a4dc1e932","modified":1593487220078},{"_id":"public/archives/2016/09/page/2/index.html","hash":"9e56739b9fe86a6d934d1183603628fc587bbe32","modified":1593487220078},{"_id":"public/archives/2016/10/index.html","hash":"199a7ca94e63e9c13aefd802a6c7a31776c46433","modified":1593487220078},{"_id":"public/archives/2016/11/index.html","hash":"1178cf76c73d6eaa28e0d15d62a8a355bb07c467","modified":1593487220078},{"_id":"public/archives/2016/12/index.html","hash":"293d9a88eaf92409305464b4943ecb1ebbf5db87","modified":1593487220078},{"_id":"public/archives/2016/12/page/2/index.html","hash":"6fb337639b29ea37e797bb08a3f5434d5db3f2a4","modified":1593487220078},{"_id":"public/archives/2017/index.html","hash":"fd23609504c2366dbbdcdff8406b257e10e035c3","modified":1593487220078},{"_id":"public/archives/2017/page/2/index.html","hash":"64dce39fb2dd92224ea3a1ee4a0f232c02cc2c9d","modified":1593487220078},{"_id":"public/archives/2017/page/3/index.html","hash":"67f75c1075d867a27d3594ad30229788a410eff2","modified":1593487220078},{"_id":"public/archives/2017/01/index.html","hash":"2f95b63a24a67440164ba3c6f10423f59bddc610","modified":1593487220078},{"_id":"public/archives/2017/02/index.html","hash":"d8c97d0b3d9e0d274297840dd5a41e25f0f4a934","modified":1593487220078},{"_id":"public/archives/2017/03/index.html","hash":"6c1067f6c7d89484fc36ba2ef30f4c80cfe8c96c","modified":1593487220078},{"_id":"public/archives/2017/04/index.html","hash":"e99f4615037b4ce27797afe2f74303e67ec262ce","modified":1593487220078},{"_id":"public/archives/2017/05/index.html","hash":"8ae1d001bb242459249e2a260fcccd24ef288bd1","modified":1593487220078},{"_id":"public/archives/2017/06/index.html","hash":"f5d538eb024cc47845ba48d4ec92f7b4f4b2c866","modified":1593487220078},{"_id":"public/archives/2017/09/index.html","hash":"2feade72165962133238d930325dfff0af2a655f","modified":1593487220078},{"_id":"public/archives/2017/11/index.html","hash":"f87ba79178f07977ffc424ff423b5632dcd04c44","modified":1593487220078},{"_id":"public/archives/2017/12/index.html","hash":"290fbbcd73c1086d2ef5064f5b3e54a536410fa5","modified":1593487220078},{"_id":"public/archives/2018/index.html","hash":"ed64b5eb2e1724fc46661e63fffa1419835a3c38","modified":1593487220078},{"_id":"public/archives/2018/02/index.html","hash":"922f02e7d8e4bf6b6306f656ebb253d12713943f","modified":1593487220078},{"_id":"public/archives/2018/03/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487220078},{"_id":"public/archives/2018/04/index.html","hash":"ac4b463a13d8c4b53a2adbcf24d6bbb98f4b765e","modified":1593487220078},{"_id":"public/archives/2018/05/index.html","hash":"df2e632ac1b2713b6af6eb70ac512d2028d0cb66","modified":1593487220078},{"_id":"public/archives/2018/06/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487220078},{"_id":"public/archives/2018/09/index.html","hash":"2090a8baa1ec1f15ba16144c81813148a0f48516","modified":1593487220078},{"_id":"public/archives/2018/11/index.html","hash":"2ea6391b78e58300b49ef0f8c90231a20823a049","modified":1593487220078},{"_id":"public/archives/2018/12/index.html","hash":"5bbf1a35d3458d7211c081a25079e7a27b963397","modified":1593487220078},{"_id":"public/archives/2019/index.html","hash":"fe121848181cf0e152f86580716e2d3689c86962","modified":1593487220078},{"_id":"public/archives/2019/03/index.html","hash":"b8518239dd474f896743f6af9ca9318c268fd4e5","modified":1593487220078},{"_id":"public/archives/2019/05/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487220078},{"_id":"public/archives/2019/11/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487220078},{"_id":"public/archives/2019/12/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487220078},{"_id":"public/categories/Android/index.html","hash":"3230fbe08d4c94626a26fa10167d31901c5a6a31","modified":1593487220078},{"_id":"public/categories/Android/page/2/index.html","hash":"e012dbc7c49510bc65ea544e4711aff96fce5958","modified":1593487220078},{"_id":"public/categories/Android/page/3/index.html","hash":"40ea3627267754eeded5571630fafa8ffcd769d3","modified":1593487220078},{"_id":"public/categories/Web-Back-end/index.html","hash":"0c0353abaad166278f9b06ddff35adaac2299f99","modified":1593487220078},{"_id":"public/categories/Web-Back-end/page/2/index.html","hash":"b7ddb9eb4a185cdce4252a2360c7dbe5ca4d697b","modified":1593487220078},{"_id":"public/categories/Web-Back-end/page/3/index.html","hash":"9ae56b37fb909496ba6497b8ce3c1f358d377920","modified":1593487220078},{"_id":"public/categories/Web-Back-end/page/4/index.html","hash":"8a2175fa7d14817f18ef59fcca7307fb243123ed","modified":1593487220078},{"_id":"public/categories/Web-Front-end/index.html","hash":"90b9c2e3a139accd8e51fdbc927798db7311cf09","modified":1593487220078},{"_id":"public/categories/Web-Front-end/page/2/index.html","hash":"32dbfadd8876fe1b4ea85ab6a9cca426f021bdb9","modified":1593487220078},{"_id":"public/categories/Web-Front-end/page/3/index.html","hash":"8e369e225cc15798aed939b92d8e42f35627ed21","modified":1593487220078},{"_id":"public/categories/Web-Front-end/page/4/index.html","hash":"16da143d5a23708089a6dd3328d36b8d1679307f","modified":1593487220078},{"_id":"public/categories/Other/index.html","hash":"77d404fbd39e2926d7d08347a3113f3f7c1b44b9","modified":1593487220078},{"_id":"public/categories/iOS/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487220078},{"_id":"public/blog/index.html","hash":"6a372c248ca7b575e0ff0825650d1287f4b96015","modified":1593487265774},{"_id":"public/blog/page/2/index.html","hash":"2594ad535c5c890cfd3ca123a745fe102e0cb8de","modified":1593487265774},{"_id":"public/blog/page/3/index.html","hash":"23d4a63bf435de7dd685556a1b22a18e3f88f49f","modified":1593487265774},{"_id":"public/blog/page/4/index.html","hash":"0601c7bd53077f94c341b2ab1b5d91ddf4a1790c","modified":1593487265774},{"_id":"public/blog/page/5/index.html","hash":"33164e975e21ce244ba11da8e1e03dc74a53310b","modified":1593487265774},{"_id":"public/blog/page/6/index.html","hash":"e106c5ce253ea037859fb976d418a534b225a1d4","modified":1593487265774},{"_id":"public/blog/page/7/index.html","hash":"9c27cbcd88b7e48f7d0d39addbf8679b5504052a","modified":1593487265774},{"_id":"public/blog/page/8/index.html","hash":"409ce1ba94b1d587720a7b540d752c7b61bb7508","modified":1593487265774},{"_id":"public/blog/page/9/index.html","hash":"c965ed965e6ccf6c46b89a90120b233026daf1ec","modified":1593487265774},{"_id":"public/blog/page/10/index.html","hash":"56b4e5799279a37eaa0b821fb61a79650f3b111c","modified":1593487265774},{"_id":"public/blog/page/11/index.html","hash":"38aa419cf54e0e77079251b521147ae44806fbf0","modified":1593487265774},{"_id":"public/blog/page/12/index.html","hash":"340bd388c90663af17d5d589aab34dd2fa4d3766","modified":1593487265774},{"_id":"public/tags/Android/index.html","hash":"c800ee38e967ef33d0efc5d34bb14616c40880a9","modified":1593487220078},{"_id":"public/tags/Android/page/2/index.html","hash":"1c5f0cad749351690ab9623346a639865ef416ae","modified":1593487220078},{"_id":"public/tags/Android/page/3/index.html","hash":"9973d3e330bc30c4cc217c76e7a0d5a159788dc7","modified":1593487220078},{"_id":"public/tags/Java/index.html","hash":"023e24d244968f0e2ef2fa97ac897bd24bb8a2a5","modified":1593487220078},{"_id":"public/tags/Java/page/2/index.html","hash":"cb2de5913938edf93581a7c8fb0fecca85495525","modified":1593487220078},{"_id":"public/tags/Java/page/3/index.html","hash":"a2cd48f036cc0617cd898d5479802ff79deb317e","modified":1593487220078},{"_id":"public/tags/JSON/index.html","hash":"4a5836b002bca1e4c4c784b440a2d7f027f6178e","modified":1593487220078},{"_id":"public/tags/PHP/index.html","hash":"b93071ff42598bd7cf88f859a4071d98a9087491","modified":1593487220078},{"_id":"public/tags/PHP/page/2/index.html","hash":"e0a38920366236431b125bf182ea0e78e6b44c27","modified":1593487220078},{"_id":"public/tags/Session/index.html","hash":"ce584f2fa38f1c41250cde291728fde01b0f4167","modified":1593487220078},{"_id":"public/tags/SQLite/index.html","hash":"4dfccafd899e852c1864d9da2f918d2e4d1fadf7","modified":1593487220078},{"_id":"public/tags/Tomcat/index.html","hash":"cd43fb1d837d465f0def9572667f881d6536717b","modified":1593487220078},{"_id":"public/tags/CSS/index.html","hash":"6e0fbc9c198fcfc21f3992df929fe076aeb9b9dd","modified":1593487220078},{"_id":"public/tags/JavaScript/index.html","hash":"dc909d44998e2ecc1ef53bd81160eedbcea53f32","modified":1593487220078},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"d8a280197830ce72d3ab199b3ec8007a80528ae2","modified":1593487220078},{"_id":"public/tags/JavaScript/page/3/index.html","hash":"453ebcec65a4d6fc33de0cc5d54d043d48401af4","modified":1593487220078},{"_id":"public/tags/jQuery/index.html","hash":"4aa584ba91cb8b537ec060fa0c4483f4449d0cf5","modified":1593487220078},{"_id":"public/tags/AJAX/index.html","hash":"19c9f85111e0025854e70f52c0b5f7770b2bb456","modified":1593487220078},{"_id":"public/tags/HTML/index.html","hash":"8761131e51a563940470403fde7e305475b76721","modified":1593487220078},{"_id":"public/tags/Canvas/index.html","hash":"feca731830f1d11b853e943bf15f6274d4d6be40","modified":1593487220078},{"_id":"public/tags/Apache/index.html","hash":"784d37313dc9142e7b3e2d944e02413634e0fd42","modified":1593487220078},{"_id":"public/tags/WampServer/index.html","hash":"f37a5051c61606a1e15b1d70b39328ab50fe502a","modified":1593487220078},{"_id":"public/tags/Cookie/index.html","hash":"1ed2ecad272e614a62bc4d42b532acee4b9b73ce","modified":1593487220078},{"_id":"public/tags/WordPress/index.html","hash":"b9f05f4dc682bcbab20fef93a45f88a83f363d96","modified":1593487220078},{"_id":"public/tags/Git/index.html","hash":"98575c325918d02ec895ef15630cdb21fcc54bc1","modified":1593487220078},{"_id":"public/tags/Homestead/index.html","hash":"1d45cd73410c425951fb449f4aaac7fbd83cbe5d","modified":1593487220078},{"_id":"public/tags/phpMyAdmin/index.html","hash":"32d4c09bcc3e9e082ba30f0fa8e36a4a4c73c816","modified":1593487220078},{"_id":"public/tags/Vue-js/index.html","hash":"452c643e52689cb701500c7cc5d9661722563f79","modified":1593487220078},{"_id":"public/tags/Laravel/index.html","hash":"64af4e9c51bed4bff04d3d4f3f85db7832e9e84d","modified":1593487220078},{"_id":"public/tags/MySQL/index.html","hash":"ca0bdbf71701038af112d812cad0eeeeb26b5087","modified":1593487220078},{"_id":"public/tags/SMTP/index.html","hash":"0df0394287f49c4cde72bbc1727f6914a6b0d9c9","modified":1593487220078},{"_id":"public/tags/SSH/index.html","hash":"ea26838d1eca74a57d5b61d4c843ab07a51609f3","modified":1593487220078},{"_id":"public/tags/虚拟机/index.html","hash":"2a63adf2cd2e71f40c81bbe04c1a2ee46e68d748","modified":1593487220078},{"_id":"public/tags/Linux/index.html","hash":"7b4fd98d1ddce4a021c4144400b888348fa53ffa","modified":1593487220078},{"_id":"public/tags/Nginx/index.html","hash":"db726337f24f0201e6aed111f131a8aa3f317f71","modified":1593487220078},{"_id":"public/tags/SSL/index.html","hash":"50aaf2c7cf41459df2d82ce8a0a3efbe0ee0f555","modified":1593487220078},{"_id":"public/tags/HTTPS/index.html","hash":"50aaf2c7cf41459df2d82ce8a0a3efbe0ee0f555","modified":1593487220078},{"_id":"public/tags/微信/index.html","hash":"f9c55b8af60688751c2700ee63f371d13a58bb88","modified":1593487220078},{"_id":"public/tags/ES6/index.html","hash":"3ec6d2c60af318ad1d160717f799fc193ecc2b0e","modified":1593487220078},{"_id":"public/tags/Sass/index.html","hash":"8084e333d534b8a79587fb9370dd1fb5b6d004e3","modified":1593487220078},{"_id":"public/tags/Hexo/index.html","hash":"c3d29424dcdbfe83c5f1f3bc608157f2c0efbf06","modified":1593487220078},{"_id":"public/tags/Gulp/index.html","hash":"f0668138f8d940b59dbf2387261a55e5dc3ecb04","modified":1593487220078},{"_id":"public/tags/JWT/index.html","hash":"4409d3ecfa8d1b491fd245097a780dc7e7b465cd","modified":1593487220078},{"_id":"public/tags/API/index.html","hash":"4409d3ecfa8d1b491fd245097a780dc7e7b465cd","modified":1593487220078},{"_id":"public/tags/小程序/index.html","hash":"cd36054717871ab1a4bb1df4b1625a4ffd8b2f1e","modified":1593487220078},{"_id":"public/tags/Let-s-Encrypt/index.html","hash":"8daae3ff39a3c555196461327a5378129a8d699c","modified":1593487220078},{"_id":"public/tags/ACME/index.html","hash":"8daae3ff39a3c555196461327a5378129a8d699c","modified":1593487220078},{"_id":"public/tags/Certbot/index.html","hash":"922f02e7d8e4bf6b6306f656ebb253d12713943f","modified":1593487220078},{"_id":"public/tags/GitHub-Pages/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487220078},{"_id":"public/tags/CDN/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487220078},{"_id":"public/tags/DNS/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487220078},{"_id":"public/tags/Node-js/index.html","hash":"bf83a584a4b4e275934eb6a8bd24f4927ba115e9","modified":1593487220078},{"_id":"public/tags/对象存储/index.html","hash":"ac4b463a13d8c4b53a2adbcf24d6bbb98f4b765e","modified":1593487220078},{"_id":"public/tags/Vim/index.html","hash":"df2e632ac1b2713b6af6eb70ac512d2028d0cb66","modified":1593487220078},{"_id":"public/tags/i18n/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487220078},{"_id":"public/tags/CSV/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487220078},{"_id":"public/tags/YAML/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487220078},{"_id":"public/tags/社交平台/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/分享/index.html","hash":"6c33070f6a28dd22fc0c160b4ef14a5508264ac2","modified":1593487220078},{"_id":"public/tags/深度链接/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Deep-Linking/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Facebook/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Twitter/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Instagram/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/WhatsApp/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Line/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Messenger/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487220078},{"_id":"public/tags/Android-Studio/index.html","hash":"ddd1e50e1e31aa7586c60c5b7f692545c7349f5d","modified":1593487220078},{"_id":"public/tags/APP/index.html","hash":"ddd1e50e1e31aa7586c60c5b7f692545c7349f5d","modified":1593487220078},{"_id":"public/tags/Promise/index.html","hash":"b8518239dd474f896743f6af9ca9318c268fd4e5","modified":1593487220078},{"_id":"public/tags/Hybrid-App/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487220078},{"_id":"public/tags/WebView/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487220078},{"_id":"public/tags/JsBridge/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487220078},{"_id":"public/tags/PixiJS/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487220078},{"_id":"public/tags/WebGL/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487220078},{"_id":"public/tags/2D/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487220078},{"_id":"public/tags/anime-js/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487220078},{"_id":"public/tags/H5/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487220078},{"_id":"public/tags/Swift/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487220078},{"_id":"public/tags/iOS/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487220078},{"_id":"public/tags/Serverless/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487220078},{"_id":"public/tags/FaaS/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487220078},{"_id":"public/tags/OpenWhisk/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487220078},{"_id":"public/tags/Chrome/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487220078},{"_id":"public/tags/WebComponents/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487220078},{"_id":"public/blog/201911241301/index.html","hash":"89e7722f229bb27c5ee6ce210f499f2ed3756320","modified":1593485162167},{"_id":"public/images/site_title.png","hash":"b0806741b9be5f55668972fe4e501e58f5e04921","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_fragment.png","hash":"a9e91e6d083cb5883c2d9bdde15b94963e1df6e8","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_intent_1.png","hash":"81d1635fea8083119aef523eb441e4bc09b22f76","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_intent_2.png","hash":"e5e5ba44028acd56de60d63b684beb24e222198a","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_json_1.png","hash":"be4ec594b19d1fd84eb7218af41483ed535df91b","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_json_2.png","hash":"bc1e8108dda305954addc61e6625f78aeea71217","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_sqlite.png","hash":"0683d92840c5b6e3e1c110cbc9dcecc4956b7b00","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_toast_1.png","hash":"526d14eb316583dd33048547c1bda4a95343ce37","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_toast_2.png","hash":"ee4a2ab57b869d4652528b065039204a3cfd6a08","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_view_pager_1.png","hash":"65d802b14534b57dd529518f1f6e01498ea3462f","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_view_pager_2.png","hash":"52dc55130810ddb765715a43dffea630fffbfa12","modified":1593487265774},{"_id":"public/images/posts/2015/11/android_view_pager_3.png","hash":"82a3bef437c75966c032b225e622450cfc7455a2","modified":1593487265774},{"_id":"public/images/posts/2015/12/android_list_view_1.png","hash":"5ef997f1f3f2384a3ad9c74a808467f0c553d495","modified":1593487265774},{"_id":"public/images/posts/2015/12/android_list_view_2.png","hash":"d70bde0bf9e5beea6bedcff0faf12ec2cac02d84","modified":1593487265774},{"_id":"public/images/posts/2015/12/android_list_view_3.png","hash":"5e019680daa4b1ddf397e6b937ee61605a1701d9","modified":1593487265774},{"_id":"public/images/posts/2015/12/android_system_version_1.png","hash":"10da993495e0086da1b2afd60cf123ac83b81f23","modified":1593487265774},{"_id":"public/images/posts/2015/12/android_system_version_2.png","hash":"d4c638e4efce2c655106253acff76284ee77fb25","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_1.png","hash":"044b99489d3d4f586ddf82f94cf338ef41c7b206","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_2.png","hash":"07725feac80d325c7af678c24a8de752edf8772c","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_3.png","hash":"48fbb7914ed1eb59cf440d32d028e68ed0c437a5","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_popover_1.png","hash":"283b425664d5ac6e82333400b14aed2e742e3281","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_popover_2.png","hash":"c4104671573dc34abc0e96ceb2578e6178e8e81c","modified":1593487265774},{"_id":"public/images/posts/2016/01/android_toolbar_popover_3.png","hash":"bb60bd1be3899541e341cbbb2d6ba9f2220c36eb","modified":1593487265774},{"_id":"public/images/posts/2017/02/https_installed.png","hash":"273a13e494dd36b55b5d86903817ac08ba71894c","modified":1593487265774},{"_id":"public/images/posts/2017/05/gulp_efficiency.png","hash":"60ce6a85e93124e44831aeb72afe32e60f23d1b2","modified":1593487265774},{"_id":"public/images/posts/2017/11/lets_encrypt_logo.png","hash":"b9fd0889826b5f21c7e366a492a6d2bf27622080","modified":1593487265774},{"_id":"public/images/posts/2017/12/apidoc_ui.png","hash":"70bf70bbb00f1e11eb4d7ea8468beacdd96ae644","modified":1593487265774},{"_id":"public/images/posts/2018/05/vim_comment_after.png","hash":"2ba1abd49c63d89a40d8f500e5e5db8e9256ed4a","modified":1593487265774},{"_id":"public/images/posts/2018/05/vim_comment_before.png","hash":"c4c68e225c4d6a06c3d42ce01877d963d8f22d0c","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_layers.jpg","hash":"ddc6080b445867648aa669906f2b8f1aab6e5352","modified":1593487265774},{"_id":"public/images/posts/2018/12/swift_logo.png","hash":"6d41f11113d34a10b03955596356b07f4a878d1e","modified":1593487265774},{"_id":"public/images/posts/2018/12/wechat_block.png","hash":"c6bd12efde9f4f2b69949b87dc0656670f813779","modified":1593487265774},{"_id":"public/images/posts/2018/12/android_project_structure.png","hash":"fdee69f3a8333148e623ac5d9b7e14360ea20e48","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_practice.jpg","hash":"24fbeb0363949a50b23ca5d6e4625470947ec521","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_intro.jpg","hash":"3af8131e4456f5ba26123fa32bfbb0e7da3b78b0","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_serverless_framework_deploy.jpg","hash":"cf0a280102b284cb88222cd6b11941c00c13e4e5","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_adblock.png","hash":"11a54f1e8ba8d5ac7c5a58996352cfd09bd2a056","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_popup.png","hash":"4008ade0300ebed5124a39008af1077f241c0669","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_debug_background.png","hash":"69b9f5cce08d383ae8318288873207a3c27c7d9f","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_structure.png","hash":"a282066378eecddd6cd3997e1921cdf7542e8aea","modified":1593487265774},{"_id":"public/images/posts/2017/08/shadowsocks_youtube.png","hash":"ff5ab3de82580340753013274394af43b32419e3","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_management.png","hash":"4e6c0fb5ab55a23a45cf86f7e6dfab1c72371b78","modified":1593487265774},{"_id":"public/fonts/PermanentMarker-Regular.ttf","hash":"6d0bcddcb32c60bb9c75eacdffb5deef7913ebf2","modified":1593487265774},{"_id":"public/images/posts/2018/11/open_graph.jpg","hash":"1321a6efb0306b6a70f60196795331d2f832c8da","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_camera.jpg","hash":"6eb95b93a95ac0d1465ea65fa3f9eca5ee58375a","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_brands.jpg","hash":"5b3b90837bc0b3ed396bb387d343ce595cf97dde","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_faas.jpg","hash":"f30c8723f8b82d1cda63facf0b2b60a4f62b0366","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_openwhisk.jpg","hash":"65d37cb79b363a4eae721ac2d1b53093c2f8ef1e","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_openwhisk_principle.jpg","hash":"cbbc2dbdcf8734ddd8ee2dda82cb62393ba323f4","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_serverless_framework.jpg","hash":"bb69418ef16971667b8d2abb5d1ed5fe38c2705a","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_scf_trigger.jpg","hash":"aa8e7202f6eeec8491d7dd3f31de14ddf7cc74c9","modified":1593487265774},{"_id":"public/images/posts/2019/12/chrome_extension_management.jpg","hash":"000fae21feca9bb7680ededb0519354be21c51c6","modified":1593487265774},{"_id":"public/css/app.css","hash":"14258149cf1876a2eaa17e87b7d9144be9233052","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_animated_sprite.jpg","hash":"46b892009a417464df0e242dc55ba28a8baf7b15","modified":1593487265774},{"_id":"public/images/posts/2019/11/serverless_pizza_as_a_service.jpg","hash":"86ee327e00dd3b491f233c99775ab575bd260e45","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_candy_house_sign.gif","hash":"cab0d25c333763fd6c532751782695424edd832b","modified":1593487265774},{"_id":"public/images/posts/2017/03/mini_program_practice.gif","hash":"b4222f4097634b70071f7a44c8809729c8dbc251","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_design.jpg","hash":"b05aed76d3cbdc8952ad57ac251c78d9b25651ee","modified":1593487265774},{"_id":"public/images/posts/2018/11/pixi_practice_preview.gif","hash":"52fce231461e95e6a44ffa1ca24463b58d6fa659","modified":1593487265774},{"_id":"public/blog/posts/201912210126/index.html","hash":"6ccef583decb7ebee6611b40f414207b3196a0a8","modified":1593487265774},{"_id":"public/blog/posts/201905270037/index.html","hash":"c69a6ca613dd49dec45df3f9daf6c9272f07d981","modified":1593487265774},{"_id":"public/blog/posts/201903152149/index.html","hash":"3abae7c259bee3cbee1ca30838d58b3742ba0e90","modified":1593487265774},{"_id":"public/blog/posts/201812221835/index.html","hash":"3b0c15908ccfcfdc231ad31d6d75d873892b6b6f","modified":1593487265774},{"_id":"public/blog/posts/201812182120/index.html","hash":"b9e1153afc31f7c599bff24104bbfb7af73e6935","modified":1593487265774},{"_id":"public/blog/posts/201811151317/index.html","hash":"b7190166140802b41896c1bb43e7983392a137ab","modified":1593487265774},{"_id":"public/blog/posts/201811112150/index.html","hash":"faf57d582dad16db80718e24d72ec8726692b9c2","modified":1593487265774},{"_id":"public/blog/posts/201809022300/index.html","hash":"67ca60b258f1e517fe8371f2d8047e62964b52f3","modified":1593487265774},{"_id":"public/blog/posts/201806102124/index.html","hash":"e37b684e6ec8617c3498233767fac6bce32f6b71","modified":1593487265774},{"_id":"public/blog/posts/201805091633/index.html","hash":"c58e093b450e136e820f898ee6974f793a73897d","modified":1593487265774},{"_id":"public/blog/posts/201804032248/index.html","hash":"97555bb70bc94b6d7fb4f6910e4619b49c2c7526","modified":1593487265774},{"_id":"public/blog/posts/201803201114/index.html","hash":"175cc8bf5697a28b774608754eedc5f49985bcec","modified":1593487265774},{"_id":"public/blog/posts/201802211638/index.html","hash":"3149f18f86ff54fc35a1793788955e7147adbe4c","modified":1593487265774},{"_id":"public/blog/posts/201712270023/index.html","hash":"14d4c5ee05656e9a26fde80d3cfefcdad0480ae0","modified":1593487265774},{"_id":"public/blog/posts/201712042239/index.html","hash":"c5a21ebca1f2ca52cb27198de1e29360066f6602","modified":1593487265774},{"_id":"public/blog/posts/201711151432/index.html","hash":"8d9c6807c2f5a823753529f979223005b88e29bc","modified":1593487265774},{"_id":"public/blog/posts/201711032345/index.html","hash":"81a2c7e0ba364a56b9f4e459d6dce96768b23431","modified":1593487265774},{"_id":"public/blog/posts/201709282141/index.html","hash":"0f3ff5c6bbb239d63da4764caf0f6c9f8dc5a43a","modified":1593487265774},{"_id":"public/blog/posts/201709031318/index.html","hash":"bd6f8ab2aaea854beb6e6000cc17880d0aa93334","modified":1593487265774},{"_id":"public/blog/posts/201706270002/index.html","hash":"6e0f535d7a8a19a07542d56955f5b931c5a77538","modified":1593487265774},{"_id":"public/blog/posts/201706111300/index.html","hash":"886232e0a21bb53e3b3a59a1120d4ee1ea65fa47","modified":1593487265774},{"_id":"public/blog/posts/201705201637/index.html","hash":"203f55033d7471ae9a767b258330d2dce42d7bab","modified":1593487265774},{"_id":"public/blog/posts/201705181334/index.html","hash":"692abbbecfc4cabafbdf0aafe955ece7ace23f32","modified":1593487265774},{"_id":"public/blog/posts/201705141050/index.html","hash":"9cd83a853f6fb8a47eacdff9928684b889aceb92","modified":1593487265774},{"_id":"public/blog/posts/201705031841/index.html","hash":"759e21998523c068625dd5e02f4f4ecc02e9caf0","modified":1593487265774},{"_id":"public/blog/posts/201704280003/index.html","hash":"699f02f3a749ac3a37851156713555986b50488d","modified":1593487265774},{"_id":"public/blog/posts/201704231552/index.html","hash":"d494d4c7c43d61fe91d5ca3eefd26c2d95be19b0","modified":1593487265774},{"_id":"public/blog/posts/201704170054/index.html","hash":"49f67cc10e26e583323c14098077f42987754994","modified":1593487265774},{"_id":"public/blog/posts/201703281144/index.html","hash":"cd4a5a0a464a179fbd6a7855c322eb9fa7881b18","modified":1593487265774},{"_id":"public/blog/posts/201703161308/index.html","hash":"711cb908f7a58d11651986871d8b7f7f1c15e768","modified":1593487265774},{"_id":"public/blog/posts/201703131746/index.html","hash":"a1abb07e8524cee0eba0a8a9e11380ca03aff436","modified":1593487265774},{"_id":"public/blog/posts/201703031619/index.html","hash":"7ef9b75d2cb88c0c3b4681b14fea81773c853834","modified":1593487265774},{"_id":"public/blog/posts/201702231619/index.html","hash":"c7163552f903827b5be49d9ca193dfa4ed68ea3b","modified":1593487265774},{"_id":"public/blog/posts/201702172359/index.html","hash":"b24693f129817734b9557e1617114f4ea800811d","modified":1593487265774},{"_id":"public/blog/posts/201702162332/index.html","hash":"431c28272231d2059a0f35dc62b3100e2df98eda","modified":1593487265774},{"_id":"public/blog/posts/201702121305/index.html","hash":"9a786aa747e4e05b2bd71f42ce666eb0d15f456c","modified":1593487265774},{"_id":"public/blog/posts/201701232204/index.html","hash":"16f70b986f06048cea068fec010bf90e3840b884","modified":1593487265774},{"_id":"public/blog/posts/201612291329/index.html","hash":"f699106673ca5f6bbbd4dfa6c0ad4543bb00660c","modified":1593487265774},{"_id":"public/blog/posts/201612230017/index.html","hash":"ed461b46c7175afdd22984199665ed16856e19d8","modified":1593487265774},{"_id":"public/blog/posts/201612202327/index.html","hash":"7b90710e453f3a179bd7f160b3a7e5f2f1539088","modified":1593487265774},{"_id":"public/blog/posts/201612182314/index.html","hash":"2cb7f61ede2cfc8701ed3c892aa97e042dccacb1","modified":1593487265774},{"_id":"public/blog/posts/201612151602/index.html","hash":"5acc1119e85f6ea4e4c3e71b08100db70a42183f","modified":1593487265774},{"_id":"public/blog/posts/201612151531/index.html","hash":"29f6f0e636ed276da9fdb8d89e557add8daa8b64","modified":1593487265774},{"_id":"public/blog/posts/201612131510/index.html","hash":"e927effbe889856524074ee0c0abb53a97a07440","modified":1593487265774},{"_id":"public/blog/posts/201612131044/index.html","hash":"a193f2577ae169632fcc7335d54b4e692c79d8d1","modified":1593487265774},{"_id":"public/blog/posts/201612031812/index.html","hash":"730eb8bdfb887d217b87b2967e53af5ec48dc1b4","modified":1593487265774},{"_id":"public/blog/posts/201612031245/index.html","hash":"4fb123872b8d77650a02d9d62a8b29e17f1450aa","modified":1593487265774},{"_id":"public/blog/posts/201612022308/index.html","hash":"44fb1c6b2b0dbf86ea9069dfba8d9bfe74fe12f0","modified":1593487265774},{"_id":"public/blog/posts/201611282340/index.html","hash":"b72366695a94c0b595e407a96135bb49ae6fa1e6","modified":1593487265774},{"_id":"public/blog/posts/201611211414/index.html","hash":"703a298ea98d3230a0f775032377a7f3e80ddae9","modified":1593487265774},{"_id":"public/blog/posts/201611061601/index.html","hash":"8d0087352bc01b9255796eb0325f40e106bea52d","modified":1593487265774},{"_id":"public/blog/posts/201611051552/index.html","hash":"a87dab3629b0f4317261ec614f88e8ed3f9e71dc","modified":1593487265774},{"_id":"public/blog/posts/201610301718/index.html","hash":"c9e115a9c202e1ff536786c6b74c3b5c2b2bfbe9","modified":1593487265774},{"_id":"public/blog/posts/201610291236/index.html","hash":"d97a562b2fa411dfd190e803448c5edc51723ae0","modified":1593487265774},{"_id":"public/blog/posts/201610271424/index.html","hash":"d210284373c0b024c77f8387b38f289dc1bd78da","modified":1593487265774},{"_id":"public/blog/posts/201610241409/index.html","hash":"8173e14df19e21aec468d12d1949318e286f8cd0","modified":1593487265774},{"_id":"public/blog/posts/201610231443/index.html","hash":"0df841910d14487a42f91a27dcb363b9a7779ecc","modified":1593487265774},{"_id":"public/blog/posts/201610231047/index.html","hash":"38773f5141eed541c706b44549754055d4615cfe","modified":1593487265774},{"_id":"public/blog/posts/201610221606/index.html","hash":"f38bc22159b07d9e446e9e904dc4729b0993dd53","modified":1593487265774},{"_id":"public/blog/posts/201609291442/index.html","hash":"701bada517692d0b659ee4e1e6d4976df306d3a5","modified":1593487265774},{"_id":"public/blog/posts/201609191337/index.html","hash":"b1012a780b4f2b8e0e437d22e3b5983d9ad70833","modified":1593487265774},{"_id":"public/blog/posts/201609191328/index.html","hash":"099a7a20a5865c649c9108c14e00936c1bf2ccb3","modified":1593487265774},{"_id":"public/blog/posts/201609191314/index.html","hash":"86a3b8650951a061ce84292ca4099e33906cd527","modified":1593487265774},{"_id":"public/blog/posts/201609130236/index.html","hash":"64028f94e5dfba2b897b1cfdb1f0c25898f0d2b6","modified":1593487265774},{"_id":"public/blog/posts/201609121450/index.html","hash":"53e8ed8c126ea19dd9dbafc8fc5bf60379eeb727","modified":1593487265774},{"_id":"public/blog/posts/201609120010/index.html","hash":"3bc9d1ec1d4d73fe9aff667c8786d01d67595dac","modified":1593487265774},{"_id":"public/blog/posts/201609101729/index.html","hash":"5dab7851b60ad8889627190361c52addb553a5d3","modified":1593487265774},{"_id":"public/blog/posts/201609101555/index.html","hash":"3dad18aae8ffcbf3489fc4be83e584fb77fc67de","modified":1593487265774},{"_id":"public/blog/posts/201609091146/index.html","hash":"f0b7e80a5312f2e2a6a6d6386908fa677a8b4693","modified":1593487265774},{"_id":"public/blog/posts/201609031820/index.html","hash":"49ed10c494fe2b411740bc2247461599b56c932f","modified":1593487265774},{"_id":"public/blog/posts/201609011252/index.html","hash":"438ec7955165d893c704f4110dd637083f4b8a11","modified":1593487265774},{"_id":"public/blog/posts/201608301340/index.html","hash":"65eab0ad2f6e6b7eb9629eed9a503f7140c609ae","modified":1593487265774},{"_id":"public/blog/posts/201608301211/index.html","hash":"c17f9f9691a042e0cce7d895b354b52e1e89e28f","modified":1593487265774},{"_id":"public/blog/posts/201608282347/index.html","hash":"e7034df2074255ce65b9c876085396f939fb30be","modified":1593487265774},{"_id":"public/blog/posts/201608282314/index.html","hash":"52a4e75d93f3d821e0ed0fe03518875e72fbd097","modified":1593487265774},{"_id":"public/blog/posts/201608282310/index.html","hash":"7927e362593bc8b9eb17cc27d6dad0d37e6d95eb","modified":1593487265774},{"_id":"public/blog/posts/201608211150/index.html","hash":"dde6b74d6de2f65a34b0fb8d7b093d9b8c669b48","modified":1593487265774},{"_id":"public/blog/posts/201608141814/index.html","hash":"c74d376aa1ef5318cd1187f29185c197ce61ccaf","modified":1593487265774},{"_id":"public/blog/posts/201608112242/index.html","hash":"fee8ba79683096094ea66d9ca20f6f3678783050","modified":1593487265774},{"_id":"public/blog/posts/201608112105/index.html","hash":"a158e7f2b5664d4db05c6a32e1ff156b985775ca","modified":1593487265774},{"_id":"public/blog/posts/201608101917/index.html","hash":"f54252512185a8ec5dddc9de1b795a3bd84bef55","modified":1593487265774},{"_id":"public/blog/posts/201608021503/index.html","hash":"5b2666fec5767b0e71fab266cc6b0452b554c1f6","modified":1593487265774},{"_id":"public/blog/posts/201604072243/index.html","hash":"569a9e294ca265a932d7108b7c36c716d15c87a6","modified":1593487265774},{"_id":"public/blog/posts/201602131217/index.html","hash":"321f7f73acffadbeda68567d32cb275597c16cd3","modified":1593487265774},{"_id":"public/blog/posts/201602130101/index.html","hash":"f4af488e5f3080e68061eff836b6573c08883583","modified":1593487265774},{"_id":"public/blog/posts/201602082011/index.html","hash":"3b90988dc4fcde69770ee8edfda3d1d8e8811c86","modified":1593487265774},{"_id":"public/blog/posts/201602081955/index.html","hash":"da198dfcfd86ca39ab919572ab9b5c14d0880f05","modified":1593487265774},{"_id":"public/blog/posts/201602081412/index.html","hash":"6b922bf61e9e0fd8319b08e9802a77c400c4ea8d","modified":1593487265774},{"_id":"public/blog/posts/201602071410/index.html","hash":"66f3e9ecf81be840f7cf0c7c9b805757eeb5101d","modified":1593487265774},{"_id":"public/blog/posts/201602071317/index.html","hash":"515fb437f4bffba9af592674de7203ddee0099a9","modified":1593487265774},{"_id":"public/blog/posts/201602062240/index.html","hash":"cd70676d5cd7de739eefc5fcb3241d955f74b781","modified":1593487265774},{"_id":"public/blog/posts/201601312007/index.html","hash":"f4deef4b3fd005cdb6cafe15c1ce636d0fd58af0","modified":1593487265774},{"_id":"public/blog/posts/201601292210/index.html","hash":"a4a9afe3ca24dbf68546a2fc142fab8050d89f43","modified":1593487265774},{"_id":"public/blog/posts/201601281943/index.html","hash":"8de7bcfb29cba448691938f2ae69a04e8f33dc75","modified":1593487265774},{"_id":"public/blog/posts/201601281912/index.html","hash":"b5d681addb236d5bc585c9a3d05eadec8f97216e","modified":1593487265774},{"_id":"public/blog/posts/201601271719/index.html","hash":"b00105c2326d45dd175f30cc7143f9f8b54f8256","modified":1593487265774},{"_id":"public/blog/posts/201601081723/index.html","hash":"fb535ba8948fc0c00caaf0b240e4729f7e9fdee3","modified":1593487265774},{"_id":"public/blog/posts/201512151559/index.html","hash":"1ea8dba2f0be20ba43df7c7ce460a98b1b0b9b81","modified":1593487265774},{"_id":"public/blog/posts/201512151459/index.html","hash":"80d7d9eebba8ea47831170f6636a7e18d7e0e0e3","modified":1593487265774},{"_id":"public/blog/posts/201512071550/index.html","hash":"ba815ca035f8029e1bf85dbc99ecefcbb78c3af7","modified":1593487265774},{"_id":"public/blog/posts/201512071519/index.html","hash":"f4fe2f182b704215ba694f22d78aa9d48736f63e","modified":1593487265774},{"_id":"public/blog/posts/201512052105/index.html","hash":"7dde45d6866c4079b957abb85f8591236ea461dc","modified":1593487265774},{"_id":"public/blog/posts/201512052039/index.html","hash":"b8c4e670a3450a2b2999eaaa81ccca40a7015610","modified":1593487265774},{"_id":"public/blog/posts/201512051642/index.html","hash":"8a1a9fff06e916880552c19c1ebdfc88d21ec0e2","modified":1593487265774},{"_id":"public/blog/posts/201511292049/index.html","hash":"b817a6754a1af3de487177a0d57f83c12c8dfc7f","modified":1593487265774},{"_id":"public/blog/posts/201511111947/index.html","hash":"3d919174a6d567d927dadc12b73ba1038293f04b","modified":1593487265774},{"_id":"public/blog/posts/201511100107/index.html","hash":"120601636fdb771bc012ebcc2591b955bfaaa517","modified":1593487265774},{"_id":"public/blog/posts/201511081215/index.html","hash":"e7dac24a56a5b3ab8691a6f7d4a37b912198bf52","modified":1593487265774},{"_id":"public/blog/posts/201511052235/index.html","hash":"73bfc9e7062c3bfdf1b9e6caf2ad336d25659090","modified":1593487265774},{"_id":"public/blog/posts/201511041034/index.html","hash":"ff8e57072f520804ebf1cb5a5a3473c1625b4c73","modified":1593487265774},{"_id":"public/blog/posts/201511022234/index.html","hash":"a566fa9269582e21b24382f0f05abc4331470689","modified":1593487265774},{"_id":"public/blog/posts/201510300114/index.html","hash":"54d712250b779b46e4f823f039bf11531c050121","modified":1593487265774},{"_id":"public/blog/posts/201911241301/index.html","hash":"89e7722f229bb27c5ee6ce210f499f2ed3756320","modified":1593487265774},{"_id":"public/blog/archives/index.html","hash":"295a277a69e420c1e2158f959ca026a6619edd7e","modified":1593487265774},{"_id":"public/blog/archives/page/2/index.html","hash":"90f32872af6e6581076d179e1d8ab86973fdc9c2","modified":1593487265774},{"_id":"public/blog/archives/page/3/index.html","hash":"df93645d8d3b34d4269c01b23872adee1b6360ee","modified":1593487265774},{"_id":"public/blog/archives/page/4/index.html","hash":"5e1236cc0320c71017c6c1aeb8be1df67257087d","modified":1593487265774},{"_id":"public/blog/archives/page/5/index.html","hash":"cda14bcab528bb2b144c2ee2859d154d2e859306","modified":1593487265774},{"_id":"public/blog/archives/page/6/index.html","hash":"cc1b66f910fa7f3216c8abd32f4f864a49dfb566","modified":1593487265774},{"_id":"public/blog/archives/page/7/index.html","hash":"ee2d2a15fd6ab34cf4caf82daaba503a61525ddd","modified":1593487265774},{"_id":"public/blog/archives/page/8/index.html","hash":"8b415b3a79b25d3f16b0571b3d4b85aa4882dd4c","modified":1593487265774},{"_id":"public/blog/archives/page/9/index.html","hash":"1cef8f4c883b7a0756b440fcc1d17c45d2583f69","modified":1593487265774},{"_id":"public/blog/archives/page/10/index.html","hash":"cba178b2952ccd4152ed5d262f9f7eed759f37c4","modified":1593487265774},{"_id":"public/blog/archives/page/11/index.html","hash":"e20e04df2b16b5d9a3a7be035a4a98b9362d9eb8","modified":1593487265774},{"_id":"public/blog/archives/page/12/index.html","hash":"66185eded19650b53cf9acb4fd085197e95252fa","modified":1593487265774},{"_id":"public/blog/archives/2015/index.html","hash":"f73ced23a46b904e0a9c9cf6db051214c9e78abf","modified":1593487265774},{"_id":"public/blog/archives/2015/page/2/index.html","hash":"83cee52249c97f24ecc9673a08c7a27ebf2effe2","modified":1593487265774},{"_id":"public/blog/archives/2015/10/index.html","hash":"0e6bd359372d833b1cf210651ea51db15426350e","modified":1593487265774},{"_id":"public/blog/archives/2015/11/index.html","hash":"c045863107537f7fa4800b61d3c5621b7b5a33ef","modified":1593487265774},{"_id":"public/blog/archives/2015/12/index.html","hash":"beaa48c5acd3383819179c95ce505381adf1fc28","modified":1593487265774},{"_id":"public/blog/archives/2016/index.html","hash":"05e83c7002a314a1a3e414de87a1a5a782fd3da3","modified":1593487265774},{"_id":"public/blog/archives/2016/page/2/index.html","hash":"1c3c515b9d3ab0897faa46d2b57c39c7d0f8b62f","modified":1593487265774},{"_id":"public/blog/archives/2016/page/3/index.html","hash":"3daa6bdd6ac1cfd1a800950f0f773f576f68a085","modified":1593487265774},{"_id":"public/blog/archives/2016/page/4/index.html","hash":"7a7df66eda906120dffde741aa1ef0385d394d96","modified":1593487265774},{"_id":"public/blog/archives/2016/page/5/index.html","hash":"ca9c1ff268be595b0deb3a775c7eea2bb7f62d87","modified":1593487265774},{"_id":"public/blog/archives/2016/page/6/index.html","hash":"b02f962028c92ac23949cef6e566530dd28487e2","modified":1593487265774},{"_id":"public/blog/archives/2016/01/index.html","hash":"85f398a5d96c0a7b627513ff4fe997293996a7df","modified":1593487265774},{"_id":"public/blog/archives/2016/02/index.html","hash":"a3d9948b24950038c4cfca189d1b6cfc01877fee","modified":1593487265774},{"_id":"public/blog/archives/2016/04/index.html","hash":"cd43fb1d837d465f0def9572667f881d6536717b","modified":1593487265774},{"_id":"public/blog/archives/2016/08/index.html","hash":"bd792d40a01a9f733ffabf54d0ff2944e24c7342","modified":1593487265774},{"_id":"public/blog/archives/2016/08/page/2/index.html","hash":"ec70613331e24b875ae9d39902e932cfbdac081d","modified":1593487265774},{"_id":"public/blog/archives/2016/09/index.html","hash":"650b88e59a414594293699749fbd0886364de33b","modified":1593487265774},{"_id":"public/blog/archives/2016/09/page/2/index.html","hash":"7482338086121a7e805853c45f07ffc053153dec","modified":1593487265774},{"_id":"public/blog/archives/2016/10/index.html","hash":"199a7ca94e63e9c13aefd802a6c7a31776c46433","modified":1593487265774},{"_id":"public/blog/archives/2016/11/index.html","hash":"1178cf76c73d6eaa28e0d15d62a8a355bb07c467","modified":1593487265774},{"_id":"public/blog/archives/2016/12/index.html","hash":"fb30ed8669bb4f75516a8bb8f3b4f7ffd6700565","modified":1593487265774},{"_id":"public/blog/archives/2016/12/page/2/index.html","hash":"ddd970d6ca4bf6357ac02e9b39a3a0c7ba4f4d56","modified":1593487265774},{"_id":"public/blog/archives/2017/index.html","hash":"8be4031672b62261535a45fa1fd05b67ebc70b96","modified":1593487265774},{"_id":"public/blog/archives/2017/page/2/index.html","hash":"f8af68dc3363a91fd08613b6c42e31637243b7ab","modified":1593487265774},{"_id":"public/blog/archives/2017/page/3/index.html","hash":"be65db8158c84d79ebb947009fb5ba3765807902","modified":1593487265774},{"_id":"public/blog/archives/2017/01/index.html","hash":"2f95b63a24a67440164ba3c6f10423f59bddc610","modified":1593487265774},{"_id":"public/blog/archives/2017/02/index.html","hash":"d8c97d0b3d9e0d274297840dd5a41e25f0f4a934","modified":1593487265774},{"_id":"public/blog/archives/2017/03/index.html","hash":"6c1067f6c7d89484fc36ba2ef30f4c80cfe8c96c","modified":1593487265774},{"_id":"public/blog/archives/2017/04/index.html","hash":"e99f4615037b4ce27797afe2f74303e67ec262ce","modified":1593487265774},{"_id":"public/blog/archives/2017/05/index.html","hash":"8ae1d001bb242459249e2a260fcccd24ef288bd1","modified":1593487265774},{"_id":"public/blog/archives/2017/06/index.html","hash":"f5d538eb024cc47845ba48d4ec92f7b4f4b2c866","modified":1593487265774},{"_id":"public/blog/archives/2017/09/index.html","hash":"2feade72165962133238d930325dfff0af2a655f","modified":1593487265774},{"_id":"public/blog/archives/2017/11/index.html","hash":"f87ba79178f07977ffc424ff423b5632dcd04c44","modified":1593487265774},{"_id":"public/blog/archives/2017/12/index.html","hash":"290fbbcd73c1086d2ef5064f5b3e54a536410fa5","modified":1593487265774},{"_id":"public/blog/archives/2018/index.html","hash":"ed64b5eb2e1724fc46661e63fffa1419835a3c38","modified":1593487265774},{"_id":"public/blog/archives/2018/02/index.html","hash":"922f02e7d8e4bf6b6306f656ebb253d12713943f","modified":1593487265774},{"_id":"public/blog/archives/2018/03/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487265774},{"_id":"public/blog/archives/2018/04/index.html","hash":"ac4b463a13d8c4b53a2adbcf24d6bbb98f4b765e","modified":1593487265774},{"_id":"public/blog/archives/2018/05/index.html","hash":"df2e632ac1b2713b6af6eb70ac512d2028d0cb66","modified":1593487265774},{"_id":"public/blog/archives/2018/06/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487265774},{"_id":"public/blog/archives/2018/09/index.html","hash":"2090a8baa1ec1f15ba16144c81813148a0f48516","modified":1593487265774},{"_id":"public/blog/archives/2018/11/index.html","hash":"2ea6391b78e58300b49ef0f8c90231a20823a049","modified":1593487265774},{"_id":"public/blog/archives/2018/12/index.html","hash":"5bbf1a35d3458d7211c081a25079e7a27b963397","modified":1593487265774},{"_id":"public/blog/archives/2019/index.html","hash":"fe121848181cf0e152f86580716e2d3689c86962","modified":1593487265774},{"_id":"public/blog/archives/2019/03/index.html","hash":"b8518239dd474f896743f6af9ca9318c268fd4e5","modified":1593487265774},{"_id":"public/blog/archives/2019/11/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487265774},{"_id":"public/blog/archives/2019/05/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487265774},{"_id":"public/blog/archives/2019/12/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487265774},{"_id":"public/blog/categories/Android/index.html","hash":"9b512ea800cea885196715050af4986c4059fa94","modified":1593487265774},{"_id":"public/blog/categories/Android/page/2/index.html","hash":"88a636f4c5717a829ffcabc544a8000e96364e0b","modified":1593487265774},{"_id":"public/blog/categories/Android/page/3/index.html","hash":"c830cc60c54ff9f10612c7e29392b9d4ace712c5","modified":1593487265774},{"_id":"public/blog/categories/Web-Back-end/index.html","hash":"820ae84298465e4daee79baccf47c562f4752677","modified":1593487265774},{"_id":"public/blog/categories/Web-Back-end/page/2/index.html","hash":"843775397cd7518444c706262ef06cadc7e356d1","modified":1593487265774},{"_id":"public/blog/categories/Web-Back-end/page/3/index.html","hash":"862cb69b52d9021282d7a638cc121f8ab45baba0","modified":1593487265774},{"_id":"public/blog/categories/Web-Back-end/page/4/index.html","hash":"a4ddda425e85a46d9087acba9827ba1809c2a6b9","modified":1593487265774},{"_id":"public/blog/categories/Web-Front-end/index.html","hash":"3e9998df4bd3ab76ab8b8c413849ea6fc9ef0e14","modified":1593487265774},{"_id":"public/blog/categories/Web-Front-end/page/2/index.html","hash":"7db3daa2ae227df175fcc22b4cc28c13db3580f2","modified":1593487265774},{"_id":"public/blog/categories/Web-Front-end/page/3/index.html","hash":"57a5fdd4ff19c0486a2d94e029ba375a112ab375","modified":1593487265774},{"_id":"public/blog/categories/Web-Front-end/page/4/index.html","hash":"5c00dd5a62fc59e467a8b653bebe278f4f121847","modified":1593487265774},{"_id":"public/blog/categories/Other/index.html","hash":"77d404fbd39e2926d7d08347a3113f3f7c1b44b9","modified":1593487265774},{"_id":"public/blog/categories/iOS/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487265774},{"_id":"public/blog/tags/Android/index.html","hash":"9f5049d3b44bce07f04a61cecb877d042b476c49","modified":1593487265774},{"_id":"public/blog/tags/Android/page/2/index.html","hash":"ad22f32edf5ad02eaaa924a42258df2196724c97","modified":1593487265774},{"_id":"public/blog/tags/Android/page/3/index.html","hash":"eaf5b99207183d22905affc33f733e46f4231c4a","modified":1593487265774},{"_id":"public/blog/tags/Java/index.html","hash":"87dc8cabd08271dd35a6a4e9816bdfa349768248","modified":1593487265774},{"_id":"public/blog/tags/Java/page/2/index.html","hash":"4616c07d169f8d533b0631ca655617e0a15b7368","modified":1593487265774},{"_id":"public/blog/tags/Java/page/3/index.html","hash":"99fecdd2580d737d3c9bfafe8500c5b622151555","modified":1593487265774},{"_id":"public/blog/tags/JSON/index.html","hash":"4a5836b002bca1e4c4c784b440a2d7f027f6178e","modified":1593487265774},{"_id":"public/blog/tags/PHP/index.html","hash":"be2129c5e913af0a28fd69769980d3c11bae6e99","modified":1593487265774},{"_id":"public/blog/tags/PHP/page/2/index.html","hash":"c8bf910ec2b241bd46933732edee79581859ee2a","modified":1593487265774},{"_id":"public/blog/tags/Session/index.html","hash":"ce584f2fa38f1c41250cde291728fde01b0f4167","modified":1593487265774},{"_id":"public/blog/tags/SQLite/index.html","hash":"4dfccafd899e852c1864d9da2f918d2e4d1fadf7","modified":1593487265774},{"_id":"public/blog/tags/Tomcat/index.html","hash":"cd43fb1d837d465f0def9572667f881d6536717b","modified":1593487265774},{"_id":"public/blog/tags/CSS/index.html","hash":"6e0fbc9c198fcfc21f3992df929fe076aeb9b9dd","modified":1593487265774},{"_id":"public/blog/tags/JavaScript/index.html","hash":"2bbb8f7863347e3f00b499b88f7fd7be7676af6b","modified":1593487265774},{"_id":"public/blog/tags/JavaScript/page/2/index.html","hash":"33627d51732d4c32b39fd09a4c7d54ec7acb9393","modified":1593487265774},{"_id":"public/blog/tags/JavaScript/page/3/index.html","hash":"3ef5e3b19de82a9b1c0f5eb0f5e043d4347eccca","modified":1593487265774},{"_id":"public/blog/tags/jQuery/index.html","hash":"4aa584ba91cb8b537ec060fa0c4483f4449d0cf5","modified":1593487265774},{"_id":"public/blog/tags/AJAX/index.html","hash":"19c9f85111e0025854e70f52c0b5f7770b2bb456","modified":1593487265774},{"_id":"public/blog/tags/HTML/index.html","hash":"8761131e51a563940470403fde7e305475b76721","modified":1593487265774},{"_id":"public/blog/tags/Canvas/index.html","hash":"feca731830f1d11b853e943bf15f6274d4d6be40","modified":1593487265774},{"_id":"public/blog/tags/Apache/index.html","hash":"784d37313dc9142e7b3e2d944e02413634e0fd42","modified":1593487265774},{"_id":"public/blog/tags/WampServer/index.html","hash":"f37a5051c61606a1e15b1d70b39328ab50fe502a","modified":1593487265774},{"_id":"public/blog/tags/Cookie/index.html","hash":"1ed2ecad272e614a62bc4d42b532acee4b9b73ce","modified":1593487265774},{"_id":"public/blog/tags/WordPress/index.html","hash":"b9f05f4dc682bcbab20fef93a45f88a83f363d96","modified":1593487265774},{"_id":"public/blog/tags/Git/index.html","hash":"98575c325918d02ec895ef15630cdb21fcc54bc1","modified":1593487265774},{"_id":"public/blog/tags/Homestead/index.html","hash":"1d45cd73410c425951fb449f4aaac7fbd83cbe5d","modified":1593487265774},{"_id":"public/blog/tags/phpMyAdmin/index.html","hash":"32d4c09bcc3e9e082ba30f0fa8e36a4a4c73c816","modified":1593487265774},{"_id":"public/blog/tags/Vue-js/index.html","hash":"452c643e52689cb701500c7cc5d9661722563f79","modified":1593487265774},{"_id":"public/blog/tags/Laravel/index.html","hash":"64af4e9c51bed4bff04d3d4f3f85db7832e9e84d","modified":1593487265774},{"_id":"public/blog/tags/MySQL/index.html","hash":"ca0bdbf71701038af112d812cad0eeeeb26b5087","modified":1593487265774},{"_id":"public/blog/tags/SMTP/index.html","hash":"0df0394287f49c4cde72bbc1727f6914a6b0d9c9","modified":1593487265774},{"_id":"public/blog/tags/SSH/index.html","hash":"ea26838d1eca74a57d5b61d4c843ab07a51609f3","modified":1593487265774},{"_id":"public/blog/tags/虚拟机/index.html","hash":"2a63adf2cd2e71f40c81bbe04c1a2ee46e68d748","modified":1593487265774},{"_id":"public/blog/tags/Linux/index.html","hash":"7b4fd98d1ddce4a021c4144400b888348fa53ffa","modified":1593487265774},{"_id":"public/blog/tags/Nginx/index.html","hash":"db726337f24f0201e6aed111f131a8aa3f317f71","modified":1593487265774},{"_id":"public/blog/tags/SSL/index.html","hash":"50aaf2c7cf41459df2d82ce8a0a3efbe0ee0f555","modified":1593487265774},{"_id":"public/blog/tags/HTTPS/index.html","hash":"50aaf2c7cf41459df2d82ce8a0a3efbe0ee0f555","modified":1593487265774},{"_id":"public/blog/tags/微信/index.html","hash":"f9c55b8af60688751c2700ee63f371d13a58bb88","modified":1593487265774},{"_id":"public/blog/tags/ES6/index.html","hash":"3ec6d2c60af318ad1d160717f799fc193ecc2b0e","modified":1593487265774},{"_id":"public/blog/tags/Sass/index.html","hash":"8084e333d534b8a79587fb9370dd1fb5b6d004e3","modified":1593487265774},{"_id":"public/blog/tags/Hexo/index.html","hash":"c3d29424dcdbfe83c5f1f3bc608157f2c0efbf06","modified":1593487265774},{"_id":"public/blog/tags/Gulp/index.html","hash":"f0668138f8d940b59dbf2387261a55e5dc3ecb04","modified":1593487265774},{"_id":"public/blog/tags/JWT/index.html","hash":"4409d3ecfa8d1b491fd245097a780dc7e7b465cd","modified":1593487265774},{"_id":"public/blog/tags/API/index.html","hash":"4409d3ecfa8d1b491fd245097a780dc7e7b465cd","modified":1593487265774},{"_id":"public/blog/tags/小程序/index.html","hash":"cd36054717871ab1a4bb1df4b1625a4ffd8b2f1e","modified":1593487265774},{"_id":"public/blog/tags/Let-s-Encrypt/index.html","hash":"8daae3ff39a3c555196461327a5378129a8d699c","modified":1593487265774},{"_id":"public/blog/tags/ACME/index.html","hash":"8daae3ff39a3c555196461327a5378129a8d699c","modified":1593487265774},{"_id":"public/blog/tags/Certbot/index.html","hash":"922f02e7d8e4bf6b6306f656ebb253d12713943f","modified":1593487265774},{"_id":"public/blog/tags/GitHub-Pages/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487265774},{"_id":"public/blog/tags/CDN/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487265774},{"_id":"public/blog/tags/DNS/index.html","hash":"7ff1e481d326248ffb92de251c72e682ebb8e4a9","modified":1593487265774},{"_id":"public/blog/tags/Node-js/index.html","hash":"bf83a584a4b4e275934eb6a8bd24f4927ba115e9","modified":1593487265774},{"_id":"public/blog/tags/对象存储/index.html","hash":"ac4b463a13d8c4b53a2adbcf24d6bbb98f4b765e","modified":1593487265774},{"_id":"public/blog/tags/Vim/index.html","hash":"df2e632ac1b2713b6af6eb70ac512d2028d0cb66","modified":1593487265774},{"_id":"public/blog/tags/i18n/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487265774},{"_id":"public/blog/tags/CSV/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487265774},{"_id":"public/blog/tags/YAML/index.html","hash":"43eb205170ca006194c0ba4aba29840126708b99","modified":1593487265774},{"_id":"public/blog/tags/社交平台/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/分享/index.html","hash":"6c33070f6a28dd22fc0c160b4ef14a5508264ac2","modified":1593487265774},{"_id":"public/blog/tags/深度链接/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Deep-Linking/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Facebook/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Twitter/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Instagram/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/WhatsApp/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Line/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Messenger/index.html","hash":"a3498be0792c3e44dcdf106eaf455127520797df","modified":1593487265774},{"_id":"public/blog/tags/Android-Studio/index.html","hash":"ddd1e50e1e31aa7586c60c5b7f692545c7349f5d","modified":1593487265774},{"_id":"public/blog/tags/APP/index.html","hash":"ddd1e50e1e31aa7586c60c5b7f692545c7349f5d","modified":1593487265774},{"_id":"public/blog/tags/Promise/index.html","hash":"b8518239dd474f896743f6af9ca9318c268fd4e5","modified":1593487265774},{"_id":"public/blog/tags/Hybrid-App/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487265774},{"_id":"public/blog/tags/WebView/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487265774},{"_id":"public/blog/tags/JsBridge/index.html","hash":"4bcc678a5fe71ddae45189baac133bbeb5be8490","modified":1593487265774},{"_id":"public/blog/tags/PixiJS/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487265774},{"_id":"public/blog/tags/WebGL/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487265774},{"_id":"public/blog/tags/2D/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487265774},{"_id":"public/blog/tags/anime-js/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487265774},{"_id":"public/blog/tags/H5/index.html","hash":"5d2abf4ebb3d0d41a106812bc23100ed6795dde6","modified":1593487265774},{"_id":"public/blog/tags/Swift/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487265774},{"_id":"public/blog/tags/iOS/index.html","hash":"b0f8df2b20a20bd13708d7da4e1deb6d1fd94b27","modified":1593487265774},{"_id":"public/blog/tags/Serverless/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487265774},{"_id":"public/blog/tags/FaaS/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487265774},{"_id":"public/blog/tags/OpenWhisk/index.html","hash":"5465077c6211924086f51e55931abff22b3923f8","modified":1593487265774},{"_id":"public/blog/tags/Chrome/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487265774},{"_id":"public/blog/tags/WebComponents/index.html","hash":"55db1053984ca42f6fd2bef875ebe7d7f10c6ddc","modified":1593487265774},{"_id":"source/404.html","hash":"b18ee9a29706a8b7352fdcf012f02c77cbdd08e1","modified":1593487391596},{"_id":"source/404/index.html","hash":"b18ee9a29706a8b7352fdcf012f02c77cbdd08e1","modified":1593487464356}],"Category":[{"name":"Android","_id":"ckc1bt44u0003rqgjb2g79jr7"},{"name":"Web Back-end","_id":"ckc1bt47a002lrqgjbypkfvda"},{"name":"Web Front-end","_id":"ckc1bt47o0036rqgj1w5sgobr"},{"name":"Other","_id":"ckc1bt48p005frqgj2plj4yig"},{"name":"iOS","_id":"ckc1bt4bx00farqgjffof5iou"}],"Data":[],"Page":[{"_content":"INDEX","source":"index.html","raw":"INDEX","date":"2020-06-29T03:33:46.430Z","updated":"2020-06-29T03:33:46.430Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"ckc1bt43w0000rqgj6hxc5lr7","content":"INDEX","site":{"data":{}},"excerpt":"","more":"INDEX"},{"_content":"NOT FOUND","source":"404/index.html","raw":"NOT FOUND","date":"2020-06-30T03:24:24.356Z","updated":"2020-06-30T03:24:24.356Z","path":"404/index.html","_id":"ckc1dakkx00018pgjcs94f8fv","title":"","comments":1,"layout":"page","content":"NOT FOUND","site":{"data":{}},"excerpt":"","more":"NOT FOUND"}],"Post":[{"title":"Android 使用 Fragment 构造页面","date":"2015-11-02T14:34:33.000Z","_content":"\n假设你遇到这样的场景：1、需要将相同的界面元素显示在多个不同的页面。2、需要用几个相对独立的模块构成一个页面。\n\n单纯使用 Activity 难以满足这样的需求，需要通过 Fragment（碎片）实现。简单的说，不再直接在 Activity 上添加元素，而是在 Fragment 上添加元素，然后把这个 Fragment 添加到需要显示这些元素的 Activity 中。\n\n<!-- more -->\n\n你可以将一个 Fragment 添加到多个 Activity 、把多个 Fragment 添加到一个 Activity 、用一个 Fragment 替换另一个 Fragment ，让页面元素的管理更加灵活。\n\n首先创建一个 demo 应用，命名为 _FragmentPractice_ 。\n\n1、新建布局文件 fragment_default.xml ，它将作为 Fragment 的布局。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\">\n  <TextView\n    android:id=\"@+id/fragment_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"10dp\"\n    android:background=\"#FF4040\"\n    android:textColor=\"#FFF\"\n    android:text=\"●This is Fragment.\"/>\n</LinearLayout>\n```\n\n2、新建一个类文件 DefaultFragment.java ，稍后将调用它建立一个 Fragment 对象。\n\n``` java\npublic class DefaultFragment extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState){\n    View v = inflater.inflate(R.layout.fragment_default, parent, false);\n    return v;\n  }\n}\n```\n\n3、修改 Activity 的布局文件 activity_main.xml ，添加 FragmentLayout ，作为 Fragment 的容器。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:gravity=\"center_horizontal\"\n  android:paddingTop=\"30dp\"\n  android:background=\"#F2F2F2\" >\n  <TextView\n    android:id=\"@+id/activity_text\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:paddingBottom=\"20dp\"\n    android:text=\"●This is Activity.\" />\n  <TextView\n    android:id=\"@+id/container_text\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:paddingBottom=\"10dp\"\n    android:textColor=\"#EEC900\"\n    android:text=\"●This is Container. ↓\" />\n  <FrameLayout\n    android:id=\"@+id/fragmentContainer\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"#EEC900\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n4、修改 MainActivity.java ，使其继承 FragmentActivity ，然后重写 `onCreate` 方法，在该方法中创建 Fragment 。\n\n``` java\npublic class MainActivity extends FragmentActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mFragment = new DefaultFragment();\n    mFragmentManager.beginTransaction().add(R.id.fragmentContainer, mFragment).commit();\n  }\n}\n```\n\n运行结果：\n\n{% img /images/posts/2015/11/android_fragment.png 240  在页面中添加 Fragment %}","source":"_posts/2015-11-02@Android 使用 Fragment 构造页面.md","raw":"---\ntitle: Android 使用 Fragment 构造页面\ncategories:\n  - Android\ndate: 2015-11-02 22:34:33\ntags:\n  - Android\n  - Java\n---\n\n假设你遇到这样的场景：1、需要将相同的界面元素显示在多个不同的页面。2、需要用几个相对独立的模块构成一个页面。\n\n单纯使用 Activity 难以满足这样的需求，需要通过 Fragment（碎片）实现。简单的说，不再直接在 Activity 上添加元素，而是在 Fragment 上添加元素，然后把这个 Fragment 添加到需要显示这些元素的 Activity 中。\n\n<!-- more -->\n\n你可以将一个 Fragment 添加到多个 Activity 、把多个 Fragment 添加到一个 Activity 、用一个 Fragment 替换另一个 Fragment ，让页面元素的管理更加灵活。\n\n首先创建一个 demo 应用，命名为 _FragmentPractice_ 。\n\n1、新建布局文件 fragment_default.xml ，它将作为 Fragment 的布局。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\">\n  <TextView\n    android:id=\"@+id/fragment_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:padding=\"10dp\"\n    android:background=\"#FF4040\"\n    android:textColor=\"#FFF\"\n    android:text=\"●This is Fragment.\"/>\n</LinearLayout>\n```\n\n2、新建一个类文件 DefaultFragment.java ，稍后将调用它建立一个 Fragment 对象。\n\n``` java\npublic class DefaultFragment extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState){\n    View v = inflater.inflate(R.layout.fragment_default, parent, false);\n    return v;\n  }\n}\n```\n\n3、修改 Activity 的布局文件 activity_main.xml ，添加 FragmentLayout ，作为 Fragment 的容器。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:gravity=\"center_horizontal\"\n  android:paddingTop=\"30dp\"\n  android:background=\"#F2F2F2\" >\n  <TextView\n    android:id=\"@+id/activity_text\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:paddingBottom=\"20dp\"\n    android:text=\"●This is Activity.\" />\n  <TextView\n    android:id=\"@+id/container_text\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:paddingBottom=\"10dp\"\n    android:textColor=\"#EEC900\"\n    android:text=\"●This is Container. ↓\" />\n  <FrameLayout\n    android:id=\"@+id/fragmentContainer\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"#EEC900\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n4、修改 MainActivity.java ，使其继承 FragmentActivity ，然后重写 `onCreate` 方法，在该方法中创建 Fragment 。\n\n``` java\npublic class MainActivity extends FragmentActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mFragment = new DefaultFragment();\n    mFragmentManager.beginTransaction().add(R.id.fragmentContainer, mFragment).commit();\n  }\n}\n```\n\n运行结果：\n\n{% img /images/posts/2015/11/android_fragment.png 240  在页面中添加 Fragment %}","slug":"2015-11-02@Android 使用 Fragment 构造页面","published":1,"updated":"2020-06-29T03:32:42.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt44q0001rqgj2cjy08b1","content":"<p>假设你遇到这样的场景：1、需要将相同的界面元素显示在多个不同的页面。2、需要用几个相对独立的模块构成一个页面。</p>\n<p>单纯使用 Activity 难以满足这样的需求，需要通过 Fragment（碎片）实现。简单的说，不再直接在 Activity 上添加元素，而是在 Fragment 上添加元素，然后把这个 Fragment 添加到需要显示这些元素的 Activity 中。</p>\n<a id=\"more\"></a>\n\n<p>你可以将一个 Fragment 添加到多个 Activity 、把多个 Fragment 添加到一个 Activity 、用一个 Fragment 替换另一个 Fragment ，让页面元素的管理更加灵活。</p>\n<p>首先创建一个 demo 应用，命名为 <em>FragmentPractice</em> 。</p>\n<p>1、新建布局文件 fragment_default.xml ，它将作为 Fragment 的布局。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:padding=&quot;10dp&quot;\n    android:background=&quot;#FF4040&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:text=&quot;●This is Fragment.&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>2、新建一个类文件 DefaultFragment.java ，稍后将调用它建立一个 Fragment 对象。</p>\n<pre><code class=\"java\">public class DefaultFragment extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState){\n    View v = inflater.inflate(R.layout.fragment_default, parent, false);\n    return v;\n  }\n}</code></pre>\n<p>3、修改 Activity 的布局文件 activity_main.xml ，添加 FragmentLayout ，作为 Fragment 的容器。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:gravity=&quot;center_horizontal&quot;\n  android:paddingTop=&quot;30dp&quot;\n  android:background=&quot;#F2F2F2&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/activity_text&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:paddingBottom=&quot;20dp&quot;\n    android:text=&quot;●This is Activity.&quot; /&gt;\n  &lt;TextView\n    android:id=&quot;@+id/container_text&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:paddingBottom=&quot;10dp&quot;\n    android:textColor=&quot;#EEC900&quot;\n    android:text=&quot;●This is Container. ↓&quot; /&gt;\n  &lt;FrameLayout\n    android:id=&quot;@+id/fragmentContainer&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:background=&quot;#EEC900&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>4、修改 MainActivity.java ，使其继承 FragmentActivity ，然后重写 <code>onCreate</code> 方法，在该方法中创建 Fragment 。</p>\n<pre><code class=\"java\">public class MainActivity extends FragmentActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mFragment = new DefaultFragment();\n    mFragmentManager.beginTransaction().add(R.id.fragmentContainer, mFragment).commit();\n  }\n}</code></pre>\n<p>运行结果：</p>\n<img src=\"/images/posts/2015/11/android_fragment.png\" class=\"\" width=\"240\" title=\"在页面中添加 Fragment\">","site":{"data":{}},"excerpt":"<p>假设你遇到这样的场景：1、需要将相同的界面元素显示在多个不同的页面。2、需要用几个相对独立的模块构成一个页面。</p>\n<p>单纯使用 Activity 难以满足这样的需求，需要通过 Fragment（碎片）实现。简单的说，不再直接在 Activity 上添加元素，而是在 Fragment 上添加元素，然后把这个 Fragment 添加到需要显示这些元素的 Activity 中。</p>","more":"<p>你可以将一个 Fragment 添加到多个 Activity 、把多个 Fragment 添加到一个 Activity 、用一个 Fragment 替换另一个 Fragment ，让页面元素的管理更加灵活。</p>\n<p>首先创建一个 demo 应用，命名为 <em>FragmentPractice</em> 。</p>\n<p>1、新建布局文件 fragment_default.xml ，它将作为 Fragment 的布局。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:padding=&quot;10dp&quot;\n    android:background=&quot;#FF4040&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:text=&quot;●This is Fragment.&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>2、新建一个类文件 DefaultFragment.java ，稍后将调用它建立一个 Fragment 对象。</p>\n<pre><code class=\"java\">public class DefaultFragment extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState){\n    View v = inflater.inflate(R.layout.fragment_default, parent, false);\n    return v;\n  }\n}</code></pre>\n<p>3、修改 Activity 的布局文件 activity_main.xml ，添加 FragmentLayout ，作为 Fragment 的容器。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:gravity=&quot;center_horizontal&quot;\n  android:paddingTop=&quot;30dp&quot;\n  android:background=&quot;#F2F2F2&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/activity_text&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:paddingBottom=&quot;20dp&quot;\n    android:text=&quot;●This is Activity.&quot; /&gt;\n  &lt;TextView\n    android:id=&quot;@+id/container_text&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:paddingBottom=&quot;10dp&quot;\n    android:textColor=&quot;#EEC900&quot;\n    android:text=&quot;●This is Container. ↓&quot; /&gt;\n  &lt;FrameLayout\n    android:id=&quot;@+id/fragmentContainer&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:background=&quot;#EEC900&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>4、修改 MainActivity.java ，使其继承 FragmentActivity ，然后重写 <code>onCreate</code> 方法，在该方法中创建 Fragment 。</p>\n<pre><code class=\"java\">public class MainActivity extends FragmentActivity {\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mFragment = new DefaultFragment();\n    mFragmentManager.beginTransaction().add(R.id.fragmentContainer, mFragment).commit();\n  }\n}</code></pre>\n<p>运行结果：</p>\n<img src=\"/images/posts/2015/11/android_fragment.png\" class=\"\" width=\"240\" title=\"在页面中添加 Fragment\">"},{"title":"搭建 Android 开发环境","date":"2015-10-29T17:14:59.000Z","_content":"\n第一步，安装 JDK 。访问 Oracle 官网 [下载](http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html) 与操作系统对应版本的 JDK ，并完成安装。\n\n第二步，配置环境变量。以 Win7 为例，右键单击“计算机”，选择“属性”，进入“高级系统设置”，点击右下角的“环境变量”，在“系统变量”下方点击“新建”按钮。\n\n<!-- more -->\n\n新建以下变量：\n① JAVA_HOME ，变量值为 JDK 的安装路径（如 C:\\Program Files\\Java\\jdk1.8.0_51\\）。\n② PATH ，该变量已经存在，直接在变量值后增加“%JAVA_HOME%\\bin;”。\n③ CLASSPATH ，变量值为“.;%JAVA_HOME%\\ lib\\dt.jar; %JAVA_HOME%\\ lib\\tool.jar”。\n\n第三步，安装 IDE 。即集成开发环境，Android 的 IDE 有 Eclipse 和 Android Studio ，前者是一个开源的开发平台，后者是 Google 专门为 Android 设计的 IDE 。\n\n由于 Android Studio 尚不普及，大部分学习资料仍基于 Eclipse ，所以我选择安装 Eclipse 。然而并不是所有版本的 Eclipse 都默认支持 Android 开发，需要包含 ADT、SDK 以支持 Android 开发。可以直接下载已集成 ADT、SDK、Eclipse 的压缩包，解压即可使用。\n\n第四步，关联 SDK 。\n\n启动 Eclipse ，点击“Window”菜单选择“Preferences”，进入“Android”选项，在这里设置 SDK 的目录。\n至此，已经完成了 Android 开发环境的配置。\n进入“Window”→“Android Virtual Device Manager”创建一个虚拟设备，点击“File”→“New”→“Android Application Project”新建一个应用，直接运行将可以在屏幕上看到“Hello world!”。\n\n***该方案已过时，建议使用 Android Studio 作为 IDE 。**","source":"_posts/2015-10-30@搭建 Android 开发环境.md","raw":"---\ntitle: 搭建 Android 开发环境\ncategories:\n  - Android\ndate: 2015-10-30 01:14:59\ntags:\n  - Android\n---\n\n第一步，安装 JDK 。访问 Oracle 官网 [下载](http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html) 与操作系统对应版本的 JDK ，并完成安装。\n\n第二步，配置环境变量。以 Win7 为例，右键单击“计算机”，选择“属性”，进入“高级系统设置”，点击右下角的“环境变量”，在“系统变量”下方点击“新建”按钮。\n\n<!-- more -->\n\n新建以下变量：\n① JAVA_HOME ，变量值为 JDK 的安装路径（如 C:\\Program Files\\Java\\jdk1.8.0_51\\）。\n② PATH ，该变量已经存在，直接在变量值后增加“%JAVA_HOME%\\bin;”。\n③ CLASSPATH ，变量值为“.;%JAVA_HOME%\\ lib\\dt.jar; %JAVA_HOME%\\ lib\\tool.jar”。\n\n第三步，安装 IDE 。即集成开发环境，Android 的 IDE 有 Eclipse 和 Android Studio ，前者是一个开源的开发平台，后者是 Google 专门为 Android 设计的 IDE 。\n\n由于 Android Studio 尚不普及，大部分学习资料仍基于 Eclipse ，所以我选择安装 Eclipse 。然而并不是所有版本的 Eclipse 都默认支持 Android 开发，需要包含 ADT、SDK 以支持 Android 开发。可以直接下载已集成 ADT、SDK、Eclipse 的压缩包，解压即可使用。\n\n第四步，关联 SDK 。\n\n启动 Eclipse ，点击“Window”菜单选择“Preferences”，进入“Android”选项，在这里设置 SDK 的目录。\n至此，已经完成了 Android 开发环境的配置。\n进入“Window”→“Android Virtual Device Manager”创建一个虚拟设备，点击“File”→“New”→“Android Application Project”新建一个应用，直接运行将可以在屏幕上看到“Hello world!”。\n\n***该方案已过时，建议使用 Android Studio 作为 IDE 。**","slug":"2015-10-30@搭建 Android 开发环境","published":1,"updated":"2020-06-29T03:32:42.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt44t0002rqgj8p2dgcw5","content":"<p>第一步，安装 JDK 。访问 Oracle 官网 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\" target=\"_blank\" rel=\"noopener\">下载</a> 与操作系统对应版本的 JDK ，并完成安装。</p>\n<p>第二步，配置环境变量。以 Win7 为例，右键单击“计算机”，选择“属性”，进入“高级系统设置”，点击右下角的“环境变量”，在“系统变量”下方点击“新建”按钮。</p>\n<a id=\"more\"></a>\n\n<p>新建以下变量：<br>① JAVA_HOME ，变量值为 JDK 的安装路径（如 C:\\Program Files\\Java\\jdk1.8.0_51\\）。<br>② PATH ，该变量已经存在，直接在变量值后增加“%JAVA_HOME%\\bin;”。<br>③ CLASSPATH ，变量值为“.;%JAVA_HOME%\\ lib\\dt.jar; %JAVA_HOME%\\ lib\\tool.jar”。</p>\n<p>第三步，安装 IDE 。即集成开发环境，Android 的 IDE 有 Eclipse 和 Android Studio ，前者是一个开源的开发平台，后者是 Google 专门为 Android 设计的 IDE 。</p>\n<p>由于 Android Studio 尚不普及，大部分学习资料仍基于 Eclipse ，所以我选择安装 Eclipse 。然而并不是所有版本的 Eclipse 都默认支持 Android 开发，需要包含 ADT、SDK 以支持 Android 开发。可以直接下载已集成 ADT、SDK、Eclipse 的压缩包，解压即可使用。</p>\n<p>第四步，关联 SDK 。</p>\n<p>启动 Eclipse ，点击“Window”菜单选择“Preferences”，进入“Android”选项，在这里设置 SDK 的目录。<br>至此，已经完成了 Android 开发环境的配置。<br>进入“Window”→“Android Virtual Device Manager”创建一个虚拟设备，点击“File”→“New”→“Android Application Project”新建一个应用，直接运行将可以在屏幕上看到“Hello world!”。</p>\n<p><strong>*该方案已过时，建议使用 Android Studio 作为 IDE 。</strong></p>\n","site":{"data":{}},"excerpt":"<p>第一步，安装 JDK 。访问 Oracle 官网 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\" target=\"_blank\" rel=\"noopener\">下载</a> 与操作系统对应版本的 JDK ，并完成安装。</p>\n<p>第二步，配置环境变量。以 Win7 为例，右键单击“计算机”，选择“属性”，进入“高级系统设置”，点击右下角的“环境变量”，在“系统变量”下方点击“新建”按钮。</p>","more":"<p>新建以下变量：<br>① JAVA_HOME ，变量值为 JDK 的安装路径（如 C:\\Program Files\\Java\\jdk1.8.0_51\\）。<br>② PATH ，该变量已经存在，直接在变量值后增加“%JAVA_HOME%\\bin;”。<br>③ CLASSPATH ，变量值为“.;%JAVA_HOME%\\ lib\\dt.jar; %JAVA_HOME%\\ lib\\tool.jar”。</p>\n<p>第三步，安装 IDE 。即集成开发环境，Android 的 IDE 有 Eclipse 和 Android Studio ，前者是一个开源的开发平台，后者是 Google 专门为 Android 设计的 IDE 。</p>\n<p>由于 Android Studio 尚不普及，大部分学习资料仍基于 Eclipse ，所以我选择安装 Eclipse 。然而并不是所有版本的 Eclipse 都默认支持 Android 开发，需要包含 ADT、SDK 以支持 Android 开发。可以直接下载已集成 ADT、SDK、Eclipse 的压缩包，解压即可使用。</p>\n<p>第四步，关联 SDK 。</p>\n<p>启动 Eclipse ，点击“Window”菜单选择“Preferences”，进入“Android”选项，在这里设置 SDK 的目录。<br>至此，已经完成了 Android 开发环境的配置。<br>进入“Window”→“Android Virtual Device Manager”创建一个虚拟设备，点击“File”→“New”→“Android Application Project”新建一个应用，直接运行将可以在屏幕上看到“Hello world!”。</p>\n<p><strong>*该方案已过时，建议使用 Android Studio 作为 IDE 。</strong></p>"},{"title":"Android 使用 Toast 显示提示消息","date":"2015-11-04T02:34:38.000Z","_content":"\nToast 是 Android 中用来显示信息的一种机制，能够在屏幕上显示一段提示消息。\n\n新建一个 demo 应用并命名为 _ToastPractice_ ，生成默认的 Activity 。\n\n<!-- more -->\n\n1、修改 activity_main.xml ，添加一个按钮。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:paddingBottom=\"@dimen/activity_vertical_margin\"\n  android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n  android:paddingRight=\"@dimen/activity_horizontal_margin\"\n  android:paddingTop=\"@dimen/activity_vertical_margin\"\n  tools:context=\"com.caiyiming.toastpractice.MainActivity\" >\n  <Button\n    android:id=\"@+id/buttonToastShort\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"短提示\"/>\n</RelativeLayout>\n```\n\n2、修改 MainActivity.java ，添加按钮并绑定点击事件。点击该按钮将实例化 Toast 对象、在屏幕上显示短消息。\n\n``` java\npublic class MainActivity extends ActionBarActivity {\n\n  private Button mBtn_1;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtn_1 = (Button) findViewById(R.id.buttonToastShort);\n    mBtn_1.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast mToast = Toast.makeText(getApplicationContext(), \"这是一个短提示。\", Toast.LENGTH_SHORT);\n        mToast.show();\n      }\n    });\n  }\n\n}\n```\n\n程序运行效果：\n\n{% img side-by-side /images/posts/2015/11/android_toast_1.png 220 点击按钮 %}\n\n{% img side-by-side /images/posts/2015/11/android_toast_2.png 220 显示 Toast %}\n\n\n`makeText` 方法的第三个参数用于设置 Toast 出现的时长。Toast.LENGTH_SHORT 相当于2-3秒时长，使用 Toast.LENGTH_LONG 将使 Toast 显示更久。","source":"_posts/2015-11-04@Android 使用 Toast 显示提示消息.md","raw":"---\ntitle: Android 使用 Toast 显示提示消息\ncategories:\n  - Android\ndate: 2015-11-04 10:34:38\ntags:\n  - Android\n  - Java\n---\n\nToast 是 Android 中用来显示信息的一种机制，能够在屏幕上显示一段提示消息。\n\n新建一个 demo 应用并命名为 _ToastPractice_ ，生成默认的 Activity 。\n\n<!-- more -->\n\n1、修改 activity_main.xml ，添加一个按钮。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:paddingBottom=\"@dimen/activity_vertical_margin\"\n  android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n  android:paddingRight=\"@dimen/activity_horizontal_margin\"\n  android:paddingTop=\"@dimen/activity_vertical_margin\"\n  tools:context=\"com.caiyiming.toastpractice.MainActivity\" >\n  <Button\n    android:id=\"@+id/buttonToastShort\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"短提示\"/>\n</RelativeLayout>\n```\n\n2、修改 MainActivity.java ，添加按钮并绑定点击事件。点击该按钮将实例化 Toast 对象、在屏幕上显示短消息。\n\n``` java\npublic class MainActivity extends ActionBarActivity {\n\n  private Button mBtn_1;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtn_1 = (Button) findViewById(R.id.buttonToastShort);\n    mBtn_1.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast mToast = Toast.makeText(getApplicationContext(), \"这是一个短提示。\", Toast.LENGTH_SHORT);\n        mToast.show();\n      }\n    });\n  }\n\n}\n```\n\n程序运行效果：\n\n{% img side-by-side /images/posts/2015/11/android_toast_1.png 220 点击按钮 %}\n\n{% img side-by-side /images/posts/2015/11/android_toast_2.png 220 显示 Toast %}\n\n\n`makeText` 方法的第三个参数用于设置 Toast 出现的时长。Toast.LENGTH_SHORT 相当于2-3秒时长，使用 Toast.LENGTH_LONG 将使 Toast 显示更久。","slug":"2015-11-04@Android 使用 Toast 显示提示消息","published":1,"updated":"2020-06-29T03:32:42.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt44x0005rqgjgy10g2p3","content":"<p>Toast 是 Android 中用来显示信息的一种机制，能够在屏幕上显示一段提示消息。</p>\n<p>新建一个 demo 应用并命名为 <em>ToastPractice</em> ，生成默认的 Activity 。</p>\n<a id=\"more\"></a>\n\n<p>1、修改 activity_main.xml ，添加一个按钮。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n  android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n  tools:context=&quot;com.caiyiming.toastpractice.MainActivity&quot; &gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonToastShort&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;短提示&quot;/&gt;\n&lt;/RelativeLayout&gt;</code></pre>\n<p>2、修改 MainActivity.java ，添加按钮并绑定点击事件。点击该按钮将实例化 Toast 对象、在屏幕上显示短消息。</p>\n<pre><code class=\"java\">public class MainActivity extends ActionBarActivity {\n\n  private Button mBtn_1;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtn_1 = (Button) findViewById(R.id.buttonToastShort);\n    mBtn_1.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast mToast = Toast.makeText(getApplicationContext(), &quot;这是一个短提示。&quot;, Toast.LENGTH_SHORT);\n        mToast.show();\n      }\n    });\n  }\n\n}</code></pre>\n<p>程序运行效果：</p>\n<img src=\"/images/posts/2015/11/android_toast_1.png\" class=\"side-by-side\" width=\"220\" title=\"点击按钮\">\n\n<img src=\"/images/posts/2015/11/android_toast_2.png\" class=\"side-by-side\" width=\"220\" title=\"显示 Toast\">\n\n\n<p><code>makeText</code> 方法的第三个参数用于设置 Toast 出现的时长。Toast.LENGTH_SHORT 相当于2-3秒时长，使用 Toast.LENGTH_LONG 将使 Toast 显示更久。</p>\n","site":{"data":{}},"excerpt":"<p>Toast 是 Android 中用来显示信息的一种机制，能够在屏幕上显示一段提示消息。</p>\n<p>新建一个 demo 应用并命名为 <em>ToastPractice</em> ，生成默认的 Activity 。</p>","more":"<p>1、修改 activity_main.xml ，添加一个按钮。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n  android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n  tools:context=&quot;com.caiyiming.toastpractice.MainActivity&quot; &gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonToastShort&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;短提示&quot;/&gt;\n&lt;/RelativeLayout&gt;</code></pre>\n<p>2、修改 MainActivity.java ，添加按钮并绑定点击事件。点击该按钮将实例化 Toast 对象、在屏幕上显示短消息。</p>\n<pre><code class=\"java\">public class MainActivity extends ActionBarActivity {\n\n  private Button mBtn_1;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtn_1 = (Button) findViewById(R.id.buttonToastShort);\n    mBtn_1.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast mToast = Toast.makeText(getApplicationContext(), &quot;这是一个短提示。&quot;, Toast.LENGTH_SHORT);\n        mToast.show();\n      }\n    });\n  }\n\n}</code></pre>\n<p>程序运行效果：</p>\n<img src=\"/images/posts/2015/11/android_toast_1.png\" class=\"side-by-side\" width=\"220\" title=\"点击按钮\">\n\n<img src=\"/images/posts/2015/11/android_toast_2.png\" class=\"side-by-side\" width=\"220\" title=\"显示 Toast\">\n\n\n<p><code>makeText</code> 方法的第三个参数用于设置 Toast 出现的时长。Toast.LENGTH_SHORT 相当于2-3秒时长，使用 Toast.LENGTH_LONG 将使 Toast 显示更久。</p>"},{"title":"使用 ViewPager 实现页面滑动","date":"2015-11-05T14:35:22.000Z","_content":"\n新建一个 demo 应用，命名为 _ViewPagerPractice_ 。\n\n1、创建3个布局文件，添加不同的背景和文字，作为3个页面（Fragment）的布局。\n\n<!-- more -->\n\n``` xml\n<!-- fragment_one.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#FF4040\">\n  <TextView\n    android:id=\"@+id/fragment_left_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment One!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n``` xml\n<!-- fragment_two.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#FFD700\">\n  <TextView\n    android:id=\"@+id/fragment_middle_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment Two!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n``` xml\n<!-- fragment_three.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#4876FF\">\n  <TextView\n    android:id=\"@+id/fragment_right_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment Three!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n2、创建3个类，继承 Fragment ，用于构建并返回3个不同布局的 Fragment 。\n\n``` java\n// FragmentOne.java\npublic class FragmentOne extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_one, parent, false);\n    return v;\n  }\n}\n```\n\n``` java\n// FragmentTwo.java\npublic class FragmentTwo extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_two, parent, false);\n    return v;\n  }\n}\n```\n\n``` java\n// FragmentThree.java\npublic class FragmentThree extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_three, parent, false);\n    return v;\n  }\n}\n```\n\n3、编辑 Activity 类，使其继承自 FragmentActivity 。\n\n``` java\n// MainActivity.java\npublic class MainActivity extends FragmentActivity {\n\n  // 声明变量\n  private ViewPager mViewPager;\n  private ArrayList<Fragment> mFragmentList;\n  private FragmentOne mFragmentOne;\n  private FragmentTwo mFragmentTwo;\n  private FragmentThree mFragmentThree;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // 实例化 ViewPager 并设为视图\n    mViewPager = new ViewPager(this);\n    mViewPager.setId(R.id.viewPager);\n    setContentView(mViewPager);\n\n    // 实例化3个 Fragment 并存入数组\n    mFragmentOne = new FragmentOne();\n    mFragmentTwo = new FragmentTwo();\n    mFragmentThree = new FragmentThree();\n    mFragmentList = new ArrayList<Fragment>();\n    mFragmentList.add(mFragmentOne);\n    mFragmentList.add(mFragmentTwo);\n    mFragmentList.add(mFragmentThree);\n\n    // 为 ViewPager 适配数据\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mViewPager.setAdapter(new FragmentStatePagerAdapter(mFragmentManager) {\n      @Override\n      public int getCount() {\n        return mFragmentList.size();\n      }\n      @Override\n      public Fragment getItem(int id) {\n        return mFragmentList.get(id);\n      }\n    });\n    //设置第2个Fragment为初始显示界面\n    mViewPager.setCurrentItem(1);\n  }\n\n}\n```\n\n运行应用，可以看到已经实现了三屏滑动切换。\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_1.png 220 当前页 %}\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_2.png 220 切换上一页 %}\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_3.png 220 切换下一页 %}","source":"_posts/2015-11-05@使用 ViewPager 实现页面滑动.md","raw":"---\ntitle: 使用 ViewPager 实现页面滑动\ncategories:\n  - Android\ndate: 2015-11-05 22:35:22\ntags:\n  - Android\n  - Java\n---\n\n新建一个 demo 应用，命名为 _ViewPagerPractice_ 。\n\n1、创建3个布局文件，添加不同的背景和文字，作为3个页面（Fragment）的布局。\n\n<!-- more -->\n\n``` xml\n<!-- fragment_one.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#FF4040\">\n  <TextView\n    android:id=\"@+id/fragment_left_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment One!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n``` xml\n<!-- fragment_two.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#FFD700\">\n  <TextView\n    android:id=\"@+id/fragment_middle_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment Two!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n``` xml\n<!-- fragment_three.xml -->\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\" \n  android:background=\"#4876FF\">\n  <TextView\n    android:id=\"@+id/fragment_right_text\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Fragment Three!\"\n    android:textColor=\"#FFF\"\n    android:padding=\"10dp\"/>\n</LinearLayout>\n```\n\n2、创建3个类，继承 Fragment ，用于构建并返回3个不同布局的 Fragment 。\n\n``` java\n// FragmentOne.java\npublic class FragmentOne extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_one, parent, false);\n    return v;\n  }\n}\n```\n\n``` java\n// FragmentTwo.java\npublic class FragmentTwo extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_two, parent, false);\n    return v;\n  }\n}\n```\n\n``` java\n// FragmentThree.java\npublic class FragmentThree extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_three, parent, false);\n    return v;\n  }\n}\n```\n\n3、编辑 Activity 类，使其继承自 FragmentActivity 。\n\n``` java\n// MainActivity.java\npublic class MainActivity extends FragmentActivity {\n\n  // 声明变量\n  private ViewPager mViewPager;\n  private ArrayList<Fragment> mFragmentList;\n  private FragmentOne mFragmentOne;\n  private FragmentTwo mFragmentTwo;\n  private FragmentThree mFragmentThree;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // 实例化 ViewPager 并设为视图\n    mViewPager = new ViewPager(this);\n    mViewPager.setId(R.id.viewPager);\n    setContentView(mViewPager);\n\n    // 实例化3个 Fragment 并存入数组\n    mFragmentOne = new FragmentOne();\n    mFragmentTwo = new FragmentTwo();\n    mFragmentThree = new FragmentThree();\n    mFragmentList = new ArrayList<Fragment>();\n    mFragmentList.add(mFragmentOne);\n    mFragmentList.add(mFragmentTwo);\n    mFragmentList.add(mFragmentThree);\n\n    // 为 ViewPager 适配数据\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mViewPager.setAdapter(new FragmentStatePagerAdapter(mFragmentManager) {\n      @Override\n      public int getCount() {\n        return mFragmentList.size();\n      }\n      @Override\n      public Fragment getItem(int id) {\n        return mFragmentList.get(id);\n      }\n    });\n    //设置第2个Fragment为初始显示界面\n    mViewPager.setCurrentItem(1);\n  }\n\n}\n```\n\n运行应用，可以看到已经实现了三屏滑动切换。\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_1.png 220 当前页 %}\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_2.png 220 切换上一页 %}\n\n{% img side-by-side /images/posts/2015/11/android_view_pager_3.png 220 切换下一页 %}","slug":"2015-11-05@使用 ViewPager 实现页面滑动","published":1,"updated":"2020-06-29T03:32:42.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt44y0006rqgjb7zkf0qc","content":"<p>新建一个 demo 应用，命名为 <em>ViewPagerPractice</em> 。</p>\n<p>1、创建3个布局文件，添加不同的背景和文字，作为3个页面（Fragment）的布局。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"xml\">&lt;!-- fragment_one.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#FF4040&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_left_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment One!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<pre><code class=\"xml\">&lt;!-- fragment_two.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#FFD700&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_middle_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment Two!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<pre><code class=\"xml\">&lt;!-- fragment_three.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#4876FF&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_right_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment Three!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>2、创建3个类，继承 Fragment ，用于构建并返回3个不同布局的 Fragment 。</p>\n<pre><code class=\"java\">// FragmentOne.java\npublic class FragmentOne extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_one, parent, false);\n    return v;\n  }\n}</code></pre>\n<pre><code class=\"java\">// FragmentTwo.java\npublic class FragmentTwo extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_two, parent, false);\n    return v;\n  }\n}</code></pre>\n<pre><code class=\"java\">// FragmentThree.java\npublic class FragmentThree extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_three, parent, false);\n    return v;\n  }\n}</code></pre>\n<p>3、编辑 Activity 类，使其继承自 FragmentActivity 。</p>\n<pre><code class=\"java\">// MainActivity.java\npublic class MainActivity extends FragmentActivity {\n\n  // 声明变量\n  private ViewPager mViewPager;\n  private ArrayList&lt;Fragment&gt; mFragmentList;\n  private FragmentOne mFragmentOne;\n  private FragmentTwo mFragmentTwo;\n  private FragmentThree mFragmentThree;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // 实例化 ViewPager 并设为视图\n    mViewPager = new ViewPager(this);\n    mViewPager.setId(R.id.viewPager);\n    setContentView(mViewPager);\n\n    // 实例化3个 Fragment 并存入数组\n    mFragmentOne = new FragmentOne();\n    mFragmentTwo = new FragmentTwo();\n    mFragmentThree = new FragmentThree();\n    mFragmentList = new ArrayList&lt;Fragment&gt;();\n    mFragmentList.add(mFragmentOne);\n    mFragmentList.add(mFragmentTwo);\n    mFragmentList.add(mFragmentThree);\n\n    // 为 ViewPager 适配数据\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mViewPager.setAdapter(new FragmentStatePagerAdapter(mFragmentManager) {\n      @Override\n      public int getCount() {\n        return mFragmentList.size();\n      }\n      @Override\n      public Fragment getItem(int id) {\n        return mFragmentList.get(id);\n      }\n    });\n    //设置第2个Fragment为初始显示界面\n    mViewPager.setCurrentItem(1);\n  }\n\n}</code></pre>\n<p>运行应用，可以看到已经实现了三屏滑动切换。</p>\n<img src=\"/images/posts/2015/11/android_view_pager_1.png\" class=\"side-by-side\" width=\"220\" title=\"当前页\">\n\n<img src=\"/images/posts/2015/11/android_view_pager_2.png\" class=\"side-by-side\" width=\"220\" title=\"切换上一页\">\n\n<img src=\"/images/posts/2015/11/android_view_pager_3.png\" class=\"side-by-side\" width=\"220\" title=\"切换下一页\">","site":{"data":{}},"excerpt":"<p>新建一个 demo 应用，命名为 <em>ViewPagerPractice</em> 。</p>\n<p>1、创建3个布局文件，添加不同的背景和文字，作为3个页面（Fragment）的布局。</p>","more":"<pre><code class=\"xml\">&lt;!-- fragment_one.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#FF4040&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_left_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment One!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<pre><code class=\"xml\">&lt;!-- fragment_two.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#FFD700&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_middle_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment Two!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<pre><code class=\"xml\">&lt;!-- fragment_three.xml --&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot; \n  android:background=&quot;#4876FF&quot;&gt;\n  &lt;TextView\n    android:id=&quot;@+id/fragment_right_text&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;Fragment Three!&quot;\n    android:textColor=&quot;#FFF&quot;\n    android:padding=&quot;10dp&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>2、创建3个类，继承 Fragment ，用于构建并返回3个不同布局的 Fragment 。</p>\n<pre><code class=\"java\">// FragmentOne.java\npublic class FragmentOne extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_one, parent, false);\n    return v;\n  }\n}</code></pre>\n<pre><code class=\"java\">// FragmentTwo.java\npublic class FragmentTwo extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_two, parent, false);\n    return v;\n  }\n}</code></pre>\n<pre><code class=\"java\">// FragmentThree.java\npublic class FragmentThree extends Fragment {\n  @Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {\n    View v = inflater.inflate(R.layout.fragment_three, parent, false);\n    return v;\n  }\n}</code></pre>\n<p>3、编辑 Activity 类，使其继承自 FragmentActivity 。</p>\n<pre><code class=\"java\">// MainActivity.java\npublic class MainActivity extends FragmentActivity {\n\n  // 声明变量\n  private ViewPager mViewPager;\n  private ArrayList&lt;Fragment&gt; mFragmentList;\n  private FragmentOne mFragmentOne;\n  private FragmentTwo mFragmentTwo;\n  private FragmentThree mFragmentThree;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // 实例化 ViewPager 并设为视图\n    mViewPager = new ViewPager(this);\n    mViewPager.setId(R.id.viewPager);\n    setContentView(mViewPager);\n\n    // 实例化3个 Fragment 并存入数组\n    mFragmentOne = new FragmentOne();\n    mFragmentTwo = new FragmentTwo();\n    mFragmentThree = new FragmentThree();\n    mFragmentList = new ArrayList&lt;Fragment&gt;();\n    mFragmentList.add(mFragmentOne);\n    mFragmentList.add(mFragmentTwo);\n    mFragmentList.add(mFragmentThree);\n\n    // 为 ViewPager 适配数据\n    FragmentManager mFragmentManager = getSupportFragmentManager();\n    mViewPager.setAdapter(new FragmentStatePagerAdapter(mFragmentManager) {\n      @Override\n      public int getCount() {\n        return mFragmentList.size();\n      }\n      @Override\n      public Fragment getItem(int id) {\n        return mFragmentList.get(id);\n      }\n    });\n    //设置第2个Fragment为初始显示界面\n    mViewPager.setCurrentItem(1);\n  }\n\n}</code></pre>\n<p>运行应用，可以看到已经实现了三屏滑动切换。</p>\n<img src=\"/images/posts/2015/11/android_view_pager_1.png\" class=\"side-by-side\" width=\"220\" title=\"当前页\">\n\n<img src=\"/images/posts/2015/11/android_view_pager_2.png\" class=\"side-by-side\" width=\"220\" title=\"切换上一页\">\n\n<img src=\"/images/posts/2015/11/android_view_pager_3.png\" class=\"side-by-side\" width=\"220\" title=\"切换下一页\">"},{"title":"原生 SQL 语句操作 SQLite 数据库","date":"2015-11-08T04:15:40.000Z","_content":"\n如果你既不具备数据库基础，又对 SQLite 没有任何了解，建议你先阅读相关文章补充一下理论知识。如果你具备数据库基础、希望更直接地了解 SQLite ，那么接下来的内容可能正是你想要的。\n\n<!-- more -->\n\n在 Android 中操作 SQLite 数据库有两种方式：使用封装的 API 、直接执行原生 SQL 语句。\n\n在这个 demo 中我将直接使用原生 SQL 语句操作数据库。\n<!-- more -->\n\n新建一个应用并命名为 _SQLitePractice_ ，创建默认的 Activity 。不用修改布局，使用 LogCat 输出日志来监控代码的执行。\n\n在 AndroidManifest.xml 中添加权限：\n\n``` java\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.caiyiming.sqlitepractice\"\n  android:versionCode=\"1\"\n  android:versionName=\"1.0\" >\n  <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"></uses-permission>\n  <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"></uses-permission>\n  <uses-sdk\n    android:minSdkVersion=\"8\"\n    android:targetSdkVersion=\"19\" />\n  <application\n    android:allowBackup=\"true\"\n    android:icon=\"@drawable/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\" >\n    <activity\n      android:name=\".MainActivity\"\n      android:label=\"@string/app_name\" >\n      <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n      </intent-filter>\n    </activity>\n  </application>\n</manifest>\n```\n\n编写 MainActivity.java 文件。\n\n添加 `SQLitePractice` 方法用于执行测试代码，它将在 Activity 的 `onCreate` 方法中被执行。每执行一步操作，判断是否成功并使用 LogCat 输出日志。\n\n``` java\npublic class MainActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    SQLitePractice();\n  }\n\n  protected void SQLitePractice(){\n    String mSQL;\n    Cursor mCursor;\n    String mId = null;\n    String mUsername = null;\n    String mPassword = null;\n    // 创建文件夹\n    File mFolder  = new File(\"/data/data/com.caiyiming.sqlitepractice/databases/\");\n    if (!mFolder.exists()) {\n      mFolder.mkdirs();\n    }\n    // 创建数据库\n    SQLiteDatabase mDB;\n    mDB = SQLiteDatabase.openOrCreateDatabase(\"/data/data/com.caiyiming.sqlitepractice/databases/user.db\", null);\n    if (mDB.isOpen()) {\n      Log.d(\"MainActivity\", \"数据库打开成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据库打开失败！\");\n    }\n    // 创建数据表\n    mSQL = \"CREATE TABLE IF NOT EXISTS user(_id Integer Primary Key Autoincrement, username Text, password Text)\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM sqlite_master WHERE name='user'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()!=0) {\n      Log.d(\"MainActivity\", \"数据表创建成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据表创建失败！\");\n    }\n    // 插入数据\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()==0) {\n      mSQL = \"INSERT INTO user('username','password') VALUES('小蔡', '0123456789')\";\n      mDB.execSQL(mSQL);\n    }\n    if (mCursor.getCount()!=0) {\n      Log.d(\"MainActivity\", \"数据插入成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据插入成功！\");\n    }\n    // 查询数据\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.moveToFirst()) {\n      mId = mCursor.getString(mCursor.getColumnIndex(\"_id\"));\n      mUsername = mCursor.getString(mCursor.getColumnIndex(\"username\"));\n      mPassword = mCursor.getString(mCursor.getColumnIndex(\"password\"));\n      Log.d(\"MainActivity\", \"查询数据成功！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    } else{\n      Log.d(\"MainActivity\", \"查询数据失败！\");\n    }\n    // 修改数据\n    mSQL = \"UPDATE  user SET password='9876543210' WHERE username='小蔡'\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    mCursor.moveToFirst();\n    mUsername = mCursor.getString(mCursor.getColumnIndex(\"username\"));\n    mPassword = mCursor.getString(mCursor.getColumnIndex(\"password\"));\n    if (mPassword.equals(\"9876543210\")) {\n      Log.d(\"MainActivity\", \"数据修改成功！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    } else{\n      Log.d(\"MainActivity\", \"修改数据失败！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    }\n    // 删除数据\n    mSQL = \"DELETE FROM user WHERE username='小蔡'\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (!mCursor.moveToFirst()) {\n      Log.d(\"MainActivity\", \"删除数据成功！\");\n    }\n    // 关闭数据库\n    mDB.close();\n    if (!mDB.isOpen()) {\n      Log.d(\"MainActivity\", \"数据库关闭成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据库关闭失败！\");\n    }\n  }\n\n}\n```\n\n执行程序，新建一个标签为\"MainActivity\"的筛选，观察 LogCat 输出的日志。\n\n{% img /images/posts/2015/11/android_sqlite.png 480 控制台日志 %}\n\n通过 LogCat 日志可以了解到，代码中对 SQLite 数据库的操作都已经执行了。","source":"_posts/2015-11-08@原生 SQL 语句操作 SQLite 数据库.md","raw":"---\ntitle: 原生 SQL 语句操作 SQLite 数据库\ncategories:\n  - Android\ndate: 2015-11-08 12:15:40\ntags:\n  - Android\n  - Java\n---\n\n如果你既不具备数据库基础，又对 SQLite 没有任何了解，建议你先阅读相关文章补充一下理论知识。如果你具备数据库基础、希望更直接地了解 SQLite ，那么接下来的内容可能正是你想要的。\n\n<!-- more -->\n\n在 Android 中操作 SQLite 数据库有两种方式：使用封装的 API 、直接执行原生 SQL 语句。\n\n在这个 demo 中我将直接使用原生 SQL 语句操作数据库。\n<!-- more -->\n\n新建一个应用并命名为 _SQLitePractice_ ，创建默认的 Activity 。不用修改布局，使用 LogCat 输出日志来监控代码的执行。\n\n在 AndroidManifest.xml 中添加权限：\n\n``` java\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.caiyiming.sqlitepractice\"\n  android:versionCode=\"1\"\n  android:versionName=\"1.0\" >\n  <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"></uses-permission>\n  <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"></uses-permission>\n  <uses-sdk\n    android:minSdkVersion=\"8\"\n    android:targetSdkVersion=\"19\" />\n  <application\n    android:allowBackup=\"true\"\n    android:icon=\"@drawable/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\" >\n    <activity\n      android:name=\".MainActivity\"\n      android:label=\"@string/app_name\" >\n      <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n      </intent-filter>\n    </activity>\n  </application>\n</manifest>\n```\n\n编写 MainActivity.java 文件。\n\n添加 `SQLitePractice` 方法用于执行测试代码，它将在 Activity 的 `onCreate` 方法中被执行。每执行一步操作，判断是否成功并使用 LogCat 输出日志。\n\n``` java\npublic class MainActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    SQLitePractice();\n  }\n\n  protected void SQLitePractice(){\n    String mSQL;\n    Cursor mCursor;\n    String mId = null;\n    String mUsername = null;\n    String mPassword = null;\n    // 创建文件夹\n    File mFolder  = new File(\"/data/data/com.caiyiming.sqlitepractice/databases/\");\n    if (!mFolder.exists()) {\n      mFolder.mkdirs();\n    }\n    // 创建数据库\n    SQLiteDatabase mDB;\n    mDB = SQLiteDatabase.openOrCreateDatabase(\"/data/data/com.caiyiming.sqlitepractice/databases/user.db\", null);\n    if (mDB.isOpen()) {\n      Log.d(\"MainActivity\", \"数据库打开成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据库打开失败！\");\n    }\n    // 创建数据表\n    mSQL = \"CREATE TABLE IF NOT EXISTS user(_id Integer Primary Key Autoincrement, username Text, password Text)\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM sqlite_master WHERE name='user'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()!=0) {\n      Log.d(\"MainActivity\", \"数据表创建成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据表创建失败！\");\n    }\n    // 插入数据\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()==0) {\n      mSQL = \"INSERT INTO user('username','password') VALUES('小蔡', '0123456789')\";\n      mDB.execSQL(mSQL);\n    }\n    if (mCursor.getCount()!=0) {\n      Log.d(\"MainActivity\", \"数据插入成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据插入成功！\");\n    }\n    // 查询数据\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.moveToFirst()) {\n      mId = mCursor.getString(mCursor.getColumnIndex(\"_id\"));\n      mUsername = mCursor.getString(mCursor.getColumnIndex(\"username\"));\n      mPassword = mCursor.getString(mCursor.getColumnIndex(\"password\"));\n      Log.d(\"MainActivity\", \"查询数据成功！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    } else{\n      Log.d(\"MainActivity\", \"查询数据失败！\");\n    }\n    // 修改数据\n    mSQL = \"UPDATE  user SET password='9876543210' WHERE username='小蔡'\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    mCursor.moveToFirst();\n    mUsername = mCursor.getString(mCursor.getColumnIndex(\"username\"));\n    mPassword = mCursor.getString(mCursor.getColumnIndex(\"password\"));\n    if (mPassword.equals(\"9876543210\")) {\n      Log.d(\"MainActivity\", \"数据修改成功！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    } else{\n      Log.d(\"MainActivity\", \"修改数据失败！\");\n      Log.d(\"MainActivity\", \"编号:\"+mId+\", 用户:\"+mUsername+\", 密码:\"+mPassword);\n    }\n    // 删除数据\n    mSQL = \"DELETE FROM user WHERE username='小蔡'\";\n    mDB.execSQL(mSQL);\n    mSQL = \"SELECT * FROM user WHERE username='小蔡'\";\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (!mCursor.moveToFirst()) {\n      Log.d(\"MainActivity\", \"删除数据成功！\");\n    }\n    // 关闭数据库\n    mDB.close();\n    if (!mDB.isOpen()) {\n      Log.d(\"MainActivity\", \"数据库关闭成功！\");\n    } else{\n      Log.d(\"MainActivity\", \"数据库关闭失败！\");\n    }\n  }\n\n}\n```\n\n执行程序，新建一个标签为\"MainActivity\"的筛选，观察 LogCat 输出的日志。\n\n{% img /images/posts/2015/11/android_sqlite.png 480 控制台日志 %}\n\n通过 LogCat 日志可以了解到，代码中对 SQLite 数据库的操作都已经执行了。","slug":"2015-11-08@原生 SQL 语句操作 SQLite 数据库","published":1,"updated":"2020-06-29T03:32:42.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt44z0007rqgjdily9gmb","content":"<p>如果你既不具备数据库基础，又对 SQLite 没有任何了解，建议你先阅读相关文章补充一下理论知识。如果你具备数据库基础、希望更直接地了解 SQLite ，那么接下来的内容可能正是你想要的。</p>\n<a id=\"more\"></a>\n\n<p>在 Android 中操作 SQLite 数据库有两种方式：使用封装的 API 、直接执行原生 SQL 语句。</p>\n<p>在这个 demo 中我将直接使用原生 SQL 语句操作数据库。</p>\n<!-- more -->\n\n<p>新建一个应用并命名为 <em>SQLitePractice</em> ，创建默认的 Activity 。不用修改布局，使用 LogCat 输出日志来监控代码的执行。</p>\n<p>在 AndroidManifest.xml 中添加权限：</p>\n<pre><code class=\"java\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  package=&quot;com.caiyiming.sqlitepractice&quot;\n  android:versionCode=&quot;1&quot;\n  android:versionName=&quot;1.0&quot; &gt;\n  &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;\n  &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt;\n  &lt;uses-sdk\n    android:minSdkVersion=&quot;8&quot;\n    android:targetSdkVersion=&quot;19&quot; /&gt;\n  &lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@drawable/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:theme=&quot;@style/AppTheme&quot; &gt;\n    &lt;activity\n      android:name=&quot;.MainActivity&quot;\n      android:label=&quot;@string/app_name&quot; &gt;\n      &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n      &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;</code></pre>\n<p>编写 MainActivity.java 文件。</p>\n<p>添加 <code>SQLitePractice</code> 方法用于执行测试代码，它将在 Activity 的 <code>onCreate</code> 方法中被执行。每执行一步操作，判断是否成功并使用 LogCat 输出日志。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    SQLitePractice();\n  }\n\n  protected void SQLitePractice(){\n    String mSQL;\n    Cursor mCursor;\n    String mId = null;\n    String mUsername = null;\n    String mPassword = null;\n    // 创建文件夹\n    File mFolder  = new File(&quot;/data/data/com.caiyiming.sqlitepractice/databases/&quot;);\n    if (!mFolder.exists()) {\n      mFolder.mkdirs();\n    }\n    // 创建数据库\n    SQLiteDatabase mDB;\n    mDB = SQLiteDatabase.openOrCreateDatabase(&quot;/data/data/com.caiyiming.sqlitepractice/databases/user.db&quot;, null);\n    if (mDB.isOpen()) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据库打开成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据库打开失败！&quot;);\n    }\n    // 创建数据表\n    mSQL = &quot;CREATE TABLE IF NOT EXISTS user(_id Integer Primary Key Autoincrement, username Text, password Text)&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM sqlite_master WHERE name=&#39;user&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()!=0) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据表创建成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据表创建失败！&quot;);\n    }\n    // 插入数据\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()==0) {\n      mSQL = &quot;INSERT INTO user(&#39;username&#39;,&#39;password&#39;) VALUES(&#39;小蔡&#39;, &#39;0123456789&#39;)&quot;;\n      mDB.execSQL(mSQL);\n    }\n    if (mCursor.getCount()!=0) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据插入成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据插入成功！&quot;);\n    }\n    // 查询数据\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.moveToFirst()) {\n      mId = mCursor.getString(mCursor.getColumnIndex(&quot;_id&quot;));\n      mUsername = mCursor.getString(mCursor.getColumnIndex(&quot;username&quot;));\n      mPassword = mCursor.getString(mCursor.getColumnIndex(&quot;password&quot;));\n      Log.d(&quot;MainActivity&quot;, &quot;查询数据成功！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;查询数据失败！&quot;);\n    }\n    // 修改数据\n    mSQL = &quot;UPDATE  user SET password=&#39;9876543210&#39; WHERE username=&#39;小蔡&#39;&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    mCursor.moveToFirst();\n    mUsername = mCursor.getString(mCursor.getColumnIndex(&quot;username&quot;));\n    mPassword = mCursor.getString(mCursor.getColumnIndex(&quot;password&quot;));\n    if (mPassword.equals(&quot;9876543210&quot;)) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据修改成功！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;修改数据失败！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    }\n    // 删除数据\n    mSQL = &quot;DELETE FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (!mCursor.moveToFirst()) {\n      Log.d(&quot;MainActivity&quot;, &quot;删除数据成功！&quot;);\n    }\n    // 关闭数据库\n    mDB.close();\n    if (!mDB.isOpen()) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据库关闭成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据库关闭失败！&quot;);\n    }\n  }\n\n}</code></pre>\n<p>执行程序，新建一个标签为”MainActivity”的筛选，观察 LogCat 输出的日志。</p>\n<img src=\"/images/posts/2015/11/android_sqlite.png\" class=\"\" width=\"480\" title=\"控制台日志\">\n\n<p>通过 LogCat 日志可以了解到，代码中对 SQLite 数据库的操作都已经执行了。</p>\n","site":{"data":{}},"excerpt":"<p>如果你既不具备数据库基础，又对 SQLite 没有任何了解，建议你先阅读相关文章补充一下理论知识。如果你具备数据库基础、希望更直接地了解 SQLite ，那么接下来的内容可能正是你想要的。</p>","more":"<p>在 Android 中操作 SQLite 数据库有两种方式：使用封装的 API 、直接执行原生 SQL 语句。</p>\n<p>在这个 demo 中我将直接使用原生 SQL 语句操作数据库。</p>\n<!-- more -->\n\n<p>新建一个应用并命名为 <em>SQLitePractice</em> ，创建默认的 Activity 。不用修改布局，使用 LogCat 输出日志来监控代码的执行。</p>\n<p>在 AndroidManifest.xml 中添加权限：</p>\n<pre><code class=\"java\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  package=&quot;com.caiyiming.sqlitepractice&quot;\n  android:versionCode=&quot;1&quot;\n  android:versionName=&quot;1.0&quot; &gt;\n  &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;\n  &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt;&lt;/uses-permission&gt;\n  &lt;uses-sdk\n    android:minSdkVersion=&quot;8&quot;\n    android:targetSdkVersion=&quot;19&quot; /&gt;\n  &lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@drawable/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:theme=&quot;@style/AppTheme&quot; &gt;\n    &lt;activity\n      android:name=&quot;.MainActivity&quot;\n      android:label=&quot;@string/app_name&quot; &gt;\n      &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n      &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;</code></pre>\n<p>编写 MainActivity.java 文件。</p>\n<p>添加 <code>SQLitePractice</code> 方法用于执行测试代码，它将在 Activity 的 <code>onCreate</code> 方法中被执行。每执行一步操作，判断是否成功并使用 LogCat 输出日志。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    SQLitePractice();\n  }\n\n  protected void SQLitePractice(){\n    String mSQL;\n    Cursor mCursor;\n    String mId = null;\n    String mUsername = null;\n    String mPassword = null;\n    // 创建文件夹\n    File mFolder  = new File(&quot;/data/data/com.caiyiming.sqlitepractice/databases/&quot;);\n    if (!mFolder.exists()) {\n      mFolder.mkdirs();\n    }\n    // 创建数据库\n    SQLiteDatabase mDB;\n    mDB = SQLiteDatabase.openOrCreateDatabase(&quot;/data/data/com.caiyiming.sqlitepractice/databases/user.db&quot;, null);\n    if (mDB.isOpen()) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据库打开成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据库打开失败！&quot;);\n    }\n    // 创建数据表\n    mSQL = &quot;CREATE TABLE IF NOT EXISTS user(_id Integer Primary Key Autoincrement, username Text, password Text)&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM sqlite_master WHERE name=&#39;user&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()!=0) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据表创建成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据表创建失败！&quot;);\n    }\n    // 插入数据\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.getCount()==0) {\n      mSQL = &quot;INSERT INTO user(&#39;username&#39;,&#39;password&#39;) VALUES(&#39;小蔡&#39;, &#39;0123456789&#39;)&quot;;\n      mDB.execSQL(mSQL);\n    }\n    if (mCursor.getCount()!=0) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据插入成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据插入成功！&quot;);\n    }\n    // 查询数据\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (mCursor.moveToFirst()) {\n      mId = mCursor.getString(mCursor.getColumnIndex(&quot;_id&quot;));\n      mUsername = mCursor.getString(mCursor.getColumnIndex(&quot;username&quot;));\n      mPassword = mCursor.getString(mCursor.getColumnIndex(&quot;password&quot;));\n      Log.d(&quot;MainActivity&quot;, &quot;查询数据成功！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;查询数据失败！&quot;);\n    }\n    // 修改数据\n    mSQL = &quot;UPDATE  user SET password=&#39;9876543210&#39; WHERE username=&#39;小蔡&#39;&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    mCursor.moveToFirst();\n    mUsername = mCursor.getString(mCursor.getColumnIndex(&quot;username&quot;));\n    mPassword = mCursor.getString(mCursor.getColumnIndex(&quot;password&quot;));\n    if (mPassword.equals(&quot;9876543210&quot;)) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据修改成功！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;修改数据失败！&quot;);\n      Log.d(&quot;MainActivity&quot;, &quot;编号:&quot;+mId+&quot;, 用户:&quot;+mUsername+&quot;, 密码:&quot;+mPassword);\n    }\n    // 删除数据\n    mSQL = &quot;DELETE FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mDB.execSQL(mSQL);\n    mSQL = &quot;SELECT * FROM user WHERE username=&#39;小蔡&#39;&quot;;\n    mCursor = mDB.rawQuery(mSQL, null);\n    if (!mCursor.moveToFirst()) {\n      Log.d(&quot;MainActivity&quot;, &quot;删除数据成功！&quot;);\n    }\n    // 关闭数据库\n    mDB.close();\n    if (!mDB.isOpen()) {\n      Log.d(&quot;MainActivity&quot;, &quot;数据库关闭成功！&quot;);\n    } else{\n      Log.d(&quot;MainActivity&quot;, &quot;数据库关闭失败！&quot;);\n    }\n  }\n\n}</code></pre>\n<p>执行程序，新建一个标签为”MainActivity”的筛选，观察 LogCat 输出的日志。</p>\n<img src=\"/images/posts/2015/11/android_sqlite.png\" class=\"\" width=\"480\" title=\"控制台日志\">\n\n<p>通过 LogCat 日志可以了解到，代码中对 SQLite 数据库的操作都已经执行了。</p>"},{"title":"Android 存储和解析 JSON 数据","date":"2015-11-09T17:07:49.000Z","_content":"\n> JSON是一种轻量级的数据交换格式。JSON 采用完全独立于语言的文本格式，易于阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。\n\nJSON 中的数据以键值对（key-value）的形式存在的。\n\n<!-- more -->\n\n``` java\n{\n  \"用户\": {\n    \"姓氏\": \"唐\",\n    \"名字\": \"三藏\",\n    \"邮箱\": \"email@example.com\"\n  }\n}\n```\n\n新建一个 demo 应用并命名为 _JSONPractice_ ，生成默认的 Activity 。\n\n修改 activity_main.xml ，添加一个 TextView 控件。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:padding=\"10dp\">\n\n  <TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:singleLine=\"false\"/>\n\n</RelativeLayout>\n```\n\n在 MainActivity 类中新建一个 TextView ，并在 `onCreate` 方法中将其实例化。它将用于显示解析后的信息。\n\n``` java\nprivate TextView mTextView;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n}\n```\n \n\n在 MainActivity 类中添加 `JSONWrite` 方法，用于以 JSON 格式将数据保存到文本文件，然后在日志中打印数据。\n\n``` java\nprotected void JSONWrite(){\n  // 待存储的信息\n  String mCompany = \"蔡一鸣博客 CAIYIMING BLOG\";\n  String mAddress = \"中国 福建省 厦门市\";\n  String mTelephone = \"0592-1234567\";\n  String[] mDataName = {\"孙悟空\", \"猪悟能\", \"沙悟净\"};\n  String[] mDataAge = {\"20\", \"19\", \"21\"};\n  double[] mDataSalary = { 3500.0, 2900.0, 4000.0};\n  Date[] mDataTime = {new Date(), new Date(), new Date()};\n  // 创建外层 JSON 对象\n  JSONObject mAllData = new JSONObject();\n  // 创建 JSON 数组\n  JSONArray mArray = new JSONArray();\n  // 创建单个员工的 JSON 对象\n  for (int i=0; i<mDataName.length; i++) {\n    JSONObject mTemp = new JSONObject();\n    try {\n      mTemp.put(\"Name\", mDataName[i]);\n      mTemp.put(\"Age\", mDataAge[i]);\n      mTemp.put(\"Salary\", mDataSalary[i]);\n      mTemp.put(\"Time\", mDataTime[i]);\n    } catch(JSONException e){\n    }\n    // 将单个员工的 JSON 对象放进 JSON 数组\n    mArray.put(mTemp);\n  }\n  try {\n    // 将所有数据存入外层 JSON 对象\n    mAllData.put(\"Employees\", mArray);\n    mAllData.put(\"Company\", mCompany);\n    mAllData.put(\"Address\", mAddress);\n    mAllData.put(\"Telephone\", mTelephone);\n  } catch(JSONException e){\n  }\n  // 若存储介质不存在则终止操作\n  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n    return;\n  }\n  // 新建文件对象 路径为 JSONPractice\\JSON.txt（File.separator 等于 \\ 符号）\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+\"JSONPractice\"+File.separator+\"JSON.txt\");\n  // 如果不存在 JSONPractice 则新建\n  if (!mFile.getParentFile().exists()) {\n    mFile.getParentFile().mkdirs();\n  }\n  // 新建打印流并打印数据\n  PrintStream mOut = null;\n  try {\n    mOut = new PrintStream(new FileOutputStream(mFile));\n    mOut.print(mAllData.toString());\n    Log.d(\"MainActivity\", \"JSON.txt保存成功！\");\n  } catch(FileNotFoundException e){\n    // 若文件不存在则打印日志\n    Log.d(\"MainActivity\", \"JSON.txt保存失败！\");\n  } finally{\n    // 若打印流非空则关闭打印流\n    if (mOut!=null) {\n      mOut.close();\n    }\n  }\n  // 检查文件是否存在并打印日志\n  String mContent = \"\";\n  if (mFile.exists()) {\n    try {\n      InputStream mInputStream = new FileInputStream(mFile); \n      InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n      BufferedReader mBufferReader = new BufferedReader(mInputReader);\n      String mLine;\n      // 分行读取并打印\n      while (( mLine = mBufferReader.readLine()) != null) {\n        mContent += mLine;\n      }\n      Log.d(\"MainActivity\",  mContent);\n      mInputStream.close();\n    } catch (java.io.FileNotFoundException e) {\n    } catch (IOException e) {\n    }\n  }\n  }\n```\n\n添加 `JSONRead` 方法，用于读取 `JSONWrite` 方法保存的文件，并将 JSON 数据解析出来，然后以其他格式在屏幕上输出。\n\n``` java\nprotected void JSONRead(){\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+\"JSONPractice\"+File.separator+\"JSON.txt\");\n  String mContent = \"\";\n  if (mFile.exists()) {\n    try {\n    // 读取数据\n    InputStream mInputStream = new FileInputStream(mFile); \n    InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n    BufferedReader mBufferReader = new BufferedReader(mInputReader);\n    String mLine;\n    while (( mLine = mBufferReader.readLine()) != null) {\n      mContent += mLine;\n    }\n    mInputStream.close();\n    // 解析数据\n    try {\n      JSONTokener mJT = new JSONTokener(mContent);\n      JSONObject mJO = (JSONObject) mJT.nextValue();\n      // 解析单位信息\n      String mCompany = mJO.getString(\"Company\");\n      String mTelephone = mJO.getString(\"Telephone\");\n      String mAddress = mJO.getString(\"Address\");\n      // 解析员工信息\n      JSONArray mEmployees = mJO.getJSONArray(\"Employees\");\n      // 员工一\n      JSONObject mEmployeeOne = mEmployees.getJSONObject(0);\n      String[] mEmOneInfo = new String[4];\n      mEmOneInfo[0] = mEmployeeOne.getString(\"Name\");\n      mEmOneInfo[1] = mEmployeeOne.getString(\"Age\");\n      mEmOneInfo[2] = mEmployeeOne.getString(\"Salary\");\n      mEmOneInfo[3] = mEmployeeOne.getString(\"Time\");\n      String mEmOne = \"\";\n      for ( int i=0; i<=3; i++) {\n      mEmOne = mEmOne + mEmOneInfo[i] + \" \";\n      }\n      // 员工二\n      JSONObject mEmployeeTwo = mEmployees.getJSONObject(1);\n      String[] mEmTwoInfo = new String[4];\n      mEmTwoInfo[0] = mEmployeeTwo.getString(\"Name\");\n      mEmTwoInfo[1] = mEmployeeTwo.getString(\"Age\");\n      mEmTwoInfo[2] = mEmployeeTwo.getString(\"Salary\");\n      mEmTwoInfo[3] = mEmployeeTwo.getString(\"Time\");\n      String mEmTwo = \"\";\n      for ( int i=0; i<=3; i++) {\n      mEmTwo = mEmTwo + mEmTwoInfo[i] + \" \";\n      }\n      // 员工三\n      JSONObject mEmployeeThree = mEmployees.getJSONObject(1);\n      String[] mEmThreeInfo = new String[4];\n      mEmThreeInfo[0] = mEmployeeThree.getString(\"Name\");\n      mEmThreeInfo[1] = mEmployeeThree.getString(\"Age\");\n      mEmThreeInfo[2] = mEmployeeThree.getString(\"Salary\");\n      mEmThreeInfo[3] = mEmployeeThree.getString(\"Time\");\n      String mEmThree = \"\";\n      for ( int i=0; i<=3; i++) {\n       mEmThree = mEmThree + mEmThreeInfo[i] + \" \";\n      }\n      String mOutput = null;\n      // 汇总数据并输出\n      mOutput = \"单位：\"+mCompany+\"\\n\"+\"电话：\"+mTelephone+\"\\n\"+\"地址：\"+mAddress+\n        \"\\n\\n员工信息\\n\\n\"+mEmOne+\"\\n\"+mEmTwo+\"\\n\"+mEmThree;\n      mTextView.setText(mOutput);\n    } catch (JSONException e) { }\n    } catch (java.io.FileNotFoundException e){ } catch (IOException e){ }\n  }\n}\n```\n\n修改 `onCreate` 方法，在声明周期中执行 JSONWrite 、JSONRead 方法。\n\n``` java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n  // 将信息以 JSON 格式保存到本地\n  JSONWrite();\n  // 读取并解析文件中的 JSON 数据\n  JSONRead();\n}\n```\n\n运行应用，LogCat 中打印了 JSON 数据，说明 `JSONWrite` 方法执行成功，Activity 输出格式化的内容，说明 `JSONRead` 方法执行成功。\n\n{% img /images/posts/2015/11/android_json_1.png 480 控制台日志 %}\n\n{% img /images/posts/2015/11/android_json_2.png 240 屏幕输出内容 %}","source":"_posts/2015-11-10@Android 存储和解析 JSON 数据.md","raw":"---\ntitle: Android 存储和解析 JSON 数据\ncategories:\n  - Android\ndate: 2015-11-10 01:07:49\ntags:\n  - Android\n  - Java\n  - JSON\n---\n\n> JSON是一种轻量级的数据交换格式。JSON 采用完全独立于语言的文本格式，易于阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。\n\nJSON 中的数据以键值对（key-value）的形式存在的。\n\n<!-- more -->\n\n``` java\n{\n  \"用户\": {\n    \"姓氏\": \"唐\",\n    \"名字\": \"三藏\",\n    \"邮箱\": \"email@example.com\"\n  }\n}\n```\n\n新建一个 demo 应用并命名为 _JSONPractice_ ，生成默认的 Activity 。\n\n修改 activity_main.xml ，添加一个 TextView 控件。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:padding=\"10dp\">\n\n  <TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:singleLine=\"false\"/>\n\n</RelativeLayout>\n```\n\n在 MainActivity 类中新建一个 TextView ，并在 `onCreate` 方法中将其实例化。它将用于显示解析后的信息。\n\n``` java\nprivate TextView mTextView;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n}\n```\n \n\n在 MainActivity 类中添加 `JSONWrite` 方法，用于以 JSON 格式将数据保存到文本文件，然后在日志中打印数据。\n\n``` java\nprotected void JSONWrite(){\n  // 待存储的信息\n  String mCompany = \"蔡一鸣博客 CAIYIMING BLOG\";\n  String mAddress = \"中国 福建省 厦门市\";\n  String mTelephone = \"0592-1234567\";\n  String[] mDataName = {\"孙悟空\", \"猪悟能\", \"沙悟净\"};\n  String[] mDataAge = {\"20\", \"19\", \"21\"};\n  double[] mDataSalary = { 3500.0, 2900.0, 4000.0};\n  Date[] mDataTime = {new Date(), new Date(), new Date()};\n  // 创建外层 JSON 对象\n  JSONObject mAllData = new JSONObject();\n  // 创建 JSON 数组\n  JSONArray mArray = new JSONArray();\n  // 创建单个员工的 JSON 对象\n  for (int i=0; i<mDataName.length; i++) {\n    JSONObject mTemp = new JSONObject();\n    try {\n      mTemp.put(\"Name\", mDataName[i]);\n      mTemp.put(\"Age\", mDataAge[i]);\n      mTemp.put(\"Salary\", mDataSalary[i]);\n      mTemp.put(\"Time\", mDataTime[i]);\n    } catch(JSONException e){\n    }\n    // 将单个员工的 JSON 对象放进 JSON 数组\n    mArray.put(mTemp);\n  }\n  try {\n    // 将所有数据存入外层 JSON 对象\n    mAllData.put(\"Employees\", mArray);\n    mAllData.put(\"Company\", mCompany);\n    mAllData.put(\"Address\", mAddress);\n    mAllData.put(\"Telephone\", mTelephone);\n  } catch(JSONException e){\n  }\n  // 若存储介质不存在则终止操作\n  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n    return;\n  }\n  // 新建文件对象 路径为 JSONPractice\\JSON.txt（File.separator 等于 \\ 符号）\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+\"JSONPractice\"+File.separator+\"JSON.txt\");\n  // 如果不存在 JSONPractice 则新建\n  if (!mFile.getParentFile().exists()) {\n    mFile.getParentFile().mkdirs();\n  }\n  // 新建打印流并打印数据\n  PrintStream mOut = null;\n  try {\n    mOut = new PrintStream(new FileOutputStream(mFile));\n    mOut.print(mAllData.toString());\n    Log.d(\"MainActivity\", \"JSON.txt保存成功！\");\n  } catch(FileNotFoundException e){\n    // 若文件不存在则打印日志\n    Log.d(\"MainActivity\", \"JSON.txt保存失败！\");\n  } finally{\n    // 若打印流非空则关闭打印流\n    if (mOut!=null) {\n      mOut.close();\n    }\n  }\n  // 检查文件是否存在并打印日志\n  String mContent = \"\";\n  if (mFile.exists()) {\n    try {\n      InputStream mInputStream = new FileInputStream(mFile); \n      InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n      BufferedReader mBufferReader = new BufferedReader(mInputReader);\n      String mLine;\n      // 分行读取并打印\n      while (( mLine = mBufferReader.readLine()) != null) {\n        mContent += mLine;\n      }\n      Log.d(\"MainActivity\",  mContent);\n      mInputStream.close();\n    } catch (java.io.FileNotFoundException e) {\n    } catch (IOException e) {\n    }\n  }\n  }\n```\n\n添加 `JSONRead` 方法，用于读取 `JSONWrite` 方法保存的文件，并将 JSON 数据解析出来，然后以其他格式在屏幕上输出。\n\n``` java\nprotected void JSONRead(){\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+\"JSONPractice\"+File.separator+\"JSON.txt\");\n  String mContent = \"\";\n  if (mFile.exists()) {\n    try {\n    // 读取数据\n    InputStream mInputStream = new FileInputStream(mFile); \n    InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n    BufferedReader mBufferReader = new BufferedReader(mInputReader);\n    String mLine;\n    while (( mLine = mBufferReader.readLine()) != null) {\n      mContent += mLine;\n    }\n    mInputStream.close();\n    // 解析数据\n    try {\n      JSONTokener mJT = new JSONTokener(mContent);\n      JSONObject mJO = (JSONObject) mJT.nextValue();\n      // 解析单位信息\n      String mCompany = mJO.getString(\"Company\");\n      String mTelephone = mJO.getString(\"Telephone\");\n      String mAddress = mJO.getString(\"Address\");\n      // 解析员工信息\n      JSONArray mEmployees = mJO.getJSONArray(\"Employees\");\n      // 员工一\n      JSONObject mEmployeeOne = mEmployees.getJSONObject(0);\n      String[] mEmOneInfo = new String[4];\n      mEmOneInfo[0] = mEmployeeOne.getString(\"Name\");\n      mEmOneInfo[1] = mEmployeeOne.getString(\"Age\");\n      mEmOneInfo[2] = mEmployeeOne.getString(\"Salary\");\n      mEmOneInfo[3] = mEmployeeOne.getString(\"Time\");\n      String mEmOne = \"\";\n      for ( int i=0; i<=3; i++) {\n      mEmOne = mEmOne + mEmOneInfo[i] + \" \";\n      }\n      // 员工二\n      JSONObject mEmployeeTwo = mEmployees.getJSONObject(1);\n      String[] mEmTwoInfo = new String[4];\n      mEmTwoInfo[0] = mEmployeeTwo.getString(\"Name\");\n      mEmTwoInfo[1] = mEmployeeTwo.getString(\"Age\");\n      mEmTwoInfo[2] = mEmployeeTwo.getString(\"Salary\");\n      mEmTwoInfo[3] = mEmployeeTwo.getString(\"Time\");\n      String mEmTwo = \"\";\n      for ( int i=0; i<=3; i++) {\n      mEmTwo = mEmTwo + mEmTwoInfo[i] + \" \";\n      }\n      // 员工三\n      JSONObject mEmployeeThree = mEmployees.getJSONObject(1);\n      String[] mEmThreeInfo = new String[4];\n      mEmThreeInfo[0] = mEmployeeThree.getString(\"Name\");\n      mEmThreeInfo[1] = mEmployeeThree.getString(\"Age\");\n      mEmThreeInfo[2] = mEmployeeThree.getString(\"Salary\");\n      mEmThreeInfo[3] = mEmployeeThree.getString(\"Time\");\n      String mEmThree = \"\";\n      for ( int i=0; i<=3; i++) {\n       mEmThree = mEmThree + mEmThreeInfo[i] + \" \";\n      }\n      String mOutput = null;\n      // 汇总数据并输出\n      mOutput = \"单位：\"+mCompany+\"\\n\"+\"电话：\"+mTelephone+\"\\n\"+\"地址：\"+mAddress+\n        \"\\n\\n员工信息\\n\\n\"+mEmOne+\"\\n\"+mEmTwo+\"\\n\"+mEmThree;\n      mTextView.setText(mOutput);\n    } catch (JSONException e) { }\n    } catch (java.io.FileNotFoundException e){ } catch (IOException e){ }\n  }\n}\n```\n\n修改 `onCreate` 方法，在声明周期中执行 JSONWrite 、JSONRead 方法。\n\n``` java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n  // 将信息以 JSON 格式保存到本地\n  JSONWrite();\n  // 读取并解析文件中的 JSON 数据\n  JSONRead();\n}\n```\n\n运行应用，LogCat 中打印了 JSON 数据，说明 `JSONWrite` 方法执行成功，Activity 输出格式化的内容，说明 `JSONRead` 方法执行成功。\n\n{% img /images/posts/2015/11/android_json_1.png 480 控制台日志 %}\n\n{% img /images/posts/2015/11/android_json_2.png 240 屏幕输出内容 %}","slug":"2015-11-10@Android 存储和解析 JSON 数据","published":1,"updated":"2020-06-29T03:32:42.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt452000arqgjarzy8i3p","content":"<blockquote>\n<p>JSON是一种轻量级的数据交换格式。JSON 采用完全独立于语言的文本格式，易于阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。</p>\n</blockquote>\n<p>JSON 中的数据以键值对（key-value）的形式存在的。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"java\">{\n  &quot;用户&quot;: {\n    &quot;姓氏&quot;: &quot;唐&quot;,\n    &quot;名字&quot;: &quot;三藏&quot;,\n    &quot;邮箱&quot;: &quot;email@example.com&quot;\n  }\n}</code></pre>\n<p>新建一个 demo 应用并命名为 <em>JSONPractice</em> ，生成默认的 Activity 。</p>\n<p>修改 activity_main.xml ，添加一个 TextView 控件。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:padding=&quot;10dp&quot;&gt;\n\n  &lt;TextView\n    android:id=&quot;@+id/textView&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:singleLine=&quot;false&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>在 MainActivity 类中新建一个 TextView ，并在 <code>onCreate</code> 方法中将其实例化。它将用于显示解析后的信息。</p>\n<pre><code class=\"java\">private TextView mTextView;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n}</code></pre>\n<p>在 MainActivity 类中添加 <code>JSONWrite</code> 方法，用于以 JSON 格式将数据保存到文本文件，然后在日志中打印数据。</p>\n<pre><code class=\"java\">protected void JSONWrite(){\n  // 待存储的信息\n  String mCompany = &quot;蔡一鸣博客 CAIYIMING BLOG&quot;;\n  String mAddress = &quot;中国 福建省 厦门市&quot;;\n  String mTelephone = &quot;0592-1234567&quot;;\n  String[] mDataName = {&quot;孙悟空&quot;, &quot;猪悟能&quot;, &quot;沙悟净&quot;};\n  String[] mDataAge = {&quot;20&quot;, &quot;19&quot;, &quot;21&quot;};\n  double[] mDataSalary = { 3500.0, 2900.0, 4000.0};\n  Date[] mDataTime = {new Date(), new Date(), new Date()};\n  // 创建外层 JSON 对象\n  JSONObject mAllData = new JSONObject();\n  // 创建 JSON 数组\n  JSONArray mArray = new JSONArray();\n  // 创建单个员工的 JSON 对象\n  for (int i=0; i&lt;mDataName.length; i++) {\n    JSONObject mTemp = new JSONObject();\n    try {\n      mTemp.put(&quot;Name&quot;, mDataName[i]);\n      mTemp.put(&quot;Age&quot;, mDataAge[i]);\n      mTemp.put(&quot;Salary&quot;, mDataSalary[i]);\n      mTemp.put(&quot;Time&quot;, mDataTime[i]);\n    } catch(JSONException e){\n    }\n    // 将单个员工的 JSON 对象放进 JSON 数组\n    mArray.put(mTemp);\n  }\n  try {\n    // 将所有数据存入外层 JSON 对象\n    mAllData.put(&quot;Employees&quot;, mArray);\n    mAllData.put(&quot;Company&quot;, mCompany);\n    mAllData.put(&quot;Address&quot;, mAddress);\n    mAllData.put(&quot;Telephone&quot;, mTelephone);\n  } catch(JSONException e){\n  }\n  // 若存储介质不存在则终止操作\n  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n    return;\n  }\n  // 新建文件对象 路径为 JSONPractice\\JSON.txt（File.separator 等于 \\ 符号）\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+&quot;JSONPractice&quot;+File.separator+&quot;JSON.txt&quot;);\n  // 如果不存在 JSONPractice 则新建\n  if (!mFile.getParentFile().exists()) {\n    mFile.getParentFile().mkdirs();\n  }\n  // 新建打印流并打印数据\n  PrintStream mOut = null;\n  try {\n    mOut = new PrintStream(new FileOutputStream(mFile));\n    mOut.print(mAllData.toString());\n    Log.d(&quot;MainActivity&quot;, &quot;JSON.txt保存成功！&quot;);\n  } catch(FileNotFoundException e){\n    // 若文件不存在则打印日志\n    Log.d(&quot;MainActivity&quot;, &quot;JSON.txt保存失败！&quot;);\n  } finally{\n    // 若打印流非空则关闭打印流\n    if (mOut!=null) {\n      mOut.close();\n    }\n  }\n  // 检查文件是否存在并打印日志\n  String mContent = &quot;&quot;;\n  if (mFile.exists()) {\n    try {\n      InputStream mInputStream = new FileInputStream(mFile); \n      InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n      BufferedReader mBufferReader = new BufferedReader(mInputReader);\n      String mLine;\n      // 分行读取并打印\n      while (( mLine = mBufferReader.readLine()) != null) {\n        mContent += mLine;\n      }\n      Log.d(&quot;MainActivity&quot;,  mContent);\n      mInputStream.close();\n    } catch (java.io.FileNotFoundException e) {\n    } catch (IOException e) {\n    }\n  }\n  }</code></pre>\n<p>添加 <code>JSONRead</code> 方法，用于读取 <code>JSONWrite</code> 方法保存的文件，并将 JSON 数据解析出来，然后以其他格式在屏幕上输出。</p>\n<pre><code class=\"java\">protected void JSONRead(){\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+&quot;JSONPractice&quot;+File.separator+&quot;JSON.txt&quot;);\n  String mContent = &quot;&quot;;\n  if (mFile.exists()) {\n    try {\n    // 读取数据\n    InputStream mInputStream = new FileInputStream(mFile); \n    InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n    BufferedReader mBufferReader = new BufferedReader(mInputReader);\n    String mLine;\n    while (( mLine = mBufferReader.readLine()) != null) {\n      mContent += mLine;\n    }\n    mInputStream.close();\n    // 解析数据\n    try {\n      JSONTokener mJT = new JSONTokener(mContent);\n      JSONObject mJO = (JSONObject) mJT.nextValue();\n      // 解析单位信息\n      String mCompany = mJO.getString(&quot;Company&quot;);\n      String mTelephone = mJO.getString(&quot;Telephone&quot;);\n      String mAddress = mJO.getString(&quot;Address&quot;);\n      // 解析员工信息\n      JSONArray mEmployees = mJO.getJSONArray(&quot;Employees&quot;);\n      // 员工一\n      JSONObject mEmployeeOne = mEmployees.getJSONObject(0);\n      String[] mEmOneInfo = new String[4];\n      mEmOneInfo[0] = mEmployeeOne.getString(&quot;Name&quot;);\n      mEmOneInfo[1] = mEmployeeOne.getString(&quot;Age&quot;);\n      mEmOneInfo[2] = mEmployeeOne.getString(&quot;Salary&quot;);\n      mEmOneInfo[3] = mEmployeeOne.getString(&quot;Time&quot;);\n      String mEmOne = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n      mEmOne = mEmOne + mEmOneInfo[i] + &quot; &quot;;\n      }\n      // 员工二\n      JSONObject mEmployeeTwo = mEmployees.getJSONObject(1);\n      String[] mEmTwoInfo = new String[4];\n      mEmTwoInfo[0] = mEmployeeTwo.getString(&quot;Name&quot;);\n      mEmTwoInfo[1] = mEmployeeTwo.getString(&quot;Age&quot;);\n      mEmTwoInfo[2] = mEmployeeTwo.getString(&quot;Salary&quot;);\n      mEmTwoInfo[3] = mEmployeeTwo.getString(&quot;Time&quot;);\n      String mEmTwo = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n      mEmTwo = mEmTwo + mEmTwoInfo[i] + &quot; &quot;;\n      }\n      // 员工三\n      JSONObject mEmployeeThree = mEmployees.getJSONObject(1);\n      String[] mEmThreeInfo = new String[4];\n      mEmThreeInfo[0] = mEmployeeThree.getString(&quot;Name&quot;);\n      mEmThreeInfo[1] = mEmployeeThree.getString(&quot;Age&quot;);\n      mEmThreeInfo[2] = mEmployeeThree.getString(&quot;Salary&quot;);\n      mEmThreeInfo[3] = mEmployeeThree.getString(&quot;Time&quot;);\n      String mEmThree = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n       mEmThree = mEmThree + mEmThreeInfo[i] + &quot; &quot;;\n      }\n      String mOutput = null;\n      // 汇总数据并输出\n      mOutput = &quot;单位：&quot;+mCompany+&quot;\\n&quot;+&quot;电话：&quot;+mTelephone+&quot;\\n&quot;+&quot;地址：&quot;+mAddress+\n        &quot;\\n\\n员工信息\\n\\n&quot;+mEmOne+&quot;\\n&quot;+mEmTwo+&quot;\\n&quot;+mEmThree;\n      mTextView.setText(mOutput);\n    } catch (JSONException e) { }\n    } catch (java.io.FileNotFoundException e){ } catch (IOException e){ }\n  }\n}</code></pre>\n<p>修改 <code>onCreate</code> 方法，在声明周期中执行 JSONWrite 、JSONRead 方法。</p>\n<pre><code class=\"java\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n  // 将信息以 JSON 格式保存到本地\n  JSONWrite();\n  // 读取并解析文件中的 JSON 数据\n  JSONRead();\n}</code></pre>\n<p>运行应用，LogCat 中打印了 JSON 数据，说明 <code>JSONWrite</code> 方法执行成功，Activity 输出格式化的内容，说明 <code>JSONRead</code> 方法执行成功。</p>\n<img src=\"/images/posts/2015/11/android_json_1.png\" class=\"\" width=\"480\" title=\"控制台日志\">\n\n<img src=\"/images/posts/2015/11/android_json_2.png\" class=\"\" width=\"240\" title=\"屏幕输出内容\">","site":{"data":{}},"excerpt":"<blockquote>\n<p>JSON是一种轻量级的数据交换格式。JSON 采用完全独立于语言的文本格式，易于阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。</p>\n</blockquote>\n<p>JSON 中的数据以键值对（key-value）的形式存在的。</p>","more":"<pre><code class=\"java\">{\n  &quot;用户&quot;: {\n    &quot;姓氏&quot;: &quot;唐&quot;,\n    &quot;名字&quot;: &quot;三藏&quot;,\n    &quot;邮箱&quot;: &quot;email@example.com&quot;\n  }\n}</code></pre>\n<p>新建一个 demo 应用并命名为 <em>JSONPractice</em> ，生成默认的 Activity 。</p>\n<p>修改 activity_main.xml ，添加一个 TextView 控件。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:padding=&quot;10dp&quot;&gt;\n\n  &lt;TextView\n    android:id=&quot;@+id/textView&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:singleLine=&quot;false&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>在 MainActivity 类中新建一个 TextView ，并在 <code>onCreate</code> 方法中将其实例化。它将用于显示解析后的信息。</p>\n<pre><code class=\"java\">private TextView mTextView;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n}</code></pre>\n<p>在 MainActivity 类中添加 <code>JSONWrite</code> 方法，用于以 JSON 格式将数据保存到文本文件，然后在日志中打印数据。</p>\n<pre><code class=\"java\">protected void JSONWrite(){\n  // 待存储的信息\n  String mCompany = &quot;蔡一鸣博客 CAIYIMING BLOG&quot;;\n  String mAddress = &quot;中国 福建省 厦门市&quot;;\n  String mTelephone = &quot;0592-1234567&quot;;\n  String[] mDataName = {&quot;孙悟空&quot;, &quot;猪悟能&quot;, &quot;沙悟净&quot;};\n  String[] mDataAge = {&quot;20&quot;, &quot;19&quot;, &quot;21&quot;};\n  double[] mDataSalary = { 3500.0, 2900.0, 4000.0};\n  Date[] mDataTime = {new Date(), new Date(), new Date()};\n  // 创建外层 JSON 对象\n  JSONObject mAllData = new JSONObject();\n  // 创建 JSON 数组\n  JSONArray mArray = new JSONArray();\n  // 创建单个员工的 JSON 对象\n  for (int i=0; i&lt;mDataName.length; i++) {\n    JSONObject mTemp = new JSONObject();\n    try {\n      mTemp.put(&quot;Name&quot;, mDataName[i]);\n      mTemp.put(&quot;Age&quot;, mDataAge[i]);\n      mTemp.put(&quot;Salary&quot;, mDataSalary[i]);\n      mTemp.put(&quot;Time&quot;, mDataTime[i]);\n    } catch(JSONException e){\n    }\n    // 将单个员工的 JSON 对象放进 JSON 数组\n    mArray.put(mTemp);\n  }\n  try {\n    // 将所有数据存入外层 JSON 对象\n    mAllData.put(&quot;Employees&quot;, mArray);\n    mAllData.put(&quot;Company&quot;, mCompany);\n    mAllData.put(&quot;Address&quot;, mAddress);\n    mAllData.put(&quot;Telephone&quot;, mTelephone);\n  } catch(JSONException e){\n  }\n  // 若存储介质不存在则终止操作\n  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n    return;\n  }\n  // 新建文件对象 路径为 JSONPractice\\JSON.txt（File.separator 等于 \\ 符号）\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+&quot;JSONPractice&quot;+File.separator+&quot;JSON.txt&quot;);\n  // 如果不存在 JSONPractice 则新建\n  if (!mFile.getParentFile().exists()) {\n    mFile.getParentFile().mkdirs();\n  }\n  // 新建打印流并打印数据\n  PrintStream mOut = null;\n  try {\n    mOut = new PrintStream(new FileOutputStream(mFile));\n    mOut.print(mAllData.toString());\n    Log.d(&quot;MainActivity&quot;, &quot;JSON.txt保存成功！&quot;);\n  } catch(FileNotFoundException e){\n    // 若文件不存在则打印日志\n    Log.d(&quot;MainActivity&quot;, &quot;JSON.txt保存失败！&quot;);\n  } finally{\n    // 若打印流非空则关闭打印流\n    if (mOut!=null) {\n      mOut.close();\n    }\n  }\n  // 检查文件是否存在并打印日志\n  String mContent = &quot;&quot;;\n  if (mFile.exists()) {\n    try {\n      InputStream mInputStream = new FileInputStream(mFile); \n      InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n      BufferedReader mBufferReader = new BufferedReader(mInputReader);\n      String mLine;\n      // 分行读取并打印\n      while (( mLine = mBufferReader.readLine()) != null) {\n        mContent += mLine;\n      }\n      Log.d(&quot;MainActivity&quot;,  mContent);\n      mInputStream.close();\n    } catch (java.io.FileNotFoundException e) {\n    } catch (IOException e) {\n    }\n  }\n  }</code></pre>\n<p>添加 <code>JSONRead</code> 方法，用于读取 <code>JSONWrite</code> 方法保存的文件，并将 JSON 数据解析出来，然后以其他格式在屏幕上输出。</p>\n<pre><code class=\"java\">protected void JSONRead(){\n  File mFile = new File(Environment.getExternalStorageDirectory()+File.separator+&quot;JSONPractice&quot;+File.separator+&quot;JSON.txt&quot;);\n  String mContent = &quot;&quot;;\n  if (mFile.exists()) {\n    try {\n    // 读取数据\n    InputStream mInputStream = new FileInputStream(mFile); \n    InputStreamReader mInputReader = new InputStreamReader(mInputStream);\n    BufferedReader mBufferReader = new BufferedReader(mInputReader);\n    String mLine;\n    while (( mLine = mBufferReader.readLine()) != null) {\n      mContent += mLine;\n    }\n    mInputStream.close();\n    // 解析数据\n    try {\n      JSONTokener mJT = new JSONTokener(mContent);\n      JSONObject mJO = (JSONObject) mJT.nextValue();\n      // 解析单位信息\n      String mCompany = mJO.getString(&quot;Company&quot;);\n      String mTelephone = mJO.getString(&quot;Telephone&quot;);\n      String mAddress = mJO.getString(&quot;Address&quot;);\n      // 解析员工信息\n      JSONArray mEmployees = mJO.getJSONArray(&quot;Employees&quot;);\n      // 员工一\n      JSONObject mEmployeeOne = mEmployees.getJSONObject(0);\n      String[] mEmOneInfo = new String[4];\n      mEmOneInfo[0] = mEmployeeOne.getString(&quot;Name&quot;);\n      mEmOneInfo[1] = mEmployeeOne.getString(&quot;Age&quot;);\n      mEmOneInfo[2] = mEmployeeOne.getString(&quot;Salary&quot;);\n      mEmOneInfo[3] = mEmployeeOne.getString(&quot;Time&quot;);\n      String mEmOne = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n      mEmOne = mEmOne + mEmOneInfo[i] + &quot; &quot;;\n      }\n      // 员工二\n      JSONObject mEmployeeTwo = mEmployees.getJSONObject(1);\n      String[] mEmTwoInfo = new String[4];\n      mEmTwoInfo[0] = mEmployeeTwo.getString(&quot;Name&quot;);\n      mEmTwoInfo[1] = mEmployeeTwo.getString(&quot;Age&quot;);\n      mEmTwoInfo[2] = mEmployeeTwo.getString(&quot;Salary&quot;);\n      mEmTwoInfo[3] = mEmployeeTwo.getString(&quot;Time&quot;);\n      String mEmTwo = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n      mEmTwo = mEmTwo + mEmTwoInfo[i] + &quot; &quot;;\n      }\n      // 员工三\n      JSONObject mEmployeeThree = mEmployees.getJSONObject(1);\n      String[] mEmThreeInfo = new String[4];\n      mEmThreeInfo[0] = mEmployeeThree.getString(&quot;Name&quot;);\n      mEmThreeInfo[1] = mEmployeeThree.getString(&quot;Age&quot;);\n      mEmThreeInfo[2] = mEmployeeThree.getString(&quot;Salary&quot;);\n      mEmThreeInfo[3] = mEmployeeThree.getString(&quot;Time&quot;);\n      String mEmThree = &quot;&quot;;\n      for ( int i=0; i&lt;=3; i++) {\n       mEmThree = mEmThree + mEmThreeInfo[i] + &quot; &quot;;\n      }\n      String mOutput = null;\n      // 汇总数据并输出\n      mOutput = &quot;单位：&quot;+mCompany+&quot;\\n&quot;+&quot;电话：&quot;+mTelephone+&quot;\\n&quot;+&quot;地址：&quot;+mAddress+\n        &quot;\\n\\n员工信息\\n\\n&quot;+mEmOne+&quot;\\n&quot;+mEmTwo+&quot;\\n&quot;+mEmThree;\n      mTextView.setText(mOutput);\n    } catch (JSONException e) { }\n    } catch (java.io.FileNotFoundException e){ } catch (IOException e){ }\n  }\n}</code></pre>\n<p>修改 <code>onCreate</code> 方法，在声明周期中执行 JSONWrite 、JSONRead 方法。</p>\n<pre><code class=\"java\">@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_main);\n  mTextView = (TextView) findViewById(R.id.textView);\n  // 将信息以 JSON 格式保存到本地\n  JSONWrite();\n  // 读取并解析文件中的 JSON 数据\n  JSONRead();\n}</code></pre>\n<p>运行应用，LogCat 中打印了 JSON 数据，说明 <code>JSONWrite</code> 方法执行成功，Activity 输出格式化的内容，说明 <code>JSONRead</code> 方法执行成功。</p>\n<img src=\"/images/posts/2015/11/android_json_1.png\" class=\"\" width=\"480\" title=\"控制台日志\">\n\n<img src=\"/images/posts/2015/11/android_json_2.png\" class=\"\" width=\"240\" title=\"屏幕输出内容\">"},{"title":"Android 实现“再按一次退出程序”","date":"2015-11-29T12:49:32.000Z","_content":"\n我们经常会在 APP 中看到用连按两次返回键来退出应用的设计。\n\n通常，用户在打开应用的首个 Activity 上按下返回键，得到类似“再按一次退出程序”的短提示，用户再次按下返回键，应用退出。\n\n<!-- more -->\n\n这样的设计，一方面尊重了用户长期以来自发形成的操作习惯、使得退出应用更加简便，另一方面节省了视图空间，界面上无需提供一个退出按钮。\n\n实际上要实现按两次返回键退出应用是很容易的。Activity 中有一个 `onKeyUp` 方法用来监听按键事件，覆写这个方法并添加对返回键的处理。\n\n``` java\n// 该变量用于存储上一次按键时间\nprivate long mFirstTime = 0;\n\n@Override  \npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n  switch(keyCode) {  \n    case KeyEvent.KEYCODE_BACK :\n      long mSecondTime = System.currentTimeMillis();   \n      // 当按键间隔大于2秒时弹出提示\n      if ( mSecondTime - mFirstTime > 2000) {  \n        Toast.makeText(this, \"再按一次退出程序\", Toast.LENGTH_SHORT).show();\n        // 更新上一次按键时间\n        mFirstTime = mSecondTime; \n        return true; \n      }\n      // 当按键间隔小于2秒时退出程序\n      else {\n        System.exit(0);\n      }   \n      break;  \n  }  \nreturn super.onKeyUp(keyCode, event); \n}\n```\n\n当用户第一次按下返回键，两个变量之差显然大于2000毫秒，应用弹出“再按一次退出程序”提示并将当前时间（即 mSecondTime 的值）赋予 mFirstTime 。\n\n当用户第二次按下返回键，如果两次按键时间小于2000毫秒，应用退出；如果两次按键时间大于2000毫秒，再次弹出提示并更新 mFirstTime 。","source":"_posts/2015-11-29@Android 实现“再按一次退出程序”.md","raw":"---\ntitle: Android 实现“再按一次退出程序”\ncategories:\n  - Android\ndate: 2015-11-29 20:49:32\ntags:\n  - Android\n  - Java\n---\n\n我们经常会在 APP 中看到用连按两次返回键来退出应用的设计。\n\n通常，用户在打开应用的首个 Activity 上按下返回键，得到类似“再按一次退出程序”的短提示，用户再次按下返回键，应用退出。\n\n<!-- more -->\n\n这样的设计，一方面尊重了用户长期以来自发形成的操作习惯、使得退出应用更加简便，另一方面节省了视图空间，界面上无需提供一个退出按钮。\n\n实际上要实现按两次返回键退出应用是很容易的。Activity 中有一个 `onKeyUp` 方法用来监听按键事件，覆写这个方法并添加对返回键的处理。\n\n``` java\n// 该变量用于存储上一次按键时间\nprivate long mFirstTime = 0;\n\n@Override  \npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n  switch(keyCode) {  \n    case KeyEvent.KEYCODE_BACK :\n      long mSecondTime = System.currentTimeMillis();   \n      // 当按键间隔大于2秒时弹出提示\n      if ( mSecondTime - mFirstTime > 2000) {  \n        Toast.makeText(this, \"再按一次退出程序\", Toast.LENGTH_SHORT).show();\n        // 更新上一次按键时间\n        mFirstTime = mSecondTime; \n        return true; \n      }\n      // 当按键间隔小于2秒时退出程序\n      else {\n        System.exit(0);\n      }   \n      break;  \n  }  \nreturn super.onKeyUp(keyCode, event); \n}\n```\n\n当用户第一次按下返回键，两个变量之差显然大于2000毫秒，应用弹出“再按一次退出程序”提示并将当前时间（即 mSecondTime 的值）赋予 mFirstTime 。\n\n当用户第二次按下返回键，如果两次按键时间小于2000毫秒，应用退出；如果两次按键时间大于2000毫秒，再次弹出提示并更新 mFirstTime 。","slug":"2015-11-29@Android 实现“再按一次退出程序”","published":1,"updated":"2020-06-29T03:32:42.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46b0010rqgj4cx1hbil","content":"<p>我们经常会在 APP 中看到用连按两次返回键来退出应用的设计。</p>\n<p>通常，用户在打开应用的首个 Activity 上按下返回键，得到类似“再按一次退出程序”的短提示，用户再次按下返回键，应用退出。</p>\n<a id=\"more\"></a>\n\n<p>这样的设计，一方面尊重了用户长期以来自发形成的操作习惯、使得退出应用更加简便，另一方面节省了视图空间，界面上无需提供一个退出按钮。</p>\n<p>实际上要实现按两次返回键退出应用是很容易的。Activity 中有一个 <code>onKeyUp</code> 方法用来监听按键事件，覆写这个方法并添加对返回键的处理。</p>\n<pre><code class=\"java\">// 该变量用于存储上一次按键时间\nprivate long mFirstTime = 0;\n\n@Override  \npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n  switch(keyCode) {  \n    case KeyEvent.KEYCODE_BACK :\n      long mSecondTime = System.currentTimeMillis();   \n      // 当按键间隔大于2秒时弹出提示\n      if ( mSecondTime - mFirstTime &gt; 2000) {  \n        Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();\n        // 更新上一次按键时间\n        mFirstTime = mSecondTime; \n        return true; \n      }\n      // 当按键间隔小于2秒时退出程序\n      else {\n        System.exit(0);\n      }   \n      break;  \n  }  \nreturn super.onKeyUp(keyCode, event); \n}</code></pre>\n<p>当用户第一次按下返回键，两个变量之差显然大于2000毫秒，应用弹出“再按一次退出程序”提示并将当前时间（即 mSecondTime 的值）赋予 mFirstTime 。</p>\n<p>当用户第二次按下返回键，如果两次按键时间小于2000毫秒，应用退出；如果两次按键时间大于2000毫秒，再次弹出提示并更新 mFirstTime 。</p>\n","site":{"data":{}},"excerpt":"<p>我们经常会在 APP 中看到用连按两次返回键来退出应用的设计。</p>\n<p>通常，用户在打开应用的首个 Activity 上按下返回键，得到类似“再按一次退出程序”的短提示，用户再次按下返回键，应用退出。</p>","more":"<p>这样的设计，一方面尊重了用户长期以来自发形成的操作习惯、使得退出应用更加简便，另一方面节省了视图空间，界面上无需提供一个退出按钮。</p>\n<p>实际上要实现按两次返回键退出应用是很容易的。Activity 中有一个 <code>onKeyUp</code> 方法用来监听按键事件，覆写这个方法并添加对返回键的处理。</p>\n<pre><code class=\"java\">// 该变量用于存储上一次按键时间\nprivate long mFirstTime = 0;\n\n@Override  \npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n  switch(keyCode) {  \n    case KeyEvent.KEYCODE_BACK :\n      long mSecondTime = System.currentTimeMillis();   \n      // 当按键间隔大于2秒时弹出提示\n      if ( mSecondTime - mFirstTime &gt; 2000) {  \n        Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();\n        // 更新上一次按键时间\n        mFirstTime = mSecondTime; \n        return true; \n      }\n      // 当按键间隔小于2秒时退出程序\n      else {\n        System.exit(0);\n      }   \n      break;  \n  }  \nreturn super.onKeyUp(keyCode, event); \n}</code></pre>\n<p>当用户第一次按下返回键，两个变量之差显然大于2000毫秒，应用弹出“再按一次退出程序”提示并将当前时间（即 mSecondTime 的值）赋予 mFirstTime 。</p>\n<p>当用户第二次按下返回键，如果两次按键时间小于2000毫秒，应用退出；如果两次按键时间大于2000毫秒，再次弹出提示并更新 mFirstTime 。</p>"},{"title":"使用 Intent 实现页面跳转与传值","date":"2015-11-11T11:47:35.000Z","_content":"\nAndroid 提供了 Intent（意图）用于实现 Activity（页面）的跳转与传值。Intent 好比 Android 中的信使，负责组件间通讯，它甚至可以在我们的应用中调用系统中的其他程序。\n\n<!-- more -->\n\n一般跳转：\n\n``` java\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nstartActivity(mIntent);\n```\n带参数的跳转：\n\n``` java\n// 当前 Activity\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nmIntent.putExtra(String name, String value);\nstartActivity(mIntent);\n```\n\n``` java\n// 目标 Activity\nBundle mBundle = getIntent().getExtras();\nString mText = mBundle.getString(String name);\n```\n\n新建一个 demo 应用并命名为 _IntentParactice_ ，创建默认的 MainActivity 。\n\n1、修改 MainActivity 的布局文件 activity_main.xml ，添加一个输入框和一个“跳转”按钮。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:padding=\"10dp\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n\n  <LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\" >\n\n    <EditText\n      android:id=\"@+id/edittextInfo\"\n      android:layout_width=\"0dp\"\n      android:layout_weight=\"1\"\n      android:layout_height=\"wrap_content\"/>\n\n    <Button \n      android:id=\"@+id/buttonJump\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"\n      android:text=\"跳转\"/>\n\n  </LinearLayout>\n\n</RelativeLayout>\n```\n\n2、创建 TargetActivity 的布局文件 activity_target.xml ，仅包含一个 TextView ，用于输出接收到的参数。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:background=\"#000000\"\n  android:padding=\"10dp\" >\n\n  <TextView\n    android:id=\"@+id/textviewOuput\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"16sp\"\n    android:textColor=\"#FFFFFF\"/>\n\n</RelativeLayout>\n```\n3、修改 MainActivity.java ，绑定按钮的点击事件，实现点击后保存输入的内容、跳转到目标 Activity 并传参。不用理会 IDE 报错，TargetActivity 稍后就会创建。\n\n``` java\npublic class MainActivity extends Activity {\n\n  // 声明控件\n  private EditText mInfo;\n  private Button mJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mInfo = (EditText) findViewById(R.id.edittextInfo);\n    mJump = (Button) findViewById(R.id.buttonJump);\n    // 绑定按钮的点击事件\n    mJump.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        toJump();\n      }\n    });\n  }\n\n  protected void toJump(){\n    // 获取输入的内容\n    String mText = \"\";\n    mText = mInfo.getText().toString();\n    // 新建 Intent 并设置目标页面为 TargetActivity\n    Intent mIntent = new Intent();\n    mIntent.setClass(MainActivity.this, TargetActivity.class);\n    // 添加参数到 Intent\n    mIntent.putExtra(\"Text\", mText);\n    // 开始 Intent\n    startActivity(mIntent);\n  }\n\n}\n```\n\n4、新建 TargetActivity.java 作为目标 Activity 。在 AndroidManifest.xml 中声明该页面，将 activity_target.xml 作为该页面的布局文件。TargetActivity 它将接收 MainActivity 传递的参数并在页面上输出。\n\n``` java\npublic class TargetActivity extends Activity {\n\n  // 声明控件\n  private TextView mOutput;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_target);\n    // 实例化控件\n    mOutput = (TextView) findViewById(R.id.textviewOuput);\n    getInfo();\n  }\n\n  protected void getInfo(){\n    // 获取 Intent 内包含的参数\n    Bundle mBundle = getIntent().getExtras();\n    // 提取键值为 Text 的参数\n    String mText = \"\";\n    mText = mBundle.getString(\"Text\");\n    // 在页面上输出\n    mOutput.setText(mText);\n  }\n\n}\n```\n \n\n运行程序，在第一个页面上输入文本，点击按钮将跳转到第二个页面，并在页面时显示收到的参数。\n\n{% img side-by-side /images/posts/2015/11/android_intent_1.png 220 第一个页面 %}\n\n{% img side-by-side /images/posts/2015/11/android_intent_2.png 220 第二个页面 %}","source":"_posts/2015-11-11@使用 Intent 实现页面跳转与传值.md","raw":"---\ntitle: 使用 Intent 实现页面跳转与传值\ncategories:\n  - Android\ndate: 2015-11-11 19:47:35\ntags:\n  - Android\n  - Java\n---\n\nAndroid 提供了 Intent（意图）用于实现 Activity（页面）的跳转与传值。Intent 好比 Android 中的信使，负责组件间通讯，它甚至可以在我们的应用中调用系统中的其他程序。\n\n<!-- more -->\n\n一般跳转：\n\n``` java\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nstartActivity(mIntent);\n```\n带参数的跳转：\n\n``` java\n// 当前 Activity\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nmIntent.putExtra(String name, String value);\nstartActivity(mIntent);\n```\n\n``` java\n// 目标 Activity\nBundle mBundle = getIntent().getExtras();\nString mText = mBundle.getString(String name);\n```\n\n新建一个 demo 应用并命名为 _IntentParactice_ ，创建默认的 MainActivity 。\n\n1、修改 MainActivity 的布局文件 activity_main.xml ，添加一个输入框和一个“跳转”按钮。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:padding=\"10dp\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n\n  <LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\" >\n\n    <EditText\n      android:id=\"@+id/edittextInfo\"\n      android:layout_width=\"0dp\"\n      android:layout_weight=\"1\"\n      android:layout_height=\"wrap_content\"/>\n\n    <Button \n      android:id=\"@+id/buttonJump\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"\n      android:text=\"跳转\"/>\n\n  </LinearLayout>\n\n</RelativeLayout>\n```\n\n2、创建 TargetActivity 的布局文件 activity_target.xml ，仅包含一个 TextView ，用于输出接收到的参数。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:background=\"#000000\"\n  android:padding=\"10dp\" >\n\n  <TextView\n    android:id=\"@+id/textviewOuput\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"16sp\"\n    android:textColor=\"#FFFFFF\"/>\n\n</RelativeLayout>\n```\n3、修改 MainActivity.java ，绑定按钮的点击事件，实现点击后保存输入的内容、跳转到目标 Activity 并传参。不用理会 IDE 报错，TargetActivity 稍后就会创建。\n\n``` java\npublic class MainActivity extends Activity {\n\n  // 声明控件\n  private EditText mInfo;\n  private Button mJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mInfo = (EditText) findViewById(R.id.edittextInfo);\n    mJump = (Button) findViewById(R.id.buttonJump);\n    // 绑定按钮的点击事件\n    mJump.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        toJump();\n      }\n    });\n  }\n\n  protected void toJump(){\n    // 获取输入的内容\n    String mText = \"\";\n    mText = mInfo.getText().toString();\n    // 新建 Intent 并设置目标页面为 TargetActivity\n    Intent mIntent = new Intent();\n    mIntent.setClass(MainActivity.this, TargetActivity.class);\n    // 添加参数到 Intent\n    mIntent.putExtra(\"Text\", mText);\n    // 开始 Intent\n    startActivity(mIntent);\n  }\n\n}\n```\n\n4、新建 TargetActivity.java 作为目标 Activity 。在 AndroidManifest.xml 中声明该页面，将 activity_target.xml 作为该页面的布局文件。TargetActivity 它将接收 MainActivity 传递的参数并在页面上输出。\n\n``` java\npublic class TargetActivity extends Activity {\n\n  // 声明控件\n  private TextView mOutput;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_target);\n    // 实例化控件\n    mOutput = (TextView) findViewById(R.id.textviewOuput);\n    getInfo();\n  }\n\n  protected void getInfo(){\n    // 获取 Intent 内包含的参数\n    Bundle mBundle = getIntent().getExtras();\n    // 提取键值为 Text 的参数\n    String mText = \"\";\n    mText = mBundle.getString(\"Text\");\n    // 在页面上输出\n    mOutput.setText(mText);\n  }\n\n}\n```\n \n\n运行程序，在第一个页面上输入文本，点击按钮将跳转到第二个页面，并在页面时显示收到的参数。\n\n{% img side-by-side /images/posts/2015/11/android_intent_1.png 220 第一个页面 %}\n\n{% img side-by-side /images/posts/2015/11/android_intent_2.png 220 第二个页面 %}","slug":"2015-11-11@使用 Intent 实现页面跳转与传值","published":1,"updated":"2020-06-29T03:32:42.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46c0011rqgjgbwfch6i","content":"<p>Android 提供了 Intent（意图）用于实现 Activity（页面）的跳转与传值。Intent 好比 Android 中的信使，负责组件间通讯，它甚至可以在我们的应用中调用系统中的其他程序。</p>\n<a id=\"more\"></a>\n\n<p>一般跳转：</p>\n<pre><code class=\"java\">Intent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nstartActivity(mIntent);</code></pre>\n<p>带参数的跳转：</p>\n<pre><code class=\"java\">// 当前 Activity\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nmIntent.putExtra(String name, String value);\nstartActivity(mIntent);</code></pre>\n<pre><code class=\"java\">// 目标 Activity\nBundle mBundle = getIntent().getExtras();\nString mText = mBundle.getString(String name);</code></pre>\n<p>新建一个 demo 应用并命名为 <em>IntentParactice</em> ，创建默认的 MainActivity 。</p>\n<p>1、修改 MainActivity 的布局文件 activity_main.xml ，添加一个输入框和一个“跳转”按钮。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:padding=&quot;10dp&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n\n  &lt;LinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;horizontal&quot; &gt;\n\n    &lt;EditText\n      android:id=&quot;@+id/edittextInfo&quot;\n      android:layout_width=&quot;0dp&quot;\n      android:layout_weight=&quot;1&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n\n    &lt;Button \n      android:id=&quot;@+id/buttonJump&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;\n      android:text=&quot;跳转&quot;/&gt;\n\n  &lt;/LinearLayout&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>2、创建 TargetActivity 的布局文件 activity_target.xml ，仅包含一个 TextView ，用于输出接收到的参数。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:background=&quot;#000000&quot;\n  android:padding=&quot;10dp&quot; &gt;\n\n  &lt;TextView\n    android:id=&quot;@+id/textviewOuput&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:textSize=&quot;16sp&quot;\n    android:textColor=&quot;#FFFFFF&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>3、修改 MainActivity.java ，绑定按钮的点击事件，实现点击后保存输入的内容、跳转到目标 Activity 并传参。不用理会 IDE 报错，TargetActivity 稍后就会创建。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  // 声明控件\n  private EditText mInfo;\n  private Button mJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mInfo = (EditText) findViewById(R.id.edittextInfo);\n    mJump = (Button) findViewById(R.id.buttonJump);\n    // 绑定按钮的点击事件\n    mJump.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        toJump();\n      }\n    });\n  }\n\n  protected void toJump(){\n    // 获取输入的内容\n    String mText = &quot;&quot;;\n    mText = mInfo.getText().toString();\n    // 新建 Intent 并设置目标页面为 TargetActivity\n    Intent mIntent = new Intent();\n    mIntent.setClass(MainActivity.this, TargetActivity.class);\n    // 添加参数到 Intent\n    mIntent.putExtra(&quot;Text&quot;, mText);\n    // 开始 Intent\n    startActivity(mIntent);\n  }\n\n}</code></pre>\n<p>4、新建 TargetActivity.java 作为目标 Activity 。在 AndroidManifest.xml 中声明该页面，将 activity_target.xml 作为该页面的布局文件。TargetActivity 它将接收 MainActivity 传递的参数并在页面上输出。</p>\n<pre><code class=\"java\">public class TargetActivity extends Activity {\n\n  // 声明控件\n  private TextView mOutput;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_target);\n    // 实例化控件\n    mOutput = (TextView) findViewById(R.id.textviewOuput);\n    getInfo();\n  }\n\n  protected void getInfo(){\n    // 获取 Intent 内包含的参数\n    Bundle mBundle = getIntent().getExtras();\n    // 提取键值为 Text 的参数\n    String mText = &quot;&quot;;\n    mText = mBundle.getString(&quot;Text&quot;);\n    // 在页面上输出\n    mOutput.setText(mText);\n  }\n\n}</code></pre>\n<p>运行程序，在第一个页面上输入文本，点击按钮将跳转到第二个页面，并在页面时显示收到的参数。</p>\n<img src=\"/images/posts/2015/11/android_intent_1.png\" class=\"side-by-side\" width=\"220\" title=\"第一个页面\">\n\n<img src=\"/images/posts/2015/11/android_intent_2.png\" class=\"side-by-side\" width=\"220\" title=\"第二个页面\">","site":{"data":{}},"excerpt":"<p>Android 提供了 Intent（意图）用于实现 Activity（页面）的跳转与传值。Intent 好比 Android 中的信使，负责组件间通讯，它甚至可以在我们的应用中调用系统中的其他程序。</p>","more":"<p>一般跳转：</p>\n<pre><code class=\"java\">Intent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nstartActivity(mIntent);</code></pre>\n<p>带参数的跳转：</p>\n<pre><code class=\"java\">// 当前 Activity\nIntent mIntent = new Intent();\nmIntent.setClass(Context packageContext, Class class);\nmIntent.putExtra(String name, String value);\nstartActivity(mIntent);</code></pre>\n<pre><code class=\"java\">// 目标 Activity\nBundle mBundle = getIntent().getExtras();\nString mText = mBundle.getString(String name);</code></pre>\n<p>新建一个 demo 应用并命名为 <em>IntentParactice</em> ，创建默认的 MainActivity 。</p>\n<p>1、修改 MainActivity 的布局文件 activity_main.xml ，添加一个输入框和一个“跳转”按钮。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:padding=&quot;10dp&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n\n  &lt;LinearLayout\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;horizontal&quot; &gt;\n\n    &lt;EditText\n      android:id=&quot;@+id/edittextInfo&quot;\n      android:layout_width=&quot;0dp&quot;\n      android:layout_weight=&quot;1&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n\n    &lt;Button \n      android:id=&quot;@+id/buttonJump&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;\n      android:text=&quot;跳转&quot;/&gt;\n\n  &lt;/LinearLayout&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>2、创建 TargetActivity 的布局文件 activity_target.xml ，仅包含一个 TextView ，用于输出接收到的参数。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:background=&quot;#000000&quot;\n  android:padding=&quot;10dp&quot; &gt;\n\n  &lt;TextView\n    android:id=&quot;@+id/textviewOuput&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:textSize=&quot;16sp&quot;\n    android:textColor=&quot;#FFFFFF&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>3、修改 MainActivity.java ，绑定按钮的点击事件，实现点击后保存输入的内容、跳转到目标 Activity 并传参。不用理会 IDE 报错，TargetActivity 稍后就会创建。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  // 声明控件\n  private EditText mInfo;\n  private Button mJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mInfo = (EditText) findViewById(R.id.edittextInfo);\n    mJump = (Button) findViewById(R.id.buttonJump);\n    // 绑定按钮的点击事件\n    mJump.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        toJump();\n      }\n    });\n  }\n\n  protected void toJump(){\n    // 获取输入的内容\n    String mText = &quot;&quot;;\n    mText = mInfo.getText().toString();\n    // 新建 Intent 并设置目标页面为 TargetActivity\n    Intent mIntent = new Intent();\n    mIntent.setClass(MainActivity.this, TargetActivity.class);\n    // 添加参数到 Intent\n    mIntent.putExtra(&quot;Text&quot;, mText);\n    // 开始 Intent\n    startActivity(mIntent);\n  }\n\n}</code></pre>\n<p>4、新建 TargetActivity.java 作为目标 Activity 。在 AndroidManifest.xml 中声明该页面，将 activity_target.xml 作为该页面的布局文件。TargetActivity 它将接收 MainActivity 传递的参数并在页面上输出。</p>\n<pre><code class=\"java\">public class TargetActivity extends Activity {\n\n  // 声明控件\n  private TextView mOutput;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_target);\n    // 实例化控件\n    mOutput = (TextView) findViewById(R.id.textviewOuput);\n    getInfo();\n  }\n\n  protected void getInfo(){\n    // 获取 Intent 内包含的参数\n    Bundle mBundle = getIntent().getExtras();\n    // 提取键值为 Text 的参数\n    String mText = &quot;&quot;;\n    mText = mBundle.getString(&quot;Text&quot;);\n    // 在页面上输出\n    mOutput.setText(mText);\n  }\n\n}</code></pre>\n<p>运行程序，在第一个页面上输入文本，点击按钮将跳转到第二个页面，并在页面时显示收到的参数。</p>\n<img src=\"/images/posts/2015/11/android_intent_1.png\" class=\"side-by-side\" width=\"220\" title=\"第一个页面\">\n\n<img src=\"/images/posts/2015/11/android_intent_2.png\" class=\"side-by-side\" width=\"220\" title=\"第二个页面\">"},{"title":"Android 判断系统版本","date":"2015-12-05T08:42:01.000Z","_content":"\n在开发应用的过程中，有时会遇到一些匪夷所思的兼容性问题。同一个 Activity ，在不同版本的系统上，可能出现完全不一样的效果。\n\n例如：我遇到过，单边圆角形状在 Android4.0 上显示正常，但在 Android2.2 上出现 bug 。\n\n<!-- more -->\n\n{% img side-by-side /images/posts/2015/12/android_system_version_1.png 220 %}\n\n{% img side-by-side /images/posts/2015/12/android_system_version_2.png 220 %}\n\n这时候需要判断用户的系统版本，编写不同的代码。\n\n``` java\n// 判断系统版本是否在 Android 3.0 (Honeycomb) 以上。\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB){\n\t// Android 3.0及以上\n} else {\n\t// Android 3.0以下\n}\n```\n\nAndroid 各系统版本对应的 SDK_INT 变量：\n\n``` java\npublic static class VERSION_CODES {\n\t/**\n\t * Magic version number for a current development build, which has\n\t * not yet turned into an official release.\n\t */\n\tpublic static final int CUR_DEVELOPMENT = 10000;\n\n\t/**\n\t * October 2008: The original, first, version of Android.  Yay!\n\t */\n\tpublic static final int BASE = 1;\n\n\t/**\n\t * February 2009: First Android update, officially called 1.1.\n\t */\n\tpublic static final int BASE_1_1 = 2;\n\n\t/**\n\t * May 2009: Android 1.5.\n\t */\n\tpublic static final int CUPCAKE = 3;\n\n\t/**\n\t * September 2009: Android 1.6.\n\t */\n\tpublic static final int DONUT = 4;\n\n\t/**\n\t * November 2009: Android 2.0\n\t */\n\tpublic static final int ECLAIR = 5;\n\n\t/**\n\t * December 2009: Android 2.0.1\n\t */\n\tpublic static final int ECLAIR_0_1 = 6;\n\n\t/**\n\t * January 2010: Android 2.1\n\t */\n\tpublic static final int ECLAIR_MR1 = 7;\n\n\t/**\n\t * June 2010: Android 2.2\n\t */\n\tpublic static final int FROYO = 8;\n\n\t/**\n\t * November 2010: Android 2.3\n\t */\n\tpublic static final int GINGERBREAD = 9;\n\n\t/**\n\t * February 2011: Android 2.3.3.\n\t */\n\tpublic static final int GINGERBREAD_MR1 = 10;\n\n\t/**\n\t * February 2011: Android 3.0.\n\t */\n\tpublic static final int HONEYCOMB = 11;\n\n\t/**\n\t * May 2011: Android 3.1.\n\t */\n\tpublic static final int HONEYCOMB_MR1 = 12;\n\n\t/**\n\t * June 2011: Android 3.2.\n\t */\n\tpublic static final int HONEYCOMB_MR2 = 13;\n\n\t/**\n\t * October 2011: Android 4.0.\n\t */\n\tpublic static final int ICE_CREAM_SANDWICH = 14;\n\n\t/**\n\t * December 2011: Android 4.0.3.\n\t */\n\tpublic static final int ICE_CREAM_SANDWICH_MR1 = 15;\n\n\t/**\n\t * June 2012: Android 4.1.\n\t */\n\tpublic static final int JELLY_BEAN = 16;\n\n\t/**\n\t * Android 4.2: Moar jelly beans!\n\t */\n\tpublic static final int JELLY_BEAN_MR1 = 17;\n\n\t/**\n\t * Android 4.3: Jelly Bean MR2, the revenge of the beans.\n\t */\n\tpublic static final int JELLY_BEAN_MR2 = 18;\n\n\t/**\n\t * Android 4.4: KitKat, another tasty treat.\n\t */\n\tpublic static final int KITKAT = 19;\n}\n```","source":"_posts/2015-12-05@Android 判断系统版本.md","raw":"---\ntitle: Android 判断系统版本\ncategories:\n  - Android\ndate: 2015-12-05 16:42:01\ntags:\n  - Android\n  - Java\n---\n\n在开发应用的过程中，有时会遇到一些匪夷所思的兼容性问题。同一个 Activity ，在不同版本的系统上，可能出现完全不一样的效果。\n\n例如：我遇到过，单边圆角形状在 Android4.0 上显示正常，但在 Android2.2 上出现 bug 。\n\n<!-- more -->\n\n{% img side-by-side /images/posts/2015/12/android_system_version_1.png 220 %}\n\n{% img side-by-side /images/posts/2015/12/android_system_version_2.png 220 %}\n\n这时候需要判断用户的系统版本，编写不同的代码。\n\n``` java\n// 判断系统版本是否在 Android 3.0 (Honeycomb) 以上。\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB){\n\t// Android 3.0及以上\n} else {\n\t// Android 3.0以下\n}\n```\n\nAndroid 各系统版本对应的 SDK_INT 变量：\n\n``` java\npublic static class VERSION_CODES {\n\t/**\n\t * Magic version number for a current development build, which has\n\t * not yet turned into an official release.\n\t */\n\tpublic static final int CUR_DEVELOPMENT = 10000;\n\n\t/**\n\t * October 2008: The original, first, version of Android.  Yay!\n\t */\n\tpublic static final int BASE = 1;\n\n\t/**\n\t * February 2009: First Android update, officially called 1.1.\n\t */\n\tpublic static final int BASE_1_1 = 2;\n\n\t/**\n\t * May 2009: Android 1.5.\n\t */\n\tpublic static final int CUPCAKE = 3;\n\n\t/**\n\t * September 2009: Android 1.6.\n\t */\n\tpublic static final int DONUT = 4;\n\n\t/**\n\t * November 2009: Android 2.0\n\t */\n\tpublic static final int ECLAIR = 5;\n\n\t/**\n\t * December 2009: Android 2.0.1\n\t */\n\tpublic static final int ECLAIR_0_1 = 6;\n\n\t/**\n\t * January 2010: Android 2.1\n\t */\n\tpublic static final int ECLAIR_MR1 = 7;\n\n\t/**\n\t * June 2010: Android 2.2\n\t */\n\tpublic static final int FROYO = 8;\n\n\t/**\n\t * November 2010: Android 2.3\n\t */\n\tpublic static final int GINGERBREAD = 9;\n\n\t/**\n\t * February 2011: Android 2.3.3.\n\t */\n\tpublic static final int GINGERBREAD_MR1 = 10;\n\n\t/**\n\t * February 2011: Android 3.0.\n\t */\n\tpublic static final int HONEYCOMB = 11;\n\n\t/**\n\t * May 2011: Android 3.1.\n\t */\n\tpublic static final int HONEYCOMB_MR1 = 12;\n\n\t/**\n\t * June 2011: Android 3.2.\n\t */\n\tpublic static final int HONEYCOMB_MR2 = 13;\n\n\t/**\n\t * October 2011: Android 4.0.\n\t */\n\tpublic static final int ICE_CREAM_SANDWICH = 14;\n\n\t/**\n\t * December 2011: Android 4.0.3.\n\t */\n\tpublic static final int ICE_CREAM_SANDWICH_MR1 = 15;\n\n\t/**\n\t * June 2012: Android 4.1.\n\t */\n\tpublic static final int JELLY_BEAN = 16;\n\n\t/**\n\t * Android 4.2: Moar jelly beans!\n\t */\n\tpublic static final int JELLY_BEAN_MR1 = 17;\n\n\t/**\n\t * Android 4.3: Jelly Bean MR2, the revenge of the beans.\n\t */\n\tpublic static final int JELLY_BEAN_MR2 = 18;\n\n\t/**\n\t * Android 4.4: KitKat, another tasty treat.\n\t */\n\tpublic static final int KITKAT = 19;\n}\n```","slug":"2015-12-05@Android 判断系统版本","published":1,"updated":"2020-06-29T03:32:42.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46e0013rqgj0bbj87b8","content":"<p>在开发应用的过程中，有时会遇到一些匪夷所思的兼容性问题。同一个 Activity ，在不同版本的系统上，可能出现完全不一样的效果。</p>\n<p>例如：我遇到过，单边圆角形状在 Android4.0 上显示正常，但在 Android2.2 上出现 bug 。</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2015/12/android_system_version_1.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2015/12/android_system_version_2.png\" class=\"side-by-side\" width=\"220\">\n\n<p>这时候需要判断用户的系统版本，编写不同的代码。</p>\n<pre><code class=\"java\">// 判断系统版本是否在 Android 3.0 (Honeycomb) 以上。\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB){\n    // Android 3.0及以上\n} else {\n    // Android 3.0以下\n}</code></pre>\n<p>Android 各系统版本对应的 SDK_INT 变量：</p>\n<pre><code class=\"java\">public static class VERSION_CODES {\n    /**\n     * Magic version number for a current development build, which has\n     * not yet turned into an official release.\n     */\n    public static final int CUR_DEVELOPMENT = 10000;\n\n    /**\n     * October 2008: The original, first, version of Android.  Yay!\n     */\n    public static final int BASE = 1;\n\n    /**\n     * February 2009: First Android update, officially called 1.1.\n     */\n    public static final int BASE_1_1 = 2;\n\n    /**\n     * May 2009: Android 1.5.\n     */\n    public static final int CUPCAKE = 3;\n\n    /**\n     * September 2009: Android 1.6.\n     */\n    public static final int DONUT = 4;\n\n    /**\n     * November 2009: Android 2.0\n     */\n    public static final int ECLAIR = 5;\n\n    /**\n     * December 2009: Android 2.0.1\n     */\n    public static final int ECLAIR_0_1 = 6;\n\n    /**\n     * January 2010: Android 2.1\n     */\n    public static final int ECLAIR_MR1 = 7;\n\n    /**\n     * June 2010: Android 2.2\n     */\n    public static final int FROYO = 8;\n\n    /**\n     * November 2010: Android 2.3\n     */\n    public static final int GINGERBREAD = 9;\n\n    /**\n     * February 2011: Android 2.3.3.\n     */\n    public static final int GINGERBREAD_MR1 = 10;\n\n    /**\n     * February 2011: Android 3.0.\n     */\n    public static final int HONEYCOMB = 11;\n\n    /**\n     * May 2011: Android 3.1.\n     */\n    public static final int HONEYCOMB_MR1 = 12;\n\n    /**\n     * June 2011: Android 3.2.\n     */\n    public static final int HONEYCOMB_MR2 = 13;\n\n    /**\n     * October 2011: Android 4.0.\n     */\n    public static final int ICE_CREAM_SANDWICH = 14;\n\n    /**\n     * December 2011: Android 4.0.3.\n     */\n    public static final int ICE_CREAM_SANDWICH_MR1 = 15;\n\n    /**\n     * June 2012: Android 4.1.\n     */\n    public static final int JELLY_BEAN = 16;\n\n    /**\n     * Android 4.2: Moar jelly beans!\n     */\n    public static final int JELLY_BEAN_MR1 = 17;\n\n    /**\n     * Android 4.3: Jelly Bean MR2, the revenge of the beans.\n     */\n    public static final int JELLY_BEAN_MR2 = 18;\n\n    /**\n     * Android 4.4: KitKat, another tasty treat.\n     */\n    public static final int KITKAT = 19;\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>在开发应用的过程中，有时会遇到一些匪夷所思的兼容性问题。同一个 Activity ，在不同版本的系统上，可能出现完全不一样的效果。</p>\n<p>例如：我遇到过，单边圆角形状在 Android4.0 上显示正常，但在 Android2.2 上出现 bug 。</p>","more":"<img src=\"/images/posts/2015/12/android_system_version_1.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2015/12/android_system_version_2.png\" class=\"side-by-side\" width=\"220\">\n\n<p>这时候需要判断用户的系统版本，编写不同的代码。</p>\n<pre><code class=\"java\">// 判断系统版本是否在 Android 3.0 (Honeycomb) 以上。\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB){\n    // Android 3.0及以上\n} else {\n    // Android 3.0以下\n}</code></pre>\n<p>Android 各系统版本对应的 SDK_INT 变量：</p>\n<pre><code class=\"java\">public static class VERSION_CODES {\n    /**\n     * Magic version number for a current development build, which has\n     * not yet turned into an official release.\n     */\n    public static final int CUR_DEVELOPMENT = 10000;\n\n    /**\n     * October 2008: The original, first, version of Android.  Yay!\n     */\n    public static final int BASE = 1;\n\n    /**\n     * February 2009: First Android update, officially called 1.1.\n     */\n    public static final int BASE_1_1 = 2;\n\n    /**\n     * May 2009: Android 1.5.\n     */\n    public static final int CUPCAKE = 3;\n\n    /**\n     * September 2009: Android 1.6.\n     */\n    public static final int DONUT = 4;\n\n    /**\n     * November 2009: Android 2.0\n     */\n    public static final int ECLAIR = 5;\n\n    /**\n     * December 2009: Android 2.0.1\n     */\n    public static final int ECLAIR_0_1 = 6;\n\n    /**\n     * January 2010: Android 2.1\n     */\n    public static final int ECLAIR_MR1 = 7;\n\n    /**\n     * June 2010: Android 2.2\n     */\n    public static final int FROYO = 8;\n\n    /**\n     * November 2010: Android 2.3\n     */\n    public static final int GINGERBREAD = 9;\n\n    /**\n     * February 2011: Android 2.3.3.\n     */\n    public static final int GINGERBREAD_MR1 = 10;\n\n    /**\n     * February 2011: Android 3.0.\n     */\n    public static final int HONEYCOMB = 11;\n\n    /**\n     * May 2011: Android 3.1.\n     */\n    public static final int HONEYCOMB_MR1 = 12;\n\n    /**\n     * June 2011: Android 3.2.\n     */\n    public static final int HONEYCOMB_MR2 = 13;\n\n    /**\n     * October 2011: Android 4.0.\n     */\n    public static final int ICE_CREAM_SANDWICH = 14;\n\n    /**\n     * December 2011: Android 4.0.3.\n     */\n    public static final int ICE_CREAM_SANDWICH_MR1 = 15;\n\n    /**\n     * June 2012: Android 4.1.\n     */\n    public static final int JELLY_BEAN = 16;\n\n    /**\n     * Android 4.2: Moar jelly beans!\n     */\n    public static final int JELLY_BEAN_MR1 = 17;\n\n    /**\n     * Android 4.3: Jelly Bean MR2, the revenge of the beans.\n     */\n    public static final int JELLY_BEAN_MR2 = 18;\n\n    /**\n     * Android 4.4: KitKat, another tasty treat.\n     */\n    public static final int KITKAT = 19;\n}</code></pre>"},{"title":"Android 应用中使用外部字体","date":"2015-12-05T12:39:35.000Z","_content":"\nAndroid 系统的默认字体虽不算丑，但应该不能满足大部分人对界面设计的追求。\n\n在布局文件中，TextView 控件提供了一个 fontFamily 属性，熟悉 CSS 的人可能认为这个属性是用来修改文本字体的。多次尝试之后，我发现这个属性并没什么用。好在我们还可以在代码中引用外部字体。\n\n<!-- more -->\n\n在工程的 assets 文件夹下新建 fonts 文件夹，用于存放字体文件。然后新建 Typeface 对象，并设置好字体的路径。最后，为 TextView 对象设置 Typeface 即可。\n\n``` java\npublic class MainActivity extends Activity {\n\n  private TextView mTopTitle;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mTopTitle = (TextView) findViewById(R.id.textviewTopTitle);\n    // 设置字体路径\n    Typeface mFont= Typeface.createFromAsset(getAssets(), \"fonts/Microsoft-YaHei.ttf\");\n    // 设置文本字体\n    mTopTitle.setTypeface(mFont);\n  }\n\n}\n```\n\n注意，字体文件的拓展名有 ttf 、otf 等，写错拓展名将导致应用崩溃。","source":"_posts/2015-12-05@Android 应用中使用外部字体.md","raw":"---\ntitle: Android 应用中使用外部字体\ncategories:\n  - Android\ndate: 2015-12-05 20:39:35\ntags:\n  - Android\n  - Java\n---\n\nAndroid 系统的默认字体虽不算丑，但应该不能满足大部分人对界面设计的追求。\n\n在布局文件中，TextView 控件提供了一个 fontFamily 属性，熟悉 CSS 的人可能认为这个属性是用来修改文本字体的。多次尝试之后，我发现这个属性并没什么用。好在我们还可以在代码中引用外部字体。\n\n<!-- more -->\n\n在工程的 assets 文件夹下新建 fonts 文件夹，用于存放字体文件。然后新建 Typeface 对象，并设置好字体的路径。最后，为 TextView 对象设置 Typeface 即可。\n\n``` java\npublic class MainActivity extends Activity {\n\n  private TextView mTopTitle;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mTopTitle = (TextView) findViewById(R.id.textviewTopTitle);\n    // 设置字体路径\n    Typeface mFont= Typeface.createFromAsset(getAssets(), \"fonts/Microsoft-YaHei.ttf\");\n    // 设置文本字体\n    mTopTitle.setTypeface(mFont);\n  }\n\n}\n```\n\n注意，字体文件的拓展名有 ttf 、otf 等，写错拓展名将导致应用崩溃。","slug":"2015-12-05@Android 应用中使用外部字体","published":1,"updated":"2020-06-29T03:32:42.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46f0015rqgj3jjabzrq","content":"<p>Android 系统的默认字体虽不算丑，但应该不能满足大部分人对界面设计的追求。</p>\n<p>在布局文件中，TextView 控件提供了一个 fontFamily 属性，熟悉 CSS 的人可能认为这个属性是用来修改文本字体的。多次尝试之后，我发现这个属性并没什么用。好在我们还可以在代码中引用外部字体。</p>\n<a id=\"more\"></a>\n\n<p>在工程的 assets 文件夹下新建 fonts 文件夹，用于存放字体文件。然后新建 Typeface 对象，并设置好字体的路径。最后，为 TextView 对象设置 Typeface 即可。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  private TextView mTopTitle;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mTopTitle = (TextView) findViewById(R.id.textviewTopTitle);\n    // 设置字体路径\n    Typeface mFont= Typeface.createFromAsset(getAssets(), &quot;fonts/Microsoft-YaHei.ttf&quot;);\n    // 设置文本字体\n    mTopTitle.setTypeface(mFont);\n  }\n\n}</code></pre>\n<p>注意，字体文件的拓展名有 ttf 、otf 等，写错拓展名将导致应用崩溃。</p>\n","site":{"data":{}},"excerpt":"<p>Android 系统的默认字体虽不算丑，但应该不能满足大部分人对界面设计的追求。</p>\n<p>在布局文件中，TextView 控件提供了一个 fontFamily 属性，熟悉 CSS 的人可能认为这个属性是用来修改文本字体的。多次尝试之后，我发现这个属性并没什么用。好在我们还可以在代码中引用外部字体。</p>","more":"<p>在工程的 assets 文件夹下新建 fonts 文件夹，用于存放字体文件。然后新建 Typeface 对象，并设置好字体的路径。最后，为 TextView 对象设置 Typeface 即可。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  private TextView mTopTitle;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mTopTitle = (TextView) findViewById(R.id.textviewTopTitle);\n    // 设置字体路径\n    Typeface mFont= Typeface.createFromAsset(getAssets(), &quot;fonts/Microsoft-YaHei.ttf&quot;);\n    // 设置文本字体\n    mTopTitle.setTypeface(mFont);\n  }\n\n}</code></pre>\n<p>注意，字体文件的拓展名有 ttf 、otf 等，写错拓展名将导致应用崩溃。</p>"},{"title":"使用 layer-list 实现控件阴影","date":"2015-12-05T13:05:56.000Z","_content":"\n在开发 demo 应用的过程中用到给 LinearLayout 添加阴影。\n\n这里使用 layer-list 实现，实际上就是给 LinearLayout 添加了一个包含两层 shape 的 xml 文件作为背景，有点类似 PS 里的图层。\n\n<!-- more -->\n\n在 drawable 文件夹下新建一个 xml 文件。\n\n``` xml\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <!-- 阴影 -->\n  <item>\n    <shape android:shape=\"rectangle\" >\n      <!-- 阴影颜色 -->\n      <gradient\n        android:angle=\"90\"\n        android:endColor=\"#b7b7b7\"\n        android:startColor=\"#e8e8e8\" />\n      <!-- 阴影圆角 -->\n      <corners android:radius=\"0dp\" /> \n    </shape>\n  </item>\n  <!-- 前景 -->\n  <item android:bottom=\"2dp\"> <!-- 阴影厚度 -->\n    <shape android:shape=\"rectangle\" >\n      <solid android:color=\"#fff\" /> <!-- 前景颜色 -->\n      <corners android:radius=\"0dp\" /> <!-- 前景圆角 -->\n    </shape>\n  </item>\n</layer-list>\n```\n\n为 LinearLayout 设置 _background_ 属性，引用此 xml 文件即可。\n","source":"_posts/2015-12-05@使用 layer-list 实现控件阴影.md","raw":"---\ntitle: 使用 layer-list 实现控件阴影\ncategories:\n  - Android\ndate: 2015-12-05 21:05:56\ntags:\n  - Android\n---\n\n在开发 demo 应用的过程中用到给 LinearLayout 添加阴影。\n\n这里使用 layer-list 实现，实际上就是给 LinearLayout 添加了一个包含两层 shape 的 xml 文件作为背景，有点类似 PS 里的图层。\n\n<!-- more -->\n\n在 drawable 文件夹下新建一个 xml 文件。\n\n``` xml\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <!-- 阴影 -->\n  <item>\n    <shape android:shape=\"rectangle\" >\n      <!-- 阴影颜色 -->\n      <gradient\n        android:angle=\"90\"\n        android:endColor=\"#b7b7b7\"\n        android:startColor=\"#e8e8e8\" />\n      <!-- 阴影圆角 -->\n      <corners android:radius=\"0dp\" /> \n    </shape>\n  </item>\n  <!-- 前景 -->\n  <item android:bottom=\"2dp\"> <!-- 阴影厚度 -->\n    <shape android:shape=\"rectangle\" >\n      <solid android:color=\"#fff\" /> <!-- 前景颜色 -->\n      <corners android:radius=\"0dp\" /> <!-- 前景圆角 -->\n    </shape>\n  </item>\n</layer-list>\n```\n\n为 LinearLayout 设置 _background_ 属性，引用此 xml 文件即可。\n","slug":"2015-12-05@使用 layer-list 实现控件阴影","published":1,"updated":"2020-06-29T03:32:42.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46j0018rqgja3bw56ui","content":"<p>在开发 demo 应用的过程中用到给 LinearLayout 添加阴影。</p>\n<p>这里使用 layer-list 实现，实际上就是给 LinearLayout 添加了一个包含两层 shape 的 xml 文件作为背景，有点类似 PS 里的图层。</p>\n<a id=\"more\"></a>\n\n<p>在 drawable 文件夹下新建一个 xml 文件。</p>\n<pre><code class=\"xml\">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n  &lt;!-- 阴影 --&gt;\n  &lt;item&gt;\n    &lt;shape android:shape=&quot;rectangle&quot; &gt;\n      &lt;!-- 阴影颜色 --&gt;\n      &lt;gradient\n        android:angle=&quot;90&quot;\n        android:endColor=&quot;#b7b7b7&quot;\n        android:startColor=&quot;#e8e8e8&quot; /&gt;\n      &lt;!-- 阴影圆角 --&gt;\n      &lt;corners android:radius=&quot;0dp&quot; /&gt; \n    &lt;/shape&gt;\n  &lt;/item&gt;\n  &lt;!-- 前景 --&gt;\n  &lt;item android:bottom=&quot;2dp&quot;&gt; &lt;!-- 阴影厚度 --&gt;\n    &lt;shape android:shape=&quot;rectangle&quot; &gt;\n      &lt;solid android:color=&quot;#fff&quot; /&gt; &lt;!-- 前景颜色 --&gt;\n      &lt;corners android:radius=&quot;0dp&quot; /&gt; &lt;!-- 前景圆角 --&gt;\n    &lt;/shape&gt;\n  &lt;/item&gt;\n&lt;/layer-list&gt;</code></pre>\n<p>为 LinearLayout 设置 <em>background</em> 属性，引用此 xml 文件即可。</p>\n","site":{"data":{}},"excerpt":"<p>在开发 demo 应用的过程中用到给 LinearLayout 添加阴影。</p>\n<p>这里使用 layer-list 实现，实际上就是给 LinearLayout 添加了一个包含两层 shape 的 xml 文件作为背景，有点类似 PS 里的图层。</p>","more":"<p>在 drawable 文件夹下新建一个 xml 文件。</p>\n<pre><code class=\"xml\">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n  &lt;!-- 阴影 --&gt;\n  &lt;item&gt;\n    &lt;shape android:shape=&quot;rectangle&quot; &gt;\n      &lt;!-- 阴影颜色 --&gt;\n      &lt;gradient\n        android:angle=&quot;90&quot;\n        android:endColor=&quot;#b7b7b7&quot;\n        android:startColor=&quot;#e8e8e8&quot; /&gt;\n      &lt;!-- 阴影圆角 --&gt;\n      &lt;corners android:radius=&quot;0dp&quot; /&gt; \n    &lt;/shape&gt;\n  &lt;/item&gt;\n  &lt;!-- 前景 --&gt;\n  &lt;item android:bottom=&quot;2dp&quot;&gt; &lt;!-- 阴影厚度 --&gt;\n    &lt;shape android:shape=&quot;rectangle&quot; &gt;\n      &lt;solid android:color=&quot;#fff&quot; /&gt; &lt;!-- 前景颜色 --&gt;\n      &lt;corners android:radius=&quot;0dp&quot; /&gt; &lt;!-- 前景圆角 --&gt;\n    &lt;/shape&gt;\n  &lt;/item&gt;\n&lt;/layer-list&gt;</code></pre>\n<p>为 LinearLayout 设置 <em>background</em> 属性，引用此 xml 文件即可。</p>"},{"title":"Android 使用 ListView 实现列表","date":"2015-12-07T07:19:12.000Z","_content":"\n第一步，在 Activity 的布局文件中添加 ListView 控件。\n\n<!-- more -->\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n\n  <ListView \n    android:id=\"@+id/listviewList\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"/>\n\n</RelativeLayout>\n```\n\n第二步，新建一个布局文件 layout_listview_item.xml ，作为列表中子项目的布局。\n\n这里我添加了一个 ImageView 和两个 TextView ，LinearLayout 和 RelativeLayout 仅用于排版。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"wrap_content\"\n  android:padding=\"10dp\" >\n\n  <LinearLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\">\n\n    <RelativeLayout \n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"match_parent\"\n      android:paddingRight=\"5dp\"\n      android:gravity=\"center\">\n      <ImageView \n      android:id=\"@+id/imageviewImage\"\n      android:layout_width=\"25dp\"\n      android:layout_height=\"25dp\"/>\n    </RelativeLayout>\n\n    <RelativeLayout \n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"\n      android:gravity=\"center\">\n      <TextView \n      android:id=\"@+id/textviewTextOne\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"/>\n    <TextView \n      android:id=\"@+id/textviewTextTwo\"\n      android:layout_below=\"@id/textviewTextOne\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"/>\n    </RelativeLayout>\n\n  </LinearLayout>\n\n</RelativeLayout>\n```\n\n第三步，在 Activity 的代码中实现 ListView 。\n\n``` java\npublic class MainActivity extends Activity {\n\n  // 声明控件\n  private ListView mListView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mListView = (ListView) findViewById(R.id.listviewList);\n    // 生成动态数组\n    ArrayList<HashMap<String, Object>> mListItem = new ArrayList<HashMap<String, Object>>();\n    for(int i=0; i<10; i++) {\n      // 新建 HashMap 对象\n      HashMap<String, Object> mMap = new HashMap<String, Object>(); \n      // 插入图像\n      mMap.put(\"ItemImage\", R.drawable.ic_launcher );\n      // 插入文本\n      mMap.put(\"ItemTitle\", \"Item\");\n      // 插入变量\n      mMap.put(\"ItemText\", \"This is Item No.\"+i);\n      mListItem.add(mMap);  //添加进动态数组\n    }\n    // 生成适配器\n    SimpleAdapter mSimpleAdapter = new SimpleAdapter(this, mListItem, // 数据对象\n      R.layout.layout_listview_item, // 子项目布局文件\n      new String[] {\"ItemImage\", \"ItemTitle\", \"ItemText\"}, // 数组中内容的key\n      new int[] {R.id.imageviewImage, R.id.textviewTextOne, R.id.textviewTextTwo } // 对应控件的ID\n    ); \n    // 添加并显示\n    mListView.setAdapter(mSimpleAdapter);\n    // 处理点击事件\n    mListView.setOnItemClickListener(new OnItemClickListener() {\n      @Override  \n      public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,  \n          long arg3) {\n        Toast.makeText(getBaseContext(), \"点击了第\" + arg2 + \"个项目\", Toast.LENGTH_SHORT).show();\n      }  \n    });\n    // 处理长按事件\n    mListView.setOnCreateContextMenuListener(new OnCreateContextMenuListener() {\n      @Override  \n      public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {  \n        menu.setHeaderTitle(\"长按菜单\"); // 窗口标题\n        menu.add(0, 0, 0, \"菜单第一行\"); // 菜单子项\n        menu.add(0, 1, 0, \"菜单第二行\");\n        menu.add(0, 2, 0, \"菜单第三行\");\n      }  \n    }); \n  }\n\n  // 长按菜单点击事件 \n  @Override  \n  public boolean onContextItemSelected(MenuItem mItem) {\n    Toast.makeText(getBaseContext(), \"点击了长按菜单中的第\" + mItem.getItemId() + \"个项目\", Toast.LENGTH_SHORT).show();\n    return super.onContextItemSelected(mItem);  \n  }\n\n}\n```\n\n实现效果：\n\n{% img side-by-side /images/posts/2015/12/android_list_view_1.png 220 列表 %}\n\n{% img side-by-side /images/posts/2015/12/android_list_view_2.png 220 点击事件 %}\n\n{% img side-by-side /images/posts/2015/12/android_list_view_3.png 220 长按事件 %}","source":"_posts/2015-12-07@Android 使用 ListView 实现列表.md","raw":"---\ntitle: Android 使用 ListView 实现列表\ncategories:\n  - Android\ndate: 2015-12-07 15:19:12\ntags:\n  - Android\n  - Java\n---\n\n第一步，在 Activity 的布局文件中添加 ListView 控件。\n\n<!-- more -->\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n\n  <ListView \n    android:id=\"@+id/listviewList\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"/>\n\n</RelativeLayout>\n```\n\n第二步，新建一个布局文件 layout_listview_item.xml ，作为列表中子项目的布局。\n\n这里我添加了一个 ImageView 和两个 TextView ，LinearLayout 和 RelativeLayout 仅用于排版。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"wrap_content\"\n  android:padding=\"10dp\" >\n\n  <LinearLayout \n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"horizontal\">\n\n    <RelativeLayout \n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"match_parent\"\n      android:paddingRight=\"5dp\"\n      android:gravity=\"center\">\n      <ImageView \n      android:id=\"@+id/imageviewImage\"\n      android:layout_width=\"25dp\"\n      android:layout_height=\"25dp\"/>\n    </RelativeLayout>\n\n    <RelativeLayout \n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"\n      android:gravity=\"center\">\n      <TextView \n      android:id=\"@+id/textviewTextOne\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"/>\n    <TextView \n      android:id=\"@+id/textviewTextTwo\"\n      android:layout_below=\"@id/textviewTextOne\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"/>\n    </RelativeLayout>\n\n  </LinearLayout>\n\n</RelativeLayout>\n```\n\n第三步，在 Activity 的代码中实现 ListView 。\n\n``` java\npublic class MainActivity extends Activity {\n\n  // 声明控件\n  private ListView mListView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mListView = (ListView) findViewById(R.id.listviewList);\n    // 生成动态数组\n    ArrayList<HashMap<String, Object>> mListItem = new ArrayList<HashMap<String, Object>>();\n    for(int i=0; i<10; i++) {\n      // 新建 HashMap 对象\n      HashMap<String, Object> mMap = new HashMap<String, Object>(); \n      // 插入图像\n      mMap.put(\"ItemImage\", R.drawable.ic_launcher );\n      // 插入文本\n      mMap.put(\"ItemTitle\", \"Item\");\n      // 插入变量\n      mMap.put(\"ItemText\", \"This is Item No.\"+i);\n      mListItem.add(mMap);  //添加进动态数组\n    }\n    // 生成适配器\n    SimpleAdapter mSimpleAdapter = new SimpleAdapter(this, mListItem, // 数据对象\n      R.layout.layout_listview_item, // 子项目布局文件\n      new String[] {\"ItemImage\", \"ItemTitle\", \"ItemText\"}, // 数组中内容的key\n      new int[] {R.id.imageviewImage, R.id.textviewTextOne, R.id.textviewTextTwo } // 对应控件的ID\n    ); \n    // 添加并显示\n    mListView.setAdapter(mSimpleAdapter);\n    // 处理点击事件\n    mListView.setOnItemClickListener(new OnItemClickListener() {\n      @Override  \n      public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,  \n          long arg3) {\n        Toast.makeText(getBaseContext(), \"点击了第\" + arg2 + \"个项目\", Toast.LENGTH_SHORT).show();\n      }  \n    });\n    // 处理长按事件\n    mListView.setOnCreateContextMenuListener(new OnCreateContextMenuListener() {\n      @Override  \n      public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {  \n        menu.setHeaderTitle(\"长按菜单\"); // 窗口标题\n        menu.add(0, 0, 0, \"菜单第一行\"); // 菜单子项\n        menu.add(0, 1, 0, \"菜单第二行\");\n        menu.add(0, 2, 0, \"菜单第三行\");\n      }  \n    }); \n  }\n\n  // 长按菜单点击事件 \n  @Override  \n  public boolean onContextItemSelected(MenuItem mItem) {\n    Toast.makeText(getBaseContext(), \"点击了长按菜单中的第\" + mItem.getItemId() + \"个项目\", Toast.LENGTH_SHORT).show();\n    return super.onContextItemSelected(mItem);  \n  }\n\n}\n```\n\n实现效果：\n\n{% img side-by-side /images/posts/2015/12/android_list_view_1.png 220 列表 %}\n\n{% img side-by-side /images/posts/2015/12/android_list_view_2.png 220 点击事件 %}\n\n{% img side-by-side /images/posts/2015/12/android_list_view_3.png 220 长按事件 %}","slug":"2015-12-07@Android 使用 ListView 实现列表","published":1,"updated":"2020-06-29T03:32:42.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46k001brqgjhllj1wvl","content":"<p>第一步，在 Activity 的布局文件中添加 ListView 控件。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n\n  &lt;ListView \n    android:id=&quot;@+id/listviewList&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>第二步，新建一个布局文件 layout_listview_item.xml ，作为列表中子项目的布局。</p>\n<p>这里我添加了一个 ImageView 和两个 TextView ，LinearLayout 和 RelativeLayout 仅用于排版。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;wrap_content&quot;\n  android:padding=&quot;10dp&quot; &gt;\n\n  &lt;LinearLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;horizontal&quot;&gt;\n\n    &lt;RelativeLayout \n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;match_parent&quot;\n      android:paddingRight=&quot;5dp&quot;\n      android:gravity=&quot;center&quot;&gt;\n      &lt;ImageView \n      android:id=&quot;@+id/imageviewImage&quot;\n      android:layout_width=&quot;25dp&quot;\n      android:layout_height=&quot;25dp&quot;/&gt;\n    &lt;/RelativeLayout&gt;\n\n    &lt;RelativeLayout \n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;\n      android:gravity=&quot;center&quot;&gt;\n      &lt;TextView \n      android:id=&quot;@+id/textviewTextOne&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n    &lt;TextView \n      android:id=&quot;@+id/textviewTextTwo&quot;\n      android:layout_below=&quot;@id/textviewTextOne&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n    &lt;/RelativeLayout&gt;\n\n  &lt;/LinearLayout&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>第三步，在 Activity 的代码中实现 ListView 。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  // 声明控件\n  private ListView mListView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mListView = (ListView) findViewById(R.id.listviewList);\n    // 生成动态数组\n    ArrayList&lt;HashMap&lt;String, Object&gt;&gt; mListItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();\n    for(int i=0; i&lt;10; i++) {\n      // 新建 HashMap 对象\n      HashMap&lt;String, Object&gt; mMap = new HashMap&lt;String, Object&gt;(); \n      // 插入图像\n      mMap.put(&quot;ItemImage&quot;, R.drawable.ic_launcher );\n      // 插入文本\n      mMap.put(&quot;ItemTitle&quot;, &quot;Item&quot;);\n      // 插入变量\n      mMap.put(&quot;ItemText&quot;, &quot;This is Item No.&quot;+i);\n      mListItem.add(mMap);  //添加进动态数组\n    }\n    // 生成适配器\n    SimpleAdapter mSimpleAdapter = new SimpleAdapter(this, mListItem, // 数据对象\n      R.layout.layout_listview_item, // 子项目布局文件\n      new String[] {&quot;ItemImage&quot;, &quot;ItemTitle&quot;, &quot;ItemText&quot;}, // 数组中内容的key\n      new int[] {R.id.imageviewImage, R.id.textviewTextOne, R.id.textviewTextTwo } // 对应控件的ID\n    ); \n    // 添加并显示\n    mListView.setAdapter(mSimpleAdapter);\n    // 处理点击事件\n    mListView.setOnItemClickListener(new OnItemClickListener() {\n      @Override  \n      public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,  \n          long arg3) {\n        Toast.makeText(getBaseContext(), &quot;点击了第&quot; + arg2 + &quot;个项目&quot;, Toast.LENGTH_SHORT).show();\n      }  \n    });\n    // 处理长按事件\n    mListView.setOnCreateContextMenuListener(new OnCreateContextMenuListener() {\n      @Override  \n      public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {  \n        menu.setHeaderTitle(&quot;长按菜单&quot;); // 窗口标题\n        menu.add(0, 0, 0, &quot;菜单第一行&quot;); // 菜单子项\n        menu.add(0, 1, 0, &quot;菜单第二行&quot;);\n        menu.add(0, 2, 0, &quot;菜单第三行&quot;);\n      }  \n    }); \n  }\n\n  // 长按菜单点击事件 \n  @Override  \n  public boolean onContextItemSelected(MenuItem mItem) {\n    Toast.makeText(getBaseContext(), &quot;点击了长按菜单中的第&quot; + mItem.getItemId() + &quot;个项目&quot;, Toast.LENGTH_SHORT).show();\n    return super.onContextItemSelected(mItem);  \n  }\n\n}</code></pre>\n<p>实现效果：</p>\n<img src=\"/images/posts/2015/12/android_list_view_1.png\" class=\"side-by-side\" width=\"220\" title=\"列表\">\n\n<img src=\"/images/posts/2015/12/android_list_view_2.png\" class=\"side-by-side\" width=\"220\" title=\"点击事件\">\n\n<img src=\"/images/posts/2015/12/android_list_view_3.png\" class=\"side-by-side\" width=\"220\" title=\"长按事件\">","site":{"data":{}},"excerpt":"<p>第一步，在 Activity 的布局文件中添加 ListView 控件。</p>","more":"<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n\n  &lt;ListView \n    android:id=&quot;@+id/listviewList&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>第二步，新建一个布局文件 layout_listview_item.xml ，作为列表中子项目的布局。</p>\n<p>这里我添加了一个 ImageView 和两个 TextView ，LinearLayout 和 RelativeLayout 仅用于排版。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;wrap_content&quot;\n  android:padding=&quot;10dp&quot; &gt;\n\n  &lt;LinearLayout \n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:orientation=&quot;horizontal&quot;&gt;\n\n    &lt;RelativeLayout \n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;match_parent&quot;\n      android:paddingRight=&quot;5dp&quot;\n      android:gravity=&quot;center&quot;&gt;\n      &lt;ImageView \n      android:id=&quot;@+id/imageviewImage&quot;\n      android:layout_width=&quot;25dp&quot;\n      android:layout_height=&quot;25dp&quot;/&gt;\n    &lt;/RelativeLayout&gt;\n\n    &lt;RelativeLayout \n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;\n      android:gravity=&quot;center&quot;&gt;\n      &lt;TextView \n      android:id=&quot;@+id/textviewTextOne&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n    &lt;TextView \n      android:id=&quot;@+id/textviewTextTwo&quot;\n      android:layout_below=&quot;@id/textviewTextOne&quot;\n      android:layout_width=&quot;wrap_content&quot;\n      android:layout_height=&quot;wrap_content&quot;/&gt;\n    &lt;/RelativeLayout&gt;\n\n  &lt;/LinearLayout&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p>第三步，在 Activity 的代码中实现 ListView 。</p>\n<pre><code class=\"java\">public class MainActivity extends Activity {\n\n  // 声明控件\n  private ListView mListView;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mListView = (ListView) findViewById(R.id.listviewList);\n    // 生成动态数组\n    ArrayList&lt;HashMap&lt;String, Object&gt;&gt; mListItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();\n    for(int i=0; i&lt;10; i++) {\n      // 新建 HashMap 对象\n      HashMap&lt;String, Object&gt; mMap = new HashMap&lt;String, Object&gt;(); \n      // 插入图像\n      mMap.put(&quot;ItemImage&quot;, R.drawable.ic_launcher );\n      // 插入文本\n      mMap.put(&quot;ItemTitle&quot;, &quot;Item&quot;);\n      // 插入变量\n      mMap.put(&quot;ItemText&quot;, &quot;This is Item No.&quot;+i);\n      mListItem.add(mMap);  //添加进动态数组\n    }\n    // 生成适配器\n    SimpleAdapter mSimpleAdapter = new SimpleAdapter(this, mListItem, // 数据对象\n      R.layout.layout_listview_item, // 子项目布局文件\n      new String[] {&quot;ItemImage&quot;, &quot;ItemTitle&quot;, &quot;ItemText&quot;}, // 数组中内容的key\n      new int[] {R.id.imageviewImage, R.id.textviewTextOne, R.id.textviewTextTwo } // 对应控件的ID\n    ); \n    // 添加并显示\n    mListView.setAdapter(mSimpleAdapter);\n    // 处理点击事件\n    mListView.setOnItemClickListener(new OnItemClickListener() {\n      @Override  \n      public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,  \n          long arg3) {\n        Toast.makeText(getBaseContext(), &quot;点击了第&quot; + arg2 + &quot;个项目&quot;, Toast.LENGTH_SHORT).show();\n      }  \n    });\n    // 处理长按事件\n    mListView.setOnCreateContextMenuListener(new OnCreateContextMenuListener() {\n      @Override  \n      public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {  \n        menu.setHeaderTitle(&quot;长按菜单&quot;); // 窗口标题\n        menu.add(0, 0, 0, &quot;菜单第一行&quot;); // 菜单子项\n        menu.add(0, 1, 0, &quot;菜单第二行&quot;);\n        menu.add(0, 2, 0, &quot;菜单第三行&quot;);\n      }  \n    }); \n  }\n\n  // 长按菜单点击事件 \n  @Override  \n  public boolean onContextItemSelected(MenuItem mItem) {\n    Toast.makeText(getBaseContext(), &quot;点击了长按菜单中的第&quot; + mItem.getItemId() + &quot;个项目&quot;, Toast.LENGTH_SHORT).show();\n    return super.onContextItemSelected(mItem);  \n  }\n\n}</code></pre>\n<p>实现效果：</p>\n<img src=\"/images/posts/2015/12/android_list_view_1.png\" class=\"side-by-side\" width=\"220\" title=\"列表\">\n\n<img src=\"/images/posts/2015/12/android_list_view_2.png\" class=\"side-by-side\" width=\"220\" title=\"点击事件\">\n\n<img src=\"/images/posts/2015/12/android_list_view_3.png\" class=\"side-by-side\" width=\"220\" title=\"长按事件\">"},{"title":"使用隐式 Intent 调用其他应用","date":"2015-12-07T07:50:43.000Z","_content":"\n所谓隐式 Intent（意图），即不像显式 Intent 那样明确指定由哪个 Activity 响应，而是告诉系统我们想做什么，由系统匹配可响应该意图的其他程序。\n\n<!-- more -->\n\n在应用中使用隐式 Intent 可调用系统中的其他应用，完成打开网页、发送短信等操作。\n\n下面通过一个 demo 实践隐式 Intent 的基本用法，涉及的行为有：拨打电话、发送短信、发送邮件、浏览网页。\n\n首先，在 Activity 的布局文件中添加几个按钮，点击可执行相应的隐式 Intent 。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:padding=\"10dp\"\n  tools:context=\"com.caiyiming.implicititentpractice.MainActivity\" >\n  <Button\n    android:id=\"@+id/buttonCall\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"拨打电话\"/>\n  <Button\n    android:id=\"@+id/buttonSMS\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"发送短信\"/>\n  <Button\n    android:id=\"@+id/buttonEmail\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"发送邮件\"/>\n  <Button\n    android:id=\"@+id/buttonWeb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"浏览网页\"/>\n</LinearLayout>\n```\n\n注意，要调用系统拨号功能必须在 AndroidManifest.xml 中声明拨号权限。\n\n``` xml\n<uses-permission android:name=\"android.permission.CALL_PHONE\"></uses-permission>\n```\n\n然后，在 Activity 的代码中绑定按钮的点击事件，并添加实现隐式 Intent 的方法。\n\n``` java\npublic class MainActivity extends ActionBarActivity {\n\n  // 声明按钮\n  private Button mButtonCall;\n  private Button mButtonSMS;\n  private Button mButtonEmail;\n  private Button mButtonWeb;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化按钮\n    mButtonCall = (Button) findViewById(R.id.buttonCall);\n    mButtonSMS = (Button) findViewById(R.id.buttonSMS);\n    mButtonEmail = (Button) findViewById(R.id.buttonEmail);\n    mButtonWeb = (Button) findViewById(R.id.buttonWeb);\n    // 添加点击事件\n    mButtonCall.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentCall(); }\n    });\n    mButtonSMS.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentSMS(); }\n    });\n    mButtonEmail.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentEmail(); }\n    });\n    mButtonWeb.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentWeb(); }\n    });\n  }\n\n  /**\n   * 添加用于拨打电话、发送短信、发送邮件、浏览网页的方法\n   */\n  protected void intentCall() {\n    // 新建意图\n    Intent mIntent = new Intent(Intent.ACTION_CALL);\n    // 设置要拨打的号码\n    Uri mUri = Uri.parse(\"tel:10086\");\n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n  protected void intentSMS() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置要发送短信的号码\n    Uri mUri = Uri.parse(\"smsto:10086\");\n    mIntent.setData(mUri);\n    mIntent.putExtra(\"sms_body\", \"余额\"); // 消息内容\n    startActivity(mIntent);\n  }\n  protected void intentEmail() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置协议\n    Uri mUri = Uri.parse(\"mailto:\");\n    mIntent.setData(mUri);\n    // 设置收件人\n    String[] mEmail = {\"example@example.com\", \"example@example.com\"};\n    // 设置抄送方\n    String[] mCc = {\"example@example.com\"};\n    // 设置密送方\n    String[] mBcc = {\"example@example.com\"};\n    // 设置邮件标题\n    String mSubject = \"你好\";\n    // 设置邮件内容\n    String mText = \"很高兴认识你！\";\n    mIntent.putExtra(Intent.EXTRA_EMAIL, mEmail); \n    mIntent.putExtra(Intent.EXTRA_CC, mCc); \n    mIntent.putExtra(Intent.EXTRA_BCC, mBcc); \n    mIntent.putExtra(Intent.EXTRA_SUBJECT, mSubject); \n    mIntent.putExtra(Intent.EXTRA_TEXT, mText);\n    // 添加附件\n    // mintent.putExtra(Intent.EXTRA_STREAM, Uri.parse(...)); \n    startActivity(mIntent);\n  }\n  protected void intentWeb(){\n    Intent mIntent = new Intent(Intent.ACTION_VIEW);\n    Uri mUri = Uri.parse(\"http://www.caiyiming.com\"); \n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n\n}\n```\n\n运行应用程序，点击按钮即可调用其他程序响应意图。","source":"_posts/2015-12-07@使用隐式 Intent 调用其他应用.md","raw":"---\ntitle: 使用隐式 Intent 调用其他应用\ncategories:\n  - Android\ndate: 2015-12-07 15:50:43\ntags:\n  - Android\n  - Java\n---\n\n所谓隐式 Intent（意图），即不像显式 Intent 那样明确指定由哪个 Activity 响应，而是告诉系统我们想做什么，由系统匹配可响应该意图的其他程序。\n\n<!-- more -->\n\n在应用中使用隐式 Intent 可调用系统中的其他应用，完成打开网页、发送短信等操作。\n\n下面通过一个 demo 实践隐式 Intent 的基本用法，涉及的行为有：拨打电话、发送短信、发送邮件、浏览网页。\n\n首先，在 Activity 的布局文件中添加几个按钮，点击可执行相应的隐式 Intent 。\n\n``` xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:padding=\"10dp\"\n  tools:context=\"com.caiyiming.implicititentpractice.MainActivity\" >\n  <Button\n    android:id=\"@+id/buttonCall\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"拨打电话\"/>\n  <Button\n    android:id=\"@+id/buttonSMS\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"发送短信\"/>\n  <Button\n    android:id=\"@+id/buttonEmail\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"发送邮件\"/>\n  <Button\n    android:id=\"@+id/buttonWeb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"浏览网页\"/>\n</LinearLayout>\n```\n\n注意，要调用系统拨号功能必须在 AndroidManifest.xml 中声明拨号权限。\n\n``` xml\n<uses-permission android:name=\"android.permission.CALL_PHONE\"></uses-permission>\n```\n\n然后，在 Activity 的代码中绑定按钮的点击事件，并添加实现隐式 Intent 的方法。\n\n``` java\npublic class MainActivity extends ActionBarActivity {\n\n  // 声明按钮\n  private Button mButtonCall;\n  private Button mButtonSMS;\n  private Button mButtonEmail;\n  private Button mButtonWeb;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化按钮\n    mButtonCall = (Button) findViewById(R.id.buttonCall);\n    mButtonSMS = (Button) findViewById(R.id.buttonSMS);\n    mButtonEmail = (Button) findViewById(R.id.buttonEmail);\n    mButtonWeb = (Button) findViewById(R.id.buttonWeb);\n    // 添加点击事件\n    mButtonCall.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentCall(); }\n    });\n    mButtonSMS.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentSMS(); }\n    });\n    mButtonEmail.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentEmail(); }\n    });\n    mButtonWeb.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentWeb(); }\n    });\n  }\n\n  /**\n   * 添加用于拨打电话、发送短信、发送邮件、浏览网页的方法\n   */\n  protected void intentCall() {\n    // 新建意图\n    Intent mIntent = new Intent(Intent.ACTION_CALL);\n    // 设置要拨打的号码\n    Uri mUri = Uri.parse(\"tel:10086\");\n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n  protected void intentSMS() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置要发送短信的号码\n    Uri mUri = Uri.parse(\"smsto:10086\");\n    mIntent.setData(mUri);\n    mIntent.putExtra(\"sms_body\", \"余额\"); // 消息内容\n    startActivity(mIntent);\n  }\n  protected void intentEmail() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置协议\n    Uri mUri = Uri.parse(\"mailto:\");\n    mIntent.setData(mUri);\n    // 设置收件人\n    String[] mEmail = {\"example@example.com\", \"example@example.com\"};\n    // 设置抄送方\n    String[] mCc = {\"example@example.com\"};\n    // 设置密送方\n    String[] mBcc = {\"example@example.com\"};\n    // 设置邮件标题\n    String mSubject = \"你好\";\n    // 设置邮件内容\n    String mText = \"很高兴认识你！\";\n    mIntent.putExtra(Intent.EXTRA_EMAIL, mEmail); \n    mIntent.putExtra(Intent.EXTRA_CC, mCc); \n    mIntent.putExtra(Intent.EXTRA_BCC, mBcc); \n    mIntent.putExtra(Intent.EXTRA_SUBJECT, mSubject); \n    mIntent.putExtra(Intent.EXTRA_TEXT, mText);\n    // 添加附件\n    // mintent.putExtra(Intent.EXTRA_STREAM, Uri.parse(...)); \n    startActivity(mIntent);\n  }\n  protected void intentWeb(){\n    Intent mIntent = new Intent(Intent.ACTION_VIEW);\n    Uri mUri = Uri.parse(\"http://www.caiyiming.com\"); \n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n\n}\n```\n\n运行应用程序，点击按钮即可调用其他程序响应意图。","slug":"2015-12-07@使用隐式 Intent 调用其他应用","published":1,"updated":"2020-06-29T03:32:42.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46l001erqgj801g0ica","content":"<p>所谓隐式 Intent（意图），即不像显式 Intent 那样明确指定由哪个 Activity 响应，而是告诉系统我们想做什么，由系统匹配可响应该意图的其他程序。</p>\n<a id=\"more\"></a>\n\n<p>在应用中使用隐式 Intent 可调用系统中的其他应用，完成打开网页、发送短信等操作。</p>\n<p>下面通过一个 demo 实践隐式 Intent 的基本用法，涉及的行为有：拨打电话、发送短信、发送邮件、浏览网页。</p>\n<p>首先，在 Activity 的布局文件中添加几个按钮，点击可执行相应的隐式 Intent 。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:padding=&quot;10dp&quot;\n  tools:context=&quot;com.caiyiming.implicititentpractice.MainActivity&quot; &gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonCall&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;拨打电话&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonSMS&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;发送短信&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonEmail&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;发送邮件&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonWeb&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;浏览网页&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>注意，要调用系统拨号功能必须在 AndroidManifest.xml 中声明拨号权限。</p>\n<pre><code class=\"xml\">&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;&gt;&lt;/uses-permission&gt;</code></pre>\n<p>然后，在 Activity 的代码中绑定按钮的点击事件，并添加实现隐式 Intent 的方法。</p>\n<pre><code class=\"java\">public class MainActivity extends ActionBarActivity {\n\n  // 声明按钮\n  private Button mButtonCall;\n  private Button mButtonSMS;\n  private Button mButtonEmail;\n  private Button mButtonWeb;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化按钮\n    mButtonCall = (Button) findViewById(R.id.buttonCall);\n    mButtonSMS = (Button) findViewById(R.id.buttonSMS);\n    mButtonEmail = (Button) findViewById(R.id.buttonEmail);\n    mButtonWeb = (Button) findViewById(R.id.buttonWeb);\n    // 添加点击事件\n    mButtonCall.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentCall(); }\n    });\n    mButtonSMS.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentSMS(); }\n    });\n    mButtonEmail.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentEmail(); }\n    });\n    mButtonWeb.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentWeb(); }\n    });\n  }\n\n  /**\n   * 添加用于拨打电话、发送短信、发送邮件、浏览网页的方法\n   */\n  protected void intentCall() {\n    // 新建意图\n    Intent mIntent = new Intent(Intent.ACTION_CALL);\n    // 设置要拨打的号码\n    Uri mUri = Uri.parse(&quot;tel:10086&quot;);\n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n  protected void intentSMS() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置要发送短信的号码\n    Uri mUri = Uri.parse(&quot;smsto:10086&quot;);\n    mIntent.setData(mUri);\n    mIntent.putExtra(&quot;sms_body&quot;, &quot;余额&quot;); // 消息内容\n    startActivity(mIntent);\n  }\n  protected void intentEmail() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置协议\n    Uri mUri = Uri.parse(&quot;mailto:&quot;);\n    mIntent.setData(mUri);\n    // 设置收件人\n    String[] mEmail = {&quot;example@example.com&quot;, &quot;example@example.com&quot;};\n    // 设置抄送方\n    String[] mCc = {&quot;example@example.com&quot;};\n    // 设置密送方\n    String[] mBcc = {&quot;example@example.com&quot;};\n    // 设置邮件标题\n    String mSubject = &quot;你好&quot;;\n    // 设置邮件内容\n    String mText = &quot;很高兴认识你！&quot;;\n    mIntent.putExtra(Intent.EXTRA_EMAIL, mEmail); \n    mIntent.putExtra(Intent.EXTRA_CC, mCc); \n    mIntent.putExtra(Intent.EXTRA_BCC, mBcc); \n    mIntent.putExtra(Intent.EXTRA_SUBJECT, mSubject); \n    mIntent.putExtra(Intent.EXTRA_TEXT, mText);\n    // 添加附件\n    // mintent.putExtra(Intent.EXTRA_STREAM, Uri.parse(...)); \n    startActivity(mIntent);\n  }\n  protected void intentWeb(){\n    Intent mIntent = new Intent(Intent.ACTION_VIEW);\n    Uri mUri = Uri.parse(&quot;http://www.caiyiming.com&quot;); \n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n\n}</code></pre>\n<p>运行应用程序，点击按钮即可调用其他程序响应意图。</p>\n","site":{"data":{}},"excerpt":"<p>所谓隐式 Intent（意图），即不像显式 Intent 那样明确指定由哪个 Activity 响应，而是告诉系统我们想做什么，由系统匹配可响应该意图的其他程序。</p>","more":"<p>在应用中使用隐式 Intent 可调用系统中的其他应用，完成打开网页、发送短信等操作。</p>\n<p>下面通过一个 demo 实践隐式 Intent 的基本用法，涉及的行为有：拨打电话、发送短信、发送邮件、浏览网页。</p>\n<p>首先，在 Activity 的布局文件中添加几个按钮，点击可执行相应的隐式 Intent 。</p>\n<pre><code class=\"xml\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:padding=&quot;10dp&quot;\n  tools:context=&quot;com.caiyiming.implicititentpractice.MainActivity&quot; &gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonCall&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;拨打电话&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonSMS&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;发送短信&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonEmail&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;发送邮件&quot;/&gt;\n  &lt;Button\n    android:id=&quot;@+id/buttonWeb&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;浏览网页&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>注意，要调用系统拨号功能必须在 AndroidManifest.xml 中声明拨号权限。</p>\n<pre><code class=\"xml\">&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;&gt;&lt;/uses-permission&gt;</code></pre>\n<p>然后，在 Activity 的代码中绑定按钮的点击事件，并添加实现隐式 Intent 的方法。</p>\n<pre><code class=\"java\">public class MainActivity extends ActionBarActivity {\n\n  // 声明按钮\n  private Button mButtonCall;\n  private Button mButtonSMS;\n  private Button mButtonEmail;\n  private Button mButtonWeb;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化按钮\n    mButtonCall = (Button) findViewById(R.id.buttonCall);\n    mButtonSMS = (Button) findViewById(R.id.buttonSMS);\n    mButtonEmail = (Button) findViewById(R.id.buttonEmail);\n    mButtonWeb = (Button) findViewById(R.id.buttonWeb);\n    // 添加点击事件\n    mButtonCall.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentCall(); }\n    });\n    mButtonSMS.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentSMS(); }\n    });\n    mButtonEmail.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentEmail(); }\n    });\n    mButtonWeb.setOnClickListener(new OnClickListener(){\n      @Override\n      public void onClick(View v){ intentWeb(); }\n    });\n  }\n\n  /**\n   * 添加用于拨打电话、发送短信、发送邮件、浏览网页的方法\n   */\n  protected void intentCall() {\n    // 新建意图\n    Intent mIntent = new Intent(Intent.ACTION_CALL);\n    // 设置要拨打的号码\n    Uri mUri = Uri.parse(&quot;tel:10086&quot;);\n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n  protected void intentSMS() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置要发送短信的号码\n    Uri mUri = Uri.parse(&quot;smsto:10086&quot;);\n    mIntent.setData(mUri);\n    mIntent.putExtra(&quot;sms_body&quot;, &quot;余额&quot;); // 消息内容\n    startActivity(mIntent);\n  }\n  protected void intentEmail() {\n    Intent mIntent = new Intent(Intent.ACTION_SENDTO);\n    // 设置协议\n    Uri mUri = Uri.parse(&quot;mailto:&quot;);\n    mIntent.setData(mUri);\n    // 设置收件人\n    String[] mEmail = {&quot;example@example.com&quot;, &quot;example@example.com&quot;};\n    // 设置抄送方\n    String[] mCc = {&quot;example@example.com&quot;};\n    // 设置密送方\n    String[] mBcc = {&quot;example@example.com&quot;};\n    // 设置邮件标题\n    String mSubject = &quot;你好&quot;;\n    // 设置邮件内容\n    String mText = &quot;很高兴认识你！&quot;;\n    mIntent.putExtra(Intent.EXTRA_EMAIL, mEmail); \n    mIntent.putExtra(Intent.EXTRA_CC, mCc); \n    mIntent.putExtra(Intent.EXTRA_BCC, mBcc); \n    mIntent.putExtra(Intent.EXTRA_SUBJECT, mSubject); \n    mIntent.putExtra(Intent.EXTRA_TEXT, mText);\n    // 添加附件\n    // mintent.putExtra(Intent.EXTRA_STREAM, Uri.parse(...)); \n    startActivity(mIntent);\n  }\n  protected void intentWeb(){\n    Intent mIntent = new Intent(Intent.ACTION_VIEW);\n    Uri mUri = Uri.parse(&quot;http://www.caiyiming.com&quot;); \n    mIntent.setData(mUri);\n    startActivity(mIntent);\n  }\n\n}</code></pre>\n<p>运行应用程序，点击按钮即可调用其他程序响应意图。</p>"},{"title":"使用 DatePickerDialog 选择日期","date":"2015-12-15T07:59:22.000Z","_content":"\n新建一个工程并命名为 DatePickerDialogDemo ，使用 LinearLayout 布局。\n\n在布局中分别添加一个 TextView 用于输出选择的日期、一个 Button 用于触发日期选择窗口。\n\n<!-- more -->\n\nMainActivity.xml:\n\n``` xml\nLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:padding=\"15dp\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n  <TextView\n    android:id=\"@+id/textviewText\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"\" />\n  <Button \n    android:id=\"@+id/buttonPickDate\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"选择日期\"/>\n</LinearLayout>\n```\n\n新建一个类，继承自 DialogFragment 并实现 DatePickerDialog 接口。\n\n`onDateSet` 方法在日期选择完成后被执行，它将调用 MainActivity 中的静态方法，更新 TextView 中的内容，把日期显示出来。\n\nUtilSelectDate.java:\n\n``` java\n\npublic class UtilSelectDate extends DialogFragment implements DatePickerDialog.OnDateSetListener {\n\n  // 初始化变量\n  int mYear;\n  int mMonth;\n  int mDay;\n\n  // 初始化日期选择对话框\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState) {\n  // 设置初始日期为本年本月本日\n    final Calendar mCal=Calendar.getInstance();\n    int year = mCal.get(Calendar.YEAR);\n    int month = mCal.get(Calendar.MONTH);\n    int day = mCal.get(Calendar.DAY_OF_MONTH);\n    // 返回日期选择对话框\n    return new DatePickerDialog(getActivity(), this, year, month, day);\n  }\n\n  // 日期选择完成事件\n  @Override\n  public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {\n  mYear = year;\n  mMonth = monthOfYear+1;\n  mDay = dayOfMonth;\n  // 调用 MainActivity 中的方法更新日期\n  MainActivity.updateText(mYear, mMonth, mDay);\n  }\n\n}\n```\n\nMainActivity 继承自 FragmentActivity ，点击按钮后，实例化一个日期选择窗口并显示。\n\n`updateText` 方法在 UtilSelectDate 类的 `onDateSet` 方法中调用，实现日期选择完成后的屏幕输出。\n\nMainActivity.java:\n\n``` java\npublic class MainActivity extends FragmentActivity {\n\n  private Button mPickDate;\n  private static TextView mText;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mText = (TextView) findViewById(R.id.textviewText);\n    mPickDate = (Button) findViewById(R.id.buttonPickDate);\n    // 按钮点击事件\n    mPickDate.setOnClickListener(new OnClickListener(){\n    @Override\n    public void onClick(View arg0) {\n    DialogFragment mFragment=new UtilSelectDate();\n    mFragment.show(MainActivity.this.getSupportFragmentManager(), null);\n    }\n    });\n\n  }\n\n  // 屏幕输出日期\n  static void updateText(int year, int month, int day){\n    mText.setText(String.valueOf(year)+\"年\"+String.valueOf(month)+\"月\"+String.valueOf(day)+\"日\");\n  }\n\n}\n```\n\n需要注意的是，如果是在 Fragment（而不是 FragmentActivity ）中使用，执行`show` 方法的语句需要改为：\n\n``` java\nmFragment.show(getFragmentManager(), null);\n```","source":"_posts/2015-12-15@使用 DatePickerDialog 选择日期.md","raw":"---\ntitle: 使用 DatePickerDialog 选择日期\ncategories:\n  - Android\ndate: 2015-12-15 15:59:22\ntags:\n  - Android\n  - Java\n---\n\n新建一个工程并命名为 DatePickerDialogDemo ，使用 LinearLayout 布局。\n\n在布局中分别添加一个 TextView 用于输出选择的日期、一个 Button 用于触发日期选择窗口。\n\n<!-- more -->\n\nMainActivity.xml:\n\n``` xml\nLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:padding=\"15dp\"\n  tools:context=\"${relativePackage}.${activityClass}\" >\n  <TextView\n    android:id=\"@+id/textviewText\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"\" />\n  <Button \n    android:id=\"@+id/buttonPickDate\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"选择日期\"/>\n</LinearLayout>\n```\n\n新建一个类，继承自 DialogFragment 并实现 DatePickerDialog 接口。\n\n`onDateSet` 方法在日期选择完成后被执行，它将调用 MainActivity 中的静态方法，更新 TextView 中的内容，把日期显示出来。\n\nUtilSelectDate.java:\n\n``` java\n\npublic class UtilSelectDate extends DialogFragment implements DatePickerDialog.OnDateSetListener {\n\n  // 初始化变量\n  int mYear;\n  int mMonth;\n  int mDay;\n\n  // 初始化日期选择对话框\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState) {\n  // 设置初始日期为本年本月本日\n    final Calendar mCal=Calendar.getInstance();\n    int year = mCal.get(Calendar.YEAR);\n    int month = mCal.get(Calendar.MONTH);\n    int day = mCal.get(Calendar.DAY_OF_MONTH);\n    // 返回日期选择对话框\n    return new DatePickerDialog(getActivity(), this, year, month, day);\n  }\n\n  // 日期选择完成事件\n  @Override\n  public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {\n  mYear = year;\n  mMonth = monthOfYear+1;\n  mDay = dayOfMonth;\n  // 调用 MainActivity 中的方法更新日期\n  MainActivity.updateText(mYear, mMonth, mDay);\n  }\n\n}\n```\n\nMainActivity 继承自 FragmentActivity ，点击按钮后，实例化一个日期选择窗口并显示。\n\n`updateText` 方法在 UtilSelectDate 类的 `onDateSet` 方法中调用，实现日期选择完成后的屏幕输出。\n\nMainActivity.java:\n\n``` java\npublic class MainActivity extends FragmentActivity {\n\n  private Button mPickDate;\n  private static TextView mText;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mText = (TextView) findViewById(R.id.textviewText);\n    mPickDate = (Button) findViewById(R.id.buttonPickDate);\n    // 按钮点击事件\n    mPickDate.setOnClickListener(new OnClickListener(){\n    @Override\n    public void onClick(View arg0) {\n    DialogFragment mFragment=new UtilSelectDate();\n    mFragment.show(MainActivity.this.getSupportFragmentManager(), null);\n    }\n    });\n\n  }\n\n  // 屏幕输出日期\n  static void updateText(int year, int month, int day){\n    mText.setText(String.valueOf(year)+\"年\"+String.valueOf(month)+\"月\"+String.valueOf(day)+\"日\");\n  }\n\n}\n```\n\n需要注意的是，如果是在 Fragment（而不是 FragmentActivity ）中使用，执行`show` 方法的语句需要改为：\n\n``` java\nmFragment.show(getFragmentManager(), null);\n```","slug":"2015-12-15@使用 DatePickerDialog 选择日期","published":1,"updated":"2020-06-29T03:32:42.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46n001hrqgjfk1u8uhs","content":"<p>新建一个工程并命名为 DatePickerDialogDemo ，使用 LinearLayout 布局。</p>\n<p>在布局中分别添加一个 TextView 用于输出选择的日期、一个 Button 用于触发日期选择窗口。</p>\n<a id=\"more\"></a>\n\n<p>MainActivity.xml:</p>\n<pre><code class=\"xml\">LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:padding=&quot;15dp&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/textviewText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;&quot; /&gt;\n  &lt;Button \n    android:id=&quot;@+id/buttonPickDate&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;选择日期&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>新建一个类，继承自 DialogFragment 并实现 DatePickerDialog 接口。</p>\n<p><code>onDateSet</code> 方法在日期选择完成后被执行，它将调用 MainActivity 中的静态方法，更新 TextView 中的内容，把日期显示出来。</p>\n<p>UtilSelectDate.java:</p>\n<pre><code class=\"java\">\npublic class UtilSelectDate extends DialogFragment implements DatePickerDialog.OnDateSetListener {\n\n  // 初始化变量\n  int mYear;\n  int mMonth;\n  int mDay;\n\n  // 初始化日期选择对话框\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState) {\n  // 设置初始日期为本年本月本日\n    final Calendar mCal=Calendar.getInstance();\n    int year = mCal.get(Calendar.YEAR);\n    int month = mCal.get(Calendar.MONTH);\n    int day = mCal.get(Calendar.DAY_OF_MONTH);\n    // 返回日期选择对话框\n    return new DatePickerDialog(getActivity(), this, year, month, day);\n  }\n\n  // 日期选择完成事件\n  @Override\n  public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {\n  mYear = year;\n  mMonth = monthOfYear+1;\n  mDay = dayOfMonth;\n  // 调用 MainActivity 中的方法更新日期\n  MainActivity.updateText(mYear, mMonth, mDay);\n  }\n\n}</code></pre>\n<p>MainActivity 继承自 FragmentActivity ，点击按钮后，实例化一个日期选择窗口并显示。</p>\n<p><code>updateText</code> 方法在 UtilSelectDate 类的 <code>onDateSet</code> 方法中调用，实现日期选择完成后的屏幕输出。</p>\n<p>MainActivity.java:</p>\n<pre><code class=\"java\">public class MainActivity extends FragmentActivity {\n\n  private Button mPickDate;\n  private static TextView mText;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mText = (TextView) findViewById(R.id.textviewText);\n    mPickDate = (Button) findViewById(R.id.buttonPickDate);\n    // 按钮点击事件\n    mPickDate.setOnClickListener(new OnClickListener(){\n    @Override\n    public void onClick(View arg0) {\n    DialogFragment mFragment=new UtilSelectDate();\n    mFragment.show(MainActivity.this.getSupportFragmentManager(), null);\n    }\n    });\n\n  }\n\n  // 屏幕输出日期\n  static void updateText(int year, int month, int day){\n    mText.setText(String.valueOf(year)+&quot;年&quot;+String.valueOf(month)+&quot;月&quot;+String.valueOf(day)+&quot;日&quot;);\n  }\n\n}</code></pre>\n<p>需要注意的是，如果是在 Fragment（而不是 FragmentActivity ）中使用，执行<code>show</code> 方法的语句需要改为：</p>\n<pre><code class=\"java\">mFragment.show(getFragmentManager(), null);</code></pre>\n","site":{"data":{}},"excerpt":"<p>新建一个工程并命名为 DatePickerDialogDemo ，使用 LinearLayout 布局。</p>\n<p>在布局中分别添加一个 TextView 用于输出选择的日期、一个 Button 用于触发日期选择窗口。</p>","more":"<p>MainActivity.xml:</p>\n<pre><code class=\"xml\">LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:padding=&quot;15dp&quot;\n  tools:context=&quot;${relativePackage}.${activityClass}&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/textviewText&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;&quot; /&gt;\n  &lt;Button \n    android:id=&quot;@+id/buttonPickDate&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;选择日期&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<p>新建一个类，继承自 DialogFragment 并实现 DatePickerDialog 接口。</p>\n<p><code>onDateSet</code> 方法在日期选择完成后被执行，它将调用 MainActivity 中的静态方法，更新 TextView 中的内容，把日期显示出来。</p>\n<p>UtilSelectDate.java:</p>\n<pre><code class=\"java\">\npublic class UtilSelectDate extends DialogFragment implements DatePickerDialog.OnDateSetListener {\n\n  // 初始化变量\n  int mYear;\n  int mMonth;\n  int mDay;\n\n  // 初始化日期选择对话框\n  @Override\n  public Dialog onCreateDialog(Bundle savedInstanceState) {\n  // 设置初始日期为本年本月本日\n    final Calendar mCal=Calendar.getInstance();\n    int year = mCal.get(Calendar.YEAR);\n    int month = mCal.get(Calendar.MONTH);\n    int day = mCal.get(Calendar.DAY_OF_MONTH);\n    // 返回日期选择对话框\n    return new DatePickerDialog(getActivity(), this, year, month, day);\n  }\n\n  // 日期选择完成事件\n  @Override\n  public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {\n  mYear = year;\n  mMonth = monthOfYear+1;\n  mDay = dayOfMonth;\n  // 调用 MainActivity 中的方法更新日期\n  MainActivity.updateText(mYear, mMonth, mDay);\n  }\n\n}</code></pre>\n<p>MainActivity 继承自 FragmentActivity ，点击按钮后，实例化一个日期选择窗口并显示。</p>\n<p><code>updateText</code> 方法在 UtilSelectDate 类的 <code>onDateSet</code> 方法中调用，实现日期选择完成后的屏幕输出。</p>\n<p>MainActivity.java:</p>\n<pre><code class=\"java\">public class MainActivity extends FragmentActivity {\n\n  private Button mPickDate;\n  private static TextView mText;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    // 实例化控件\n    mText = (TextView) findViewById(R.id.textviewText);\n    mPickDate = (Button) findViewById(R.id.buttonPickDate);\n    // 按钮点击事件\n    mPickDate.setOnClickListener(new OnClickListener(){\n    @Override\n    public void onClick(View arg0) {\n    DialogFragment mFragment=new UtilSelectDate();\n    mFragment.show(MainActivity.this.getSupportFragmentManager(), null);\n    }\n    });\n\n  }\n\n  // 屏幕输出日期\n  static void updateText(int year, int month, int day){\n    mText.setText(String.valueOf(year)+&quot;年&quot;+String.valueOf(month)+&quot;月&quot;+String.valueOf(day)+&quot;日&quot;);\n  }\n\n}</code></pre>\n<p>需要注意的是，如果是在 Fragment（而不是 FragmentActivity ）中使用，执行<code>show</code> 方法的语句需要改为：</p>\n<pre><code class=\"java\">mFragment.show(getFragmentManager(), null);</code></pre>"},{"title":"根据系统版本设置不同的主题","date":"2015-12-15T06:59:01.000Z","_content":"\n通常情况下，Android 应用中的控件样式为系统默认主题中的样式。\n\n为了统一控件样式、使应用整体更协调美观，我们经常会指定应用的主题，比如 Holo 主题。但是 Holo 主题只能支持 Android 3.2（API 13）及以上的系统。为了兼容 Android 3.2 以下机型，有必要让 Android 3.2 及以上、Android 3.2 以下的机型使用不同的主题。\n\n<!-- more -->\n\n以 Holo 主题为例：\n\n在 res 文件夹下新建 values-v13 文件夹，在 values-v13 文件夹下新建 style.xml 文件，内容如下。\n\n``` xml\n<resources>\n    <style name=\"AppBaseTheme\" parent=\"android:Theme.Holo.Light.NoActionBar\"></style>\n</resources>\n```\n修改 value 文件夹下的 style.xml 文件。\n\n``` xml\n<resources>\n    <style name=\"AppBaseTheme\" parent=\"@android:style/Theme.Light.NoTitleBar\"></style>\n</resources>\n```\n\n最后，修改 AndroidManifest.xml ，设置应用的主题为 AppBaseTheme 。\n\n``` xml\n<application\n        ...\n        android:theme=\"@style/AppBaseTheme\" >\n        ...\n</application>\n```\n\n这样，当 API<13 时，应用的主题为 _Theme.Light.NoTitleBar_，当 API>=13 时，应用的主题为 _Theme.Holo.Light.NoActionBar_ 。","source":"_posts/2015-12-15@根据系统版本设置不同的主题.md","raw":"---\ntitle: 根据系统版本设置不同的主题\ncategories:\n  - Android\ndate: 2015-12-15 14:59:01\ntags:\n  - Android\n  - Java\n---\n\n通常情况下，Android 应用中的控件样式为系统默认主题中的样式。\n\n为了统一控件样式、使应用整体更协调美观，我们经常会指定应用的主题，比如 Holo 主题。但是 Holo 主题只能支持 Android 3.2（API 13）及以上的系统。为了兼容 Android 3.2 以下机型，有必要让 Android 3.2 及以上、Android 3.2 以下的机型使用不同的主题。\n\n<!-- more -->\n\n以 Holo 主题为例：\n\n在 res 文件夹下新建 values-v13 文件夹，在 values-v13 文件夹下新建 style.xml 文件，内容如下。\n\n``` xml\n<resources>\n    <style name=\"AppBaseTheme\" parent=\"android:Theme.Holo.Light.NoActionBar\"></style>\n</resources>\n```\n修改 value 文件夹下的 style.xml 文件。\n\n``` xml\n<resources>\n    <style name=\"AppBaseTheme\" parent=\"@android:style/Theme.Light.NoTitleBar\"></style>\n</resources>\n```\n\n最后，修改 AndroidManifest.xml ，设置应用的主题为 AppBaseTheme 。\n\n``` xml\n<application\n        ...\n        android:theme=\"@style/AppBaseTheme\" >\n        ...\n</application>\n```\n\n这样，当 API<13 时，应用的主题为 _Theme.Light.NoTitleBar_，当 API>=13 时，应用的主题为 _Theme.Holo.Light.NoActionBar_ 。","slug":"2015-12-15@根据系统版本设置不同的主题","published":1,"updated":"2020-06-29T03:32:42.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46q001krqgjchlb7o0l","content":"<p>通常情况下，Android 应用中的控件样式为系统默认主题中的样式。</p>\n<p>为了统一控件样式、使应用整体更协调美观，我们经常会指定应用的主题，比如 Holo 主题。但是 Holo 主题只能支持 Android 3.2（API 13）及以上的系统。为了兼容 Android 3.2 以下机型，有必要让 Android 3.2 及以上、Android 3.2 以下的机型使用不同的主题。</p>\n<a id=\"more\"></a>\n\n<p>以 Holo 主题为例：</p>\n<p>在 res 文件夹下新建 values-v13 文件夹，在 values-v13 文件夹下新建 style.xml 文件，内容如下。</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;style name=&quot;AppBaseTheme&quot; parent=&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;&lt;/style&gt;\n&lt;/resources&gt;</code></pre>\n<p>修改 value 文件夹下的 style.xml 文件。</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;style name=&quot;AppBaseTheme&quot; parent=&quot;@android:style/Theme.Light.NoTitleBar&quot;&gt;&lt;/style&gt;\n&lt;/resources&gt;</code></pre>\n<p>最后，修改 AndroidManifest.xml ，设置应用的主题为 AppBaseTheme 。</p>\n<pre><code class=\"xml\">&lt;application\n        ...\n        android:theme=&quot;@style/AppBaseTheme&quot; &gt;\n        ...\n&lt;/application&gt;</code></pre>\n<p>这样，当 API&lt;13 时，应用的主题为 <em>Theme.Light.NoTitleBar_，当 API&gt;=13 时，应用的主题为 _Theme.Holo.Light.NoActionBar</em> 。</p>\n","site":{"data":{}},"excerpt":"<p>通常情况下，Android 应用中的控件样式为系统默认主题中的样式。</p>\n<p>为了统一控件样式、使应用整体更协调美观，我们经常会指定应用的主题，比如 Holo 主题。但是 Holo 主题只能支持 Android 3.2（API 13）及以上的系统。为了兼容 Android 3.2 以下机型，有必要让 Android 3.2 及以上、Android 3.2 以下的机型使用不同的主题。</p>","more":"<p>以 Holo 主题为例：</p>\n<p>在 res 文件夹下新建 values-v13 文件夹，在 values-v13 文件夹下新建 style.xml 文件，内容如下。</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;style name=&quot;AppBaseTheme&quot; parent=&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;&lt;/style&gt;\n&lt;/resources&gt;</code></pre>\n<p>修改 value 文件夹下的 style.xml 文件。</p>\n<pre><code class=\"xml\">&lt;resources&gt;\n    &lt;style name=&quot;AppBaseTheme&quot; parent=&quot;@android:style/Theme.Light.NoTitleBar&quot;&gt;&lt;/style&gt;\n&lt;/resources&gt;</code></pre>\n<p>最后，修改 AndroidManifest.xml ，设置应用的主题为 AppBaseTheme 。</p>\n<pre><code class=\"xml\">&lt;application\n        ...\n        android:theme=&quot;@style/AppBaseTheme&quot; &gt;\n        ...\n&lt;/application&gt;</code></pre>\n<p>这样，当 API&lt;13 时，应用的主题为 <em>Theme.Light.NoTitleBar_，当 API&gt;=13 时，应用的主题为 _Theme.Holo.Light.NoActionBar</em> 。</p>"},{"title":"Android 监听设备的开屏与锁屏事件","date":"2016-01-08T09:23:23.000Z","_content":"\n最近开发的一个小应用需要监听用户设备的开屏和锁屏事件，查了一些资料，发现普遍使用的方法是通过代码方式创建一个 BroadcastReceiver ，并监听 ACTION_SCREEN_ON 和 ACTION_SCREEN_OFF 两个意图。\n\n<!-- more -->\n\n代码如下：\n\n``` java\n/**\n * 实现广播接收者\n */\nprivate final BroadcastReceiver ScreenActionReceiver = new BroadcastReceiver(){\n  @Override\n  public void onReceive(final Context context, final Intent intent) {\n    String action = intent.getAction();\n    if (action.equals(Intent.ACTION_SCREEN_ON)) {\n      // 开屏事件\n      Toast.makeText(context,\"监听到屏幕解锁\", Toast.LENGTH_SHORT).show();\n    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {\n      // 锁屏事件\n      Toast.makeText(context,\"监听到屏幕锁定\", Toast.LENGTH_SHORT).show();\n    }\n  }\n};\n```\n\n``` java\n// 该变量用于判断广播接受者是否已注册\nprivate boolean isRegisterReceiver = false;\n```\n``` java\n/**\n * 注册广播接收者\n */\nprivate void registerScreenActionReceiver(){\n  if (!isRegisterReceiver) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(Intent.ACTION_SCREEN_OFF);\n    filter.addAction(Intent.ACTION_SCREEN_ON);\n    registerReceiver(ScreenActionReceiver, filter);\n    isRegisterReceiver = true;\n  }\n}\n\n/**\n * 取消注册广播接收者\n */\npublic void unregisterScreenActionReceiver(Context context) {\n  if (isRegisterReceiver) {\n    isRegisterReceiver = false;\n    context.unregisterReceiver(ScreenActionReceiver);\n  }\n}\n```\n\n最后在 Activity 或 Service 中调用 `registerScreenActionReceiver` 方法注册广播接受者。","source":"_posts/2016-01-08@Android 监听设备的开屏与锁屏事件.md","raw":"---\ntitle: Android 监听设备的开屏与锁屏事件\ncategories:\n  - Android\ndate: 2016-01-08 17:23:23\ntags:\n  - Android\n  - Java\n---\n\n最近开发的一个小应用需要监听用户设备的开屏和锁屏事件，查了一些资料，发现普遍使用的方法是通过代码方式创建一个 BroadcastReceiver ，并监听 ACTION_SCREEN_ON 和 ACTION_SCREEN_OFF 两个意图。\n\n<!-- more -->\n\n代码如下：\n\n``` java\n/**\n * 实现广播接收者\n */\nprivate final BroadcastReceiver ScreenActionReceiver = new BroadcastReceiver(){\n  @Override\n  public void onReceive(final Context context, final Intent intent) {\n    String action = intent.getAction();\n    if (action.equals(Intent.ACTION_SCREEN_ON)) {\n      // 开屏事件\n      Toast.makeText(context,\"监听到屏幕解锁\", Toast.LENGTH_SHORT).show();\n    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {\n      // 锁屏事件\n      Toast.makeText(context,\"监听到屏幕锁定\", Toast.LENGTH_SHORT).show();\n    }\n  }\n};\n```\n\n``` java\n// 该变量用于判断广播接受者是否已注册\nprivate boolean isRegisterReceiver = false;\n```\n``` java\n/**\n * 注册广播接收者\n */\nprivate void registerScreenActionReceiver(){\n  if (!isRegisterReceiver) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(Intent.ACTION_SCREEN_OFF);\n    filter.addAction(Intent.ACTION_SCREEN_ON);\n    registerReceiver(ScreenActionReceiver, filter);\n    isRegisterReceiver = true;\n  }\n}\n\n/**\n * 取消注册广播接收者\n */\npublic void unregisterScreenActionReceiver(Context context) {\n  if (isRegisterReceiver) {\n    isRegisterReceiver = false;\n    context.unregisterReceiver(ScreenActionReceiver);\n  }\n}\n```\n\n最后在 Activity 或 Service 中调用 `registerScreenActionReceiver` 方法注册广播接受者。","slug":"2016-01-08@Android 监听设备的开屏与锁屏事件","published":1,"updated":"2020-06-29T03:32:42.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46t001nrqgj17b586vp","content":"<p>最近开发的一个小应用需要监听用户设备的开屏和锁屏事件，查了一些资料，发现普遍使用的方法是通过代码方式创建一个 BroadcastReceiver ，并监听 ACTION_SCREEN_ON 和 ACTION_SCREEN_OFF 两个意图。</p>\n<a id=\"more\"></a>\n\n<p>代码如下：</p>\n<pre><code class=\"java\">/**\n * 实现广播接收者\n */\nprivate final BroadcastReceiver ScreenActionReceiver = new BroadcastReceiver(){\n  @Override\n  public void onReceive(final Context context, final Intent intent) {\n    String action = intent.getAction();\n    if (action.equals(Intent.ACTION_SCREEN_ON)) {\n      // 开屏事件\n      Toast.makeText(context,&quot;监听到屏幕解锁&quot;, Toast.LENGTH_SHORT).show();\n    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {\n      // 锁屏事件\n      Toast.makeText(context,&quot;监听到屏幕锁定&quot;, Toast.LENGTH_SHORT).show();\n    }\n  }\n};</code></pre>\n<pre><code class=\"java\">// 该变量用于判断广播接受者是否已注册\nprivate boolean isRegisterReceiver = false;</code></pre>\n<pre><code class=\"java\">/**\n * 注册广播接收者\n */\nprivate void registerScreenActionReceiver(){\n  if (!isRegisterReceiver) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(Intent.ACTION_SCREEN_OFF);\n    filter.addAction(Intent.ACTION_SCREEN_ON);\n    registerReceiver(ScreenActionReceiver, filter);\n    isRegisterReceiver = true;\n  }\n}\n\n/**\n * 取消注册广播接收者\n */\npublic void unregisterScreenActionReceiver(Context context) {\n  if (isRegisterReceiver) {\n    isRegisterReceiver = false;\n    context.unregisterReceiver(ScreenActionReceiver);\n  }\n}</code></pre>\n<p>最后在 Activity 或 Service 中调用 <code>registerScreenActionReceiver</code> 方法注册广播接受者。</p>\n","site":{"data":{}},"excerpt":"<p>最近开发的一个小应用需要监听用户设备的开屏和锁屏事件，查了一些资料，发现普遍使用的方法是通过代码方式创建一个 BroadcastReceiver ，并监听 ACTION_SCREEN_ON 和 ACTION_SCREEN_OFF 两个意图。</p>","more":"<p>代码如下：</p>\n<pre><code class=\"java\">/**\n * 实现广播接收者\n */\nprivate final BroadcastReceiver ScreenActionReceiver = new BroadcastReceiver(){\n  @Override\n  public void onReceive(final Context context, final Intent intent) {\n    String action = intent.getAction();\n    if (action.equals(Intent.ACTION_SCREEN_ON)) {\n      // 开屏事件\n      Toast.makeText(context,&quot;监听到屏幕解锁&quot;, Toast.LENGTH_SHORT).show();\n    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {\n      // 锁屏事件\n      Toast.makeText(context,&quot;监听到屏幕锁定&quot;, Toast.LENGTH_SHORT).show();\n    }\n  }\n};</code></pre>\n<pre><code class=\"java\">// 该变量用于判断广播接受者是否已注册\nprivate boolean isRegisterReceiver = false;</code></pre>\n<pre><code class=\"java\">/**\n * 注册广播接收者\n */\nprivate void registerScreenActionReceiver(){\n  if (!isRegisterReceiver) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(Intent.ACTION_SCREEN_OFF);\n    filter.addAction(Intent.ACTION_SCREEN_ON);\n    registerReceiver(ScreenActionReceiver, filter);\n    isRegisterReceiver = true;\n  }\n}\n\n/**\n * 取消注册广播接收者\n */\npublic void unregisterScreenActionReceiver(Context context) {\n  if (isRegisterReceiver) {\n    isRegisterReceiver = false;\n    context.unregisterReceiver(ScreenActionReceiver);\n  }\n}</code></pre>\n<p>最后在 Activity 或 Service 中调用 <code>registerScreenActionReceiver</code> 方法注册广播接受者。</p>"},{"title":"阻止键盘自动弹出 点击空白处结束输入","date":"2016-01-27T09:19:04.000Z","_content":"\n当一个包含 EditText 的个页面启动时，Android 将自动弹出软键盘引导用户输入内容。这样其实不太友好，有时我们希望用户能先看到整个页面，再决定点击输入框输入内容。\n\n<!-- more -->\n\n当用户输入结束后，按照一般的使用习惯，可能想要通过点击页面上的空白处来结束输入（关闭软键盘），而 Android 并不会默认这样做，需要自己通过代码实现。\n\n那么，如何防止 EditText 自动获取焦点？其实很简单，只需要给 EditText 的任意父控件加入两个属性即可。原理是使父控件获取到焦点，从而截断 EditText 自动获取焦点的动作。\n\n``` xml\n<LinearLayout\n  android:id=\"@+id/linearContentWrapper\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:focusable=\"true\"\n  android:focusableInTouchMode=\"true\">\n\n  <EditText\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n\n</LinearLayout>\n```\n\n如何实现点击空白处结束输入并关闭软键盘？\n\n首先新建一个类，命名为 UtilHideKeyboard ，定义一个 `hide` 方法用于关闭软键盘。\n\n``` java\n\n/**\n * 隐藏软键盘工具类\n */\npublic class UtilHideKeyboard {\n\n\tpublic static void hide(Activity activity) {\n\t\tInputMethodManager inputMethodManager = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);\n\t\tinputMethodManager.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);\n\t}\n\n}\n```\n\n接下来在 Activity 的代码中设置 EditText 的父控件的触摸事件，这个父控件最好是最外层的。当用户触摸空白处（父控件）时，使父控件获取焦点，并调用刚才的 `hide` 方法关闭软键盘。\n\n``` java\nprivate LinearLayout mWrappper;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_login);\n  ......\n\n  //隐藏软键盘\n  mWrappper = (LinearLayout)findViewById(R.id.linearContentWrapper);\n  mWrappper.setOnTouchListener(new View.OnTouchListener() {\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n      if(event.getAction() == MotionEvent.ACTION_DOWN){\n        mWrappper.requestFocus();\n        UtilHideKeyboard.hide(LoginActivity.this);\n      }\n      return false;\n    }\n  });\n\n}\n```\n\n搞定，这才是 EditText 正确的打开方式！","source":"_posts/2016-01-27@阻止键盘自动弹出 点击空白处结束输入.md","raw":"---\ntitle: 阻止键盘自动弹出 点击空白处结束输入\ncategories:\n  - Android\ndate: 2016-01-27 17:19:04\ntags:\n  - Android\n  - Java\n---\n\n当一个包含 EditText 的个页面启动时，Android 将自动弹出软键盘引导用户输入内容。这样其实不太友好，有时我们希望用户能先看到整个页面，再决定点击输入框输入内容。\n\n<!-- more -->\n\n当用户输入结束后，按照一般的使用习惯，可能想要通过点击页面上的空白处来结束输入（关闭软键盘），而 Android 并不会默认这样做，需要自己通过代码实现。\n\n那么，如何防止 EditText 自动获取焦点？其实很简单，只需要给 EditText 的任意父控件加入两个属性即可。原理是使父控件获取到焦点，从而截断 EditText 自动获取焦点的动作。\n\n``` xml\n<LinearLayout\n  android:id=\"@+id/linearContentWrapper\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:orientation=\"vertical\"\n  android:focusable=\"true\"\n  android:focusableInTouchMode=\"true\">\n\n  <EditText\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\" />\n\n</LinearLayout>\n```\n\n如何实现点击空白处结束输入并关闭软键盘？\n\n首先新建一个类，命名为 UtilHideKeyboard ，定义一个 `hide` 方法用于关闭软键盘。\n\n``` java\n\n/**\n * 隐藏软键盘工具类\n */\npublic class UtilHideKeyboard {\n\n\tpublic static void hide(Activity activity) {\n\t\tInputMethodManager inputMethodManager = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);\n\t\tinputMethodManager.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);\n\t}\n\n}\n```\n\n接下来在 Activity 的代码中设置 EditText 的父控件的触摸事件，这个父控件最好是最外层的。当用户触摸空白处（父控件）时，使父控件获取焦点，并调用刚才的 `hide` 方法关闭软键盘。\n\n``` java\nprivate LinearLayout mWrappper;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_login);\n  ......\n\n  //隐藏软键盘\n  mWrappper = (LinearLayout)findViewById(R.id.linearContentWrapper);\n  mWrappper.setOnTouchListener(new View.OnTouchListener() {\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n      if(event.getAction() == MotionEvent.ACTION_DOWN){\n        mWrappper.requestFocus();\n        UtilHideKeyboard.hide(LoginActivity.this);\n      }\n      return false;\n    }\n  });\n\n}\n```\n\n搞定，这才是 EditText 正确的打开方式！","slug":"2016-01-27@阻止键盘自动弹出 点击空白处结束输入","published":1,"updated":"2020-06-29T03:32:42.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46v001qrqgj2pydar8y","content":"<p>当一个包含 EditText 的个页面启动时，Android 将自动弹出软键盘引导用户输入内容。这样其实不太友好，有时我们希望用户能先看到整个页面，再决定点击输入框输入内容。</p>\n<a id=\"more\"></a>\n\n<p>当用户输入结束后，按照一般的使用习惯，可能想要通过点击页面上的空白处来结束输入（关闭软键盘），而 Android 并不会默认这样做，需要自己通过代码实现。</p>\n<p>那么，如何防止 EditText 自动获取焦点？其实很简单，只需要给 EditText 的任意父控件加入两个属性即可。原理是使父控件获取到焦点，从而截断 EditText 自动获取焦点的动作。</p>\n<pre><code class=\"xml\">&lt;LinearLayout\n  android:id=&quot;@+id/linearContentWrapper&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:focusable=&quot;true&quot;\n  android:focusableInTouchMode=&quot;true&quot;&gt;\n\n  &lt;EditText\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/LinearLayout&gt;</code></pre>\n<p>如何实现点击空白处结束输入并关闭软键盘？</p>\n<p>首先新建一个类，命名为 UtilHideKeyboard ，定义一个 <code>hide</code> 方法用于关闭软键盘。</p>\n<pre><code class=\"java\">\n/**\n * 隐藏软键盘工具类\n */\npublic class UtilHideKeyboard {\n\n    public static void hide(Activity activity) {\n        InputMethodManager inputMethodManager = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);\n        inputMethodManager.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);\n    }\n\n}</code></pre>\n<p>接下来在 Activity 的代码中设置 EditText 的父控件的触摸事件，这个父控件最好是最外层的。当用户触摸空白处（父控件）时，使父控件获取焦点，并调用刚才的 <code>hide</code> 方法关闭软键盘。</p>\n<pre><code class=\"java\">private LinearLayout mWrappper;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_login);\n  ......\n\n  //隐藏软键盘\n  mWrappper = (LinearLayout)findViewById(R.id.linearContentWrapper);\n  mWrappper.setOnTouchListener(new View.OnTouchListener() {\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n      if(event.getAction() == MotionEvent.ACTION_DOWN){\n        mWrappper.requestFocus();\n        UtilHideKeyboard.hide(LoginActivity.this);\n      }\n      return false;\n    }\n  });\n\n}</code></pre>\n<p>搞定，这才是 EditText 正确的打开方式！</p>\n","site":{"data":{}},"excerpt":"<p>当一个包含 EditText 的个页面启动时，Android 将自动弹出软键盘引导用户输入内容。这样其实不太友好，有时我们希望用户能先看到整个页面，再决定点击输入框输入内容。</p>","more":"<p>当用户输入结束后，按照一般的使用习惯，可能想要通过点击页面上的空白处来结束输入（关闭软键盘），而 Android 并不会默认这样做，需要自己通过代码实现。</p>\n<p>那么，如何防止 EditText 自动获取焦点？其实很简单，只需要给 EditText 的任意父控件加入两个属性即可。原理是使父控件获取到焦点，从而截断 EditText 自动获取焦点的动作。</p>\n<pre><code class=\"xml\">&lt;LinearLayout\n  android:id=&quot;@+id/linearContentWrapper&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:orientation=&quot;vertical&quot;\n  android:focusable=&quot;true&quot;\n  android:focusableInTouchMode=&quot;true&quot;&gt;\n\n  &lt;EditText\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/LinearLayout&gt;</code></pre>\n<p>如何实现点击空白处结束输入并关闭软键盘？</p>\n<p>首先新建一个类，命名为 UtilHideKeyboard ，定义一个 <code>hide</code> 方法用于关闭软键盘。</p>\n<pre><code class=\"java\">\n/**\n * 隐藏软键盘工具类\n */\npublic class UtilHideKeyboard {\n\n    public static void hide(Activity activity) {\n        InputMethodManager inputMethodManager = (InputMethodManager) activity.getSystemService(Activity.INPUT_METHOD_SERVICE);\n        inputMethodManager.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), 0);\n    }\n\n}</code></pre>\n<p>接下来在 Activity 的代码中设置 EditText 的父控件的触摸事件，这个父控件最好是最外层的。当用户触摸空白处（父控件）时，使父控件获取焦点，并调用刚才的 <code>hide</code> 方法关闭软键盘。</p>\n<pre><code class=\"java\">private LinearLayout mWrappper;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.activity_login);\n  ......\n\n  //隐藏软键盘\n  mWrappper = (LinearLayout)findViewById(R.id.linearContentWrapper);\n  mWrappper.setOnTouchListener(new View.OnTouchListener() {\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n      if(event.getAction() == MotionEvent.ACTION_DOWN){\n        mWrappper.requestFocus();\n        UtilHideKeyboard.hide(LoginActivity.this);\n      }\n      return false;\n    }\n  });\n\n}</code></pre>\n<p>搞定，这才是 EditText 正确的打开方式！</p>"},{"title":"Android 实现导航栏下拉菜单","date":"2016-01-28T11:43:48.000Z","_content":"\n只需两步即可在导航栏实现一个下拉菜单。\n\n首先，在 res\\menu 下创建子菜单的布局文件 menu_child.xml 。\n\n<!-- more -->\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    <item\n        android:id=\"@+id/action_settings\"\n        android:title=\"设置\"\n        android:orderInCategory=\"1\"\n        app:showAsAction=\"never\"/>\n    <item\n        android:id=\"@+id/action_about\"\n        android:title=\"关于\"\n        android:orderInCategory=\"2\"\n        app:showAsAction=\"never\" />\n</menu>\n```\n\n_title_ 属性设置了子菜单显示的文本。_orderInCategory_ 属性设置了排列顺序，数字小的在上、大的在下。_showAsAction_ 属性必须为 never ，否则会被识别成一级菜单。\n\n然后，在 Activity 中覆写两个方法，一个用于实现菜单，另一个用于设置子菜单的点击事件。\n\n``` java\n// 菜单子项的布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n  getMenuInflater().inflate(R.menu.menu_child, menu);\n  return true;\n}\n\n// 菜单子项的点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  int id = item.getItemId();\n  if (id == R.id.action_settings) {\n    Toast.makeText(getBaseContext(), \"点击了设置按钮\", Toast.LENGTH_SHORT).show();\n    return true;\n  } else if (id == R.id.action_about) {\n    Toast.makeText(getBaseContext(), \"点击了关于按钮\", Toast.LENGTH_SHORT).show();\n    return true;\n  }\n  return super.onOptionsItemSelected(item);\n}\n```\n\n\n不需要再做其他事情，Android 会自动在顶栏的最右边增加一个菜单按钮，点击后它将弹出子菜单。\n\n实现效果：\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_1.png 220 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_2.png 220 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_3.png 220 %}\n ","source":"_posts/2016-01-28@Android 实现导航栏下拉菜单.md","raw":"---\ntitle: Android 实现导航栏下拉菜单\ncategories:\n  - Android\ndate: 2016-01-28 19:43:48\ntags:\n  - Android\n  - Java\n---\n\n只需两步即可在导航栏实现一个下拉菜单。\n\n首先，在 res\\menu 下创建子菜单的布局文件 menu_child.xml 。\n\n<!-- more -->\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n    <item\n        android:id=\"@+id/action_settings\"\n        android:title=\"设置\"\n        android:orderInCategory=\"1\"\n        app:showAsAction=\"never\"/>\n    <item\n        android:id=\"@+id/action_about\"\n        android:title=\"关于\"\n        android:orderInCategory=\"2\"\n        app:showAsAction=\"never\" />\n</menu>\n```\n\n_title_ 属性设置了子菜单显示的文本。_orderInCategory_ 属性设置了排列顺序，数字小的在上、大的在下。_showAsAction_ 属性必须为 never ，否则会被识别成一级菜单。\n\n然后，在 Activity 中覆写两个方法，一个用于实现菜单，另一个用于设置子菜单的点击事件。\n\n``` java\n// 菜单子项的布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n  getMenuInflater().inflate(R.menu.menu_child, menu);\n  return true;\n}\n\n// 菜单子项的点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  int id = item.getItemId();\n  if (id == R.id.action_settings) {\n    Toast.makeText(getBaseContext(), \"点击了设置按钮\", Toast.LENGTH_SHORT).show();\n    return true;\n  } else if (id == R.id.action_about) {\n    Toast.makeText(getBaseContext(), \"点击了关于按钮\", Toast.LENGTH_SHORT).show();\n    return true;\n  }\n  return super.onOptionsItemSelected(item);\n}\n```\n\n\n不需要再做其他事情，Android 会自动在顶栏的最右边增加一个菜单按钮，点击后它将弹出子菜单。\n\n实现效果：\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_1.png 220 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_2.png 220 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_popover_3.png 220 %}\n ","slug":"2016-01-28@Android 实现导航栏下拉菜单","published":1,"updated":"2020-06-29T03:32:42.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46w001trqgj9n9o6g9w","content":"<p>只需两步即可在导航栏实现一个下拉菜单。</p>\n<p>首先，在 res\\menu 下创建子菜单的布局文件 menu_child.xml 。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n    &lt;item\n        android:id=&quot;@+id/action_settings&quot;\n        android:title=&quot;设置&quot;\n        android:orderInCategory=&quot;1&quot;\n        app:showAsAction=&quot;never&quot;/&gt;\n    &lt;item\n        android:id=&quot;@+id/action_about&quot;\n        android:title=&quot;关于&quot;\n        android:orderInCategory=&quot;2&quot;\n        app:showAsAction=&quot;never&quot; /&gt;\n&lt;/menu&gt;</code></pre>\n<p><em>title</em> 属性设置了子菜单显示的文本。<em>orderInCategory</em> 属性设置了排列顺序，数字小的在上、大的在下。<em>showAsAction</em> 属性必须为 never ，否则会被识别成一级菜单。</p>\n<p>然后，在 Activity 中覆写两个方法，一个用于实现菜单，另一个用于设置子菜单的点击事件。</p>\n<pre><code class=\"java\">// 菜单子项的布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n  getMenuInflater().inflate(R.menu.menu_child, menu);\n  return true;\n}\n\n// 菜单子项的点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  int id = item.getItemId();\n  if (id == R.id.action_settings) {\n    Toast.makeText(getBaseContext(), &quot;点击了设置按钮&quot;, Toast.LENGTH_SHORT).show();\n    return true;\n  } else if (id == R.id.action_about) {\n    Toast.makeText(getBaseContext(), &quot;点击了关于按钮&quot;, Toast.LENGTH_SHORT).show();\n    return true;\n  }\n  return super.onOptionsItemSelected(item);\n}</code></pre>\n<p>不需要再做其他事情，Android 会自动在顶栏的最右边增加一个菜单按钮，点击后它将弹出子菜单。</p>\n<p>实现效果：</p>\n<img src=\"/images/posts/2016/01/android_toolbar_popover_1.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_popover_2.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_popover_3.png\" class=\"side-by-side\" width=\"220\">\n","site":{"data":{}},"excerpt":"<p>只需两步即可在导航栏实现一个下拉菜单。</p>\n<p>首先，在 res\\menu 下创建子菜单的布局文件 menu_child.xml 。</p>","more":"<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n    &lt;item\n        android:id=&quot;@+id/action_settings&quot;\n        android:title=&quot;设置&quot;\n        android:orderInCategory=&quot;1&quot;\n        app:showAsAction=&quot;never&quot;/&gt;\n    &lt;item\n        android:id=&quot;@+id/action_about&quot;\n        android:title=&quot;关于&quot;\n        android:orderInCategory=&quot;2&quot;\n        app:showAsAction=&quot;never&quot; /&gt;\n&lt;/menu&gt;</code></pre>\n<p><em>title</em> 属性设置了子菜单显示的文本。<em>orderInCategory</em> 属性设置了排列顺序，数字小的在上、大的在下。<em>showAsAction</em> 属性必须为 never ，否则会被识别成一级菜单。</p>\n<p>然后，在 Activity 中覆写两个方法，一个用于实现菜单，另一个用于设置子菜单的点击事件。</p>\n<pre><code class=\"java\">// 菜单子项的布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n  getMenuInflater().inflate(R.menu.menu_child, menu);\n  return true;\n}\n\n// 菜单子项的点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  int id = item.getItemId();\n  if (id == R.id.action_settings) {\n    Toast.makeText(getBaseContext(), &quot;点击了设置按钮&quot;, Toast.LENGTH_SHORT).show();\n    return true;\n  } else if (id == R.id.action_about) {\n    Toast.makeText(getBaseContext(), &quot;点击了关于按钮&quot;, Toast.LENGTH_SHORT).show();\n    return true;\n  }\n  return super.onOptionsItemSelected(item);\n}</code></pre>\n<p>不需要再做其他事情，Android 会自动在顶栏的最右边增加一个菜单按钮，点击后它将弹出子菜单。</p>\n<p>实现效果：</p>\n<img src=\"/images/posts/2016/01/android_toolbar_popover_1.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_popover_2.png\" class=\"side-by-side\" width=\"220\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_popover_3.png\" class=\"side-by-side\" width=\"220\">"},{"title":"使用 ToolBar 实现自定义导航栏","date":"2016-01-28T11:12:26.000Z","_content":"\nToolBar 可以实现导航栏的自定义效果，如在导航上添加返回按钮、菜单按钮等。\n\n以前不会用 Android 默认提供的 ToolBar 或者 ActionBar ，每次都会自己写一个简单的顶栏。这几天尝试了用 ToolBar 实现导航栏。\n\n<!-- more -->\n\n首先，在 Android Studio 中新建一个工程并命名为 ToolBarPractice ，最小 API 设为8。添加 MainActivity 和 SecondActivity 两个空的 Activity ，默认都继承自 AppCompatActivity 。为什么不使用默认已经包含 ToolBar 的 Activity ？因为我想要手动添加 ToolBar 从而理清整个过程。\n\n接下来在 MainActiviy 中添加一个按钮，用于跳转至 SecondActivity 。这部分比较简单，可以略过。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\" \n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\" \n  android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n  android:paddingRight=\"@dimen/activity_horizontal_margin\"\n  android:paddingTop=\"@dimen/activity_vertical_margin\"\n  android:paddingBottom=\"@dimen/activity_vertical_margin\"\n  tools:context=\"com.caiyiming.toolbarpractice.MainActivity\">\n\n  <Button\n    android:id=\"@+id/buttonJump\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"JUMP\"/>\n\n</RelativeLayout>\n```\n\n``` java\npublic class MainActivity extends AppCompatActivity {\n\n  private Button mBtnJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtnJump = (Button)findViewById(R.id.buttonJump);\n    mBtnJump.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Intent intent = new Intent();\n        intent.setClass(MainActivity.this, SecondActivity.class);\n        startActivity(intent);\n      }\n    });\n  }\n\n}\n```\n\n因为准备在 SecondActivity 中使用 ToolBar 顶栏，必须修改它的主题，去除默认顶栏。这里通过在 style 文件中添加一个 AppTheme.NoActionBar 主题来实现，这也是 Android Studio 默认采用的方式。\n\n另外，设置 MainActivity 作为 SecondActivity 的父 Acitivty ，这样在 SecondActivity 中点击返回按钮时才会返回 MainActivity 。\n\n``` xml\n<style name=\"AppTheme.NoActionBar\">\n  <item name=\"windowActionBar\">false</item>\n  <item name=\"windowNoTitle\">true</item>\n</style>\n```\n\n``` xml\n<activity\n  android:name=\".SecondActivity\"\n  android:label=\"SecondActivity\"\n  android:theme=\"@style/AppTheme.NoActionBar\"\n  android:parentActivityName=\".MainActivity\">\n  <meta-data\n    android:name=\"android.support.PARENT_ACTIVITY\"\n    android:value=\"com.caiyiming.toolbarpractice.MainActivity\" />\n</activity>\n```\n\nOK ，接下来在 style 文件中添加两个值，作为导航栏和状态栏的样式。\n\n``` xml\n<style name=\"AppTheme.AppBarOverlay\" parent=\"ThemeOverlay.AppCompat.Dark.ActionBar\" />\n<style name=\"AppTheme.PopupOverlay\" parent=\"ThemeOverlay.AppCompat.Light\" />\n```\n\n修改 SecondActivity 的布局文件，使其包含了一个 ToolBar 控件。\n\n``` xml\n<android.support.design.widget.CoordinatorLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:fitsSystemWindows=\"true\"\n  tools:context=\"com.caiyiming.toolbarpractice.SecondActivity\">\n\n  <android.support.design.widget.AppBarLayout\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"match_parent\"\n    android:theme=\"@style/AppTheme.AppBarOverlay\">\n    <android.support.v7.widget.Toolbar\n      android:id=\"@+id/toolbar\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"?attr/actionBarSize\"\n      android:background=\"?attr/colorPrimary\"\n      app:popupTheme=\"@style/AppTheme.PopupOverlay\" />\n  </android.support.design.widget.AppBarLayout>\n\n  <!--内容-->\n\n</android.support.design.widget.CoordinatorLayout>\n```\n\n接下来，修改 SecondActivity 的代码，实例化 ToolBar 并实现一个返回按钮。\n\n另外，还可以自定义顶栏上的主标题、副标题、Logo、返回按钮图标，修改按钮的点击事件。\n\n``` java\npublic class SecondActivity extends AppCompatActivity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_second);\n\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    // 设置图标\n    toolbar.setLogo(R.mipmap.ic_launcher);\n    // 设置标题\n    toolbar.setTitle(\"Title\");\n    // 设置副标题\n    toolbar.setSubtitle(\"Sub title\");\n    // 设置返回按钮图标\n    toolbar.setNavigationIcon(R.mipmap.ic_chevron_left);\n    setSupportActionBar(toolbar);\n    // 添加默认返回按钮\n    getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n    // 返回按钮的点击事件\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast.makeText(getBaseContext(), \"点击了左侧导航按钮\", Toast.LENGTH_SHORT).show();\n      }\n    }); \n  }\n\n}\n```\n\n接下来继续在顶栏的右侧实现几个菜单按钮。\n\n首先，在 res 文件夹下新建一个菜单布局文件 menu_default.xml ，添加两个选项。\n_title_ 属性用于设置提示，长按图标的情况下将显示这些文字。_orderInCategory_ 属性用于设置排列顺序，数字小的在左、大的在右；_icon_ 属性设置图标。_showAsAction_ 属性设置显示方式，可选择总是显示，或仅当空间足够时显示等。\n\n``` xml\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n  <item\n    android:id=\"@+id/action_next\"\n    android:title=\"create\"\n    android:orderInCategory=\"1\"\n    android:icon=\"@mipmap/ic_create\"\n    app:showAsAction=\"always\" />\n  <item\n    android:id=\"@+id/action_next\"\n    android:title=\"more\"\n    android:orderInCategory=\"2\"\n    android:icon=\"@mipmap/ic_more\"\n    app:showAsAction=\"always\" />\n</menu>\n```\n\n在 SecondActivity.java 中重写两个方法，实现菜单及其按钮的点击事件。\n\n``` java\n// 引用导航菜单布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu){\n  getMenuInflater().inflate(R.menu.menu_default, menu);\n  return true;\n}\n\n// 导航按钮点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  switch(item.getItemId()){\n    case R.id.action_create:\n      Toast.makeText(getBaseContext(), \"点击了Create图标\", Toast.LENGTH_SHORT).show();\n      break;\n    case R.id.action_more:\n      Toast.makeText(getBaseContext(), \"点击了More图标\", Toast.LENGTH_SHORT).show();\n      break;\n    default:\n      break;\n  }\n  return super.onOptionsItemSelected(item);\n}\n```\n\n运行效果：\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_1.png 220 导航栏   %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_2.png 220 长按选项 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_3.png 220 点击选项 %}","source":"_posts/2016-01-28@使用 ToolBar 实现自定义导航栏.md","raw":"---\ntitle: 使用 ToolBar 实现自定义导航栏\ncategories:\n  - Android\ndate: 2016-01-28 19:12:26\ntags:\n  - Android\n  - Java\n---\n\nToolBar 可以实现导航栏的自定义效果，如在导航上添加返回按钮、菜单按钮等。\n\n以前不会用 Android 默认提供的 ToolBar 或者 ActionBar ，每次都会自己写一个简单的顶栏。这几天尝试了用 ToolBar 实现导航栏。\n\n<!-- more -->\n\n首先，在 Android Studio 中新建一个工程并命名为 ToolBarPractice ，最小 API 设为8。添加 MainActivity 和 SecondActivity 两个空的 Activity ，默认都继承自 AppCompatActivity 。为什么不使用默认已经包含 ToolBar 的 Activity ？因为我想要手动添加 ToolBar 从而理清整个过程。\n\n接下来在 MainActiviy 中添加一个按钮，用于跳转至 SecondActivity 。这部分比较简单，可以略过。\n\n``` xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\" \n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\" \n  android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n  android:paddingRight=\"@dimen/activity_horizontal_margin\"\n  android:paddingTop=\"@dimen/activity_vertical_margin\"\n  android:paddingBottom=\"@dimen/activity_vertical_margin\"\n  tools:context=\"com.caiyiming.toolbarpractice.MainActivity\">\n\n  <Button\n    android:id=\"@+id/buttonJump\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"JUMP\"/>\n\n</RelativeLayout>\n```\n\n``` java\npublic class MainActivity extends AppCompatActivity {\n\n  private Button mBtnJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtnJump = (Button)findViewById(R.id.buttonJump);\n    mBtnJump.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Intent intent = new Intent();\n        intent.setClass(MainActivity.this, SecondActivity.class);\n        startActivity(intent);\n      }\n    });\n  }\n\n}\n```\n\n因为准备在 SecondActivity 中使用 ToolBar 顶栏，必须修改它的主题，去除默认顶栏。这里通过在 style 文件中添加一个 AppTheme.NoActionBar 主题来实现，这也是 Android Studio 默认采用的方式。\n\n另外，设置 MainActivity 作为 SecondActivity 的父 Acitivty ，这样在 SecondActivity 中点击返回按钮时才会返回 MainActivity 。\n\n``` xml\n<style name=\"AppTheme.NoActionBar\">\n  <item name=\"windowActionBar\">false</item>\n  <item name=\"windowNoTitle\">true</item>\n</style>\n```\n\n``` xml\n<activity\n  android:name=\".SecondActivity\"\n  android:label=\"SecondActivity\"\n  android:theme=\"@style/AppTheme.NoActionBar\"\n  android:parentActivityName=\".MainActivity\">\n  <meta-data\n    android:name=\"android.support.PARENT_ACTIVITY\"\n    android:value=\"com.caiyiming.toolbarpractice.MainActivity\" />\n</activity>\n```\n\nOK ，接下来在 style 文件中添加两个值，作为导航栏和状态栏的样式。\n\n``` xml\n<style name=\"AppTheme.AppBarOverlay\" parent=\"ThemeOverlay.AppCompat.Dark.ActionBar\" />\n<style name=\"AppTheme.PopupOverlay\" parent=\"ThemeOverlay.AppCompat.Light\" />\n```\n\n修改 SecondActivity 的布局文件，使其包含了一个 ToolBar 控件。\n\n``` xml\n<android.support.design.widget.CoordinatorLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  android:fitsSystemWindows=\"true\"\n  tools:context=\"com.caiyiming.toolbarpractice.SecondActivity\">\n\n  <android.support.design.widget.AppBarLayout\n    android:layout_height=\"wrap_content\"\n    android:layout_width=\"match_parent\"\n    android:theme=\"@style/AppTheme.AppBarOverlay\">\n    <android.support.v7.widget.Toolbar\n      android:id=\"@+id/toolbar\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"?attr/actionBarSize\"\n      android:background=\"?attr/colorPrimary\"\n      app:popupTheme=\"@style/AppTheme.PopupOverlay\" />\n  </android.support.design.widget.AppBarLayout>\n\n  <!--内容-->\n\n</android.support.design.widget.CoordinatorLayout>\n```\n\n接下来，修改 SecondActivity 的代码，实例化 ToolBar 并实现一个返回按钮。\n\n另外，还可以自定义顶栏上的主标题、副标题、Logo、返回按钮图标，修改按钮的点击事件。\n\n``` java\npublic class SecondActivity extends AppCompatActivity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_second);\n\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    // 设置图标\n    toolbar.setLogo(R.mipmap.ic_launcher);\n    // 设置标题\n    toolbar.setTitle(\"Title\");\n    // 设置副标题\n    toolbar.setSubtitle(\"Sub title\");\n    // 设置返回按钮图标\n    toolbar.setNavigationIcon(R.mipmap.ic_chevron_left);\n    setSupportActionBar(toolbar);\n    // 添加默认返回按钮\n    getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n    // 返回按钮的点击事件\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast.makeText(getBaseContext(), \"点击了左侧导航按钮\", Toast.LENGTH_SHORT).show();\n      }\n    }); \n  }\n\n}\n```\n\n接下来继续在顶栏的右侧实现几个菜单按钮。\n\n首先，在 res 文件夹下新建一个菜单布局文件 menu_default.xml ，添加两个选项。\n_title_ 属性用于设置提示，长按图标的情况下将显示这些文字。_orderInCategory_ 属性用于设置排列顺序，数字小的在左、大的在右；_icon_ 属性设置图标。_showAsAction_ 属性设置显示方式，可选择总是显示，或仅当空间足够时显示等。\n\n``` xml\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n  <item\n    android:id=\"@+id/action_next\"\n    android:title=\"create\"\n    android:orderInCategory=\"1\"\n    android:icon=\"@mipmap/ic_create\"\n    app:showAsAction=\"always\" />\n  <item\n    android:id=\"@+id/action_next\"\n    android:title=\"more\"\n    android:orderInCategory=\"2\"\n    android:icon=\"@mipmap/ic_more\"\n    app:showAsAction=\"always\" />\n</menu>\n```\n\n在 SecondActivity.java 中重写两个方法，实现菜单及其按钮的点击事件。\n\n``` java\n// 引用导航菜单布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu){\n  getMenuInflater().inflate(R.menu.menu_default, menu);\n  return true;\n}\n\n// 导航按钮点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  switch(item.getItemId()){\n    case R.id.action_create:\n      Toast.makeText(getBaseContext(), \"点击了Create图标\", Toast.LENGTH_SHORT).show();\n      break;\n    case R.id.action_more:\n      Toast.makeText(getBaseContext(), \"点击了More图标\", Toast.LENGTH_SHORT).show();\n      break;\n    default:\n      break;\n  }\n  return super.onOptionsItemSelected(item);\n}\n```\n\n运行效果：\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_1.png 220 导航栏   %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_2.png 220 长按选项 %}\n\n{% img side-by-side /images/posts/2016/01/android_toolbar_3.png 220 点击选项 %}","slug":"2016-01-28@使用 ToolBar 实现自定义导航栏","published":1,"updated":"2020-06-29T03:32:42.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46x001wrqgj2mcp9521","content":"<p>ToolBar 可以实现导航栏的自定义效果，如在导航上添加返回按钮、菜单按钮等。</p>\n<p>以前不会用 Android 默认提供的 ToolBar 或者 ActionBar ，每次都会自己写一个简单的顶栏。这几天尝试了用 ToolBar 实现导航栏。</p>\n<a id=\"more\"></a>\n\n<p>首先，在 Android Studio 中新建一个工程并命名为 ToolBarPractice ，最小 API 设为8。添加 MainActivity 和 SecondActivity 两个空的 Activity ，默认都继承自 AppCompatActivity 。为什么不使用默认已经包含 ToolBar 的 Activity ？因为我想要手动添加 ToolBar 从而理清整个过程。</p>\n<p>接下来在 MainActiviy 中添加一个按钮，用于跳转至 SecondActivity 。这部分比较简单，可以略过。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot; \n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot; \n  android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n  android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n  tools:context=&quot;com.caiyiming.toolbarpractice.MainActivity&quot;&gt;\n\n  &lt;Button\n    android:id=&quot;@+id/buttonJump&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;JUMP&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<pre><code class=\"java\">public class MainActivity extends AppCompatActivity {\n\n  private Button mBtnJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtnJump = (Button)findViewById(R.id.buttonJump);\n    mBtnJump.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Intent intent = new Intent();\n        intent.setClass(MainActivity.this, SecondActivity.class);\n        startActivity(intent);\n      }\n    });\n  }\n\n}</code></pre>\n<p>因为准备在 SecondActivity 中使用 ToolBar 顶栏，必须修改它的主题，去除默认顶栏。这里通过在 style 文件中添加一个 AppTheme.NoActionBar 主题来实现，这也是 Android Studio 默认采用的方式。</p>\n<p>另外，设置 MainActivity 作为 SecondActivity 的父 Acitivty ，这样在 SecondActivity 中点击返回按钮时才会返回 MainActivity 。</p>\n<pre><code class=\"xml\">&lt;style name=&quot;AppTheme.NoActionBar&quot;&gt;\n  &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;\n  &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;\n&lt;/style&gt;</code></pre>\n<pre><code class=\"xml\">&lt;activity\n  android:name=&quot;.SecondActivity&quot;\n  android:label=&quot;SecondActivity&quot;\n  android:theme=&quot;@style/AppTheme.NoActionBar&quot;\n  android:parentActivityName=&quot;.MainActivity&quot;&gt;\n  &lt;meta-data\n    android:name=&quot;android.support.PARENT_ACTIVITY&quot;\n    android:value=&quot;com.caiyiming.toolbarpractice.MainActivity&quot; /&gt;\n&lt;/activity&gt;</code></pre>\n<p>OK ，接下来在 style 文件中添加两个值，作为导航栏和状态栏的样式。</p>\n<pre><code class=\"xml\">&lt;style name=&quot;AppTheme.AppBarOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot; /&gt;\n&lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot; /&gt;</code></pre>\n<p>修改 SecondActivity 的布局文件，使其包含了一个 ToolBar 控件。</p>\n<pre><code class=\"xml\">&lt;android.support.design.widget.CoordinatorLayout\n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:fitsSystemWindows=&quot;true&quot;\n  tools:context=&quot;com.caiyiming.toolbarpractice.SecondActivity&quot;&gt;\n\n  &lt;android.support.design.widget.AppBarLayout\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;\n    &lt;android.support.v7.widget.Toolbar\n      android:id=&quot;@+id/toolbar&quot;\n      android:layout_width=&quot;match_parent&quot;\n      android:layout_height=&quot;?attr/actionBarSize&quot;\n      android:background=&quot;?attr/colorPrimary&quot;\n      app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt;\n  &lt;/android.support.design.widget.AppBarLayout&gt;\n\n  &lt;!--内容--&gt;\n\n&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre>\n<p>接下来，修改 SecondActivity 的代码，实例化 ToolBar 并实现一个返回按钮。</p>\n<p>另外，还可以自定义顶栏上的主标题、副标题、Logo、返回按钮图标，修改按钮的点击事件。</p>\n<pre><code class=\"java\">public class SecondActivity extends AppCompatActivity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_second);\n\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    // 设置图标\n    toolbar.setLogo(R.mipmap.ic_launcher);\n    // 设置标题\n    toolbar.setTitle(&quot;Title&quot;);\n    // 设置副标题\n    toolbar.setSubtitle(&quot;Sub title&quot;);\n    // 设置返回按钮图标\n    toolbar.setNavigationIcon(R.mipmap.ic_chevron_left);\n    setSupportActionBar(toolbar);\n    // 添加默认返回按钮\n    getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n    // 返回按钮的点击事件\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast.makeText(getBaseContext(), &quot;点击了左侧导航按钮&quot;, Toast.LENGTH_SHORT).show();\n      }\n    }); \n  }\n\n}</code></pre>\n<p>接下来继续在顶栏的右侧实现几个菜单按钮。</p>\n<p>首先，在 res 文件夹下新建一个菜单布局文件 menu_default.xml ，添加两个选项。<br><em>title</em> 属性用于设置提示，长按图标的情况下将显示这些文字。<em>orderInCategory</em> 属性用于设置排列顺序，数字小的在左、大的在右；<em>icon</em> 属性设置图标。<em>showAsAction</em> 属性设置显示方式，可选择总是显示，或仅当空间足够时显示等。</p>\n<pre><code class=\"xml\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n  &lt;item\n    android:id=&quot;@+id/action_next&quot;\n    android:title=&quot;create&quot;\n    android:orderInCategory=&quot;1&quot;\n    android:icon=&quot;@mipmap/ic_create&quot;\n    app:showAsAction=&quot;always&quot; /&gt;\n  &lt;item\n    android:id=&quot;@+id/action_next&quot;\n    android:title=&quot;more&quot;\n    android:orderInCategory=&quot;2&quot;\n    android:icon=&quot;@mipmap/ic_more&quot;\n    app:showAsAction=&quot;always&quot; /&gt;\n&lt;/menu&gt;</code></pre>\n<p>在 SecondActivity.java 中重写两个方法，实现菜单及其按钮的点击事件。</p>\n<pre><code class=\"java\">// 引用导航菜单布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu){\n  getMenuInflater().inflate(R.menu.menu_default, menu);\n  return true;\n}\n\n// 导航按钮点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  switch(item.getItemId()){\n    case R.id.action_create:\n      Toast.makeText(getBaseContext(), &quot;点击了Create图标&quot;, Toast.LENGTH_SHORT).show();\n      break;\n    case R.id.action_more:\n      Toast.makeText(getBaseContext(), &quot;点击了More图标&quot;, Toast.LENGTH_SHORT).show();\n      break;\n    default:\n      break;\n  }\n  return super.onOptionsItemSelected(item);\n}</code></pre>\n<p>运行效果：</p>\n<img src=\"/images/posts/2016/01/android_toolbar_1.png\" class=\"side-by-side\" width=\"220\" title=\"导航栏\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_2.png\" class=\"side-by-side\" width=\"220\" title=\"长按选项\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_3.png\" class=\"side-by-side\" width=\"220\" title=\"点击选项\">","site":{"data":{}},"excerpt":"<p>ToolBar 可以实现导航栏的自定义效果，如在导航上添加返回按钮、菜单按钮等。</p>\n<p>以前不会用 Android 默认提供的 ToolBar 或者 ActionBar ，每次都会自己写一个简单的顶栏。这几天尝试了用 ToolBar 实现导航栏。</p>","more":"<p>首先，在 Android Studio 中新建一个工程并命名为 ToolBarPractice ，最小 API 设为8。添加 MainActivity 和 SecondActivity 两个空的 Activity ，默认都继承自 AppCompatActivity 。为什么不使用默认已经包含 ToolBar 的 Activity ？因为我想要手动添加 ToolBar 从而理清整个过程。</p>\n<p>接下来在 MainActiviy 中添加一个按钮，用于跳转至 SecondActivity 。这部分比较简单，可以略过。</p>\n<pre><code class=\"xml\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot; \n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot; \n  android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;\n  android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;\n  android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;\n  tools:context=&quot;com.caiyiming.toolbarpractice.MainActivity&quot;&gt;\n\n  &lt;Button\n    android:id=&quot;@+id/buttonJump&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:text=&quot;JUMP&quot;/&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<pre><code class=\"java\">public class MainActivity extends AppCompatActivity {\n\n  private Button mBtnJump;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mBtnJump = (Button)findViewById(R.id.buttonJump);\n    mBtnJump.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Intent intent = new Intent();\n        intent.setClass(MainActivity.this, SecondActivity.class);\n        startActivity(intent);\n      }\n    });\n  }\n\n}</code></pre>\n<p>因为准备在 SecondActivity 中使用 ToolBar 顶栏，必须修改它的主题，去除默认顶栏。这里通过在 style 文件中添加一个 AppTheme.NoActionBar 主题来实现，这也是 Android Studio 默认采用的方式。</p>\n<p>另外，设置 MainActivity 作为 SecondActivity 的父 Acitivty ，这样在 SecondActivity 中点击返回按钮时才会返回 MainActivity 。</p>\n<pre><code class=\"xml\">&lt;style name=&quot;AppTheme.NoActionBar&quot;&gt;\n  &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;\n  &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;\n&lt;/style&gt;</code></pre>\n<pre><code class=\"xml\">&lt;activity\n  android:name=&quot;.SecondActivity&quot;\n  android:label=&quot;SecondActivity&quot;\n  android:theme=&quot;@style/AppTheme.NoActionBar&quot;\n  android:parentActivityName=&quot;.MainActivity&quot;&gt;\n  &lt;meta-data\n    android:name=&quot;android.support.PARENT_ACTIVITY&quot;\n    android:value=&quot;com.caiyiming.toolbarpractice.MainActivity&quot; /&gt;\n&lt;/activity&gt;</code></pre>\n<p>OK ，接下来在 style 文件中添加两个值，作为导航栏和状态栏的样式。</p>\n<pre><code class=\"xml\">&lt;style name=&quot;AppTheme.AppBarOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot; /&gt;\n&lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot; /&gt;</code></pre>\n<p>修改 SecondActivity 的布局文件，使其包含了一个 ToolBar 控件。</p>\n<pre><code class=\"xml\">&lt;android.support.design.widget.CoordinatorLayout\n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n  xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n  android:layout_width=&quot;match_parent&quot;\n  android:layout_height=&quot;match_parent&quot;\n  android:fitsSystemWindows=&quot;true&quot;\n  tools:context=&quot;com.caiyiming.toolbarpractice.SecondActivity&quot;&gt;\n\n  &lt;android.support.design.widget.AppBarLayout\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;\n    &lt;android.support.v7.widget.Toolbar\n      android:id=&quot;@+id/toolbar&quot;\n      android:layout_width=&quot;match_parent&quot;\n      android:layout_height=&quot;?attr/actionBarSize&quot;\n      android:background=&quot;?attr/colorPrimary&quot;\n      app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt;\n  &lt;/android.support.design.widget.AppBarLayout&gt;\n\n  &lt;!--内容--&gt;\n\n&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre>\n<p>接下来，修改 SecondActivity 的代码，实例化 ToolBar 并实现一个返回按钮。</p>\n<p>另外，还可以自定义顶栏上的主标题、副标题、Logo、返回按钮图标，修改按钮的点击事件。</p>\n<pre><code class=\"java\">public class SecondActivity extends AppCompatActivity {\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_second);\n\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    // 设置图标\n    toolbar.setLogo(R.mipmap.ic_launcher);\n    // 设置标题\n    toolbar.setTitle(&quot;Title&quot;);\n    // 设置副标题\n    toolbar.setSubtitle(&quot;Sub title&quot;);\n    // 设置返回按钮图标\n    toolbar.setNavigationIcon(R.mipmap.ic_chevron_left);\n    setSupportActionBar(toolbar);\n    // 添加默认返回按钮\n    getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n    // 返回按钮的点击事件\n    toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Toast.makeText(getBaseContext(), &quot;点击了左侧导航按钮&quot;, Toast.LENGTH_SHORT).show();\n      }\n    }); \n  }\n\n}</code></pre>\n<p>接下来继续在顶栏的右侧实现几个菜单按钮。</p>\n<p>首先，在 res 文件夹下新建一个菜单布局文件 menu_default.xml ，添加两个选项。<br><em>title</em> 属性用于设置提示，长按图标的情况下将显示这些文字。<em>orderInCategory</em> 属性用于设置排列顺序，数字小的在左、大的在右；<em>icon</em> 属性设置图标。<em>showAsAction</em> 属性设置显示方式，可选择总是显示，或仅当空间足够时显示等。</p>\n<pre><code class=\"xml\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n  &lt;item\n    android:id=&quot;@+id/action_next&quot;\n    android:title=&quot;create&quot;\n    android:orderInCategory=&quot;1&quot;\n    android:icon=&quot;@mipmap/ic_create&quot;\n    app:showAsAction=&quot;always&quot; /&gt;\n  &lt;item\n    android:id=&quot;@+id/action_next&quot;\n    android:title=&quot;more&quot;\n    android:orderInCategory=&quot;2&quot;\n    android:icon=&quot;@mipmap/ic_more&quot;\n    app:showAsAction=&quot;always&quot; /&gt;\n&lt;/menu&gt;</code></pre>\n<p>在 SecondActivity.java 中重写两个方法，实现菜单及其按钮的点击事件。</p>\n<pre><code class=\"java\">// 引用导航菜单布局\n@Override\npublic boolean onCreateOptionsMenu(Menu menu){\n  getMenuInflater().inflate(R.menu.menu_default, menu);\n  return true;\n}\n\n// 导航按钮点击事件\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n  switch(item.getItemId()){\n    case R.id.action_create:\n      Toast.makeText(getBaseContext(), &quot;点击了Create图标&quot;, Toast.LENGTH_SHORT).show();\n      break;\n    case R.id.action_more:\n      Toast.makeText(getBaseContext(), &quot;点击了More图标&quot;, Toast.LENGTH_SHORT).show();\n      break;\n    default:\n      break;\n  }\n  return super.onOptionsItemSelected(item);\n}</code></pre>\n<p>运行效果：</p>\n<img src=\"/images/posts/2016/01/android_toolbar_1.png\" class=\"side-by-side\" width=\"220\" title=\"导航栏\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_2.png\" class=\"side-by-side\" width=\"220\" title=\"长按选项\">\n\n<img src=\"/images/posts/2016/01/android_toolbar_3.png\" class=\"side-by-side\" width=\"220\" title=\"点击选项\">"},{"title":"Android 客户端发送 GET 请求","date":"2016-01-29T14:10:47.000Z","_content":"\n最近在开发涉及服务端的工程，预感到将会频繁使用客户端向服务端发送 GET 请求、服务端向客户端返回内容。\n\n于是 review 了以前写的一个雏形天气应用，重新理顺了使用方法，在此总结以备后用。\n\n<!-- more -->\n\n服务端我用的是 php ，功能无非是查询数据库和屏幕输出字符串，不再赘述。这里主要讲讲客户端的代码。\n\n交互顺序大致是：客户端请求 http 链接，一般是带参数的 GET 链接。服务端做出反应，并屏幕输出内容（如登录是否成功），待客户端读取。客户端读取返回内容，并做出相应动作，如显示一个密码错误的提示。\n\n这里客户端向服务端传递了2个参数，获取到服务端屏幕输出的信息，并通过 Handler 将信息发送给主线程。\n\n``` java\n// 获取要发送的参数\nfinal String email = mEditEmail.getText().toString();\nfinal String password = mEditPassword.getText().toString();\n// 创建一个新线程\nThread thread = new Thread(){\n  @Override\n  public void run(){\n    String link = \"http://www.caiyiming.com/example.php?email=\" + email + \"&password=\" + password; //要请求的链接\n      try{\n      // 发送 http 请求\n      URL url = new URL(link);\n      HttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect(); \n      // 读取返回的内容\n      InputStream in = conn.getInputStream();\n      BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n      String info = reader.readLine();\n      // 发送消息给主线程\n      Message msg = Message.obtain();\n      msg.obj = info;\n      msg.what = 0;\n      handler.sendMessage(msg);\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n};\nthread.start();\n```\n\n假设服务端收到参数后，在数据库内比对了邮箱和密码，并屏幕输出了 _success_ 或 _failure_ 来向客户端反馈校验是否成功。子线程读取到信息后通过 Handler 的 `sendMessage` 向主线程发送消息。\n\n接下来我们需要在主线程中写一个 Handler ，用于接收子线程传递过来的 _success_ 或 _failure_ ，并在用户界面上显示简短提示。\n\n``` java\n// 处理返回的内容\nHandler handler = new Handler(){\n  @Override\n  public void handleMessage(Message msg){\n  super.handleMessage(msg);\n  String info = (String)msg.obj;\n  if( info.equals(\"success\") ){\n    Toast.makeText(getBaseContext(), \"校验成功\"), Toast.LENGTH_SHORT).show();\n  } else( info.equals(\"failure\") ){\n    Toast.makeText(getBaseContext(), \"校验失败\"), Toast.LENGTH_SHORT).show();\n  }\n  }\n};\n```\n\n为什么我们不在子线程中直接显示提示呢？因为 UI 的变化只能由主线程来执行，在子线程中改变界面会导致程序崩溃。这一点我也是在经历过多次崩溃的教训后才终于理解了。\n\n在这个例子中我只让服务端输出了简短的字符串，实际使用时也可以采用 JSON 格式输出大量信息，可参考 JSON 的解析方法实现。","source":"_posts/2016-01-29@Android 客户端发送 GET 请求.md","raw":"---\ntitle: Android 客户端发送 GET 请求\ncategories:\n  - Android\ndate: 2016-01-29 22:10:47\ntags:\n  - Android\n  - Java\n---\n\n最近在开发涉及服务端的工程，预感到将会频繁使用客户端向服务端发送 GET 请求、服务端向客户端返回内容。\n\n于是 review 了以前写的一个雏形天气应用，重新理顺了使用方法，在此总结以备后用。\n\n<!-- more -->\n\n服务端我用的是 php ，功能无非是查询数据库和屏幕输出字符串，不再赘述。这里主要讲讲客户端的代码。\n\n交互顺序大致是：客户端请求 http 链接，一般是带参数的 GET 链接。服务端做出反应，并屏幕输出内容（如登录是否成功），待客户端读取。客户端读取返回内容，并做出相应动作，如显示一个密码错误的提示。\n\n这里客户端向服务端传递了2个参数，获取到服务端屏幕输出的信息，并通过 Handler 将信息发送给主线程。\n\n``` java\n// 获取要发送的参数\nfinal String email = mEditEmail.getText().toString();\nfinal String password = mEditPassword.getText().toString();\n// 创建一个新线程\nThread thread = new Thread(){\n  @Override\n  public void run(){\n    String link = \"http://www.caiyiming.com/example.php?email=\" + email + \"&password=\" + password; //要请求的链接\n      try{\n      // 发送 http 请求\n      URL url = new URL(link);\n      HttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect(); \n      // 读取返回的内容\n      InputStream in = conn.getInputStream();\n      BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n      String info = reader.readLine();\n      // 发送消息给主线程\n      Message msg = Message.obtain();\n      msg.obj = info;\n      msg.what = 0;\n      handler.sendMessage(msg);\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n};\nthread.start();\n```\n\n假设服务端收到参数后，在数据库内比对了邮箱和密码，并屏幕输出了 _success_ 或 _failure_ 来向客户端反馈校验是否成功。子线程读取到信息后通过 Handler 的 `sendMessage` 向主线程发送消息。\n\n接下来我们需要在主线程中写一个 Handler ，用于接收子线程传递过来的 _success_ 或 _failure_ ，并在用户界面上显示简短提示。\n\n``` java\n// 处理返回的内容\nHandler handler = new Handler(){\n  @Override\n  public void handleMessage(Message msg){\n  super.handleMessage(msg);\n  String info = (String)msg.obj;\n  if( info.equals(\"success\") ){\n    Toast.makeText(getBaseContext(), \"校验成功\"), Toast.LENGTH_SHORT).show();\n  } else( info.equals(\"failure\") ){\n    Toast.makeText(getBaseContext(), \"校验失败\"), Toast.LENGTH_SHORT).show();\n  }\n  }\n};\n```\n\n为什么我们不在子线程中直接显示提示呢？因为 UI 的变化只能由主线程来执行，在子线程中改变界面会导致程序崩溃。这一点我也是在经历过多次崩溃的教训后才终于理解了。\n\n在这个例子中我只让服务端输出了简短的字符串，实际使用时也可以采用 JSON 格式输出大量信息，可参考 JSON 的解析方法实现。","slug":"2016-01-29@Android 客户端发送 GET 请求","published":1,"updated":"2020-06-29T03:32:42.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46y001zrqgj1iyodxfu","content":"<p>最近在开发涉及服务端的工程，预感到将会频繁使用客户端向服务端发送 GET 请求、服务端向客户端返回内容。</p>\n<p>于是 review 了以前写的一个雏形天气应用，重新理顺了使用方法，在此总结以备后用。</p>\n<a id=\"more\"></a>\n\n<p>服务端我用的是 php ，功能无非是查询数据库和屏幕输出字符串，不再赘述。这里主要讲讲客户端的代码。</p>\n<p>交互顺序大致是：客户端请求 http 链接，一般是带参数的 GET 链接。服务端做出反应，并屏幕输出内容（如登录是否成功），待客户端读取。客户端读取返回内容，并做出相应动作，如显示一个密码错误的提示。</p>\n<p>这里客户端向服务端传递了2个参数，获取到服务端屏幕输出的信息，并通过 Handler 将信息发送给主线程。</p>\n<pre><code class=\"java\">// 获取要发送的参数\nfinal String email = mEditEmail.getText().toString();\nfinal String password = mEditPassword.getText().toString();\n// 创建一个新线程\nThread thread = new Thread(){\n  @Override\n  public void run(){\n    String link = &quot;http://www.caiyiming.com/example.php?email=&quot; + email + &quot;&amp;password=&quot; + password; //要请求的链接\n      try{\n      // 发送 http 请求\n      URL url = new URL(link);\n      HttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect(); \n      // 读取返回的内容\n      InputStream in = conn.getInputStream();\n      BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n      String info = reader.readLine();\n      // 发送消息给主线程\n      Message msg = Message.obtain();\n      msg.obj = info;\n      msg.what = 0;\n      handler.sendMessage(msg);\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n};\nthread.start();</code></pre>\n<p>假设服务端收到参数后，在数据库内比对了邮箱和密码，并屏幕输出了 <em>success</em> 或 <em>failure</em> 来向客户端反馈校验是否成功。子线程读取到信息后通过 Handler 的 <code>sendMessage</code> 向主线程发送消息。</p>\n<p>接下来我们需要在主线程中写一个 Handler ，用于接收子线程传递过来的 <em>success</em> 或 <em>failure</em> ，并在用户界面上显示简短提示。</p>\n<pre><code class=\"java\">// 处理返回的内容\nHandler handler = new Handler(){\n  @Override\n  public void handleMessage(Message msg){\n  super.handleMessage(msg);\n  String info = (String)msg.obj;\n  if( info.equals(&quot;success&quot;) ){\n    Toast.makeText(getBaseContext(), &quot;校验成功&quot;), Toast.LENGTH_SHORT).show();\n  } else( info.equals(&quot;failure&quot;) ){\n    Toast.makeText(getBaseContext(), &quot;校验失败&quot;), Toast.LENGTH_SHORT).show();\n  }\n  }\n};</code></pre>\n<p>为什么我们不在子线程中直接显示提示呢？因为 UI 的变化只能由主线程来执行，在子线程中改变界面会导致程序崩溃。这一点我也是在经历过多次崩溃的教训后才终于理解了。</p>\n<p>在这个例子中我只让服务端输出了简短的字符串，实际使用时也可以采用 JSON 格式输出大量信息，可参考 JSON 的解析方法实现。</p>\n","site":{"data":{}},"excerpt":"<p>最近在开发涉及服务端的工程，预感到将会频繁使用客户端向服务端发送 GET 请求、服务端向客户端返回内容。</p>\n<p>于是 review 了以前写的一个雏形天气应用，重新理顺了使用方法，在此总结以备后用。</p>","more":"<p>服务端我用的是 php ，功能无非是查询数据库和屏幕输出字符串，不再赘述。这里主要讲讲客户端的代码。</p>\n<p>交互顺序大致是：客户端请求 http 链接，一般是带参数的 GET 链接。服务端做出反应，并屏幕输出内容（如登录是否成功），待客户端读取。客户端读取返回内容，并做出相应动作，如显示一个密码错误的提示。</p>\n<p>这里客户端向服务端传递了2个参数，获取到服务端屏幕输出的信息，并通过 Handler 将信息发送给主线程。</p>\n<pre><code class=\"java\">// 获取要发送的参数\nfinal String email = mEditEmail.getText().toString();\nfinal String password = mEditPassword.getText().toString();\n// 创建一个新线程\nThread thread = new Thread(){\n  @Override\n  public void run(){\n    String link = &quot;http://www.caiyiming.com/example.php?email=&quot; + email + &quot;&amp;password=&quot; + password; //要请求的链接\n      try{\n      // 发送 http 请求\n      URL url = new URL(link);\n      HttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect(); \n      // 读取返回的内容\n      InputStream in = conn.getInputStream();\n      BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n      String info = reader.readLine();\n      // 发送消息给主线程\n      Message msg = Message.obtain();\n      msg.obj = info;\n      msg.what = 0;\n      handler.sendMessage(msg);\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n};\nthread.start();</code></pre>\n<p>假设服务端收到参数后，在数据库内比对了邮箱和密码，并屏幕输出了 <em>success</em> 或 <em>failure</em> 来向客户端反馈校验是否成功。子线程读取到信息后通过 Handler 的 <code>sendMessage</code> 向主线程发送消息。</p>\n<p>接下来我们需要在主线程中写一个 Handler ，用于接收子线程传递过来的 <em>success</em> 或 <em>failure</em> ，并在用户界面上显示简短提示。</p>\n<pre><code class=\"java\">// 处理返回的内容\nHandler handler = new Handler(){\n  @Override\n  public void handleMessage(Message msg){\n  super.handleMessage(msg);\n  String info = (String)msg.obj;\n  if( info.equals(&quot;success&quot;) ){\n    Toast.makeText(getBaseContext(), &quot;校验成功&quot;), Toast.LENGTH_SHORT).show();\n  } else( info.equals(&quot;failure&quot;) ){\n    Toast.makeText(getBaseContext(), &quot;校验失败&quot;), Toast.LENGTH_SHORT).show();\n  }\n  }\n};</code></pre>\n<p>为什么我们不在子线程中直接显示提示呢？因为 UI 的变化只能由主线程来执行，在子线程中改变界面会导致程序崩溃。这一点我也是在经历过多次崩溃的教训后才终于理解了。</p>\n<p>在这个例子中我只让服务端输出了简短的字符串，实际使用时也可以采用 JSON 格式输出大量信息，可参考 JSON 的解析方法实现。</p>"},{"title":"Android 与服务端的 Session 保持","date":"2016-01-31T12:07:54.000Z","_content":"\n在开发联网应用的过程中，有时候会希望 php 服务端能通过 Session 保存一些信息，以便随时验证客户端的登录状态，或完成其它功能。但实际操作中发现，Android 客户端每次请求服务端都被视为一个新的请求，SessionID 都会改变，也就是说根本没办法使用 Session 存储和读取信息。\n\n<!-- more -->\n\n我们可以通过保存 SessionID 、请求服务端的同时传递 SessionID 来解决这个问题，让服务器知道两次请求来自同一个客户端。\n\n发送请求并保存 SessionID ：\n\n``` java\nURL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect();\n// 获得 SessionID\nString cookieval = conn.getHeaderField(\"set-cookie\");\nString sessionid;\nif(cookieval != null) {\n  sessionid = cookieval.substring(0, cookieval.indexOf(\";\"));\n}\n```\n\n可以将 SesshinID 通过全局变量或者 SQLite 数据库保存下来，方便以后请求时调用。\n\n请求链接的同时发送 SessionID ：\n\n``` java\nURL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection();\nconn.setRequestProperty(\"cookie\", UtilGlobalVariable.sessionId);\nconn.connect();\n```","source":"_posts/2016-01-31@Android 与服务端的 Session 保持.md","raw":"---\ntitle: Android 与服务端的 Session 保持\ncategories:\n  - Android\ndate: 2016-01-31 20:07:54\ntags:\n  - Android\n  - Java\n  - PHP\n  - Session\n---\n\n在开发联网应用的过程中，有时候会希望 php 服务端能通过 Session 保存一些信息，以便随时验证客户端的登录状态，或完成其它功能。但实际操作中发现，Android 客户端每次请求服务端都被视为一个新的请求，SessionID 都会改变，也就是说根本没办法使用 Session 存储和读取信息。\n\n<!-- more -->\n\n我们可以通过保存 SessionID 、请求服务端的同时传递 SessionID 来解决这个问题，让服务器知道两次请求来自同一个客户端。\n\n发送请求并保存 SessionID ：\n\n``` java\nURL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect();\n// 获得 SessionID\nString cookieval = conn.getHeaderField(\"set-cookie\");\nString sessionid;\nif(cookieval != null) {\n  sessionid = cookieval.substring(0, cookieval.indexOf(\";\"));\n}\n```\n\n可以将 SesshinID 通过全局变量或者 SQLite 数据库保存下来，方便以后请求时调用。\n\n请求链接的同时发送 SessionID ：\n\n``` java\nURL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection();\nconn.setRequestProperty(\"cookie\", UtilGlobalVariable.sessionId);\nconn.connect();\n```","slug":"2016-01-31@Android 与服务端的 Session 保持","published":1,"updated":"2020-06-29T03:32:42.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt46z0022rqgj4rxh6hty","content":"<p>在开发联网应用的过程中，有时候会希望 php 服务端能通过 Session 保存一些信息，以便随时验证客户端的登录状态，或完成其它功能。但实际操作中发现，Android 客户端每次请求服务端都被视为一个新的请求，SessionID 都会改变，也就是说根本没办法使用 Session 存储和读取信息。</p>\n<a id=\"more\"></a>\n\n<p>我们可以通过保存 SessionID 、请求服务端的同时传递 SessionID 来解决这个问题，让服务器知道两次请求来自同一个客户端。</p>\n<p>发送请求并保存 SessionID ：</p>\n<pre><code class=\"java\">URL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect();\n// 获得 SessionID\nString cookieval = conn.getHeaderField(&quot;set-cookie&quot;);\nString sessionid;\nif(cookieval != null) {\n  sessionid = cookieval.substring(0, cookieval.indexOf(&quot;;&quot;));\n}</code></pre>\n<p>可以将 SesshinID 通过全局变量或者 SQLite 数据库保存下来，方便以后请求时调用。</p>\n<p>请求链接的同时发送 SessionID ：</p>\n<pre><code class=\"java\">URL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection();\nconn.setRequestProperty(&quot;cookie&quot;, UtilGlobalVariable.sessionId);\nconn.connect();</code></pre>\n","site":{"data":{}},"excerpt":"<p>在开发联网应用的过程中，有时候会希望 php 服务端能通过 Session 保存一些信息，以便随时验证客户端的登录状态，或完成其它功能。但实际操作中发现，Android 客户端每次请求服务端都被视为一个新的请求，SessionID 都会改变，也就是说根本没办法使用 Session 存储和读取信息。</p>","more":"<p>我们可以通过保存 SessionID 、请求服务端的同时传递 SessionID 来解决这个问题，让服务器知道两次请求来自同一个客户端。</p>\n<p>发送请求并保存 SessionID ：</p>\n<pre><code class=\"java\">URL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection(); conn.connect();\n// 获得 SessionID\nString cookieval = conn.getHeaderField(&quot;set-cookie&quot;);\nString sessionid;\nif(cookieval != null) {\n  sessionid = cookieval.substring(0, cookieval.indexOf(&quot;;&quot;));\n}</code></pre>\n<p>可以将 SesshinID 通过全局变量或者 SQLite 数据库保存下来，方便以后请求时调用。</p>\n<p>请求链接的同时发送 SessionID ：</p>\n<pre><code class=\"java\">URL url = new URL(link);\nHttpURLConnection conn= (HttpURLConnection)url.openConnection();\nconn.setRequestProperty(&quot;cookie&quot;, UtilGlobalVariable.sessionId);\nconn.connect();</code></pre>"},{"title":"解决 SQLite 把空值转为字符串","date":"2016-02-06T14:40:50.000Z","_content":"\n遇到一个非常诡异的问题。\n\n当服务端通过 `json_encode` 方法输出 JSON 格式数据，空值会被以明文形式输出。\n\n<!-- more -->\n\n``` json\n{ \"name\": null }\n```\n\n客户端通过 JSONTokener、JSONObject 解析后直接存入 SQLite 数据库，null（空值）会被认为是字符串“null”。\n\n这样就导致从数据库中取出的是一个字符串，判断结果为非空。\n\n我的解决办法是写一个静态方法，从服务器返回的 JSON 里解析出的字符串，都经过此方法。\n\n``` java\npublic static String fixNullValue(String string){\n  if( string.equals(\"null\") ){\n    string = \"\";\n    return string;\n  }else{\n    return string;\n  }\n}\n```\n\n``` java\nname = fixNullValue(name);\n```\n\n即如果解析到的字符串内容等于“null”，就在存入数据库前赋值为空字符串。\n\n注意，不能使用 `string = null` ，这样做的结果还是会被 SQLite 存为字符串“null”。\n\n以后从数据库里取值的时候，可以用 `isEmpty` 方法判断是否为空。\n\n``` java\nif( !name.isEmpty() )\n```","source":"_posts/2016-02-06@解决 SQLite 把空值转为字符串.md","raw":"---\ntitle: 解决 SQLite 把空值转为字符串\ncategories:\n  - Android\ndate: 2016-02-06 22:40:50\ntags:\n  - Android\n  - Java\n  - SQLite\n---\n\n遇到一个非常诡异的问题。\n\n当服务端通过 `json_encode` 方法输出 JSON 格式数据，空值会被以明文形式输出。\n\n<!-- more -->\n\n``` json\n{ \"name\": null }\n```\n\n客户端通过 JSONTokener、JSONObject 解析后直接存入 SQLite 数据库，null（空值）会被认为是字符串“null”。\n\n这样就导致从数据库中取出的是一个字符串，判断结果为非空。\n\n我的解决办法是写一个静态方法，从服务器返回的 JSON 里解析出的字符串，都经过此方法。\n\n``` java\npublic static String fixNullValue(String string){\n  if( string.equals(\"null\") ){\n    string = \"\";\n    return string;\n  }else{\n    return string;\n  }\n}\n```\n\n``` java\nname = fixNullValue(name);\n```\n\n即如果解析到的字符串内容等于“null”，就在存入数据库前赋值为空字符串。\n\n注意，不能使用 `string = null` ，这样做的结果还是会被 SQLite 存为字符串“null”。\n\n以后从数据库里取值的时候，可以用 `isEmpty` 方法判断是否为空。\n\n``` java\nif( !name.isEmpty() )\n```","slug":"2016-02-06@解决 SQLite 把空值转为字符串","published":1,"updated":"2020-06-29T03:32:42.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4700025rqgj7kejfexa","content":"<p>遇到一个非常诡异的问题。</p>\n<p>当服务端通过 <code>json_encode</code> 方法输出 JSON 格式数据，空值会被以明文形式输出。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"json\">{ &quot;name&quot;: null }</code></pre>\n<p>客户端通过 JSONTokener、JSONObject 解析后直接存入 SQLite 数据库，null（空值）会被认为是字符串“null”。</p>\n<p>这样就导致从数据库中取出的是一个字符串，判断结果为非空。</p>\n<p>我的解决办法是写一个静态方法，从服务器返回的 JSON 里解析出的字符串，都经过此方法。</p>\n<pre><code class=\"java\">public static String fixNullValue(String string){\n  if( string.equals(&quot;null&quot;) ){\n    string = &quot;&quot;;\n    return string;\n  }else{\n    return string;\n  }\n}</code></pre>\n<pre><code class=\"java\">name = fixNullValue(name);</code></pre>\n<p>即如果解析到的字符串内容等于“null”，就在存入数据库前赋值为空字符串。</p>\n<p>注意，不能使用 <code>string = null</code> ，这样做的结果还是会被 SQLite 存为字符串“null”。</p>\n<p>以后从数据库里取值的时候，可以用 <code>isEmpty</code> 方法判断是否为空。</p>\n<pre><code class=\"java\">if( !name.isEmpty() )</code></pre>\n","site":{"data":{}},"excerpt":"<p>遇到一个非常诡异的问题。</p>\n<p>当服务端通过 <code>json_encode</code> 方法输出 JSON 格式数据，空值会被以明文形式输出。</p>","more":"<pre><code class=\"json\">{ &quot;name&quot;: null }</code></pre>\n<p>客户端通过 JSONTokener、JSONObject 解析后直接存入 SQLite 数据库，null（空值）会被认为是字符串“null”。</p>\n<p>这样就导致从数据库中取出的是一个字符串，判断结果为非空。</p>\n<p>我的解决办法是写一个静态方法，从服务器返回的 JSON 里解析出的字符串，都经过此方法。</p>\n<pre><code class=\"java\">public static String fixNullValue(String string){\n  if( string.equals(&quot;null&quot;) ){\n    string = &quot;&quot;;\n    return string;\n  }else{\n    return string;\n  }\n}</code></pre>\n<pre><code class=\"java\">name = fixNullValue(name);</code></pre>\n<p>即如果解析到的字符串内容等于“null”，就在存入数据库前赋值为空字符串。</p>\n<p>注意，不能使用 <code>string = null</code> ，这样做的结果还是会被 SQLite 存为字符串“null”。</p>\n<p>以后从数据库里取值的时候，可以用 <code>isEmpty</code> 方法判断是否为空。</p>\n<pre><code class=\"java\">if( !name.isEmpty() )</code></pre>"},{"title":"Android 上传文件到 PHP 服务端","date":"2016-02-07T06:10:05.000Z","_content":"\n最近练习的小项目中用到了文件上传功能，从 Android 客户端向 PHP 服务端上传文件。\n\n查了不少资料，看过很多 demo ，结果照搬过来都以失败告终了。经过阅读、思考和尝试后终于改出了能用的代码。\n\n<!-- more -->\n\n实际上实现的方法都差不多，客户端发送 POST 请求向服务端上传文件，服务端判断、接收。\n\n先谈一谈几点需要特别注意的地方。\n\n① SD 卡的路径要用 `Environment.getExternalStorageDirectory` 获取，因为不同手机默认的 SD 卡路径可能不同。\n\n② 在每次测试之前，确保本地文件确实存在且可读，用 PC 确定服务端链接可以访问。\n\n③ 客户端设置的文件键名 name 必须和服务端一致。\n\n客户端：\n\n```\n// 文件路径 建议用 Environment.getExternalStorageDirectory 方法获取 SD 卡路径\nprivate String filePath = \"/sdcard/example/image.jpg\";\n\n/**\n * 上传图片到服务端\n * @param targetUrl 服务端链接\n */\nprivate void uploadFile(final String targetUrl) {\n  Thread thread = new Thread() {\n    @Override\n    public void run() {\n      String end = \"\\r\\n\";\n      String twoHyphens = \"--\";\n      String boundary = \"******\";\n      try {\n        URL url = new URL(targetUrl);\n        HttpURLConnection httpURLConnection = (HttpURLConnection)url.openConnection();\n        // 设置每次传输的流大小\n        httpURLConnection.setChunkedStreamingMode(128 * 1024); //128K\n        // 允许输入输出流\n        httpURLConnection.setDoInput(true);\n        httpURLConnection.setDoOutput(true);\n        httpURLConnection.setUseCaches(false);\n        // 使用 POST 方法\n        httpURLConnection.setRequestMethod(\"POST\");\n        httpURLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        httpURLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n        httpURLConnection.setRequestProperty(\"Content-Type\",\n            \"multipart/form-data;boundary=\" + boundary);\n        DataOutputStream dos = new DataOutputStream(httpURLConnection.getOutputStream());\n        dos.writeBytes(twoHyphens + boundary + end);\n        // 设置 name 为 file\n        dos.writeBytes(\"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"\"\n            + filePath.substring(filePath.lastIndexOf(\"/\") + 1)\n            + \"\\\"\"\n            + end);\n        dos.writeBytes(end);\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] buffer = new byte[8192]; // 8k\n        int count = 0;\n        // 读取文件\n        while ((count = fis.read(buffer)) != -1) {\n          dos.write(buffer, 0, count);\n        }\n        fis.close();\n        dos.writeBytes(end);\n        dos.writeBytes(twoHyphens + boundary + twoHyphens + end);\n        dos.flush();\n        // ResponseCode 可以用来判断错误类型\n        // int status = httpURLConnection.getResponseCode();\n        InputStream is = httpURLConnection.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is, \"utf-8\");\n        BufferedReader br = new BufferedReader(isr);\n        // 获取返回内容\n        String info = br.readLine();\n        dos.close();\n        is.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  };\n  thread.start();\n}\n```\n\n服务端：\n\n``` php\n// 定义 ROOT 为当前目录\ndefine('ROOT', dirname(__FILE__).'/');  \n\n// 限制拓展名为 jpg 且文件大小在5KB以内。\nif((pathinfo($_FILES[\"file\"][\"name\"], PATHINFO_EXTENSION) == \"jpg\") && ($_FILES[\"file\"][\"size\"] < 5000)){\n  // 上传文件失败\n  if($_FILES[\"file\"][\"error\"] > 0){\n    echo \"错误代码：\" . $_FILES[\"file\"][\"error\"] . \"<br />\"; \n  }\n  // 上传文件成功\n  else{\n    if ( !( file_exists(ROOT. $_FILES[\"file\"][\"name\"]) ) ){\n      // 将临文件移动到指定路径\n      move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], ROOT . $_FILES[\"file\"][\"name\"]  );\n    }\n  }\n}\n?>\n```\n\n建议先写服务端代码，确定接口可用后再用客户端发送请求。","source":"_posts/2016-02-07@Android 上传文件到 PHP 服务端.md","raw":"---\ntitle: Android 上传文件到 PHP 服务端\ncategories:\n  - Android\ndate: 2016-02-07 14:10:05\ntags:\n  - Android\n  - Java\n  - PHP\n---\n\n最近练习的小项目中用到了文件上传功能，从 Android 客户端向 PHP 服务端上传文件。\n\n查了不少资料，看过很多 demo ，结果照搬过来都以失败告终了。经过阅读、思考和尝试后终于改出了能用的代码。\n\n<!-- more -->\n\n实际上实现的方法都差不多，客户端发送 POST 请求向服务端上传文件，服务端判断、接收。\n\n先谈一谈几点需要特别注意的地方。\n\n① SD 卡的路径要用 `Environment.getExternalStorageDirectory` 获取，因为不同手机默认的 SD 卡路径可能不同。\n\n② 在每次测试之前，确保本地文件确实存在且可读，用 PC 确定服务端链接可以访问。\n\n③ 客户端设置的文件键名 name 必须和服务端一致。\n\n客户端：\n\n```\n// 文件路径 建议用 Environment.getExternalStorageDirectory 方法获取 SD 卡路径\nprivate String filePath = \"/sdcard/example/image.jpg\";\n\n/**\n * 上传图片到服务端\n * @param targetUrl 服务端链接\n */\nprivate void uploadFile(final String targetUrl) {\n  Thread thread = new Thread() {\n    @Override\n    public void run() {\n      String end = \"\\r\\n\";\n      String twoHyphens = \"--\";\n      String boundary = \"******\";\n      try {\n        URL url = new URL(targetUrl);\n        HttpURLConnection httpURLConnection = (HttpURLConnection)url.openConnection();\n        // 设置每次传输的流大小\n        httpURLConnection.setChunkedStreamingMode(128 * 1024); //128K\n        // 允许输入输出流\n        httpURLConnection.setDoInput(true);\n        httpURLConnection.setDoOutput(true);\n        httpURLConnection.setUseCaches(false);\n        // 使用 POST 方法\n        httpURLConnection.setRequestMethod(\"POST\");\n        httpURLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        httpURLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n        httpURLConnection.setRequestProperty(\"Content-Type\",\n            \"multipart/form-data;boundary=\" + boundary);\n        DataOutputStream dos = new DataOutputStream(httpURLConnection.getOutputStream());\n        dos.writeBytes(twoHyphens + boundary + end);\n        // 设置 name 为 file\n        dos.writeBytes(\"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"\"\n            + filePath.substring(filePath.lastIndexOf(\"/\") + 1)\n            + \"\\\"\"\n            + end);\n        dos.writeBytes(end);\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] buffer = new byte[8192]; // 8k\n        int count = 0;\n        // 读取文件\n        while ((count = fis.read(buffer)) != -1) {\n          dos.write(buffer, 0, count);\n        }\n        fis.close();\n        dos.writeBytes(end);\n        dos.writeBytes(twoHyphens + boundary + twoHyphens + end);\n        dos.flush();\n        // ResponseCode 可以用来判断错误类型\n        // int status = httpURLConnection.getResponseCode();\n        InputStream is = httpURLConnection.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is, \"utf-8\");\n        BufferedReader br = new BufferedReader(isr);\n        // 获取返回内容\n        String info = br.readLine();\n        dos.close();\n        is.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  };\n  thread.start();\n}\n```\n\n服务端：\n\n``` php\n// 定义 ROOT 为当前目录\ndefine('ROOT', dirname(__FILE__).'/');  \n\n// 限制拓展名为 jpg 且文件大小在5KB以内。\nif((pathinfo($_FILES[\"file\"][\"name\"], PATHINFO_EXTENSION) == \"jpg\") && ($_FILES[\"file\"][\"size\"] < 5000)){\n  // 上传文件失败\n  if($_FILES[\"file\"][\"error\"] > 0){\n    echo \"错误代码：\" . $_FILES[\"file\"][\"error\"] . \"<br />\"; \n  }\n  // 上传文件成功\n  else{\n    if ( !( file_exists(ROOT. $_FILES[\"file\"][\"name\"]) ) ){\n      // 将临文件移动到指定路径\n      move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], ROOT . $_FILES[\"file\"][\"name\"]  );\n    }\n  }\n}\n?>\n```\n\n建议先写服务端代码，确定接口可用后再用客户端发送请求。","slug":"2016-02-07@Android 上传文件到 PHP 服务端","published":1,"updated":"2020-06-29T03:32:42.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4720029rqgjhvu3b39q","content":"<p>最近练习的小项目中用到了文件上传功能，从 Android 客户端向 PHP 服务端上传文件。</p>\n<p>查了不少资料，看过很多 demo ，结果照搬过来都以失败告终了。经过阅读、思考和尝试后终于改出了能用的代码。</p>\n<a id=\"more\"></a>\n\n<p>实际上实现的方法都差不多，客户端发送 POST 请求向服务端上传文件，服务端判断、接收。</p>\n<p>先谈一谈几点需要特别注意的地方。</p>\n<p>① SD 卡的路径要用 <code>Environment.getExternalStorageDirectory</code> 获取，因为不同手机默认的 SD 卡路径可能不同。</p>\n<p>② 在每次测试之前，确保本地文件确实存在且可读，用 PC 确定服务端链接可以访问。</p>\n<p>③ 客户端设置的文件键名 name 必须和服务端一致。</p>\n<p>客户端：</p>\n<pre><code>// 文件路径 建议用 Environment.getExternalStorageDirectory 方法获取 SD 卡路径\nprivate String filePath = &quot;/sdcard/example/image.jpg&quot;;\n\n/**\n * 上传图片到服务端\n * @param targetUrl 服务端链接\n */\nprivate void uploadFile(final String targetUrl) {\n  Thread thread = new Thread() {\n    @Override\n    public void run() {\n      String end = &quot;\\r\\n&quot;;\n      String twoHyphens = &quot;--&quot;;\n      String boundary = &quot;******&quot;;\n      try {\n        URL url = new URL(targetUrl);\n        HttpURLConnection httpURLConnection = (HttpURLConnection)url.openConnection();\n        // 设置每次传输的流大小\n        httpURLConnection.setChunkedStreamingMode(128 * 1024); //128K\n        // 允许输入输出流\n        httpURLConnection.setDoInput(true);\n        httpURLConnection.setDoOutput(true);\n        httpURLConnection.setUseCaches(false);\n        // 使用 POST 方法\n        httpURLConnection.setRequestMethod(&quot;POST&quot;);\n        httpURLConnection.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n        httpURLConnection.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);\n        httpURLConnection.setRequestProperty(&quot;Content-Type&quot;,\n            &quot;multipart/form-data;boundary=&quot; + boundary);\n        DataOutputStream dos = new DataOutputStream(httpURLConnection.getOutputStream());\n        dos.writeBytes(twoHyphens + boundary + end);\n        // 设置 name 为 file\n        dos.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;file\\&quot;; filename=\\&quot;&quot;\n            + filePath.substring(filePath.lastIndexOf(&quot;/&quot;) + 1)\n            + &quot;\\&quot;&quot;\n            + end);\n        dos.writeBytes(end);\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] buffer = new byte[8192]; // 8k\n        int count = 0;\n        // 读取文件\n        while ((count = fis.read(buffer)) != -1) {\n          dos.write(buffer, 0, count);\n        }\n        fis.close();\n        dos.writeBytes(end);\n        dos.writeBytes(twoHyphens + boundary + twoHyphens + end);\n        dos.flush();\n        // ResponseCode 可以用来判断错误类型\n        // int status = httpURLConnection.getResponseCode();\n        InputStream is = httpURLConnection.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);\n        BufferedReader br = new BufferedReader(isr);\n        // 获取返回内容\n        String info = br.readLine();\n        dos.close();\n        is.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  };\n  thread.start();\n}</code></pre><p>服务端：</p>\n<pre><code class=\"php\">// 定义 ROOT 为当前目录\ndefine(&#39;ROOT&#39;, dirname(__FILE__).&#39;/&#39;);  \n\n// 限制拓展名为 jpg 且文件大小在5KB以内。\nif((pathinfo($_FILES[&quot;file&quot;][&quot;name&quot;], PATHINFO_EXTENSION) == &quot;jpg&quot;) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 5000)){\n  // 上传文件失败\n  if($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){\n    echo &quot;错误代码：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;; \n  }\n  // 上传文件成功\n  else{\n    if ( !( file_exists(ROOT. $_FILES[&quot;file&quot;][&quot;name&quot;]) ) ){\n      // 将临文件移动到指定路径\n      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], ROOT . $_FILES[&quot;file&quot;][&quot;name&quot;]  );\n    }\n  }\n}\n?&gt;</code></pre>\n<p>建议先写服务端代码，确定接口可用后再用客户端发送请求。</p>\n","site":{"data":{}},"excerpt":"<p>最近练习的小项目中用到了文件上传功能，从 Android 客户端向 PHP 服务端上传文件。</p>\n<p>查了不少资料，看过很多 demo ，结果照搬过来都以失败告终了。经过阅读、思考和尝试后终于改出了能用的代码。</p>","more":"<p>实际上实现的方法都差不多，客户端发送 POST 请求向服务端上传文件，服务端判断、接收。</p>\n<p>先谈一谈几点需要特别注意的地方。</p>\n<p>① SD 卡的路径要用 <code>Environment.getExternalStorageDirectory</code> 获取，因为不同手机默认的 SD 卡路径可能不同。</p>\n<p>② 在每次测试之前，确保本地文件确实存在且可读，用 PC 确定服务端链接可以访问。</p>\n<p>③ 客户端设置的文件键名 name 必须和服务端一致。</p>\n<p>客户端：</p>\n<pre><code>// 文件路径 建议用 Environment.getExternalStorageDirectory 方法获取 SD 卡路径\nprivate String filePath = &quot;/sdcard/example/image.jpg&quot;;\n\n/**\n * 上传图片到服务端\n * @param targetUrl 服务端链接\n */\nprivate void uploadFile(final String targetUrl) {\n  Thread thread = new Thread() {\n    @Override\n    public void run() {\n      String end = &quot;\\r\\n&quot;;\n      String twoHyphens = &quot;--&quot;;\n      String boundary = &quot;******&quot;;\n      try {\n        URL url = new URL(targetUrl);\n        HttpURLConnection httpURLConnection = (HttpURLConnection)url.openConnection();\n        // 设置每次传输的流大小\n        httpURLConnection.setChunkedStreamingMode(128 * 1024); //128K\n        // 允许输入输出流\n        httpURLConnection.setDoInput(true);\n        httpURLConnection.setDoOutput(true);\n        httpURLConnection.setUseCaches(false);\n        // 使用 POST 方法\n        httpURLConnection.setRequestMethod(&quot;POST&quot;);\n        httpURLConnection.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n        httpURLConnection.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);\n        httpURLConnection.setRequestProperty(&quot;Content-Type&quot;,\n            &quot;multipart/form-data;boundary=&quot; + boundary);\n        DataOutputStream dos = new DataOutputStream(httpURLConnection.getOutputStream());\n        dos.writeBytes(twoHyphens + boundary + end);\n        // 设置 name 为 file\n        dos.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;file\\&quot;; filename=\\&quot;&quot;\n            + filePath.substring(filePath.lastIndexOf(&quot;/&quot;) + 1)\n            + &quot;\\&quot;&quot;\n            + end);\n        dos.writeBytes(end);\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] buffer = new byte[8192]; // 8k\n        int count = 0;\n        // 读取文件\n        while ((count = fis.read(buffer)) != -1) {\n          dos.write(buffer, 0, count);\n        }\n        fis.close();\n        dos.writeBytes(end);\n        dos.writeBytes(twoHyphens + boundary + twoHyphens + end);\n        dos.flush();\n        // ResponseCode 可以用来判断错误类型\n        // int status = httpURLConnection.getResponseCode();\n        InputStream is = httpURLConnection.getInputStream();\n        InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);\n        BufferedReader br = new BufferedReader(isr);\n        // 获取返回内容\n        String info = br.readLine();\n        dos.close();\n        is.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  };\n  thread.start();\n}</code></pre><p>服务端：</p>\n<pre><code class=\"php\">// 定义 ROOT 为当前目录\ndefine(&#39;ROOT&#39;, dirname(__FILE__).&#39;/&#39;);  \n\n// 限制拓展名为 jpg 且文件大小在5KB以内。\nif((pathinfo($_FILES[&quot;file&quot;][&quot;name&quot;], PATHINFO_EXTENSION) == &quot;jpg&quot;) &amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 5000)){\n  // 上传文件失败\n  if($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){\n    echo &quot;错误代码：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;; \n  }\n  // 上传文件成功\n  else{\n    if ( !( file_exists(ROOT. $_FILES[&quot;file&quot;][&quot;name&quot;]) ) ){\n      // 将临文件移动到指定路径\n      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], ROOT . $_FILES[&quot;file&quot;][&quot;name&quot;]  );\n    }\n  }\n}\n?&gt;</code></pre>\n<p>建议先写服务端代码，确定接口可用后再用客户端发送请求。</p>"},{"title":"Fragment onResume 方法无效问题","date":"2016-02-07T05:17:22.000Z","_content":"\n`onResume` 在 Activity 中是个非常常用的生命周期方法，它在 Activity 每次显示时都被执行，可用于刷新 UI 等操作。\n\nFragment 和 Activity 一样存在 `onResume` 方法，但我发现直接覆写 `onResume` 方法后，当 Fragment 显示到前台时不会执行这个方法。网上有人推荐使用 `setUserVisibleHint` 方法。\n\n<!-- more -->\n\n``` java\n@Override\npublic void setUserVisibleHint(boolean isVisibleToUser) {\n  super.setUserVisibleHint(isVisibleToUser);\n  if (isVisibleToUser) {\n    // 相当于 Fragment 的 onResume\n  } else {\n    // 相当于 Fragment 的 onPause\n  }\n}\n```\n\n但我尝试后也发现没有效果，不知道是什么原因。\n\n我的使用场景是，当用户退出 AnotherActivity ，返回 MainActivity 的时候，我希望 MainActivity 内已经存在的 Fragment 可以刷新 UI（查询数据库内是否有变更的内容）。我尝试过在 `onResume` 和 `setUserVisibleHint` 这两个方法下执行刷新 UI 的方法，都不成功；在 AnotherActivity 退出前调用 Fragment 内刷新 UI 的方法，也不成功。\n\n最后我的解决方案是，手动执行，让 MainActivity 来通知 Fragment 执行 `onResume` 方法。\n\n``` java\n@Override\npublic void onResume() {\n  super.onResume();\n  // 添加需要的操作\n}\n```\n\n在 MainActivity 下创建一个静态方法。\n\n``` java\npublic static void resumeFragment() {\n  fragment.onResume();\n}\n```\n\n当需要执行 Fragment 的 `onResume` 方法时：\n\n``` java\nMainActivity.resumeFragment();\n```\n\n还有一种方法，直接在 MainActivity 的 `onResume` 方法里刷新 Fragment 的 UI ，也有效果。\n\n``` java\nif( fragment.isAdded() ) {\n  // Fragment 中的静态方法\n  fragment.refreshProfile();\n}\n```","source":"_posts/2016-02-07@Fragment onResume 方法无效问题.md","raw":"---\ntitle: Fragment onResume 方法无效问题\ncategories:\n  - Android\ndate: 2016-02-07 13:17:22\ntags:\n  - Android\n---\n\n`onResume` 在 Activity 中是个非常常用的生命周期方法，它在 Activity 每次显示时都被执行，可用于刷新 UI 等操作。\n\nFragment 和 Activity 一样存在 `onResume` 方法，但我发现直接覆写 `onResume` 方法后，当 Fragment 显示到前台时不会执行这个方法。网上有人推荐使用 `setUserVisibleHint` 方法。\n\n<!-- more -->\n\n``` java\n@Override\npublic void setUserVisibleHint(boolean isVisibleToUser) {\n  super.setUserVisibleHint(isVisibleToUser);\n  if (isVisibleToUser) {\n    // 相当于 Fragment 的 onResume\n  } else {\n    // 相当于 Fragment 的 onPause\n  }\n}\n```\n\n但我尝试后也发现没有效果，不知道是什么原因。\n\n我的使用场景是，当用户退出 AnotherActivity ，返回 MainActivity 的时候，我希望 MainActivity 内已经存在的 Fragment 可以刷新 UI（查询数据库内是否有变更的内容）。我尝试过在 `onResume` 和 `setUserVisibleHint` 这两个方法下执行刷新 UI 的方法，都不成功；在 AnotherActivity 退出前调用 Fragment 内刷新 UI 的方法，也不成功。\n\n最后我的解决方案是，手动执行，让 MainActivity 来通知 Fragment 执行 `onResume` 方法。\n\n``` java\n@Override\npublic void onResume() {\n  super.onResume();\n  // 添加需要的操作\n}\n```\n\n在 MainActivity 下创建一个静态方法。\n\n``` java\npublic static void resumeFragment() {\n  fragment.onResume();\n}\n```\n\n当需要执行 Fragment 的 `onResume` 方法时：\n\n``` java\nMainActivity.resumeFragment();\n```\n\n还有一种方法，直接在 MainActivity 的 `onResume` 方法里刷新 Fragment 的 UI ，也有效果。\n\n``` java\nif( fragment.isAdded() ) {\n  // Fragment 中的静态方法\n  fragment.refreshProfile();\n}\n```","slug":"2016-02-07@Fragment onResume 方法无效问题","published":1,"updated":"2020-06-29T03:32:42.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt475002crqgj6ttcejbo","content":"<p><code>onResume</code> 在 Activity 中是个非常常用的生命周期方法，它在 Activity 每次显示时都被执行，可用于刷新 UI 等操作。</p>\n<p>Fragment 和 Activity 一样存在 <code>onResume</code> 方法，但我发现直接覆写 <code>onResume</code> 方法后，当 Fragment 显示到前台时不会执行这个方法。网上有人推荐使用 <code>setUserVisibleHint</code> 方法。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"java\">@Override\npublic void setUserVisibleHint(boolean isVisibleToUser) {\n  super.setUserVisibleHint(isVisibleToUser);\n  if (isVisibleToUser) {\n    // 相当于 Fragment 的 onResume\n  } else {\n    // 相当于 Fragment 的 onPause\n  }\n}</code></pre>\n<p>但我尝试后也发现没有效果，不知道是什么原因。</p>\n<p>我的使用场景是，当用户退出 AnotherActivity ，返回 MainActivity 的时候，我希望 MainActivity 内已经存在的 Fragment 可以刷新 UI（查询数据库内是否有变更的内容）。我尝试过在 <code>onResume</code> 和 <code>setUserVisibleHint</code> 这两个方法下执行刷新 UI 的方法，都不成功；在 AnotherActivity 退出前调用 Fragment 内刷新 UI 的方法，也不成功。</p>\n<p>最后我的解决方案是，手动执行，让 MainActivity 来通知 Fragment 执行 <code>onResume</code> 方法。</p>\n<pre><code class=\"java\">@Override\npublic void onResume() {\n  super.onResume();\n  // 添加需要的操作\n}</code></pre>\n<p>在 MainActivity 下创建一个静态方法。</p>\n<pre><code class=\"java\">public static void resumeFragment() {\n  fragment.onResume();\n}</code></pre>\n<p>当需要执行 Fragment 的 <code>onResume</code> 方法时：</p>\n<pre><code class=\"java\">MainActivity.resumeFragment();</code></pre>\n<p>还有一种方法，直接在 MainActivity 的 <code>onResume</code> 方法里刷新 Fragment 的 UI ，也有效果。</p>\n<pre><code class=\"java\">if( fragment.isAdded() ) {\n  // Fragment 中的静态方法\n  fragment.refreshProfile();\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p><code>onResume</code> 在 Activity 中是个非常常用的生命周期方法，它在 Activity 每次显示时都被执行，可用于刷新 UI 等操作。</p>\n<p>Fragment 和 Activity 一样存在 <code>onResume</code> 方法，但我发现直接覆写 <code>onResume</code> 方法后，当 Fragment 显示到前台时不会执行这个方法。网上有人推荐使用 <code>setUserVisibleHint</code> 方法。</p>","more":"<pre><code class=\"java\">@Override\npublic void setUserVisibleHint(boolean isVisibleToUser) {\n  super.setUserVisibleHint(isVisibleToUser);\n  if (isVisibleToUser) {\n    // 相当于 Fragment 的 onResume\n  } else {\n    // 相当于 Fragment 的 onPause\n  }\n}</code></pre>\n<p>但我尝试后也发现没有效果，不知道是什么原因。</p>\n<p>我的使用场景是，当用户退出 AnotherActivity ，返回 MainActivity 的时候，我希望 MainActivity 内已经存在的 Fragment 可以刷新 UI（查询数据库内是否有变更的内容）。我尝试过在 <code>onResume</code> 和 <code>setUserVisibleHint</code> 这两个方法下执行刷新 UI 的方法，都不成功；在 AnotherActivity 退出前调用 Fragment 内刷新 UI 的方法，也不成功。</p>\n<p>最后我的解决方案是，手动执行，让 MainActivity 来通知 Fragment 执行 <code>onResume</code> 方法。</p>\n<pre><code class=\"java\">@Override\npublic void onResume() {\n  super.onResume();\n  // 添加需要的操作\n}</code></pre>\n<p>在 MainActivity 下创建一个静态方法。</p>\n<pre><code class=\"java\">public static void resumeFragment() {\n  fragment.onResume();\n}</code></pre>\n<p>当需要执行 Fragment 的 <code>onResume</code> 方法时：</p>\n<pre><code class=\"java\">MainActivity.resumeFragment();</code></pre>\n<p>还有一种方法，直接在 MainActivity 的 <code>onResume</code> 方法里刷新 Fragment 的 UI ，也有效果。</p>\n<pre><code class=\"java\">if( fragment.isAdded() ) {\n  // Fragment 中的静态方法\n  fragment.refreshProfile();\n}</code></pre>"},{"title":"PHP 中正确计算中文字数","date":"2016-02-08T06:12:26.000Z","_content":"\n在使用 PHP 开发网站或服务端的时候，经常需要限制用户输入信息的长度。\n\nPHP 提供了 `strlen` 方法用于计算字符串的长度。早期一般用这个方法判断字数。\n\n<!-- more -->\n\n``` php\necho strlen('早上好');\n```\n\n不过，这个方法计算的是字节数，而不是字符数（字数）。在 utf-8 编码下，一个汉字一般等于3个字节。所以用 `strlen` 计算“早上好”的长度，结果等于9。换言之，在使用 `strlen` 限制长度小于12的情况下，用户可以输入12个英文字母，或4个汉字。\n\n以前解决这种问题一般使用更宽容的长度限制，如：预计让用户输入12个中文字符，则限制 `strlen($s)<=36` 。这又会导致用户能够输入36个英文字符。\n\n最好的解决办法是使用新版 PHP（通过拓展）提供的 `mb_strlen` 方法，它可以忽略编码造成中英文字节数的差别，计算字符数，也就真正实现了计算字数。\n\n``` php\necho mb_strlen( '早上好', 'utf-8');\n```\n\n用 `mb_strlen` 计算“早上好”的长度，结果为3。","source":"_posts/2016-02-08@PHP 中正确计算中文字数.md","raw":"---\ntitle: PHP 中正确计算中文字数\ncategories:\n  - Web Back-end\ndate: 2016-02-08 14:12:26\ntags:\n  - PHP\n---\n\n在使用 PHP 开发网站或服务端的时候，经常需要限制用户输入信息的长度。\n\nPHP 提供了 `strlen` 方法用于计算字符串的长度。早期一般用这个方法判断字数。\n\n<!-- more -->\n\n``` php\necho strlen('早上好');\n```\n\n不过，这个方法计算的是字节数，而不是字符数（字数）。在 utf-8 编码下，一个汉字一般等于3个字节。所以用 `strlen` 计算“早上好”的长度，结果等于9。换言之，在使用 `strlen` 限制长度小于12的情况下，用户可以输入12个英文字母，或4个汉字。\n\n以前解决这种问题一般使用更宽容的长度限制，如：预计让用户输入12个中文字符，则限制 `strlen($s)<=36` 。这又会导致用户能够输入36个英文字符。\n\n最好的解决办法是使用新版 PHP（通过拓展）提供的 `mb_strlen` 方法，它可以忽略编码造成中英文字节数的差别，计算字符数，也就真正实现了计算字数。\n\n``` php\necho mb_strlen( '早上好', 'utf-8');\n```\n\n用 `mb_strlen` 计算“早上好”的长度，结果为3。","slug":"2016-02-08@PHP 中正确计算中文字数","published":1,"updated":"2020-06-29T03:32:42.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt476002frqgjd0bc5h86","content":"<p>在使用 PHP 开发网站或服务端的时候，经常需要限制用户输入信息的长度。</p>\n<p>PHP 提供了 <code>strlen</code> 方法用于计算字符串的长度。早期一般用这个方法判断字数。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"php\">echo strlen(&#39;早上好&#39;);</code></pre>\n<p>不过，这个方法计算的是字节数，而不是字符数（字数）。在 utf-8 编码下，一个汉字一般等于3个字节。所以用 <code>strlen</code> 计算“早上好”的长度，结果等于9。换言之，在使用 <code>strlen</code> 限制长度小于12的情况下，用户可以输入12个英文字母，或4个汉字。</p>\n<p>以前解决这种问题一般使用更宽容的长度限制，如：预计让用户输入12个中文字符，则限制 <code>strlen($s)&lt;=36</code> 。这又会导致用户能够输入36个英文字符。</p>\n<p>最好的解决办法是使用新版 PHP（通过拓展）提供的 <code>mb_strlen</code> 方法，它可以忽略编码造成中英文字节数的差别，计算字符数，也就真正实现了计算字数。</p>\n<pre><code class=\"php\">echo mb_strlen( &#39;早上好&#39;, &#39;utf-8&#39;);</code></pre>\n<p>用 <code>mb_strlen</code> 计算“早上好”的长度，结果为3。</p>\n","site":{"data":{}},"excerpt":"<p>在使用 PHP 开发网站或服务端的时候，经常需要限制用户输入信息的长度。</p>\n<p>PHP 提供了 <code>strlen</code> 方法用于计算字符串的长度。早期一般用这个方法判断字数。</p>","more":"<pre><code class=\"php\">echo strlen(&#39;早上好&#39;);</code></pre>\n<p>不过，这个方法计算的是字节数，而不是字符数（字数）。在 utf-8 编码下，一个汉字一般等于3个字节。所以用 <code>strlen</code> 计算“早上好”的长度，结果等于9。换言之，在使用 <code>strlen</code> 限制长度小于12的情况下，用户可以输入12个英文字母，或4个汉字。</p>\n<p>以前解决这种问题一般使用更宽容的长度限制，如：预计让用户输入12个中文字符，则限制 <code>strlen($s)&lt;=36</code> 。这又会导致用户能够输入36个英文字符。</p>\n<p>最好的解决办法是使用新版 PHP（通过拓展）提供的 <code>mb_strlen</code> 方法，它可以忽略编码造成中英文字节数的差别，计算字符数，也就真正实现了计算字数。</p>\n<pre><code class=\"php\">echo mb_strlen( &#39;早上好&#39;, &#39;utf-8&#39;);</code></pre>\n<p>用 <code>mb_strlen</code> 计算“早上好”的长度，结果为3。</p>"},{"title":"使用 AlertDialog 实现自定义对话框","date":"2016-02-08T12:11:58.000Z","_content":"\n首先创建 AlertDialog 对话框的布局文件：\n\n``` xml\n<LinearLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"300dp\"\n  android:layout_height=\"200dp\"\n  android:paddingTop=\"@dimen/dialog_margin_top\"\n  android:paddingBottom=\"@dimen/dialog_margin_bottom\"\n  android:paddingLeft=\"@dimen/long_margin\"\n  android:paddingRight=\"@dimen/long_margin\"\n  android:layout_gravity=\"center\"\n  android:background=\"#ffffff\" >\n  <TextView\n    android:id=\"@+id/textview\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"/>\n</LinearLayout>\n```\n<!-- more -->\n\n构造 AlertDialog ：\n\n``` java\n// 创建一个AlertDialog对象，\nAlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();\nalertDialog.show();\n// 设置AlertDialog的布局\nalertDialog.getWindow().setContentView(R.layout.dialog);\n// 子控件的初始化和使用和Activity下类似\nTextView textview = (TextView)alertDialog.getWindow().findViewById(R.id.textview);\ntitle.setText(\"example\");\n```\n\nAlertDialog 的关闭方法：\n\n``` java\nalertDialog.dismiss();\n```\n\n如果想要为 AlertDialog 使用自定义主题，首先在 style.xml 文件内新建一个主题。这里我继承了系统自带的 Theme.AppCompat.Light.Dialog.Alert 主题，然后一项配色，命名为 AppDialogTheme 。\n\n``` xml\n<style\n  name=\"AppDialogTheme\"\n  parent=\"Theme.AppCompat.Light.Dialog.Alert\">\n  <item name=\"colorAccent\">@color/colorRed</item>\n</style>\n```\n\n然后在 AlertDialog 的构造方法中，增加指定主题样式的参数。\n\n``` java\nAlertDialog alertDialog = new AlertDialog.Builder(\n  MainActivity.this, R.style.AppDialogTheme\n).create();\n```\n\nAlertDialog 显示时默认不可以使用输入法。如果需要在弹出的对话框中使用 EditText 、让用户输入内容，需要在执行 `show` 方法后加入另外两行代码。\n\n``` java\n// 允许输入法弹出\nalertDialog.getWindow().clearFlags( WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM );\nalertDialog.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE );\n```","source":"_posts/2016-02-08@使用 AlertDialog 实现自定义对话框.md","raw":"---\ntitle: 使用 AlertDialog 实现自定义对话框\ncategories:\n  - Android\ndate: 2016-02-08 20:11:58\ntags:\n  - Android\n  - Java\n---\n\n首先创建 AlertDialog 对话框的布局文件：\n\n``` xml\n<LinearLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"300dp\"\n  android:layout_height=\"200dp\"\n  android:paddingTop=\"@dimen/dialog_margin_top\"\n  android:paddingBottom=\"@dimen/dialog_margin_bottom\"\n  android:paddingLeft=\"@dimen/long_margin\"\n  android:paddingRight=\"@dimen/long_margin\"\n  android:layout_gravity=\"center\"\n  android:background=\"#ffffff\" >\n  <TextView\n    android:id=\"@+id/textview\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"/>\n</LinearLayout>\n```\n<!-- more -->\n\n构造 AlertDialog ：\n\n``` java\n// 创建一个AlertDialog对象，\nAlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();\nalertDialog.show();\n// 设置AlertDialog的布局\nalertDialog.getWindow().setContentView(R.layout.dialog);\n// 子控件的初始化和使用和Activity下类似\nTextView textview = (TextView)alertDialog.getWindow().findViewById(R.id.textview);\ntitle.setText(\"example\");\n```\n\nAlertDialog 的关闭方法：\n\n``` java\nalertDialog.dismiss();\n```\n\n如果想要为 AlertDialog 使用自定义主题，首先在 style.xml 文件内新建一个主题。这里我继承了系统自带的 Theme.AppCompat.Light.Dialog.Alert 主题，然后一项配色，命名为 AppDialogTheme 。\n\n``` xml\n<style\n  name=\"AppDialogTheme\"\n  parent=\"Theme.AppCompat.Light.Dialog.Alert\">\n  <item name=\"colorAccent\">@color/colorRed</item>\n</style>\n```\n\n然后在 AlertDialog 的构造方法中，增加指定主题样式的参数。\n\n``` java\nAlertDialog alertDialog = new AlertDialog.Builder(\n  MainActivity.this, R.style.AppDialogTheme\n).create();\n```\n\nAlertDialog 显示时默认不可以使用输入法。如果需要在弹出的对话框中使用 EditText 、让用户输入内容，需要在执行 `show` 方法后加入另外两行代码。\n\n``` java\n// 允许输入法弹出\nalertDialog.getWindow().clearFlags( WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM );\nalertDialog.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE );\n```","slug":"2016-02-08@使用 AlertDialog 实现自定义对话框","published":1,"updated":"2020-06-29T03:32:42.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt479002jrqgj6on56e5p","content":"<p>首先创建 AlertDialog 对话框的布局文件：</p>\n<pre><code class=\"xml\">&lt;LinearLayout\n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;300dp&quot;\n  android:layout_height=&quot;200dp&quot;\n  android:paddingTop=&quot;@dimen/dialog_margin_top&quot;\n  android:paddingBottom=&quot;@dimen/dialog_margin_bottom&quot;\n  android:paddingLeft=&quot;@dimen/long_margin&quot;\n  android:paddingRight=&quot;@dimen/long_margin&quot;\n  android:layout_gravity=&quot;center&quot;\n  android:background=&quot;#ffffff&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/textview&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<a id=\"more\"></a>\n\n<p>构造 AlertDialog ：</p>\n<pre><code class=\"java\">// 创建一个AlertDialog对象，\nAlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();\nalertDialog.show();\n// 设置AlertDialog的布局\nalertDialog.getWindow().setContentView(R.layout.dialog);\n// 子控件的初始化和使用和Activity下类似\nTextView textview = (TextView)alertDialog.getWindow().findViewById(R.id.textview);\ntitle.setText(&quot;example&quot;);</code></pre>\n<p>AlertDialog 的关闭方法：</p>\n<pre><code class=\"java\">alertDialog.dismiss();</code></pre>\n<p>如果想要为 AlertDialog 使用自定义主题，首先在 style.xml 文件内新建一个主题。这里我继承了系统自带的 Theme.AppCompat.Light.Dialog.Alert 主题，然后一项配色，命名为 AppDialogTheme 。</p>\n<pre><code class=\"xml\">&lt;style\n  name=&quot;AppDialogTheme&quot;\n  parent=&quot;Theme.AppCompat.Light.Dialog.Alert&quot;&gt;\n  &lt;item name=&quot;colorAccent&quot;&gt;@color/colorRed&lt;/item&gt;\n&lt;/style&gt;</code></pre>\n<p>然后在 AlertDialog 的构造方法中，增加指定主题样式的参数。</p>\n<pre><code class=\"java\">AlertDialog alertDialog = new AlertDialog.Builder(\n  MainActivity.this, R.style.AppDialogTheme\n).create();</code></pre>\n<p>AlertDialog 显示时默认不可以使用输入法。如果需要在弹出的对话框中使用 EditText 、让用户输入内容，需要在执行 <code>show</code> 方法后加入另外两行代码。</p>\n<pre><code class=\"java\">// 允许输入法弹出\nalertDialog.getWindow().clearFlags( WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM );\nalertDialog.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE );</code></pre>\n","site":{"data":{}},"excerpt":"<p>首先创建 AlertDialog 对话框的布局文件：</p>\n<pre><code class=\"xml\">&lt;LinearLayout\n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  android:layout_width=&quot;300dp&quot;\n  android:layout_height=&quot;200dp&quot;\n  android:paddingTop=&quot;@dimen/dialog_margin_top&quot;\n  android:paddingBottom=&quot;@dimen/dialog_margin_bottom&quot;\n  android:paddingLeft=&quot;@dimen/long_margin&quot;\n  android:paddingRight=&quot;@dimen/long_margin&quot;\n  android:layout_gravity=&quot;center&quot;\n  android:background=&quot;#ffffff&quot; &gt;\n  &lt;TextView\n    android:id=&quot;@+id/textview&quot;\n    android:layout_width=&quot;wrap_content&quot;\n    android:layout_height=&quot;wrap_content&quot;/&gt;\n&lt;/LinearLayout&gt;</code></pre>","more":"<p>构造 AlertDialog ：</p>\n<pre><code class=\"java\">// 创建一个AlertDialog对象，\nAlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();\nalertDialog.show();\n// 设置AlertDialog的布局\nalertDialog.getWindow().setContentView(R.layout.dialog);\n// 子控件的初始化和使用和Activity下类似\nTextView textview = (TextView)alertDialog.getWindow().findViewById(R.id.textview);\ntitle.setText(&quot;example&quot;);</code></pre>\n<p>AlertDialog 的关闭方法：</p>\n<pre><code class=\"java\">alertDialog.dismiss();</code></pre>\n<p>如果想要为 AlertDialog 使用自定义主题，首先在 style.xml 文件内新建一个主题。这里我继承了系统自带的 Theme.AppCompat.Light.Dialog.Alert 主题，然后一项配色，命名为 AppDialogTheme 。</p>\n<pre><code class=\"xml\">&lt;style\n  name=&quot;AppDialogTheme&quot;\n  parent=&quot;Theme.AppCompat.Light.Dialog.Alert&quot;&gt;\n  &lt;item name=&quot;colorAccent&quot;&gt;@color/colorRed&lt;/item&gt;\n&lt;/style&gt;</code></pre>\n<p>然后在 AlertDialog 的构造方法中，增加指定主题样式的参数。</p>\n<pre><code class=\"java\">AlertDialog alertDialog = new AlertDialog.Builder(\n  MainActivity.this, R.style.AppDialogTheme\n).create();</code></pre>\n<p>AlertDialog 显示时默认不可以使用输入法。如果需要在弹出的对话框中使用 EditText 、让用户输入内容，需要在执行 <code>show</code> 方法后加入另外两行代码。</p>\n<pre><code class=\"java\">// 允许输入法弹出\nalertDialog.getWindow().clearFlags( WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM );\nalertDialog.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE );</code></pre>"},{"title":"使用 shape 实现矢量圆角背景","date":"2016-02-08T11:55:38.000Z","_content":"\n在 drawable 目录下新建 background.xml 资源文件。\n\n``` xml\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\">   \n  <solid\n    android:color=\"#fff\" />   \n  <corners\n    android:topLeftRadius=\"5dp\"\n    android:topRightRadius=\"5dp\"\n    android:bottomRightRadius=\"5dp\"\n    android:bottomLeftRadius=\"5dp\" />\n</shape>\n```\n\n<!-- more -->\n\n`solid` 标签定义该矢量图的背景色为白色，`corners` 定义该矢量图的四个角为半径 5dp 的圆角。\n\n像使用图片背景一样引用即可。\n\n``` xml\nandroid:background=\"@drawable/background\"\n```","source":"_posts/2016-02-08@使用 shape 实现矢量圆角背景.md","raw":"---\ntitle: 使用 shape 实现矢量圆角背景\ncategories:\n  - Android\ndate: 2016-02-08 19:55:38\ntags:\n  - Android\n---\n\n在 drawable 目录下新建 background.xml 资源文件。\n\n``` xml\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\">   \n  <solid\n    android:color=\"#fff\" />   \n  <corners\n    android:topLeftRadius=\"5dp\"\n    android:topRightRadius=\"5dp\"\n    android:bottomRightRadius=\"5dp\"\n    android:bottomLeftRadius=\"5dp\" />\n</shape>\n```\n\n<!-- more -->\n\n`solid` 标签定义该矢量图的背景色为白色，`corners` 定义该矢量图的四个角为半径 5dp 的圆角。\n\n像使用图片背景一样引用即可。\n\n``` xml\nandroid:background=\"@drawable/background\"\n```","slug":"2016-02-08@使用 shape 实现矢量圆角背景","published":1,"updated":"2020-06-29T03:32:42.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47b002nrqgjcash4nbq","content":"<p>在 drawable 目录下新建 background.xml 资源文件。</p>\n<pre><code class=\"xml\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;   \n  &lt;solid\n    android:color=&quot;#fff&quot; /&gt;   \n  &lt;corners\n    android:topLeftRadius=&quot;5dp&quot;\n    android:topRightRadius=&quot;5dp&quot;\n    android:bottomRightRadius=&quot;5dp&quot;\n    android:bottomLeftRadius=&quot;5dp&quot; /&gt;\n&lt;/shape&gt;</code></pre>\n<a id=\"more\"></a>\n\n<p><code>solid</code> 标签定义该矢量图的背景色为白色，<code>corners</code> 定义该矢量图的四个角为半径 5dp 的圆角。</p>\n<p>像使用图片背景一样引用即可。</p>\n<pre><code class=\"xml\">android:background=&quot;@drawable/background&quot;</code></pre>\n","site":{"data":{}},"excerpt":"<p>在 drawable 目录下新建 background.xml 资源文件。</p>\n<pre><code class=\"xml\">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;   \n  &lt;solid\n    android:color=&quot;#fff&quot; /&gt;   \n  &lt;corners\n    android:topLeftRadius=&quot;5dp&quot;\n    android:topRightRadius=&quot;5dp&quot;\n    android:bottomRightRadius=&quot;5dp&quot;\n    android:bottomLeftRadius=&quot;5dp&quot; /&gt;\n&lt;/shape&gt;</code></pre>","more":"<p><code>solid</code> 标签定义该矢量图的背景色为白色，<code>corners</code> 定义该矢量图的四个角为半径 5dp 的圆角。</p>\n<p>像使用图片背景一样引用即可。</p>\n<pre><code class=\"xml\">android:background=&quot;@drawable/background&quot;</code></pre>"},{"title":"EditText 光标定位到最后","date":"2016-02-12T17:01:30.000Z","_content":"\n有时候我们需要把 EditText 的光标定位到内容的最末尾。\n\n比如让用户修改某些信息的时候，为了对用户更友好，我们把用户之前设置的内容填充进入。Android 并不会自动把光标移动到内容的末端，需要手动完成。\n\n<!-- more -->\n\n``` js\nedittext.setText(\"example\");\nedittext.setSelection(edittext.getText().length());\n```\n\n使用 EditText 的 setSelection 方法，设置光标定位的位置为 EditText 的内容长度，就这么简单。","source":"_posts/2016-02-13@EditText 光标定位到最后.md","raw":"---\ntitle: EditText 光标定位到最后\ncategories:\n  - Android\ndate: 2016-02-13 01:01:30\ntags:\n  - Android\n  - Java\n---\n\n有时候我们需要把 EditText 的光标定位到内容的最末尾。\n\n比如让用户修改某些信息的时候，为了对用户更友好，我们把用户之前设置的内容填充进入。Android 并不会自动把光标移动到内容的末端，需要手动完成。\n\n<!-- more -->\n\n``` js\nedittext.setText(\"example\");\nedittext.setSelection(edittext.getText().length());\n```\n\n使用 EditText 的 setSelection 方法，设置光标定位的位置为 EditText 的内容长度，就这么简单。","slug":"2016-02-13@EditText 光标定位到最后","published":1,"updated":"2020-06-29T03:32:42.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47f002rrqgj944hc1o0","content":"<p>有时候我们需要把 EditText 的光标定位到内容的最末尾。</p>\n<p>比如让用户修改某些信息的时候，为了对用户更友好，我们把用户之前设置的内容填充进入。Android 并不会自动把光标移动到内容的末端，需要手动完成。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"js\">edittext.setText(&quot;example&quot;);\nedittext.setSelection(edittext.getText().length());</code></pre>\n<p>使用 EditText 的 setSelection 方法，设置光标定位的位置为 EditText 的内容长度，就这么简单。</p>\n","site":{"data":{}},"excerpt":"<p>有时候我们需要把 EditText 的光标定位到内容的最末尾。</p>\n<p>比如让用户修改某些信息的时候，为了对用户更友好，我们把用户之前设置的内容填充进入。Android 并不会自动把光标移动到内容的末端，需要手动完成。</p>","more":"<pre><code class=\"js\">edittext.setText(&quot;example&quot;);\nedittext.setSelection(edittext.getText().length());</code></pre>\n<p>使用 EditText 的 setSelection 方法，设置光标定位的位置为 EditText 的内容长度，就这么简单。</p>"},{"title":"全局获取 Context 的两种方法","date":"2016-02-13T04:17:47.000Z","_content":"\n在某些场景下我们无法调用 `getBaseContext` 和 `getContext` 方法，但依然需要获得 Context ，怎么办？有两种方法可以实现全局获取 Context 对象。\n\n<!-- more -->\n\n第一种方法通过自定义 Application 类实现，Application 类是应用每次启动都会初始化的类。\n\n首先，新建一个 App 类，继承自 Application 类。\n\n``` java\npublic class App extends Application {\n\n  private static Context context;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    context=getApplicationContext();\n  }\n\n  public static Context getContext() {\n    return context;\n  }\n}\n```\n\n在 Manifest 文件中注册该类，使应用每次启动时初始化这个类。\n\n``` xml\n<application\n  android:name=\".App\"\n  ... >\n```\n\n当需要获取 Context 的时候，只需：\n\n``` java\nContext context = App.getContext();\n```\n\n第二种方法与第一种类似。\n\n新建一个 MyContext 类作为工具类，同样继承自 Application 。\n\n``` java\npublic class MyContext extends Application {\n\n  private static Context instance;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    instance = this;\n  }\n\n  public static Context getInstance() {\n    return instance;\n  }\n\n}\n```\n\n当需要获取 Context 的时候，只需：\n\n``` java\nContext context = MyContext.getInstance();\n```","source":"_posts/2016-02-13@全局获取 Context 的两种方法.md","raw":"---\ntitle: 全局获取 Context 的两种方法\ncategories:\n  - Android\ndate: 2016-02-13 12:17:47\ntags:\n  - Android\n  - Java\n---\n\n在某些场景下我们无法调用 `getBaseContext` 和 `getContext` 方法，但依然需要获得 Context ，怎么办？有两种方法可以实现全局获取 Context 对象。\n\n<!-- more -->\n\n第一种方法通过自定义 Application 类实现，Application 类是应用每次启动都会初始化的类。\n\n首先，新建一个 App 类，继承自 Application 类。\n\n``` java\npublic class App extends Application {\n\n  private static Context context;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    context=getApplicationContext();\n  }\n\n  public static Context getContext() {\n    return context;\n  }\n}\n```\n\n在 Manifest 文件中注册该类，使应用每次启动时初始化这个类。\n\n``` xml\n<application\n  android:name=\".App\"\n  ... >\n```\n\n当需要获取 Context 的时候，只需：\n\n``` java\nContext context = App.getContext();\n```\n\n第二种方法与第一种类似。\n\n新建一个 MyContext 类作为工具类，同样继承自 Application 。\n\n``` java\npublic class MyContext extends Application {\n\n  private static Context instance;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    instance = this;\n  }\n\n  public static Context getInstance() {\n    return instance;\n  }\n\n}\n```\n\n当需要获取 Context 的时候，只需：\n\n``` java\nContext context = MyContext.getInstance();\n```","slug":"2016-02-13@全局获取 Context 的两种方法","published":1,"updated":"2020-06-29T03:32:42.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47h002trqgjf85t1o7s","content":"<p>在某些场景下我们无法调用 <code>getBaseContext</code> 和 <code>getContext</code> 方法，但依然需要获得 Context ，怎么办？有两种方法可以实现全局获取 Context 对象。</p>\n<a id=\"more\"></a>\n\n<p>第一种方法通过自定义 Application 类实现，Application 类是应用每次启动都会初始化的类。</p>\n<p>首先，新建一个 App 类，继承自 Application 类。</p>\n<pre><code class=\"java\">public class App extends Application {\n\n  private static Context context;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    context=getApplicationContext();\n  }\n\n  public static Context getContext() {\n    return context;\n  }\n}</code></pre>\n<p>在 Manifest 文件中注册该类，使应用每次启动时初始化这个类。</p>\n<pre><code class=\"xml\">&lt;application\n  android:name=&quot;.App&quot;\n  ... &gt;</code></pre>\n<p>当需要获取 Context 的时候，只需：</p>\n<pre><code class=\"java\">Context context = App.getContext();</code></pre>\n<p>第二种方法与第一种类似。</p>\n<p>新建一个 MyContext 类作为工具类，同样继承自 Application 。</p>\n<pre><code class=\"java\">public class MyContext extends Application {\n\n  private static Context instance;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    instance = this;\n  }\n\n  public static Context getInstance() {\n    return instance;\n  }\n\n}</code></pre>\n<p>当需要获取 Context 的时候，只需：</p>\n<pre><code class=\"java\">Context context = MyContext.getInstance();</code></pre>\n","site":{"data":{}},"excerpt":"<p>在某些场景下我们无法调用 <code>getBaseContext</code> 和 <code>getContext</code> 方法，但依然需要获得 Context ，怎么办？有两种方法可以实现全局获取 Context 对象。</p>","more":"<p>第一种方法通过自定义 Application 类实现，Application 类是应用每次启动都会初始化的类。</p>\n<p>首先，新建一个 App 类，继承自 Application 类。</p>\n<pre><code class=\"java\">public class App extends Application {\n\n  private static Context context;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    context=getApplicationContext();\n  }\n\n  public static Context getContext() {\n    return context;\n  }\n}</code></pre>\n<p>在 Manifest 文件中注册该类，使应用每次启动时初始化这个类。</p>\n<pre><code class=\"xml\">&lt;application\n  android:name=&quot;.App&quot;\n  ... &gt;</code></pre>\n<p>当需要获取 Context 的时候，只需：</p>\n<pre><code class=\"java\">Context context = App.getContext();</code></pre>\n<p>第二种方法与第一种类似。</p>\n<p>新建一个 MyContext 类作为工具类，同样继承自 Application 。</p>\n<pre><code class=\"java\">public class MyContext extends Application {\n\n  private static Context instance;\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    instance = this;\n  }\n\n  public static Context getInstance() {\n    return instance;\n  }\n\n}</code></pre>\n<p>当需要获取 Context 的时候，只需：</p>\n<pre><code class=\"java\">Context context = MyContext.getInstance();</code></pre>"},{"title":"修改 Tomcat 服务器默认字符","date":"2016-04-07T14:43:11.000Z","_content":"\n在 JSP 中使用 get 方式传递中文将产生乱码，且不能用 request 对象指定字符来解决，必须配置 Tomcat 服务器的参数。\n\n1、打开 conf/server.xml 文件。\n\n<!-- more -->\n\n2、在 Connector 标签下添加属性 `URIEncoding=\"utf-8\"` 。\n\n```\n<Connector\n  port=\"8080\"\n  protocol=\"HTTP/1.1\"\n  connectionTimeout=\"20000\"\n  redirectPort=\"8443\" \n  URIEncoding=\"utf-8\"/>\n```\n\n3、重启 Tomcat 服务器。\n","source":"_posts/2016-04-07@修改 Tomcat 服务器默认字符.md","raw":"---\ntitle: 修改 Tomcat 服务器默认字符\ncategories:\n  - Web Back-end\ndate: 2016-04-07 22:43:11\ntags:\n  - Tomcat\n---\n\n在 JSP 中使用 get 方式传递中文将产生乱码，且不能用 request 对象指定字符来解决，必须配置 Tomcat 服务器的参数。\n\n1、打开 conf/server.xml 文件。\n\n<!-- more -->\n\n2、在 Connector 标签下添加属性 `URIEncoding=\"utf-8\"` 。\n\n```\n<Connector\n  port=\"8080\"\n  protocol=\"HTTP/1.1\"\n  connectionTimeout=\"20000\"\n  redirectPort=\"8443\" \n  URIEncoding=\"utf-8\"/>\n```\n\n3、重启 Tomcat 服务器。\n","slug":"2016-04-07@修改 Tomcat 服务器默认字符","published":1,"updated":"2020-06-29T03:32:42.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47k002xrqgjcta6cgmf","content":"<p>在 JSP 中使用 get 方式传递中文将产生乱码，且不能用 request 对象指定字符来解决，必须配置 Tomcat 服务器的参数。</p>\n<p>1、打开 conf/server.xml 文件。</p>\n<a id=\"more\"></a>\n\n<p>2、在 Connector 标签下添加属性 <code>URIEncoding=&quot;utf-8&quot;</code> 。</p>\n<pre><code>&lt;Connector\n  port=&quot;8080&quot;\n  protocol=&quot;HTTP/1.1&quot;\n  connectionTimeout=&quot;20000&quot;\n  redirectPort=&quot;8443&quot; \n  URIEncoding=&quot;utf-8&quot;/&gt;</code></pre><p>3、重启 Tomcat 服务器。</p>\n","site":{"data":{}},"excerpt":"<p>在 JSP 中使用 get 方式传递中文将产生乱码，且不能用 request 对象指定字符来解决，必须配置 Tomcat 服务器的参数。</p>\n<p>1、打开 conf/server.xml 文件。</p>","more":"<p>2、在 Connector 标签下添加属性 <code>URIEncoding=&quot;utf-8&quot;</code> 。</p>\n<pre><code>&lt;Connector\n  port=&quot;8080&quot;\n  protocol=&quot;HTTP/1.1&quot;\n  connectionTimeout=&quot;20000&quot;\n  redirectPort=&quot;8443&quot; \n  URIEncoding=&quot;utf-8&quot;/&gt;</code></pre><p>3、重启 Tomcat 服务器。</p>"},{"title":"通过 CSS 引用外部字体","date":"2016-08-10T11:17:15.000Z","_content":"\n引用文件：\n\n``` css\n@font-face { \n  font-family: MyFont; /*字体名字*/ \n  src: url(MyFont.ttf); /*文件路径*/ \n}\n```\n<!-- more -->\n\n使用字体：\n\n``` css\n.text { \n  font-family: MyFont; \n}\n```","source":"_posts/2016-08-10@通过 CSS 引用外部字体.md","raw":"---\ntitle: 通过 CSS 引用外部字体\ncategories:\n  - Web Front-end\ndate: 2016-08-10 19:17:15\ntags:\n  - CSS\n---\n\n引用文件：\n\n``` css\n@font-face { \n  font-family: MyFont; /*字体名字*/ \n  src: url(MyFont.ttf); /*文件路径*/ \n}\n```\n<!-- more -->\n\n使用字体：\n\n``` css\n.text { \n  font-family: MyFont; \n}\n```","slug":"2016-08-10@通过 CSS 引用外部字体","published":1,"updated":"2020-06-29T03:32:42.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47l0030rqgjc4ea2vsz","content":"<p>引用文件：</p>\n<pre><code class=\"css\">@font-face { \n  font-family: MyFont; /*字体名字*/ \n  src: url(MyFont.ttf); /*文件路径*/ \n}</code></pre>\n<a id=\"more\"></a>\n\n<p>使用字体：</p>\n<pre><code class=\"css\">.text { \n  font-family: MyFont; \n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>引用文件：</p>\n<pre><code class=\"css\">@font-face { \n  font-family: MyFont; /*字体名字*/ \n  src: url(MyFont.ttf); /*文件路径*/ \n}</code></pre>","more":"<p>使用字体：</p>\n<pre><code class=\"css\">.text { \n  font-family: MyFont; \n}</code></pre>"},{"title":"获取浏览器可视区域的尺寸","date":"2016-08-02T07:03:09.000Z","_content":"\n在不同浏览器都实用的 JavaScript 方案：\n\n``` js\nvar w= document.documentElement.clientWidth || document.body.clientWidth;\nvar h= document.documentElement.clientHeight || document.body.clientHeight;\n```\n","source":"_posts/2016-08-02@获取浏览器可视区域的尺寸.md","raw":"---\ntitle: 获取浏览器可视区域的尺寸\ncategories:\n  - Web Front-end\ndate: 2016-08-02 15:03:09\ntags:\n  - JavaScript\n---\n\n在不同浏览器都实用的 JavaScript 方案：\n\n``` js\nvar w= document.documentElement.clientWidth || document.body.clientWidth;\nvar h= document.documentElement.clientHeight || document.body.clientHeight;\n```\n","slug":"2016-08-02@获取浏览器可视区域的尺寸","published":1,"updated":"2020-06-29T03:32:42.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47m0034rqgj6abf8gxi","content":"<p>在不同浏览器都实用的 JavaScript 方案：</p>\n<pre><code class=\"js\">var w= document.documentElement.clientWidth || document.body.clientWidth;\nvar h= document.documentElement.clientHeight || document.body.clientHeight;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>在不同浏览器都实用的 JavaScript 方案：</p>\n<pre><code class=\"js\">var w= document.documentElement.clientWidth || document.body.clientWidth;\nvar h= document.documentElement.clientHeight || document.body.clientHeight;</code></pre>\n"},{"title":"JS 倒计时代码","date":"2016-08-11T13:05:35.000Z","_content":"\n网站发送验证码后，通常需要有一个倒计时器。在倒计时期间关闭“获取验证码”按钮，以防用户频繁地获取验证码。\n\n我是利用 JS 的 setTimeout 方法实现倒计时的，基本示例如下，加上更新前端的代码即可完成倒数。\n\n<!-- more -->\n\n``` js\nvar time = 60;\ndocument.write(time--+\"<br>\"); \nsetCountdown(time);\n\nfunction setCountdown(time){\n\tdocument.write(time--+\"<br>\"); \n\tsetTimeout(function(){ setCountdown(time) },1000);\n}\n```","source":"_posts/2016-08-11@JS 倒计时代码.md","raw":"---\ntitle: JS 倒计时代码\ncategories:\n  - Web Front-end\ndate: 2016-08-11 21:05:35\ntags:\n  - JavaScript\n---\n\n网站发送验证码后，通常需要有一个倒计时器。在倒计时期间关闭“获取验证码”按钮，以防用户频繁地获取验证码。\n\n我是利用 JS 的 setTimeout 方法实现倒计时的，基本示例如下，加上更新前端的代码即可完成倒数。\n\n<!-- more -->\n\n``` js\nvar time = 60;\ndocument.write(time--+\"<br>\"); \nsetCountdown(time);\n\nfunction setCountdown(time){\n\tdocument.write(time--+\"<br>\"); \n\tsetTimeout(function(){ setCountdown(time) },1000);\n}\n```","slug":"2016-08-11@JS 倒计时代码","published":1,"updated":"2020-06-29T03:32:42.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47o0038rqgj5j4yccvv","content":"<p>网站发送验证码后，通常需要有一个倒计时器。在倒计时期间关闭“获取验证码”按钮，以防用户频繁地获取验证码。</p>\n<p>我是利用 JS 的 setTimeout 方法实现倒计时的，基本示例如下，加上更新前端的代码即可完成倒数。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"js\">var time = 60;\ndocument.write(time--+&quot;&lt;br&gt;&quot;); \nsetCountdown(time);\n\nfunction setCountdown(time){\n    document.write(time--+&quot;&lt;br&gt;&quot;); \n    setTimeout(function(){ setCountdown(time) },1000);\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>网站发送验证码后，通常需要有一个倒计时器。在倒计时期间关闭“获取验证码”按钮，以防用户频繁地获取验证码。</p>\n<p>我是利用 JS 的 setTimeout 方法实现倒计时的，基本示例如下，加上更新前端的代码即可完成倒数。</p>","more":"<pre><code class=\"js\">var time = 60;\ndocument.write(time--+&quot;&lt;br&gt;&quot;); \nsetCountdown(time);\n\nfunction setCountdown(time){\n    document.write(time--+&quot;&lt;br&gt;&quot;); \n    setTimeout(function(){ setCountdown(time) },1000);\n}</code></pre>"},{"title":"使用 jQuery 实现 AJAX 异步请求","date":"2016-08-11T14:42:09.000Z","_content":"\n引用 jQuery 库文件。\n\n``` xhtml\n<script type=\"text/javascript\" src=\"js/jquery-3.1.0.min.js\"></script>\n```\n<!-- more -->\n\n在脚本中添加 ajax（GET方式）：\n\n``` js\n$.ajax({\n\turl:  'target.php',  // 请求路径\n\ttype: 'get',  // 请求类型\n\tdata: { \n\t\t// 参数\n\t\tusername: \"caiyiming\",\n\t\tpassword: \"123456\"\n\t},\n\tasync : false,  // 是否异步执行\n\tsuccess: function(response){\n\t\t// 成功后调用的代码\n\t},\n\terror: function(result) {  \n\t\t// 失败后调用的代码\n\t}  \n});\n```\n使用 POST 方式：\n\n``` js\n$.ajax({\n\turl:  'target.php', \n\ttype: 'post',\n\tdata: { \n\t\tusername: \"caiyiming\"\n\t},\n\tasync : false,\n\tsuccess: function(response){\n\t},\n\terror: function(response) { \n\t}  \n});\n```","source":"_posts/2016-08-11@jQuery 使用 AJAX 实现异步请求.md","raw":"---\ntitle: 使用 jQuery 实现 AJAX 异步请求\ncategories:\n  - Web Front-end\ndate: 2016-08-11 22:42:09\ntags:\n  - jQuery\n  - AJAX\n  - JavaScript\n---\n\n引用 jQuery 库文件。\n\n``` xhtml\n<script type=\"text/javascript\" src=\"js/jquery-3.1.0.min.js\"></script>\n```\n<!-- more -->\n\n在脚本中添加 ajax（GET方式）：\n\n``` js\n$.ajax({\n\turl:  'target.php',  // 请求路径\n\ttype: 'get',  // 请求类型\n\tdata: { \n\t\t// 参数\n\t\tusername: \"caiyiming\",\n\t\tpassword: \"123456\"\n\t},\n\tasync : false,  // 是否异步执行\n\tsuccess: function(response){\n\t\t// 成功后调用的代码\n\t},\n\terror: function(result) {  \n\t\t// 失败后调用的代码\n\t}  \n});\n```\n使用 POST 方式：\n\n``` js\n$.ajax({\n\turl:  'target.php', \n\ttype: 'post',\n\tdata: { \n\t\tusername: \"caiyiming\"\n\t},\n\tasync : false,\n\tsuccess: function(response){\n\t},\n\terror: function(response) { \n\t}  \n});\n```","slug":"2016-08-11@jQuery 使用 AJAX 实现异步请求","published":1,"updated":"2020-06-29T03:32:42.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47p003brqgj64rp5qd2","content":"<p>引用 jQuery 库文件。</p>\n<pre><code class=\"xhtml\">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.0.min.js&quot;&gt;&lt;/script&gt;</code></pre>\n<a id=\"more\"></a>\n\n<p>在脚本中添加 ajax（GET方式）：</p>\n<pre><code class=\"js\">$.ajax({\n    url:  &#39;target.php&#39;,  // 请求路径\n    type: &#39;get&#39;,  // 请求类型\n    data: { \n        // 参数\n        username: &quot;caiyiming&quot;,\n        password: &quot;123456&quot;\n    },\n    async : false,  // 是否异步执行\n    success: function(response){\n        // 成功后调用的代码\n    },\n    error: function(result) {  \n        // 失败后调用的代码\n    }  \n});</code></pre>\n<p>使用 POST 方式：</p>\n<pre><code class=\"js\">$.ajax({\n    url:  &#39;target.php&#39;, \n    type: &#39;post&#39;,\n    data: { \n        username: &quot;caiyiming&quot;\n    },\n    async : false,\n    success: function(response){\n    },\n    error: function(response) { \n    }  \n});</code></pre>\n","site":{"data":{}},"excerpt":"<p>引用 jQuery 库文件。</p>\n<pre><code class=\"xhtml\">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.0.min.js&quot;&gt;&lt;/script&gt;</code></pre>","more":"<p>在脚本中添加 ajax（GET方式）：</p>\n<pre><code class=\"js\">$.ajax({\n    url:  &#39;target.php&#39;,  // 请求路径\n    type: &#39;get&#39;,  // 请求类型\n    data: { \n        // 参数\n        username: &quot;caiyiming&quot;,\n        password: &quot;123456&quot;\n    },\n    async : false,  // 是否异步执行\n    success: function(response){\n        // 成功后调用的代码\n    },\n    error: function(result) {  \n        // 失败后调用的代码\n    }  \n});</code></pre>\n<p>使用 POST 方式：</p>\n<pre><code class=\"js\">$.ajax({\n    url:  &#39;target.php&#39;, \n    type: &#39;post&#39;,\n    data: { \n        username: &quot;caiyiming&quot;\n    },\n    async : false,\n    success: function(response){\n    },\n    error: function(response) { \n    }  \n});</code></pre>"},{"title":"PHP 中实现 URL 跳转","date":"2016-08-14T10:14:18.000Z","_content":"\nJavaScrip 方式：\n\n``` php\n$link=\"target.html\";\necho \"<script type = \\\"text/javascript\\\">window.location.href='\".$link.\"'</script>\";\n```","source":"_posts/2016-08-14@PHP 中实现 URL 跳转.md","raw":"---\ntitle: PHP 中实现 URL 跳转\ncategories:\n  - Web Back-end\ndate: 2016-08-14 18:14:18\ntags:\n  - PHP\n---\n\nJavaScrip 方式：\n\n``` php\n$link=\"target.html\";\necho \"<script type = \\\"text/javascript\\\">window.location.href='\".$link.\"'</script>\";\n```","slug":"2016-08-14@PHP 中实现 URL 跳转","published":1,"updated":"2020-06-29T03:32:42.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47r003frqgjgfaaa6cw","content":"<p>JavaScrip 方式：</p>\n<pre><code class=\"php\">$link=&quot;target.html&quot;;\necho &quot;&lt;script type = \\&quot;text/javascript\\&quot;&gt;window.location.href=&#39;&quot;.$link.&quot;&#39;&lt;/script&gt;&quot;;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScrip 方式：</p>\n<pre><code class=\"php\">$link=&quot;target.html&quot;;\necho &quot;&lt;script type = \\&quot;text/javascript\\&quot;&gt;window.location.href=&#39;&quot;.$link.&quot;&#39;&lt;/script&gt;&quot;;</code></pre>\n"},{"title":"Textarea 的换行符处理","date":"2016-08-21T03:50:36.000Z","_content":"\n用户使用 textarea 控件输入的包含回车换行的内容，后端获取后存储到数据库会变成一整段文本，存在换行符丢失的问题。为了保留换行符，需要在前后端通信的过程中做一些必要的处理。\n\n<!-- more -->\n\n使用 JavaScript 把字符串中的所有换行符替换为 `<br/>` ，再存到MySQL数据库中，以后前端显示时就可以直接打印这个字符串。\n\n``` js\nstring = string.replace(/\\n/g,\"<br/>\");\n```\n\n如果用户要通过 textarea 再次编辑该字符串，使用 PHP 把所有的 `<br/>` 替换为换行符后再显示给用户。\n\n``` php\n$string = str_replace(\"<br/>\",\"\\n\",$string);\n```","source":"_posts/2016-08-21@Textarea 的换行符处理.md","raw":"---\ntitle: Textarea 的换行符处理\ncategories:\n  - Web Front-end\ndate: 2016-08-21 11:50:36\ntags:\n  - JavaScript\n  - PHP\n---\n\n用户使用 textarea 控件输入的包含回车换行的内容，后端获取后存储到数据库会变成一整段文本，存在换行符丢失的问题。为了保留换行符，需要在前后端通信的过程中做一些必要的处理。\n\n<!-- more -->\n\n使用 JavaScript 把字符串中的所有换行符替换为 `<br/>` ，再存到MySQL数据库中，以后前端显示时就可以直接打印这个字符串。\n\n``` js\nstring = string.replace(/\\n/g,\"<br/>\");\n```\n\n如果用户要通过 textarea 再次编辑该字符串，使用 PHP 把所有的 `<br/>` 替换为换行符后再显示给用户。\n\n``` php\n$string = str_replace(\"<br/>\",\"\\n\",$string);\n```","slug":"2016-08-21@Textarea 的换行符处理","published":1,"updated":"2020-06-29T03:32:42.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47v003irqgj2p4vegx9","content":"<p>用户使用 textarea 控件输入的包含回车换行的内容，后端获取后存储到数据库会变成一整段文本，存在换行符丢失的问题。为了保留换行符，需要在前后端通信的过程中做一些必要的处理。</p>\n<a id=\"more\"></a>\n\n<p>使用 JavaScript 把字符串中的所有换行符替换为 <code>&lt;br/&gt;</code> ，再存到MySQL数据库中，以后前端显示时就可以直接打印这个字符串。</p>\n<pre><code class=\"js\">string = string.replace(/\\n/g,&quot;&lt;br/&gt;&quot;);</code></pre>\n<p>如果用户要通过 textarea 再次编辑该字符串，使用 PHP 把所有的 <code>&lt;br/&gt;</code> 替换为换行符后再显示给用户。</p>\n<pre><code class=\"php\">$string = str_replace(&quot;&lt;br/&gt;&quot;,&quot;\\n&quot;,$string);</code></pre>\n","site":{"data":{}},"excerpt":"<p>用户使用 textarea 控件输入的包含回车换行的内容，后端获取后存储到数据库会变成一整段文本，存在换行符丢失的问题。为了保留换行符，需要在前后端通信的过程中做一些必要的处理。</p>","more":"<p>使用 JavaScript 把字符串中的所有换行符替换为 <code>&lt;br/&gt;</code> ，再存到MySQL数据库中，以后前端显示时就可以直接打印这个字符串。</p>\n<pre><code class=\"js\">string = string.replace(/\\n/g,&quot;&lt;br/&gt;&quot;);</code></pre>\n<p>如果用户要通过 textarea 再次编辑该字符串，使用 PHP 把所有的 <code>&lt;br/&gt;</code> 替换为换行符后再显示给用户。</p>\n<pre><code class=\"php\">$string = str_replace(&quot;&lt;br/&gt;&quot;,&quot;\\n&quot;,$string);</code></pre>"},{"title":"Canvas 不支持使用 CSS 设置尺寸","date":"2016-08-28T15:47:11.000Z","_content":"\n如果用 Canvas 画一个图形（我这里生成的是用户头像），生成 DataUrl 后把图片保存到本地，就会发现图形增加了不必要的宽度和高度。如果保存的格式是 jpg ，那么多余的部分就会表现为黑边。如果保存的格式是 png ，那么多余的部分就会表现为透明但仍占用宽高的图像。\n\n<!-- more -->\n\n通过排查我发现原因在于 Canvas 的默认宽高是300px*150px，它并不会因为你在上面 drawImage 而自动调整宽高去适应你的图形。所以你生成的图像总是有多余的部分，总是300px*150px的尺寸，显然我不能够这样保存用户的头像。\n\n于是我希望通过修改 Canvas 的尺寸来解决这个问题，使其尺寸固定，和我要生成图像尺寸一致。\n\n但是在通过 CSS 给 Canvas 添加 `style=\"width:120px; height:120px;\"` 后，Canvas 只是通过拉伸改变了尺寸，图像被扭曲、黑边仍然存在。\n\n原来，Canvas 并不支持用 CSS 来调整大小。可用的方案有两种，一是直接在标签内设置，二是通过 JS 设置。\n\n直接在标签内设置宽高：\n\n``` xhtml\n<canvas id=\"canvas\" width=\"200\" height=\"100\"></canvas>\n```\n\n通过 JS 设置宽高：\n\n``` js\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 200;\ncanvas.height = 100;\n```","source":"_posts/2016-08-28@Canvas 不支持使用 CSS 设置尺寸.md","raw":"---\ntitle: Canvas 不支持使用 CSS 设置尺寸\ncategories:\n  - Web Front-end\ndate: 2016-08-28 23:47:11\ntags:\n  - HTML\n  - Canvas\n  - JavaScript\n---\n\n如果用 Canvas 画一个图形（我这里生成的是用户头像），生成 DataUrl 后把图片保存到本地，就会发现图形增加了不必要的宽度和高度。如果保存的格式是 jpg ，那么多余的部分就会表现为黑边。如果保存的格式是 png ，那么多余的部分就会表现为透明但仍占用宽高的图像。\n\n<!-- more -->\n\n通过排查我发现原因在于 Canvas 的默认宽高是300px*150px，它并不会因为你在上面 drawImage 而自动调整宽高去适应你的图形。所以你生成的图像总是有多余的部分，总是300px*150px的尺寸，显然我不能够这样保存用户的头像。\n\n于是我希望通过修改 Canvas 的尺寸来解决这个问题，使其尺寸固定，和我要生成图像尺寸一致。\n\n但是在通过 CSS 给 Canvas 添加 `style=\"width:120px; height:120px;\"` 后，Canvas 只是通过拉伸改变了尺寸，图像被扭曲、黑边仍然存在。\n\n原来，Canvas 并不支持用 CSS 来调整大小。可用的方案有两种，一是直接在标签内设置，二是通过 JS 设置。\n\n直接在标签内设置宽高：\n\n``` xhtml\n<canvas id=\"canvas\" width=\"200\" height=\"100\"></canvas>\n```\n\n通过 JS 设置宽高：\n\n``` js\nvar canvas = document.getElementById(\"canvas\");\ncanvas.width = 200;\ncanvas.height = 100;\n```","slug":"2016-08-28@Canvas 不支持使用 CSS 设置尺寸","published":1,"updated":"2020-06-29T03:32:42.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt47w003lrqgj1l608xvl","content":"<p>如果用 Canvas 画一个图形（我这里生成的是用户头像），生成 DataUrl 后把图片保存到本地，就会发现图形增加了不必要的宽度和高度。如果保存的格式是 jpg ，那么多余的部分就会表现为黑边。如果保存的格式是 png ，那么多余的部分就会表现为透明但仍占用宽高的图像。</p>\n<a id=\"more\"></a>\n\n<p>通过排查我发现原因在于 Canvas 的默认宽高是300px<em>150px，它并不会因为你在上面 drawImage 而自动调整宽高去适应你的图形。所以你生成的图像总是有多余的部分，总是300px</em>150px的尺寸，显然我不能够这样保存用户的头像。</p>\n<p>于是我希望通过修改 Canvas 的尺寸来解决这个问题，使其尺寸固定，和我要生成图像尺寸一致。</p>\n<p>但是在通过 CSS 给 Canvas 添加 <code>style=&quot;width:120px; height:120px;&quot;</code> 后，Canvas 只是通过拉伸改变了尺寸，图像被扭曲、黑边仍然存在。</p>\n<p>原来，Canvas 并不支持用 CSS 来调整大小。可用的方案有两种，一是直接在标签内设置，二是通过 JS 设置。</p>\n<p>直接在标签内设置宽高：</p>\n<pre><code class=\"xhtml\">&lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</code></pre>\n<p>通过 JS 设置宽高：</p>\n<pre><code class=\"js\">var canvas = document.getElementById(&quot;canvas&quot;);\ncanvas.width = 200;\ncanvas.height = 100;</code></pre>\n","site":{"data":{}},"excerpt":"<p>如果用 Canvas 画一个图形（我这里生成的是用户头像），生成 DataUrl 后把图片保存到本地，就会发现图形增加了不必要的宽度和高度。如果保存的格式是 jpg ，那么多余的部分就会表现为黑边。如果保存的格式是 png ，那么多余的部分就会表现为透明但仍占用宽高的图像。</p>","more":"<p>通过排查我发现原因在于 Canvas 的默认宽高是300px<em>150px，它并不会因为你在上面 drawImage 而自动调整宽高去适应你的图形。所以你生成的图像总是有多余的部分，总是300px</em>150px的尺寸，显然我不能够这样保存用户的头像。</p>\n<p>于是我希望通过修改 Canvas 的尺寸来解决这个问题，使其尺寸固定，和我要生成图像尺寸一致。</p>\n<p>但是在通过 CSS 给 Canvas 添加 <code>style=&quot;width:120px; height:120px;&quot;</code> 后，Canvas 只是通过拉伸改变了尺寸，图像被扭曲、黑边仍然存在。</p>\n<p>原来，Canvas 并不支持用 CSS 来调整大小。可用的方案有两种，一是直接在标签内设置，二是通过 JS 设置。</p>\n<p>直接在标签内设置宽高：</p>\n<pre><code class=\"xhtml\">&lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</code></pre>\n<p>通过 JS 设置宽高：</p>\n<pre><code class=\"js\">var canvas = document.getElementById(&quot;canvas&quot;);\ncanvas.width = 200;\ncanvas.height = 100;</code></pre>"},{"title":"Cropper + Canvas 实现用户头像裁剪与上传","date":"2016-08-28T15:14:24.000Z","_content":"\n第一步：使用 Github 上的开源项目 [cropper](https://github.com/fengyuanchen/cropper) 实现选择被裁剪图片、裁剪操作和不同大小头像的预览，这个项目可以返回（被裁减图片上）需要裁出的部分的坐标和尺寸。\n\n<!-- more -->\n\n第二步：通过 cropper 直接取到 x、y、w、h 四个值，就是你要裁取的图片相对原图的坐标和尺寸。\n\n第三步：使用 HTML5 的 FileReader 读取文件，然后使用 Canvas 绘制用户的头像。\n\n``` js\n//初始化canvas对象\nvar canvas=document.getElementById('my-canvas');\nvar context = canvas.getContext('2d');\n//读取被图片源文件\nvar file = input.files[0];\nvar reader = new FileReader(); reader.readAsDataURL(file);\nreader.onload=function(e){\n  var img = new Image();\n  img.src = this.result;\n  if( file!=null ){\n    //生成裁剪后的图片\n    context.drawImage(img, x, y, w, h, 0, 0, 120, 120);\n    //将图片转换成DataUrl\n    var imageData = canvas.toDataURL('image/jpeg',0.9);\n  }\n}\n```\n\n这里用到的 `drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)` 方法，参数含义如下，sx、sy 是目标矩形的起始（左上端）坐标，sw、sh 是目标矩形的宽高，dx、dy 是目标矩形绘制在 Cavans 画布上的起始位置的坐标（一般取0），dw、dh 是目标矩形绘制后的宽高（可以通过这2个参数标准化头像尺寸）。此外 `toDataURL` 方法的第1个参数表示要生成的图片格式，默认是 png ，第2个参数是可选的，表示图片压缩等级，可以取0-1之间的值。\n\n第四步：至此已经得到了图片的 DataURL ，通过 POST 方式提交，服务端接收保存图片即可。","source":"_posts/2016-08-28@Cropper + Canvas 实现用户头像裁剪与上传.md","raw":"---\ntitle: Cropper + Canvas 实现用户头像裁剪与上传\ncategories:\n  - Web Front-end\ndate: 2016-08-28 23:14:24\ntags:\n  - Canvas\n  - JavaScript\n---\n\n第一步：使用 Github 上的开源项目 [cropper](https://github.com/fengyuanchen/cropper) 实现选择被裁剪图片、裁剪操作和不同大小头像的预览，这个项目可以返回（被裁减图片上）需要裁出的部分的坐标和尺寸。\n\n<!-- more -->\n\n第二步：通过 cropper 直接取到 x、y、w、h 四个值，就是你要裁取的图片相对原图的坐标和尺寸。\n\n第三步：使用 HTML5 的 FileReader 读取文件，然后使用 Canvas 绘制用户的头像。\n\n``` js\n//初始化canvas对象\nvar canvas=document.getElementById('my-canvas');\nvar context = canvas.getContext('2d');\n//读取被图片源文件\nvar file = input.files[0];\nvar reader = new FileReader(); reader.readAsDataURL(file);\nreader.onload=function(e){\n  var img = new Image();\n  img.src = this.result;\n  if( file!=null ){\n    //生成裁剪后的图片\n    context.drawImage(img, x, y, w, h, 0, 0, 120, 120);\n    //将图片转换成DataUrl\n    var imageData = canvas.toDataURL('image/jpeg',0.9);\n  }\n}\n```\n\n这里用到的 `drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)` 方法，参数含义如下，sx、sy 是目标矩形的起始（左上端）坐标，sw、sh 是目标矩形的宽高，dx、dy 是目标矩形绘制在 Cavans 画布上的起始位置的坐标（一般取0），dw、dh 是目标矩形绘制后的宽高（可以通过这2个参数标准化头像尺寸）。此外 `toDataURL` 方法的第1个参数表示要生成的图片格式，默认是 png ，第2个参数是可选的，表示图片压缩等级，可以取0-1之间的值。\n\n第四步：至此已经得到了图片的 DataURL ，通过 POST 方式提交，服务端接收保存图片即可。","slug":"2016-08-28@Cropper + Canvas 实现用户头像裁剪与上传","published":1,"updated":"2020-06-29T03:32:42.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt480003prqgjg7yi2hv2","content":"<p>第一步：使用 Github 上的开源项目 <a href=\"https://github.com/fengyuanchen/cropper\" target=\"_blank\" rel=\"noopener\">cropper</a> 实现选择被裁剪图片、裁剪操作和不同大小头像的预览，这个项目可以返回（被裁减图片上）需要裁出的部分的坐标和尺寸。</p>\n<a id=\"more\"></a>\n\n<p>第二步：通过 cropper 直接取到 x、y、w、h 四个值，就是你要裁取的图片相对原图的坐标和尺寸。</p>\n<p>第三步：使用 HTML5 的 FileReader 读取文件，然后使用 Canvas 绘制用户的头像。</p>\n<pre><code class=\"js\">//初始化canvas对象\nvar canvas=document.getElementById(&#39;my-canvas&#39;);\nvar context = canvas.getContext(&#39;2d&#39;);\n//读取被图片源文件\nvar file = input.files[0];\nvar reader = new FileReader(); reader.readAsDataURL(file);\nreader.onload=function(e){\n  var img = new Image();\n  img.src = this.result;\n  if( file!=null ){\n    //生成裁剪后的图片\n    context.drawImage(img, x, y, w, h, 0, 0, 120, 120);\n    //将图片转换成DataUrl\n    var imageData = canvas.toDataURL(&#39;image/jpeg&#39;,0.9);\n  }\n}</code></pre>\n<p>这里用到的 <code>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</code> 方法，参数含义如下，sx、sy 是目标矩形的起始（左上端）坐标，sw、sh 是目标矩形的宽高，dx、dy 是目标矩形绘制在 Cavans 画布上的起始位置的坐标（一般取0），dw、dh 是目标矩形绘制后的宽高（可以通过这2个参数标准化头像尺寸）。此外 <code>toDataURL</code> 方法的第1个参数表示要生成的图片格式，默认是 png ，第2个参数是可选的，表示图片压缩等级，可以取0-1之间的值。</p>\n<p>第四步：至此已经得到了图片的 DataURL ，通过 POST 方式提交，服务端接收保存图片即可。</p>\n","site":{"data":{}},"excerpt":"<p>第一步：使用 Github 上的开源项目 <a href=\"https://github.com/fengyuanchen/cropper\" target=\"_blank\" rel=\"noopener\">cropper</a> 实现选择被裁剪图片、裁剪操作和不同大小头像的预览，这个项目可以返回（被裁减图片上）需要裁出的部分的坐标和尺寸。</p>","more":"<p>第二步：通过 cropper 直接取到 x、y、w、h 四个值，就是你要裁取的图片相对原图的坐标和尺寸。</p>\n<p>第三步：使用 HTML5 的 FileReader 读取文件，然后使用 Canvas 绘制用户的头像。</p>\n<pre><code class=\"js\">//初始化canvas对象\nvar canvas=document.getElementById(&#39;my-canvas&#39;);\nvar context = canvas.getContext(&#39;2d&#39;);\n//读取被图片源文件\nvar file = input.files[0];\nvar reader = new FileReader(); reader.readAsDataURL(file);\nreader.onload=function(e){\n  var img = new Image();\n  img.src = this.result;\n  if( file!=null ){\n    //生成裁剪后的图片\n    context.drawImage(img, x, y, w, h, 0, 0, 120, 120);\n    //将图片转换成DataUrl\n    var imageData = canvas.toDataURL(&#39;image/jpeg&#39;,0.9);\n  }\n}</code></pre>\n<p>这里用到的 <code>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</code> 方法，参数含义如下，sx、sy 是目标矩形的起始（左上端）坐标，sw、sh 是目标矩形的宽高，dx、dy 是目标矩形绘制在 Cavans 画布上的起始位置的坐标（一般取0），dw、dh 是目标矩形绘制后的宽高（可以通过这2个参数标准化头像尺寸）。此外 <code>toDataURL</code> 方法的第1个参数表示要生成的图片格式，默认是 png ，第2个参数是可选的，表示图片压缩等级，可以取0-1之间的值。</p>\n<p>第四步：至此已经得到了图片的 DataURL ，通过 POST 方式提交，服务端接收保存图片即可。</p>"},{"title":"检测浏览器是否支持 H5","date":"2016-08-28T15:10:32.000Z","_content":"\n通过全局对象检测：\n\n``` js\n<script>\n  window.onload = function() {\n    if (window.applicationCache) {\n      document.write(\"Yes, your browser can use offline web applications.\");\n    } else {\n      document.write(\"No, your browser cannot use offline web applications.\");\n    }\n  }\n</script>\n```","source":"_posts/2016-08-28@检测浏览器是否支持 H5.md","raw":"---\ntitle: 检测浏览器是否支持 H5\ncategories:\n  - Web Front-end\ndate: 2016-08-28 23:10:32\ntags:\n  - JavaScript\n---\n\n通过全局对象检测：\n\n``` js\n<script>\n  window.onload = function() {\n    if (window.applicationCache) {\n      document.write(\"Yes, your browser can use offline web applications.\");\n    } else {\n      document.write(\"No, your browser cannot use offline web applications.\");\n    }\n  }\n</script>\n```","slug":"2016-08-28@检测浏览器是否支持 H5","published":1,"updated":"2020-06-29T03:32:42.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt482003trqgj7uwqb9kp","content":"<p>通过全局对象检测：</p>\n<pre><code class=\"js\">&lt;script&gt;\n  window.onload = function() {\n    if (window.applicationCache) {\n      document.write(&quot;Yes, your browser can use offline web applications.&quot;);\n    } else {\n      document.write(&quot;No, your browser cannot use offline web applications.&quot;);\n    }\n  }\n&lt;/script&gt;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>通过全局对象检测：</p>\n<pre><code class=\"js\">&lt;script&gt;\n  window.onload = function() {\n    if (window.applicationCache) {\n      document.write(&quot;Yes, your browser can use offline web applications.&quot;);\n    } else {\n      document.write(&quot;No, your browser cannot use offline web applications.&quot;);\n    }\n  }\n&lt;/script&gt;</code></pre>\n"},{"title":"CSS3 实现全屏背景图片","date":"2016-08-30T05:40:08.000Z","_content":"\nWeb 开发时经常用到背景图片铺满整个屏幕，需要能够自适应各种设备。CSS3 新增的 `background-size` 可以实现这个效果，在 html 标签上添加 CSS 代码，这里用 `fixed` 和 `center` 定位背景图，然后用 `background-size` 来使图片铺满。具体代码如下，这段代码摘自互联网。\n\n<!-- more -->\n\n``` css\nhtml {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n}\n```\n\n经过实测自适应效果非常好，但该方案仍然存在 BUG ，在手机端的一些浏览器上会在页面下方出现白边。\n\n经测试发现这是因为背景图铺满的区域是 html 标签，而不是我们实际感知到的屏幕范围。有的浏览器会将 html 标签里的内容的高度作为 html 标签的高度，如果 html 的高度小于设备屏幕的高度，就会出现空白区域。解决方法也很简单，在 CSS 代码中设置 html 的高度始终为100%。\n\n``` css\nhtml {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n  height: 100%;\n}\n```","source":"_posts/2016-08-30@CSS3 实现全屏背景图片.md","raw":"---\ntitle: CSS3 实现全屏背景图片\ncategories:\n  - Web Front-end\ndate: 2016-08-30 13:40:08\ntags:\n  - CSS\n---\n\nWeb 开发时经常用到背景图片铺满整个屏幕，需要能够自适应各种设备。CSS3 新增的 `background-size` 可以实现这个效果，在 html 标签上添加 CSS 代码，这里用 `fixed` 和 `center` 定位背景图，然后用 `background-size` 来使图片铺满。具体代码如下，这段代码摘自互联网。\n\n<!-- more -->\n\n``` css\nhtml {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n}\n```\n\n经过实测自适应效果非常好，但该方案仍然存在 BUG ，在手机端的一些浏览器上会在页面下方出现白边。\n\n经测试发现这是因为背景图铺满的区域是 html 标签，而不是我们实际感知到的屏幕范围。有的浏览器会将 html 标签里的内容的高度作为 html 标签的高度，如果 html 的高度小于设备屏幕的高度，就会出现空白区域。解决方法也很简单，在 CSS 代码中设置 html 的高度始终为100%。\n\n``` css\nhtml {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n  height: 100%;\n}\n```","slug":"2016-08-30@CSS3 实现全屏背景图片","published":1,"updated":"2020-06-29T03:32:42.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt486003wrqgj1hjv2u1d","content":"<p>Web 开发时经常用到背景图片铺满整个屏幕，需要能够自适应各种设备。CSS3 新增的 <code>background-size</code> 可以实现这个效果，在 html 标签上添加 CSS 代码，这里用 <code>fixed</code> 和 <code>center</code> 定位背景图，然后用 <code>background-size</code> 来使图片铺满。具体代码如下，这段代码摘自互联网。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"css\">html {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n}</code></pre>\n<p>经过实测自适应效果非常好，但该方案仍然存在 BUG ，在手机端的一些浏览器上会在页面下方出现白边。</p>\n<p>经测试发现这是因为背景图铺满的区域是 html 标签，而不是我们实际感知到的屏幕范围。有的浏览器会将 html 标签里的内容的高度作为 html 标签的高度，如果 html 的高度小于设备屏幕的高度，就会出现空白区域。解决方法也很简单，在 CSS 代码中设置 html 的高度始终为100%。</p>\n<pre><code class=\"css\">html {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n  height: 100%;\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>Web 开发时经常用到背景图片铺满整个屏幕，需要能够自适应各种设备。CSS3 新增的 <code>background-size</code> 可以实现这个效果，在 html 标签上添加 CSS 代码，这里用 <code>fixed</code> 和 <code>center</code> 定位背景图，然后用 <code>background-size</code> 来使图片铺满。具体代码如下，这段代码摘自互联网。</p>","more":"<pre><code class=\"css\">html {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n}</code></pre>\n<p>经过实测自适应效果非常好，但该方案仍然存在 BUG ，在手机端的一些浏览器上会在页面下方出现白边。</p>\n<p>经测试发现这是因为背景图铺满的区域是 html 标签，而不是我们实际感知到的屏幕范围。有的浏览器会将 html 标签里的内容的高度作为 html 标签的高度，如果 html 的高度小于设备屏幕的高度，就会出现空白区域。解决方法也很简单，在 CSS 代码中设置 html 的高度始终为100%。</p>\n<pre><code class=\"css\">html {\n  background: url(bg.jpg) no-repeat center center fixed;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n  background-size: cover;\n  height: 100%;\n}</code></pre>"},{"title":"WampServer 局域网访问配置","date":"2016-08-30T04:11:44.000Z","_content":"\n让局域网内的其他设备（如 Pad 、手机）可以访问 WampServer 上的内容，将会非常便于测试不同设备的浏览效果。要做到这点，需要修改 Apache 配置文件，使服务器允许被局域网内的设备访问。\n\n<!-- more -->\n\n1、如果未在 WampServer 中配置虚拟主机过的情况下，直接在 http.conf 中找以下字段，一般在 `<Directory>` 标签内。将 Require local 修改为 Require all granted 即可。重启服务器后，局域网内的其他设备通过 IP 地址（如 192.168.1.1 ）访问。由于我的 WampSever 已配置过虚拟主机，未测试实际效果。\n\n```\n# onlineoffline tag - don't remove\n  Require all granted\n```\n\n2、如果 WampServer 已经配置了虚拟主机，在 httpd-vhosts.conf 中修改虚拟主机的配置。同样是将 Require local 修改为 Require all granted ，如果没有 `<Directory>` 标签就自己写一个。另外，修改端口号。重启服务器后，其他设备通过IP+端口号（如 192.168.1.1:8080 ）访问。\n\n```\n<VirtualHost *:8080>\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n  <Directory  \"C:/vhost/example.com\">\n    Options +Indexes +FollowSymLinks +MultiViews\n    AllowOverride All\n    Require all granted\n  </Directory>\n</VirtualHost>\n```\n\n此时局域网内的所有设备都可以通过IP+端口号访问这个项目，但服务器本机反而无法通过 hosts 绑定域名访问了。即使在 hosts 中添加相应端口号也无效。\n\n```\n// 这是无效的\n127.0.0.1:8080 example.com\n```\n\n解决方法是在 httpd-vhosts.conf 中添加一个80端口的虚拟主机，仍然指向同一个项目路径。然后在 hosts 中做正常的域名绑定。PC 端就可以正常使用域名访问这个项目了。\n\n```\n<VirtualHost *:80>\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n</VirtualHost>\n```\n\n```\n127.0.0.1    example.com\n```","source":"_posts/2016-08-30@WampServer 局域网访问配置.md","raw":"---\ntitle: WampServer 局域网访问配置\ncategories:\n  - Web Back-end\ndate: 2016-08-30 12:11:44\ntags:\n  - Apache\n  - WampServer\n---\n\n让局域网内的其他设备（如 Pad 、手机）可以访问 WampServer 上的内容，将会非常便于测试不同设备的浏览效果。要做到这点，需要修改 Apache 配置文件，使服务器允许被局域网内的设备访问。\n\n<!-- more -->\n\n1、如果未在 WampServer 中配置虚拟主机过的情况下，直接在 http.conf 中找以下字段，一般在 `<Directory>` 标签内。将 Require local 修改为 Require all granted 即可。重启服务器后，局域网内的其他设备通过 IP 地址（如 192.168.1.1 ）访问。由于我的 WampSever 已配置过虚拟主机，未测试实际效果。\n\n```\n# onlineoffline tag - don't remove\n  Require all granted\n```\n\n2、如果 WampServer 已经配置了虚拟主机，在 httpd-vhosts.conf 中修改虚拟主机的配置。同样是将 Require local 修改为 Require all granted ，如果没有 `<Directory>` 标签就自己写一个。另外，修改端口号。重启服务器后，其他设备通过IP+端口号（如 192.168.1.1:8080 ）访问。\n\n```\n<VirtualHost *:8080>\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n  <Directory  \"C:/vhost/example.com\">\n    Options +Indexes +FollowSymLinks +MultiViews\n    AllowOverride All\n    Require all granted\n  </Directory>\n</VirtualHost>\n```\n\n此时局域网内的所有设备都可以通过IP+端口号访问这个项目，但服务器本机反而无法通过 hosts 绑定域名访问了。即使在 hosts 中添加相应端口号也无效。\n\n```\n// 这是无效的\n127.0.0.1:8080 example.com\n```\n\n解决方法是在 httpd-vhosts.conf 中添加一个80端口的虚拟主机，仍然指向同一个项目路径。然后在 hosts 中做正常的域名绑定。PC 端就可以正常使用域名访问这个项目了。\n\n```\n<VirtualHost *:80>\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n</VirtualHost>\n```\n\n```\n127.0.0.1    example.com\n```","slug":"2016-08-30@WampServer 局域网访问配置","published":1,"updated":"2020-06-29T03:32:42.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4880040rqgj4lz95tc2","content":"<p>让局域网内的其他设备（如 Pad 、手机）可以访问 WampServer 上的内容，将会非常便于测试不同设备的浏览效果。要做到这点，需要修改 Apache 配置文件，使服务器允许被局域网内的设备访问。</p>\n<a id=\"more\"></a>\n\n<p>1、如果未在 WampServer 中配置虚拟主机过的情况下，直接在 http.conf 中找以下字段，一般在 <code>&lt;Directory&gt;</code> 标签内。将 Require local 修改为 Require all granted 即可。重启服务器后，局域网内的其他设备通过 IP 地址（如 192.168.1.1 ）访问。由于我的 WampSever 已配置过虚拟主机，未测试实际效果。</p>\n<pre><code># onlineoffline tag - don&#39;t remove\n  Require all granted</code></pre><p>2、如果 WampServer 已经配置了虚拟主机，在 httpd-vhosts.conf 中修改虚拟主机的配置。同样是将 Require local 修改为 Require all granted ，如果没有 <code>&lt;Directory&gt;</code> 标签就自己写一个。另外，修改端口号。重启服务器后，其他设备通过IP+端口号（如 192.168.1.1:8080 ）访问。</p>\n<pre><code>&lt;VirtualHost *:8080&gt;\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n  &lt;Directory  &quot;C:/vhost/example.com&quot;&gt;\n    Options +Indexes +FollowSymLinks +MultiViews\n    AllowOverride All\n    Require all granted\n  &lt;/Directory&gt;\n&lt;/VirtualHost&gt;</code></pre><p>此时局域网内的所有设备都可以通过IP+端口号访问这个项目，但服务器本机反而无法通过 hosts 绑定域名访问了。即使在 hosts 中添加相应端口号也无效。</p>\n<pre><code>// 这是无效的\n127.0.0.1:8080 example.com</code></pre><p>解决方法是在 httpd-vhosts.conf 中添加一个80端口的虚拟主机，仍然指向同一个项目路径。然后在 hosts 中做正常的域名绑定。PC 端就可以正常使用域名访问这个项目了。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n&lt;/VirtualHost&gt;</code></pre><pre><code>127.0.0.1    example.com</code></pre>","site":{"data":{}},"excerpt":"<p>让局域网内的其他设备（如 Pad 、手机）可以访问 WampServer 上的内容，将会非常便于测试不同设备的浏览效果。要做到这点，需要修改 Apache 配置文件，使服务器允许被局域网内的设备访问。</p>","more":"<p>1、如果未在 WampServer 中配置虚拟主机过的情况下，直接在 http.conf 中找以下字段，一般在 <code>&lt;Directory&gt;</code> 标签内。将 Require local 修改为 Require all granted 即可。重启服务器后，局域网内的其他设备通过 IP 地址（如 192.168.1.1 ）访问。由于我的 WampSever 已配置过虚拟主机，未测试实际效果。</p>\n<pre><code># onlineoffline tag - don&#39;t remove\n  Require all granted</code></pre><p>2、如果 WampServer 已经配置了虚拟主机，在 httpd-vhosts.conf 中修改虚拟主机的配置。同样是将 Require local 修改为 Require all granted ，如果没有 <code>&lt;Directory&gt;</code> 标签就自己写一个。另外，修改端口号。重启服务器后，其他设备通过IP+端口号（如 192.168.1.1:8080 ）访问。</p>\n<pre><code>&lt;VirtualHost *:8080&gt;\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n  &lt;Directory  &quot;C:/vhost/example.com&quot;&gt;\n    Options +Indexes +FollowSymLinks +MultiViews\n    AllowOverride All\n    Require all granted\n  &lt;/Directory&gt;\n&lt;/VirtualHost&gt;</code></pre><p>此时局域网内的所有设备都可以通过IP+端口号访问这个项目，但服务器本机反而无法通过 hosts 绑定域名访问了。即使在 hosts 中添加相应端口号也无效。</p>\n<pre><code>// 这是无效的\n127.0.0.1:8080 example.com</code></pre><p>解决方法是在 httpd-vhosts.conf 中添加一个80端口的虚拟主机，仍然指向同一个项目路径。然后在 hosts 中做正常的域名绑定。PC 端就可以正常使用域名访问这个项目了。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  ServerName example.com\n  DocumentRoot C:/vhost/example.com\n&lt;/VirtualHost&gt;</code></pre><pre><code>127.0.0.1    example.com</code></pre>"},{"title":"判断页面是否在 iFrame 中","date":"2016-09-01T04:52:33.000Z","_content":"\n如果我们不判断某页面是否在 iFrame 中执行，进而对页面做出一些修改，很可能会出现一些用户体验不佳的 BUG 。例如，我们在A页面中的 iFrame 中显示了B页面内容、B页面中存在链接跳转到A页面，当点击B页面中的链接后等于是在 iFrame 中打开了A页面，如此循环就变成了A页面不断嵌套A页面的效果，这显然不会是我们想要呈现给用户的。\n\n<!-- more -->\n\n解决方法只需要简单的一句 JS 代码，即可判断当前页面是否处于 iFrame 中，然后做相应处理即可。\n\n```\n<script type=\"text/javascript\">\nif (self!=top) {\n    // 当前页面处于iFrame中\n}\n</script>\n```","source":"_posts/2016-09-01@判断页面是否在 iFrame 中.md","raw":"---\ntitle: 判断页面是否在 iFrame 中\ncategories:\n  - Web Front-end\ndate: 2016-09-01 12:52:33\ntags:\n  - JavaScript\n---\n\n如果我们不判断某页面是否在 iFrame 中执行，进而对页面做出一些修改，很可能会出现一些用户体验不佳的 BUG 。例如，我们在A页面中的 iFrame 中显示了B页面内容、B页面中存在链接跳转到A页面，当点击B页面中的链接后等于是在 iFrame 中打开了A页面，如此循环就变成了A页面不断嵌套A页面的效果，这显然不会是我们想要呈现给用户的。\n\n<!-- more -->\n\n解决方法只需要简单的一句 JS 代码，即可判断当前页面是否处于 iFrame 中，然后做相应处理即可。\n\n```\n<script type=\"text/javascript\">\nif (self!=top) {\n    // 当前页面处于iFrame中\n}\n</script>\n```","slug":"2016-09-01@判断页面是否在 iFrame 中","published":1,"updated":"2020-06-29T03:32:42.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4890043rqgj8ly54zjp","content":"<p>如果我们不判断某页面是否在 iFrame 中执行，进而对页面做出一些修改，很可能会出现一些用户体验不佳的 BUG 。例如，我们在A页面中的 iFrame 中显示了B页面内容、B页面中存在链接跳转到A页面，当点击B页面中的链接后等于是在 iFrame 中打开了A页面，如此循环就变成了A页面不断嵌套A页面的效果，这显然不会是我们想要呈现给用户的。</p>\n<a id=\"more\"></a>\n\n<p>解决方法只需要简单的一句 JS 代码，即可判断当前页面是否处于 iFrame 中，然后做相应处理即可。</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\nif (self!=top) {\n    // 当前页面处于iFrame中\n}\n&lt;/script&gt;</code></pre>","site":{"data":{}},"excerpt":"<p>如果我们不判断某页面是否在 iFrame 中执行，进而对页面做出一些修改，很可能会出现一些用户体验不佳的 BUG 。例如，我们在A页面中的 iFrame 中显示了B页面内容、B页面中存在链接跳转到A页面，当点击B页面中的链接后等于是在 iFrame 中打开了A页面，如此循环就变成了A页面不断嵌套A页面的效果，这显然不会是我们想要呈现给用户的。</p>","more":"<p>解决方法只需要简单的一句 JS 代码，即可判断当前页面是否处于 iFrame 中，然后做相应处理即可。</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\nif (self!=top) {\n    // 当前页面处于iFrame中\n}\n&lt;/script&gt;</code></pre>"},{"title":"一个小技巧强制刷新浏览器缓存的图片","date":"2016-09-03T10:20:23.000Z","_content":"\n在服务器上的图片文件发生改变，但 img 的 src 保持不变的情况下，浏览器会直接读取缓存的图片文件，而不会重新加载图片。\n\n虽然缓存有利于减少页面打开时间，但这在一些场景下是不适用的。比如用户修改了自己的头像，同一用户的头像文件的路径是固定的，由于浏览器使用了缓存，此时用户仍然只能看到之前的头像。那么该如何强制浏览器重新加载图片呢？\n\n<!-- more -->\n\n很简单，在图片发生改变时修改 src ，给图片的链接加一个随机参数即可。\n\n``` js\nimage.src = '/img/example.jpg?t=' + Math.random();\n```\n","source":"_posts/2016-09-03@一个小技巧强制刷新浏览器缓存的图片.md","raw":"---\ntitle: 一个小技巧强制刷新浏览器缓存的图片\ncategories:\n  - Web Front-end\ndate: 2016-09-03 18:20:23\ntags:\n  - JavaScript\n---\n\n在服务器上的图片文件发生改变，但 img 的 src 保持不变的情况下，浏览器会直接读取缓存的图片文件，而不会重新加载图片。\n\n虽然缓存有利于减少页面打开时间，但这在一些场景下是不适用的。比如用户修改了自己的头像，同一用户的头像文件的路径是固定的，由于浏览器使用了缓存，此时用户仍然只能看到之前的头像。那么该如何强制浏览器重新加载图片呢？\n\n<!-- more -->\n\n很简单，在图片发生改变时修改 src ，给图片的链接加一个随机参数即可。\n\n``` js\nimage.src = '/img/example.jpg?t=' + Math.random();\n```\n","slug":"2016-09-03@一个小技巧强制刷新浏览器缓存的图片","published":1,"updated":"2020-06-29T03:32:42.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48a0047rqgj0f464zlr","content":"<p>在服务器上的图片文件发生改变，但 img 的 src 保持不变的情况下，浏览器会直接读取缓存的图片文件，而不会重新加载图片。</p>\n<p>虽然缓存有利于减少页面打开时间，但这在一些场景下是不适用的。比如用户修改了自己的头像，同一用户的头像文件的路径是固定的，由于浏览器使用了缓存，此时用户仍然只能看到之前的头像。那么该如何强制浏览器重新加载图片呢？</p>\n<a id=\"more\"></a>\n\n<p>很简单，在图片发生改变时修改 src ，给图片的链接加一个随机参数即可。</p>\n<pre><code class=\"js\">image.src = &#39;/img/example.jpg?t=&#39; + Math.random();</code></pre>\n","site":{"data":{}},"excerpt":"<p>在服务器上的图片文件发生改变，但 img 的 src 保持不变的情况下，浏览器会直接读取缓存的图片文件，而不会重新加载图片。</p>\n<p>虽然缓存有利于减少页面打开时间，但这在一些场景下是不适用的。比如用户修改了自己的头像，同一用户的头像文件的路径是固定的，由于浏览器使用了缓存，此时用户仍然只能看到之前的头像。那么该如何强制浏览器重新加载图片呢？</p>","more":"<p>很简单，在图片发生改变时修改 src ，给图片的链接加一个随机参数即可。</p>\n<pre><code class=\"js\">image.src = &#39;/img/example.jpg?t=&#39; + Math.random();</code></pre>"},{"title":"PHP中 使用 JSON 数据","date":"2016-09-09T03:46:10.000Z","_content":"\nphp5.2+ 提供了 `json_encode` 和 `json_decode` 方法进行 JSON 的编码和解码。\n\n`json_encode` 可将数组或对象转换成 JSON 格式数据，一般用到数组。下面是在数组中编辑好用户信息，然后转换成 JSON 格式数据。\n\n<!-- more -->\n\n``` php\n$arr = array ('name'=>'mike','age'=>'20','from'=>'USA');\n$json =  json_encode($arr);\necho $json;\n\n// 输出内容\n{\"name\":\"mike\",\"age\":\"20\",\"from\":\"USA\"}\n```\n\n`json_decode` 方法可将 JSON 格式数据转换成对象或数组，进而使用里面的数据。下面是两种方式输出用户名。\n\n```\n// 解析为对象\n$obj = json_decode($json);\necho $obj->name;\n\n// 解析为数组\n$arr = json_decode($json,true);\necho $arr['name'];\n```\n\n需要注意的是，如果是自己手写的 JSON 格式的字符串，在使用 `json_decode` 解析时可能会返回 null ，这基本上是因为 JSON 格式错误导致的，仔细检查字符串的格式即可。","source":"_posts/2016-09-09@PHP中 使用 JSON 数据.md","raw":"---\ntitle: PHP中 使用 JSON 数据\ncategories:\n  - Web Back-end\ndate: 2016-09-09 11:46:10\ntags:\n  - PHP\n  - JSON\n---\n\nphp5.2+ 提供了 `json_encode` 和 `json_decode` 方法进行 JSON 的编码和解码。\n\n`json_encode` 可将数组或对象转换成 JSON 格式数据，一般用到数组。下面是在数组中编辑好用户信息，然后转换成 JSON 格式数据。\n\n<!-- more -->\n\n``` php\n$arr = array ('name'=>'mike','age'=>'20','from'=>'USA');\n$json =  json_encode($arr);\necho $json;\n\n// 输出内容\n{\"name\":\"mike\",\"age\":\"20\",\"from\":\"USA\"}\n```\n\n`json_decode` 方法可将 JSON 格式数据转换成对象或数组，进而使用里面的数据。下面是两种方式输出用户名。\n\n```\n// 解析为对象\n$obj = json_decode($json);\necho $obj->name;\n\n// 解析为数组\n$arr = json_decode($json,true);\necho $arr['name'];\n```\n\n需要注意的是，如果是自己手写的 JSON 格式的字符串，在使用 `json_decode` 解析时可能会返回 null ，这基本上是因为 JSON 格式错误导致的，仔细检查字符串的格式即可。","slug":"2016-09-09@PHP中 使用 JSON 数据","published":1,"updated":"2020-06-29T03:32:42.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48b004arqgjgdypcomv","content":"<p>php5.2+ 提供了 <code>json_encode</code> 和 <code>json_decode</code> 方法进行 JSON 的编码和解码。</p>\n<p><code>json_encode</code> 可将数组或对象转换成 JSON 格式数据，一般用到数组。下面是在数组中编辑好用户信息，然后转换成 JSON 格式数据。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"php\">$arr = array (&#39;name&#39;=&gt;&#39;mike&#39;,&#39;age&#39;=&gt;&#39;20&#39;,&#39;from&#39;=&gt;&#39;USA&#39;);\n$json =  json_encode($arr);\necho $json;\n\n// 输出内容\n{&quot;name&quot;:&quot;mike&quot;,&quot;age&quot;:&quot;20&quot;,&quot;from&quot;:&quot;USA&quot;}</code></pre>\n<p><code>json_decode</code> 方法可将 JSON 格式数据转换成对象或数组，进而使用里面的数据。下面是两种方式输出用户名。</p>\n<pre><code>// 解析为对象\n$obj = json_decode($json);\necho $obj-&gt;name;\n\n// 解析为数组\n$arr = json_decode($json,true);\necho $arr[&#39;name&#39;];</code></pre><p>需要注意的是，如果是自己手写的 JSON 格式的字符串，在使用 <code>json_decode</code> 解析时可能会返回 null ，这基本上是因为 JSON 格式错误导致的，仔细检查字符串的格式即可。</p>\n","site":{"data":{}},"excerpt":"<p>php5.2+ 提供了 <code>json_encode</code> 和 <code>json_decode</code> 方法进行 JSON 的编码和解码。</p>\n<p><code>json_encode</code> 可将数组或对象转换成 JSON 格式数据，一般用到数组。下面是在数组中编辑好用户信息，然后转换成 JSON 格式数据。</p>","more":"<pre><code class=\"php\">$arr = array (&#39;name&#39;=&gt;&#39;mike&#39;,&#39;age&#39;=&gt;&#39;20&#39;,&#39;from&#39;=&gt;&#39;USA&#39;);\n$json =  json_encode($arr);\necho $json;\n\n// 输出内容\n{&quot;name&quot;:&quot;mike&quot;,&quot;age&quot;:&quot;20&quot;,&quot;from&quot;:&quot;USA&quot;}</code></pre>\n<p><code>json_decode</code> 方法可将 JSON 格式数据转换成对象或数组，进而使用里面的数据。下面是两种方式输出用户名。</p>\n<pre><code>// 解析为对象\n$obj = json_decode($json);\necho $obj-&gt;name;\n\n// 解析为数组\n$arr = json_decode($json,true);\necho $arr[&#39;name&#39;];</code></pre><p>需要注意的是，如果是自己手写的 JSON 格式的字符串，在使用 <code>json_decode</code> 解析时可能会返回 null ，这基本上是因为 JSON 格式错误导致的，仔细检查字符串的格式即可。</p>"},{"title":"Textarea 禁用回车换行","date":"2016-09-10T07:55:27.000Z","_content":"\n在使用 textarea 控件时，某些场景下需要禁止用户使用回车换行。这时可以用 JavaScript 监听用户输入事件，判断按键为回车后返回 false 即可。\n\n<!-- more -->\n\nHTML:\n\n``` xhtml\n<textarea onkeydown=\"noWrap(event)\"></textarea>\n```\n\nJavaScript:\n\n``` js\nfunction noWrap(event) {\n\tif (event.keyCode==13) event.returnValue = false;\n}\n```","source":"_posts/2016-09-10@Textarea 禁用回车换行.md","raw":"---\ntitle: Textarea 禁用回车换行\ncategories:\n  - Web Front-end\ndate: 2016-09-10 15:55:27\ntags:\n  - JavaScript\n---\n\n在使用 textarea 控件时，某些场景下需要禁止用户使用回车换行。这时可以用 JavaScript 监听用户输入事件，判断按键为回车后返回 false 即可。\n\n<!-- more -->\n\nHTML:\n\n``` xhtml\n<textarea onkeydown=\"noWrap(event)\"></textarea>\n```\n\nJavaScript:\n\n``` js\nfunction noWrap(event) {\n\tif (event.keyCode==13) event.returnValue = false;\n}\n```","slug":"2016-09-10@Textarea 禁用回车换行","published":1,"updated":"2020-06-29T03:32:42.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48c004drqgj1xl0eqg1","content":"<p>在使用 textarea 控件时，某些场景下需要禁止用户使用回车换行。这时可以用 JavaScript 监听用户输入事件，判断按键为回车后返回 false 即可。</p>\n<a id=\"more\"></a>\n\n<p>HTML:</p>\n<pre><code class=\"xhtml\">&lt;textarea onkeydown=&quot;noWrap(event)&quot;&gt;&lt;/textarea&gt;</code></pre>\n<p>JavaScript:</p>\n<pre><code class=\"js\">function noWrap(event) {\n    if (event.keyCode==13) event.returnValue = false;\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>在使用 textarea 控件时，某些场景下需要禁止用户使用回车换行。这时可以用 JavaScript 监听用户输入事件，判断按键为回车后返回 false 即可。</p>","more":"<p>HTML:</p>\n<pre><code class=\"xhtml\">&lt;textarea onkeydown=&quot;noWrap(event)&quot;&gt;&lt;/textarea&gt;</code></pre>\n<p>JavaScript:</p>\n<pre><code class=\"js\">function noWrap(event) {\n    if (event.keyCode==13) event.returnValue = false;\n}</code></pre>"},{"title":"解决 json_encode 中文乱码","date":"2016-09-10T09:29:00.000Z","_content":"\n如果用 json_encode 将一个包含中文的数组转换成 JSON 格式数据，会发现中文部分全部变成了乱码。PHP 5.4+ 可以通过在使用 `json_encode` 时增加参数 JSON_UNESCAPED_UNICODE 解决。\n\n<!-- more -->\n\n``` php\njson_encode($arr, JSON_UNESCAPED_UNICODE);\n```\n\n这样得到的 JSON 数据就不会出现中文乱码的问题了。","source":"_posts/2016-09-10@解决 json_encode 中文乱码.md","raw":"---\ntitle: 解决 json_encode 中文乱码\ncategories:\n  - Web Back-end\ndate: 2016-09-10 17:29:00\ntags:\n  - PHP\n  - JSON\n---\n\n如果用 json_encode 将一个包含中文的数组转换成 JSON 格式数据，会发现中文部分全部变成了乱码。PHP 5.4+ 可以通过在使用 `json_encode` 时增加参数 JSON_UNESCAPED_UNICODE 解决。\n\n<!-- more -->\n\n``` php\njson_encode($arr, JSON_UNESCAPED_UNICODE);\n```\n\n这样得到的 JSON 数据就不会出现中文乱码的问题了。","slug":"2016-09-10@解决 json_encode 中文乱码","published":1,"updated":"2020-06-29T03:32:42.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48e004hrqgj9fapb5hm","content":"<p>如果用 json_encode 将一个包含中文的数组转换成 JSON 格式数据，会发现中文部分全部变成了乱码。PHP 5.4+ 可以通过在使用 <code>json_encode</code> 时增加参数 JSON_UNESCAPED_UNICODE 解决。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"php\">json_encode($arr, JSON_UNESCAPED_UNICODE);</code></pre>\n<p>这样得到的 JSON 数据就不会出现中文乱码的问题了。</p>\n","site":{"data":{}},"excerpt":"<p>如果用 json_encode 将一个包含中文的数组转换成 JSON 格式数据，会发现中文部分全部变成了乱码。PHP 5.4+ 可以通过在使用 <code>json_encode</code> 时增加参数 JSON_UNESCAPED_UNICODE 解决。</p>","more":"<pre><code class=\"php\">json_encode($arr, JSON_UNESCAPED_UNICODE);</code></pre>\n<p>这样得到的 JSON 数据就不会出现中文乱码的问题了。</p>"},{"title":"Rewrite 后 GET 参数丢失的处理","date":"2016-09-12T06:50:26.000Z","_content":"\n在 Apache Rewrite 中，如果定义的规则中包含了自定义 GET 参数，原有的 GET 参数就会消失。\n\n例如，下面这条规则生效后，访问 www.example.com/mike 实际上是访问 www.example.com/index.php?url=mike ，index.php 可以接收到参数 url ，这个 GET 参数实际上是我们在重写时自定义的。\n\n<!-- more -->\n\n```\nRewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1\n```\n\n如果访问的时候加上其他参数（如 www.example.com/mike?param=1） ，index.php 仍旧只能接收到参数 url ，无法接收链接中的其他参数。\n\n\n要解决这个问题，只要在重写规则里加上参数 %{QUERY_STRING} ，处理请求的页面即可收到原有链接中的所有参数，重写规则示例如下。\n\n```\nRewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1&%{QUERY_STRING}\n```","source":"_posts/2016-09-12@Rewrite 后 GET 参数丢失的处理.md","raw":"---\ntitle: Rewrite 后 GET 参数丢失的处理\ncategories:\n  - Web Back-end\ndate: 2016-09-12 14:50:26\ntags:\n  - Apache\n---\n\n在 Apache Rewrite 中，如果定义的规则中包含了自定义 GET 参数，原有的 GET 参数就会消失。\n\n例如，下面这条规则生效后，访问 www.example.com/mike 实际上是访问 www.example.com/index.php?url=mike ，index.php 可以接收到参数 url ，这个 GET 参数实际上是我们在重写时自定义的。\n\n<!-- more -->\n\n```\nRewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1\n```\n\n如果访问的时候加上其他参数（如 www.example.com/mike?param=1） ，index.php 仍旧只能接收到参数 url ，无法接收链接中的其他参数。\n\n\n要解决这个问题，只要在重写规则里加上参数 %{QUERY_STRING} ，处理请求的页面即可收到原有链接中的所有参数，重写规则示例如下。\n\n```\nRewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1&%{QUERY_STRING}\n```","slug":"2016-09-12@Rewrite 后 GET 参数丢失的处理","published":1,"updated":"2020-06-29T03:32:42.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48f004krqgjehiheyuk","content":"<p>在 Apache Rewrite 中，如果定义的规则中包含了自定义 GET 参数，原有的 GET 参数就会消失。</p>\n<p>例如，下面这条规则生效后，访问 <a href=\"http://www.example.com/mike\" target=\"_blank\" rel=\"noopener\">www.example.com/mike</a> 实际上是访问 <a href=\"http://www.example.com/index.php?url=mike\" target=\"_blank\" rel=\"noopener\">www.example.com/index.php?url=mike</a> ，index.php 可以接收到参数 url ，这个 GET 参数实际上是我们在重写时自定义的。</p>\n<a id=\"more\"></a>\n\n<pre><code>RewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1</code></pre><p>如果访问的时候加上其他参数（如 <a href=\"http://www.example.com/mike?param=1）\" target=\"_blank\" rel=\"noopener\">www.example.com/mike?param=1）</a> ，index.php 仍旧只能接收到参数 url ，无法接收链接中的其他参数。</p>\n<p>要解决这个问题，只要在重写规则里加上参数 %{QUERY_STRING} ，处理请求的页面即可收到原有链接中的所有参数，重写规则示例如下。</p>\n<pre><code>RewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1&amp;%{QUERY_STRING}</code></pre>","site":{"data":{}},"excerpt":"<p>在 Apache Rewrite 中，如果定义的规则中包含了自定义 GET 参数，原有的 GET 参数就会消失。</p>\n<p>例如，下面这条规则生效后，访问 <a href=\"http://www.example.com/mike\" target=\"_blank\" rel=\"noopener\">www.example.com/mike</a> 实际上是访问 <a href=\"http://www.example.com/index.php?url=mike\" target=\"_blank\" rel=\"noopener\">www.example.com/index.php?url=mike</a> ，index.php 可以接收到参数 url ，这个 GET 参数实际上是我们在重写时自定义的。</p>","more":"<pre><code>RewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1</code></pre><p>如果访问的时候加上其他参数（如 <a href=\"http://www.example.com/mike?param=1）\" target=\"_blank\" rel=\"noopener\">www.example.com/mike?param=1）</a> ，index.php 仍旧只能接收到参数 url ，无法接收链接中的其他参数。</p>\n<p>要解决这个问题，只要在重写规则里加上参数 %{QUERY_STRING} ，处理请求的页面即可收到原有链接中的所有参数，重写规则示例如下。</p>\n<pre><code>RewriteRule ^([a-zA-Z\\d]+)$ index.php?url=$1&amp;%{QUERY_STRING}</code></pre>"},{"title":"Rewrite 禁止访问某种文件","date":"2016-09-11T16:10:31.000Z","_content":"\n当我们不希望一些服务端的文件被用户直接浏览、又必须用到这些文件时，可以通过 Apache Rewrite 禁止直接访问某些格式的文件。\n\n首先，在根目录下的 .htaccess 文件（没有则新建）中开启重写引擎。\n\n<!-- more -->\n\n```\nRewriteEngine on\n```\n\n然后，添加以下规则。这里禁止了用户访问 XML 格式的文件。\n\n```\n<FilesMatch \"\\.(xml)$\">\n  order deny,allow  \n  deny from all\n</FilesMatch>\n```\n\n实测 XML 被禁止访问后，仍然可以正常用 PHP 解析文件内部的数据。","source":"_posts/2016-09-12@Rewrite 禁止访问某种文件.md","raw":"---\ntitle: Rewrite 禁止访问某种文件\ncategories:\n  - Web Back-end\ndate: 2016-09-12 00:10:31\ntags:\n  - Apache\n---\n\n当我们不希望一些服务端的文件被用户直接浏览、又必须用到这些文件时，可以通过 Apache Rewrite 禁止直接访问某些格式的文件。\n\n首先，在根目录下的 .htaccess 文件（没有则新建）中开启重写引擎。\n\n<!-- more -->\n\n```\nRewriteEngine on\n```\n\n然后，添加以下规则。这里禁止了用户访问 XML 格式的文件。\n\n```\n<FilesMatch \"\\.(xml)$\">\n  order deny,allow  \n  deny from all\n</FilesMatch>\n```\n\n实测 XML 被禁止访问后，仍然可以正常用 PHP 解析文件内部的数据。","slug":"2016-09-12@Rewrite 禁止访问某种文件","published":1,"updated":"2020-06-29T03:32:42.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48g004orqgjhpvaffvl","content":"<p>当我们不希望一些服务端的文件被用户直接浏览、又必须用到这些文件时，可以通过 Apache Rewrite 禁止直接访问某些格式的文件。</p>\n<p>首先，在根目录下的 .htaccess 文件（没有则新建）中开启重写引擎。</p>\n<a id=\"more\"></a>\n\n<pre><code>RewriteEngine on</code></pre><p>然后，添加以下规则。这里禁止了用户访问 XML 格式的文件。</p>\n<pre><code>&lt;FilesMatch &quot;\\.(xml)$&quot;&gt;\n  order deny,allow  \n  deny from all\n&lt;/FilesMatch&gt;</code></pre><p>实测 XML 被禁止访问后，仍然可以正常用 PHP 解析文件内部的数据。</p>\n","site":{"data":{}},"excerpt":"<p>当我们不希望一些服务端的文件被用户直接浏览、又必须用到这些文件时，可以通过 Apache Rewrite 禁止直接访问某些格式的文件。</p>\n<p>首先，在根目录下的 .htaccess 文件（没有则新建）中开启重写引擎。</p>","more":"<pre><code>RewriteEngine on</code></pre><p>然后，添加以下规则。这里禁止了用户访问 XML 格式的文件。</p>\n<pre><code>&lt;FilesMatch &quot;\\.(xml)$&quot;&gt;\n  order deny,allow  \n  deny from all\n&lt;/FilesMatch&gt;</code></pre><p>实测 XML 被禁止访问后，仍然可以正常用 PHP 解析文件内部的数据。</p>"},{"title":"文字溢出时隐藏并加省略号","date":"2016-09-12T18:36:23.000Z","_content":"\n要使过长文字被隐藏并加上省略号，添加这段 CSS 代码即可。\n\n```\nwhite-space: nowrap;\ntext-overflow: ellipsis;\n-o-text-overflow: ellipsis;\noverflow: hidden;\n```\n\n<!-- more -->\n\n`white-space: nowrap` 表示文本不换行（除非遇到 `<br>` 标签），若无此需求可忽略该句。`text-overflow: ellipsis` 表示当文本溢出时显示省略符号来代表被修剪的文本。`overflow: hidden` 就十分常用了，表示隐藏溢出的内容。`-o-text-overflow: ellipsis` 用于兼容 Opera 浏览器。","source":"_posts/2016-09-13@文字溢出时隐藏并加省略号.md","raw":"---\ntitle: 文字溢出时隐藏并加省略号\ncategories:\n  - Web Front-end\ndate: 2016-09-13 02:36:23\ntags:\n  - CSS\n---\n\n要使过长文字被隐藏并加上省略号，添加这段 CSS 代码即可。\n\n```\nwhite-space: nowrap;\ntext-overflow: ellipsis;\n-o-text-overflow: ellipsis;\noverflow: hidden;\n```\n\n<!-- more -->\n\n`white-space: nowrap` 表示文本不换行（除非遇到 `<br>` 标签），若无此需求可忽略该句。`text-overflow: ellipsis` 表示当文本溢出时显示省略符号来代表被修剪的文本。`overflow: hidden` 就十分常用了，表示隐藏溢出的内容。`-o-text-overflow: ellipsis` 用于兼容 Opera 浏览器。","slug":"2016-09-13@文字溢出时隐藏并加省略号","published":1,"updated":"2020-06-29T03:32:42.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48h004rrqgja6lp679b","content":"<p>要使过长文字被隐藏并加上省略号，添加这段 CSS 代码即可。</p>\n<pre><code>white-space: nowrap;\ntext-overflow: ellipsis;\n-o-text-overflow: ellipsis;\noverflow: hidden;</code></pre><a id=\"more\"></a>\n\n<p><code>white-space: nowrap</code> 表示文本不换行（除非遇到 <code>&lt;br&gt;</code> 标签），若无此需求可忽略该句。<code>text-overflow: ellipsis</code> 表示当文本溢出时显示省略符号来代表被修剪的文本。<code>overflow: hidden</code> 就十分常用了，表示隐藏溢出的内容。<code>-o-text-overflow: ellipsis</code> 用于兼容 Opera 浏览器。</p>\n","site":{"data":{}},"excerpt":"<p>要使过长文字被隐藏并加上省略号，添加这段 CSS 代码即可。</p>\n<pre><code>white-space: nowrap;\ntext-overflow: ellipsis;\n-o-text-overflow: ellipsis;\noverflow: hidden;</code></pre>","more":"<p><code>white-space: nowrap</code> 表示文本不换行（除非遇到 <code>&lt;br&gt;</code> 标签），若无此需求可忽略该句。<code>text-overflow: ellipsis</code> 表示当文本溢出时显示省略符号来代表被修剪的文本。<code>overflow: hidden</code> 就十分常用了，表示隐藏溢出的内容。<code>-o-text-overflow: ellipsis</code> 用于兼容 Opera 浏览器。</p>"},{"title":"CSS3 文字阴影效果","date":"2016-09-19T05:37:49.000Z","_content":"\nCSS3 支持使用 text-shadow 属性给文字增加阴影。\n\n```\ntext-shadow: h-shadow v-shadow blur color;\n```\n<!-- more -->\n\nh-shadow 和 v-shadow 分别为水平、垂直的阴影偏移值，即阴影相对于文字的位置，可以使用负值。blur 和 color 都是可选参数，blur 是阴影模糊程度，color 则是阴影的颜色。\n\n```\ntext-shadow: 5px 5px 5px #000;\n```","source":"_posts/2016-09-19@CSS3 文字阴影效果.md","raw":"---\ntitle: CSS3 文字阴影效果\ncategories:\n  - Web Front-end\ndate: 2016-09-19 13:37:49\ntags:\n  - CSS\n---\n\nCSS3 支持使用 text-shadow 属性给文字增加阴影。\n\n```\ntext-shadow: h-shadow v-shadow blur color;\n```\n<!-- more -->\n\nh-shadow 和 v-shadow 分别为水平、垂直的阴影偏移值，即阴影相对于文字的位置，可以使用负值。blur 和 color 都是可选参数，blur 是阴影模糊程度，color 则是阴影的颜色。\n\n```\ntext-shadow: 5px 5px 5px #000;\n```","slug":"2016-09-19@CSS3 文字阴影效果","published":1,"updated":"2020-06-29T03:32:42.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48j004vrqgj8fm38d5o","content":"<p>CSS3 支持使用 text-shadow 属性给文字增加阴影。</p>\n<pre><code>text-shadow: h-shadow v-shadow blur color;</code></pre><a id=\"more\"></a>\n\n<p>h-shadow 和 v-shadow 分别为水平、垂直的阴影偏移值，即阴影相对于文字的位置，可以使用负值。blur 和 color 都是可选参数，blur 是阴影模糊程度，color 则是阴影的颜色。</p>\n<pre><code>text-shadow: 5px 5px 5px #000;</code></pre>","site":{"data":{}},"excerpt":"<p>CSS3 支持使用 text-shadow 属性给文字增加阴影。</p>\n<pre><code>text-shadow: h-shadow v-shadow blur color;</code></pre>","more":"<p>h-shadow 和 v-shadow 分别为水平、垂直的阴影偏移值，即阴影相对于文字的位置，可以使用负值。blur 和 color 都是可选参数，blur 是阴影模糊程度，color 则是阴影的颜色。</p>\n<pre><code>text-shadow: 5px 5px 5px #000;</code></pre>"},{"title":"PHP 删除数组中的元素","date":"2016-09-19T05:14:29.000Z","_content":"\n删除数组元素有两种方式，第一种是使用 `unset` 方法。\n\n``` php\nunset($arr[1]);\n```\n<!-- more -->\n\n此方法删除元素后，$arr[1] 为 null ，所有元素的索引值不变，也就是说元素不会重新排列，所以不是很实用。\n\n要使元素删除后重新排列顺序，使用 array_splice 方法即可。\n\n``` php\narray_splice(array,start,length,array);\n```\narray_splice 的四个参数中，array 为要删除元素的数组；start 为要开始删除元素的位置（索引值）；length 为要删除的元素数量；最后一个参数为可选参数，允许用一个新元素替代被删除的元素。\n\n使用 array_splice 删除数组中索引为1的元素：\n\n``` php\narray_splice($arr,1,1);\n```","source":"_posts/2016-09-19@PHP 删除数组中的元素.md","raw":"---\ntitle: PHP 删除数组中的元素\ncategories:\n  - Web Back-end\ndate: 2016-09-19 13:14:29\ntags:\n  - PHP\n---\n\n删除数组元素有两种方式，第一种是使用 `unset` 方法。\n\n``` php\nunset($arr[1]);\n```\n<!-- more -->\n\n此方法删除元素后，$arr[1] 为 null ，所有元素的索引值不变，也就是说元素不会重新排列，所以不是很实用。\n\n要使元素删除后重新排列顺序，使用 array_splice 方法即可。\n\n``` php\narray_splice(array,start,length,array);\n```\narray_splice 的四个参数中，array 为要删除元素的数组；start 为要开始删除元素的位置（索引值）；length 为要删除的元素数量；最后一个参数为可选参数，允许用一个新元素替代被删除的元素。\n\n使用 array_splice 删除数组中索引为1的元素：\n\n``` php\narray_splice($arr,1,1);\n```","slug":"2016-09-19@PHP 删除数组中的元素","published":1,"updated":"2020-06-29T03:32:42.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48j004yrqgj7rgq1r9g","content":"<p>删除数组元素有两种方式，第一种是使用 <code>unset</code> 方法。</p>\n<pre><code class=\"php\">unset($arr[1]);</code></pre>\n<a id=\"more\"></a>\n\n<p>此方法删除元素后，$arr[1] 为 null ，所有元素的索引值不变，也就是说元素不会重新排列，所以不是很实用。</p>\n<p>要使元素删除后重新排列顺序，使用 array_splice 方法即可。</p>\n<pre><code class=\"php\">array_splice(array,start,length,array);</code></pre>\n<p>array_splice 的四个参数中，array 为要删除元素的数组；start 为要开始删除元素的位置（索引值）；length 为要删除的元素数量；最后一个参数为可选参数，允许用一个新元素替代被删除的元素。</p>\n<p>使用 array_splice 删除数组中索引为1的元素：</p>\n<pre><code class=\"php\">array_splice($arr,1,1);</code></pre>\n","site":{"data":{}},"excerpt":"<p>删除数组元素有两种方式，第一种是使用 <code>unset</code> 方法。</p>\n<pre><code class=\"php\">unset($arr[1]);</code></pre>","more":"<p>此方法删除元素后，$arr[1] 为 null ，所有元素的索引值不变，也就是说元素不会重新排列，所以不是很实用。</p>\n<p>要使元素删除后重新排列顺序，使用 array_splice 方法即可。</p>\n<pre><code class=\"php\">array_splice(array,start,length,array);</code></pre>\n<p>array_splice 的四个参数中，array 为要删除元素的数组；start 为要开始删除元素的位置（索引值）；length 为要删除的元素数量；最后一个参数为可选参数，允许用一个新元素替代被删除的元素。</p>\n<p>使用 array_splice 删除数组中索引为1的元素：</p>\n<pre><code class=\"php\">array_splice($arr,1,1);</code></pre>"},{"title":"Textarea 限制字符长度","date":"2016-09-19T05:28:34.000Z","_content":"\ntextarea 没有 maxlength 属性，不能像 input 一样直接在标签内设置最大输入字符数，只能通过 JavaScript 间接实现。\n\n用户每次按键输入时调用 `checkLength` 方法，该方法判断输入的内容是否超出限制的长度，若是则删除超出长度部分的字符。\n\n<!-- more -->\n\nHTML:\n\n``` xhtml\n<textarea onpropertychange=\"checkLength(this, 8)\" oninput=\"checkLength(this, 8)\"></textarea>\n```\n\nJavaScript:\n\n``` js\nfunction checkLength(element, maxlength) {\n    if (element.value.length > maxlength) {\n        element.value = element.value.substring(0, maxlength);\n    }\n}\n```","source":"_posts/2016-09-19@Textarea 限制字符长度.md","raw":"---\ntitle: Textarea 限制字符长度\ncategories:\n  - Web Front-end\ndate: 2016-09-19 13:28:34\ntags:\n  - JavaScript\n  - HTML\n---\n\ntextarea 没有 maxlength 属性，不能像 input 一样直接在标签内设置最大输入字符数，只能通过 JavaScript 间接实现。\n\n用户每次按键输入时调用 `checkLength` 方法，该方法判断输入的内容是否超出限制的长度，若是则删除超出长度部分的字符。\n\n<!-- more -->\n\nHTML:\n\n``` xhtml\n<textarea onpropertychange=\"checkLength(this, 8)\" oninput=\"checkLength(this, 8)\"></textarea>\n```\n\nJavaScript:\n\n``` js\nfunction checkLength(element, maxlength) {\n    if (element.value.length > maxlength) {\n        element.value = element.value.substring(0, maxlength);\n    }\n}\n```","slug":"2016-09-19@Textarea 限制字符长度","published":1,"updated":"2020-06-29T03:32:42.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48l0052rqgj536fhudo","content":"<p>textarea 没有 maxlength 属性，不能像 input 一样直接在标签内设置最大输入字符数，只能通过 JavaScript 间接实现。</p>\n<p>用户每次按键输入时调用 <code>checkLength</code> 方法，该方法判断输入的内容是否超出限制的长度，若是则删除超出长度部分的字符。</p>\n<a id=\"more\"></a>\n\n<p>HTML:</p>\n<pre><code class=\"xhtml\">&lt;textarea onpropertychange=&quot;checkLength(this, 8)&quot; oninput=&quot;checkLength(this, 8)&quot;&gt;&lt;/textarea&gt;</code></pre>\n<p>JavaScript:</p>\n<pre><code class=\"js\">function checkLength(element, maxlength) {\n    if (element.value.length &gt; maxlength) {\n        element.value = element.value.substring(0, maxlength);\n    }\n}</code></pre>\n","site":{"data":{}},"excerpt":"<p>textarea 没有 maxlength 属性，不能像 input 一样直接在标签内设置最大输入字符数，只能通过 JavaScript 间接实现。</p>\n<p>用户每次按键输入时调用 <code>checkLength</code> 方法，该方法判断输入的内容是否超出限制的长度，若是则删除超出长度部分的字符。</p>","more":"<p>HTML:</p>\n<pre><code class=\"xhtml\">&lt;textarea onpropertychange=&quot;checkLength(this, 8)&quot; oninput=&quot;checkLength(this, 8)&quot;&gt;&lt;/textarea&gt;</code></pre>\n<p>JavaScript:</p>\n<pre><code class=\"js\">function checkLength(element, maxlength) {\n    if (element.value.length &gt; maxlength) {\n        element.value = element.value.substring(0, maxlength);\n    }\n}</code></pre>"},{"title":"使用 PHP 设置 Cookie","date":"2016-09-29T06:42:33.000Z","_content":"\n近期使用 Cookie 实现网站的登陆保持功能，期间也遇到一些问题。\n\n1、新建\n\n``` php\nsetcookie(name,value,expire,path,domain,secure)\n```\n<!-- more -->\n\n使用 `setcookie` 方法新建 cookie 。必需参数：name ，Cookie 的名称；value ，Cookie值。可选参数：expire ，Cookie 的过期时间；path ，Cookie 的服务器路径；domain ，Cookie 的域名；secure ，是否使用安全链接。\n\n例如，创建一个名称为 email ，值为 exaple@example.com ，两星期后过期的 Cookie ，网上普遍的写法是这样的：\n\n``` php\nsetcookie('email','exaple@example.com',time()+2*7*24*3600);\n```\n但我在本地服务器测试时，出现 Cookie 跨页丢失问题，即同一网站A页面创建的 Cookie 只在A页面有效，在B页面无法读取值。于是我增加了第四个参数，解决了该问题。\n\n``` php\nsetcookie('email','exaple@example.com',time()+2*7*24*3600,'/');\n```\n\n2、读取\n\n``` php\n$_COOKIE['email'];\n```\n没什么好说的，和读取 Session 一样。使用时最好加 isset 方法判断先该 Cookie 存在，否则容易报错。\n\n3、删除\n\n```\nsetcookie('email','',time()-3600,'/');\n```\n\n要删除一个 Cookie ，设置其过期时间早于当前时间即可。","source":"_posts/2016-09-29@使用 PHP 设置 Cookie.md","raw":"---\ntitle: 使用 PHP 设置 Cookie\ncategories:\n  - Web Back-end\ndate: 2016-09-29 14:42:33\ntags:\n  - PHP\n  - Cookie\n---\n\n近期使用 Cookie 实现网站的登陆保持功能，期间也遇到一些问题。\n\n1、新建\n\n``` php\nsetcookie(name,value,expire,path,domain,secure)\n```\n<!-- more -->\n\n使用 `setcookie` 方法新建 cookie 。必需参数：name ，Cookie 的名称；value ，Cookie值。可选参数：expire ，Cookie 的过期时间；path ，Cookie 的服务器路径；domain ，Cookie 的域名；secure ，是否使用安全链接。\n\n例如，创建一个名称为 email ，值为 exaple@example.com ，两星期后过期的 Cookie ，网上普遍的写法是这样的：\n\n``` php\nsetcookie('email','exaple@example.com',time()+2*7*24*3600);\n```\n但我在本地服务器测试时，出现 Cookie 跨页丢失问题，即同一网站A页面创建的 Cookie 只在A页面有效，在B页面无法读取值。于是我增加了第四个参数，解决了该问题。\n\n``` php\nsetcookie('email','exaple@example.com',time()+2*7*24*3600,'/');\n```\n\n2、读取\n\n``` php\n$_COOKIE['email'];\n```\n没什么好说的，和读取 Session 一样。使用时最好加 isset 方法判断先该 Cookie 存在，否则容易报错。\n\n3、删除\n\n```\nsetcookie('email','',time()-3600,'/');\n```\n\n要删除一个 Cookie ，设置其过期时间早于当前时间即可。","slug":"2016-09-29@使用 PHP 设置 Cookie","published":1,"updated":"2020-06-29T03:32:42.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48m0055rqgjhbs14yv4","content":"<p>近期使用 Cookie 实现网站的登陆保持功能，期间也遇到一些问题。</p>\n<p>1、新建</p>\n<pre><code class=\"php\">setcookie(name,value,expire,path,domain,secure)</code></pre>\n<a id=\"more\"></a>\n\n<p>使用 <code>setcookie</code> 方法新建 cookie 。必需参数：name ，Cookie 的名称；value ，Cookie值。可选参数：expire ，Cookie 的过期时间；path ，Cookie 的服务器路径；domain ，Cookie 的域名；secure ，是否使用安全链接。</p>\n<p>例如，创建一个名称为 email ，值为 <a href=\"mailto:exaple@example.com\">exaple@example.com</a> ，两星期后过期的 Cookie ，网上普遍的写法是这样的：</p>\n<pre><code class=\"php\">setcookie(&#39;email&#39;,&#39;exaple@example.com&#39;,time()+2*7*24*3600);</code></pre>\n<p>但我在本地服务器测试时，出现 Cookie 跨页丢失问题，即同一网站A页面创建的 Cookie 只在A页面有效，在B页面无法读取值。于是我增加了第四个参数，解决了该问题。</p>\n<pre><code class=\"php\">setcookie(&#39;email&#39;,&#39;exaple@example.com&#39;,time()+2*7*24*3600,&#39;/&#39;);</code></pre>\n<p>2、读取</p>\n<pre><code class=\"php\">$_COOKIE[&#39;email&#39;];</code></pre>\n<p>没什么好说的，和读取 Session 一样。使用时最好加 isset 方法判断先该 Cookie 存在，否则容易报错。</p>\n<p>3、删除</p>\n<pre><code>setcookie(&#39;email&#39;,&#39;&#39;,time()-3600,&#39;/&#39;);</code></pre><p>要删除一个 Cookie ，设置其过期时间早于当前时间即可。</p>\n","site":{"data":{}},"excerpt":"<p>近期使用 Cookie 实现网站的登陆保持功能，期间也遇到一些问题。</p>\n<p>1、新建</p>\n<pre><code class=\"php\">setcookie(name,value,expire,path,domain,secure)</code></pre>","more":"<p>使用 <code>setcookie</code> 方法新建 cookie 。必需参数：name ，Cookie 的名称；value ，Cookie值。可选参数：expire ，Cookie 的过期时间；path ，Cookie 的服务器路径；domain ，Cookie 的域名；secure ，是否使用安全链接。</p>\n<p>例如，创建一个名称为 email ，值为 <a href=\"mailto:exaple@example.com\">exaple@example.com</a> ，两星期后过期的 Cookie ，网上普遍的写法是这样的：</p>\n<pre><code class=\"php\">setcookie(&#39;email&#39;,&#39;exaple@example.com&#39;,time()+2*7*24*3600);</code></pre>\n<p>但我在本地服务器测试时，出现 Cookie 跨页丢失问题，即同一网站A页面创建的 Cookie 只在A页面有效，在B页面无法读取值。于是我增加了第四个参数，解决了该问题。</p>\n<pre><code class=\"php\">setcookie(&#39;email&#39;,&#39;exaple@example.com&#39;,time()+2*7*24*3600,&#39;/&#39;);</code></pre>\n<p>2、读取</p>\n<pre><code class=\"php\">$_COOKIE[&#39;email&#39;];</code></pre>\n<p>没什么好说的，和读取 Session 一样。使用时最好加 isset 方法判断先该 Cookie 存在，否则容易报错。</p>\n<p>3、删除</p>\n<pre><code>setcookie(&#39;email&#39;,&#39;&#39;,time()-3600,&#39;/&#39;);</code></pre><p>要删除一个 Cookie ，设置其过期时间早于当前时间即可。</p>"},{"title":"WordPress 创建子主题","date":"2016-10-22T08:06:26.000Z","_content":"\nWordpress 的主题总是有许多不尽如人意的地方，经常需要自定义样式、文本。然而直接修改主题源文件的体验并不优雅。使用子主题可以避免修改在主题升级后丢失，总之值得尝试，创建子主题的方式也 非常简单。\n\n<!-- more -->\n\n接下来以自带主题 Twenty Fifteen 为例演示创建一个子主题。\n\n第一步，在 wp-content/themes/ 下新建一个文件夹，作为子主题的文件夹，该文件夹可以随意命名，我将该文件夹命名为 twentyfifteen-child 。\n\n第二步，在 twentyfifteen-child 文件夹下新建一个 style.css 文件，代码如下。\n\n``` css\n/*\nTheme Name:     Twenty Fifteen Child\nTheme URI:      http://example.com/\nDescription:    Child theme for the Twenty Fifteen theme \nAuthor:         Your name here\nAuthor URI:     http://example.com/\nTemplate:       twentyfifteen\nVersion:        1.0\n*/\n\n@import url(../twentyfifteen/style.css);\n```\n\nTemplate 后填写父主题的文件夹名称，Theme Name 后填写子主题的名称，其他项目非必填。然后导入父主题的 CSS 文件。\n\n至此，子主题已创建完毕，可以在主题中看到新增了 Twenty Fifteen Child 主题。如果觉得没有预览图片逼死强迫症，可以将父主题文件夹下的 screenshot.png 拷贝到子主题的文件夹里，或自己做一张预览图。\n\n如需修改样式，可以直接写进子主题的style.css文件中覆盖原样式。如需修改页面的 HTML 或 PHP 代码，拷贝相应文件到子主题文件夹下，修改该文件即可。如需修改某个方法，可在子主题文件夹下创建 functions.php 文件，该文件中的方法将覆盖父主题中的同名方法。","source":"_posts/2016-10-22@Wordpress 创建子主题.md","raw":"---\ntitle: WordPress 创建子主题\ncategories:\n  - Other\ndate: 2016-10-22 16:06:26\ntags:\n  - WordPress\n---\n\nWordpress 的主题总是有许多不尽如人意的地方，经常需要自定义样式、文本。然而直接修改主题源文件的体验并不优雅。使用子主题可以避免修改在主题升级后丢失，总之值得尝试，创建子主题的方式也 非常简单。\n\n<!-- more -->\n\n接下来以自带主题 Twenty Fifteen 为例演示创建一个子主题。\n\n第一步，在 wp-content/themes/ 下新建一个文件夹，作为子主题的文件夹，该文件夹可以随意命名，我将该文件夹命名为 twentyfifteen-child 。\n\n第二步，在 twentyfifteen-child 文件夹下新建一个 style.css 文件，代码如下。\n\n``` css\n/*\nTheme Name:     Twenty Fifteen Child\nTheme URI:      http://example.com/\nDescription:    Child theme for the Twenty Fifteen theme \nAuthor:         Your name here\nAuthor URI:     http://example.com/\nTemplate:       twentyfifteen\nVersion:        1.0\n*/\n\n@import url(../twentyfifteen/style.css);\n```\n\nTemplate 后填写父主题的文件夹名称，Theme Name 后填写子主题的名称，其他项目非必填。然后导入父主题的 CSS 文件。\n\n至此，子主题已创建完毕，可以在主题中看到新增了 Twenty Fifteen Child 主题。如果觉得没有预览图片逼死强迫症，可以将父主题文件夹下的 screenshot.png 拷贝到子主题的文件夹里，或自己做一张预览图。\n\n如需修改样式，可以直接写进子主题的style.css文件中覆盖原样式。如需修改页面的 HTML 或 PHP 代码，拷贝相应文件到子主题文件夹下，修改该文件即可。如需修改某个方法，可在子主题文件夹下创建 functions.php 文件，该文件中的方法将覆盖父主题中的同名方法。","slug":"2016-10-22@Wordpress 创建子主题","published":1,"updated":"2020-06-29T03:32:42.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48n0059rqgj3lqv1q2e","content":"<p>Wordpress 的主题总是有许多不尽如人意的地方，经常需要自定义样式、文本。然而直接修改主题源文件的体验并不优雅。使用子主题可以避免修改在主题升级后丢失，总之值得尝试，创建子主题的方式也 非常简单。</p>\n<a id=\"more\"></a>\n\n<p>接下来以自带主题 Twenty Fifteen 为例演示创建一个子主题。</p>\n<p>第一步，在 wp-content/themes/ 下新建一个文件夹，作为子主题的文件夹，该文件夹可以随意命名，我将该文件夹命名为 twentyfifteen-child 。</p>\n<p>第二步，在 twentyfifteen-child 文件夹下新建一个 style.css 文件，代码如下。</p>\n<pre><code class=\"css\">/*\nTheme Name:     Twenty Fifteen Child\nTheme URI:      http://example.com/\nDescription:    Child theme for the Twenty Fifteen theme \nAuthor:         Your name here\nAuthor URI:     http://example.com/\nTemplate:       twentyfifteen\nVersion:        1.0\n*/\n\n@import url(../twentyfifteen/style.css);</code></pre>\n<p>Template 后填写父主题的文件夹名称，Theme Name 后填写子主题的名称，其他项目非必填。然后导入父主题的 CSS 文件。</p>\n<p>至此，子主题已创建完毕，可以在主题中看到新增了 Twenty Fifteen Child 主题。如果觉得没有预览图片逼死强迫症，可以将父主题文件夹下的 screenshot.png 拷贝到子主题的文件夹里，或自己做一张预览图。</p>\n<p>如需修改样式，可以直接写进子主题的style.css文件中覆盖原样式。如需修改页面的 HTML 或 PHP 代码，拷贝相应文件到子主题文件夹下，修改该文件即可。如需修改某个方法，可在子主题文件夹下创建 functions.php 文件，该文件中的方法将覆盖父主题中的同名方法。</p>\n","site":{"data":{}},"excerpt":"<p>Wordpress 的主题总是有许多不尽如人意的地方，经常需要自定义样式、文本。然而直接修改主题源文件的体验并不优雅。使用子主题可以避免修改在主题升级后丢失，总之值得尝试，创建子主题的方式也 非常简单。</p>","more":"<p>接下来以自带主题 Twenty Fifteen 为例演示创建一个子主题。</p>\n<p>第一步，在 wp-content/themes/ 下新建一个文件夹，作为子主题的文件夹，该文件夹可以随意命名，我将该文件夹命名为 twentyfifteen-child 。</p>\n<p>第二步，在 twentyfifteen-child 文件夹下新建一个 style.css 文件，代码如下。</p>\n<pre><code class=\"css\">/*\nTheme Name:     Twenty Fifteen Child\nTheme URI:      http://example.com/\nDescription:    Child theme for the Twenty Fifteen theme \nAuthor:         Your name here\nAuthor URI:     http://example.com/\nTemplate:       twentyfifteen\nVersion:        1.0\n*/\n\n@import url(../twentyfifteen/style.css);</code></pre>\n<p>Template 后填写父主题的文件夹名称，Theme Name 后填写子主题的名称，其他项目非必填。然后导入父主题的 CSS 文件。</p>\n<p>至此，子主题已创建完毕，可以在主题中看到新增了 Twenty Fifteen Child 主题。如果觉得没有预览图片逼死强迫症，可以将父主题文件夹下的 screenshot.png 拷贝到子主题的文件夹里，或自己做一张预览图。</p>\n<p>如需修改样式，可以直接写进子主题的style.css文件中覆盖原样式。如需修改页面的 HTML 或 PHP 代码，拷贝相应文件到子主题文件夹下，修改该文件即可。如需修改某个方法，可在子主题文件夹下创建 functions.php 文件，该文件中的方法将覆盖父主题中的同名方法。</p>"},{"title":"Git、Shell、Git Shell、Git Bash","date":"2016-10-23T02:47:47.000Z","_content":"\n由于 Linux 和 Git 知识储备不足，最近被这些名词搞得混乱，有必要理清概念为接下来的学习铺路。\n\nGit：版本控制系统，类似 SVN 。之前也是 Git 和 GitHub 傻傻分不清楚，GitHub 是用 Git 进行版本控制的项目托管平台，本质是一个网站，所以 Git≠GitHub 。\n\n<!-- more -->\n\nShell：计算机壳层，是指“提供使用者使用界面”的软件，类似 Windows 中的命令行工具（cmd.exe）。\n\nBash：Linux 中默认的 Shell ，所以它就是一种 Shell 。\n\nGit Shell：安装了 Git 的 Shell ，即支持 Git 命令的 Shell 。GitHub 的命令行客户端也叫 Git Shell 。\n\nGit Bash：Git 的默认客户端，用于在 Windows 下使用 Git 命令。","source":"_posts/2016-10-23@Git、Shell、Git Shell、Git Bash.md","raw":"---\ntitle: Git、Shell、Git Shell、Git Bash\ncategories:\n  - Other\ndate: 2016-10-23 10:47:47\ntags:\n  - Git\n---\n\n由于 Linux 和 Git 知识储备不足，最近被这些名词搞得混乱，有必要理清概念为接下来的学习铺路。\n\nGit：版本控制系统，类似 SVN 。之前也是 Git 和 GitHub 傻傻分不清楚，GitHub 是用 Git 进行版本控制的项目托管平台，本质是一个网站，所以 Git≠GitHub 。\n\n<!-- more -->\n\nShell：计算机壳层，是指“提供使用者使用界面”的软件，类似 Windows 中的命令行工具（cmd.exe）。\n\nBash：Linux 中默认的 Shell ，所以它就是一种 Shell 。\n\nGit Shell：安装了 Git 的 Shell ，即支持 Git 命令的 Shell 。GitHub 的命令行客户端也叫 Git Shell 。\n\nGit Bash：Git 的默认客户端，用于在 Windows 下使用 Git 命令。","slug":"2016-10-23@Git、Shell、Git Shell、Git Bash","published":1,"updated":"2020-06-29T03:32:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48o005crqgjg5x773ss","content":"<p>由于 Linux 和 Git 知识储备不足，最近被这些名词搞得混乱，有必要理清概念为接下来的学习铺路。</p>\n<p>Git：版本控制系统，类似 SVN 。之前也是 Git 和 GitHub 傻傻分不清楚，GitHub 是用 Git 进行版本控制的项目托管平台，本质是一个网站，所以 Git≠GitHub 。</p>\n<a id=\"more\"></a>\n\n<p>Shell：计算机壳层，是指“提供使用者使用界面”的软件，类似 Windows 中的命令行工具（cmd.exe）。</p>\n<p>Bash：Linux 中默认的 Shell ，所以它就是一种 Shell 。</p>\n<p>Git Shell：安装了 Git 的 Shell ，即支持 Git 命令的 Shell 。GitHub 的命令行客户端也叫 Git Shell 。</p>\n<p>Git Bash：Git 的默认客户端，用于在 Windows 下使用 Git 命令。</p>\n","site":{"data":{}},"excerpt":"<p>由于 Linux 和 Git 知识储备不足，最近被这些名词搞得混乱，有必要理清概念为接下来的学习铺路。</p>\n<p>Git：版本控制系统，类似 SVN 。之前也是 Git 和 GitHub 傻傻分不清楚，GitHub 是用 Git 进行版本控制的项目托管平台，本质是一个网站，所以 Git≠GitHub 。</p>","more":"<p>Shell：计算机壳层，是指“提供使用者使用界面”的软件，类似 Windows 中的命令行工具（cmd.exe）。</p>\n<p>Bash：Linux 中默认的 Shell ，所以它就是一种 Shell 。</p>\n<p>Git Shell：安装了 Git 的 Shell ，即支持 Git 命令的 Shell 。GitHub 的命令行客户端也叫 Git Shell 。</p>\n<p>Git Bash：Git 的默认客户端，用于在 Windows 下使用 Git 命令。</p>"},{"title":"Homestead 开发环境配置","date":"2016-10-23T06:43:09.000Z","_content":"\nLaravel Homestead 是一套完整的 PHP 开发环境，类似 WampServer 。不同的是，Homestead 运行于虚拟机之中，而 WampServer 则直接将服务端软件安装在本机上。\n\n<!-- more -->\n\nHomestead 的安装依赖于虚拟机软件和 Vagrant 。Vagrant 是一个快速搭建开发环境的工具，类似装系统用的 Ghost ，可以直接把别人打包好的开发环境（包括系统和服务端软件），Copy/Paste 到一台设备中，省去逐一安装服务端软件的麻烦。\n\n接下来的实践完全基于官方文档，并且已成功在 Win7 64bit 下安装了 Homestead 。\n\n### 安装虚拟机软件\n\n虚拟机软件可选择 VirtualBox 或 VMware ，虽然官方推荐使用效率更高的 VMware ，但为了节约时间我安装了开源且免费的 [VirtualBox](https://www.virtualbox.org/) ，版本5.1.8。\n\n### 安装 Vagrant\n\n访问[官网](https://www.vagrantup.com/)下载并安装 Vagrant 。\n\n### 添加 Vagrant Box\n\nVagrant Box 是使用 Vagrant 将一整套开发环境打包成的 .box 镜像文件。在命令行工具中执行以下命令即可添加 Homestead 镜像，等待下载/安装完毕。如果下载失败，可参考[解决方案](http://www.caiyiming.com/article/20161024.html)。\n\n```\nvagrant box add laravel/homestead\n```\n \n\n### 安装 Homestead\n\n使用 Git 命令拷贝 Homestead 的代码并保存到 Home 目录的 Homestead 文件夹下。命令行中的 ~ 目录即为 Home 目录，如果你不知道 Home 目录的路径，尝试在“计算机”的地址栏输入 `%homepath%` 访问。\n\n```\ncd ~\ngit clone https://github.com/laravel/homestead.git Homestead\n```\n\n定位到 Homestead 文件夹，创建 Homestead 配置文件。\n\n```\ncd ~/Homestead\nbash init.sh\n```\n\n### 配置 Homestead\n\n用编辑器打开 Home 目录下的隐藏文件夹 .homestead 中的 Homestead.yaml 文件，该文件为 Homestead 的配置文件。\n\n```\n# 服务器的局域网 IP 地址\nip: \"192.168.10.10\"\n\n# 服务器可用内存\nmemory: 2048\n\n# 服务器可用 CPU 核心数\ncpus: 1\n\n# 虚拟机软件\nprovider: virtualbox\n\n# SSH 公钥\nauthorize: ~/.ssh/id_rsa.pub\n\n# SSH 私钥\nkeys:\n  - ~/.ssh/id_rsa\n\n# 本机与虚拟机的路径关联\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\n\n# 域名绑定\nsites:\n    - map: 192.168.10.10\n      to: /home/vagrant/Code\n\n# 默认数据库名称\ndatabases:\n    - homestead\n```\n\n_provider_ 应该根据本机已安装的虚拟机软件，设为 `virtualbox` 、 `vmware_fusion` 或 `vmware_workstation` 。_authorize/keys_ 必须与 ~/.ssh 下的对应的密钥文件名称一致。_folders_ 用于关联本机与虚拟机目录，即本机 ~/Code 路径下的文件，相当于也存在于虚拟机的代码根目录 /home/vagrant/Code 路径下，map 路径必须存在。_sites_ 关联域名与虚拟机目录，可设置多站点，此处直接关联了 IP 访问根目录。\n \n\n运行虚拟机\n\n在 ~\\Homestead 目录下，执行该命令。\n\n```\nvagrant up\n```\n \n\n测试开发环境\n\n写一个 PHP 文件放到 ~\\Code 路径下。\n\n``` php\necho 'Hello World!';\n```\n\n打开浏览器，访问192.168.10.10，看看浏览器是否打印出了 _Hello World!_ 。\n\n \n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2\n\n ","source":"_posts/2016-10-23@Homestead 开发环境配置.md","raw":"---\ntitle: Homestead 开发环境配置\ncategories:\n  - Web Back-end\ndate: 2016-10-23 14:43:09\ntags:\n  - Homestead\n---\n\nLaravel Homestead 是一套完整的 PHP 开发环境，类似 WampServer 。不同的是，Homestead 运行于虚拟机之中，而 WampServer 则直接将服务端软件安装在本机上。\n\n<!-- more -->\n\nHomestead 的安装依赖于虚拟机软件和 Vagrant 。Vagrant 是一个快速搭建开发环境的工具，类似装系统用的 Ghost ，可以直接把别人打包好的开发环境（包括系统和服务端软件），Copy/Paste 到一台设备中，省去逐一安装服务端软件的麻烦。\n\n接下来的实践完全基于官方文档，并且已成功在 Win7 64bit 下安装了 Homestead 。\n\n### 安装虚拟机软件\n\n虚拟机软件可选择 VirtualBox 或 VMware ，虽然官方推荐使用效率更高的 VMware ，但为了节约时间我安装了开源且免费的 [VirtualBox](https://www.virtualbox.org/) ，版本5.1.8。\n\n### 安装 Vagrant\n\n访问[官网](https://www.vagrantup.com/)下载并安装 Vagrant 。\n\n### 添加 Vagrant Box\n\nVagrant Box 是使用 Vagrant 将一整套开发环境打包成的 .box 镜像文件。在命令行工具中执行以下命令即可添加 Homestead 镜像，等待下载/安装完毕。如果下载失败，可参考[解决方案](http://www.caiyiming.com/article/20161024.html)。\n\n```\nvagrant box add laravel/homestead\n```\n \n\n### 安装 Homestead\n\n使用 Git 命令拷贝 Homestead 的代码并保存到 Home 目录的 Homestead 文件夹下。命令行中的 ~ 目录即为 Home 目录，如果你不知道 Home 目录的路径，尝试在“计算机”的地址栏输入 `%homepath%` 访问。\n\n```\ncd ~\ngit clone https://github.com/laravel/homestead.git Homestead\n```\n\n定位到 Homestead 文件夹，创建 Homestead 配置文件。\n\n```\ncd ~/Homestead\nbash init.sh\n```\n\n### 配置 Homestead\n\n用编辑器打开 Home 目录下的隐藏文件夹 .homestead 中的 Homestead.yaml 文件，该文件为 Homestead 的配置文件。\n\n```\n# 服务器的局域网 IP 地址\nip: \"192.168.10.10\"\n\n# 服务器可用内存\nmemory: 2048\n\n# 服务器可用 CPU 核心数\ncpus: 1\n\n# 虚拟机软件\nprovider: virtualbox\n\n# SSH 公钥\nauthorize: ~/.ssh/id_rsa.pub\n\n# SSH 私钥\nkeys:\n  - ~/.ssh/id_rsa\n\n# 本机与虚拟机的路径关联\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\n\n# 域名绑定\nsites:\n    - map: 192.168.10.10\n      to: /home/vagrant/Code\n\n# 默认数据库名称\ndatabases:\n    - homestead\n```\n\n_provider_ 应该根据本机已安装的虚拟机软件，设为 `virtualbox` 、 `vmware_fusion` 或 `vmware_workstation` 。_authorize/keys_ 必须与 ~/.ssh 下的对应的密钥文件名称一致。_folders_ 用于关联本机与虚拟机目录，即本机 ~/Code 路径下的文件，相当于也存在于虚拟机的代码根目录 /home/vagrant/Code 路径下，map 路径必须存在。_sites_ 关联域名与虚拟机目录，可设置多站点，此处直接关联了 IP 访问根目录。\n \n\n运行虚拟机\n\n在 ~\\Homestead 目录下，执行该命令。\n\n```\nvagrant up\n```\n \n\n测试开发环境\n\n写一个 PHP 文件放到 ~\\Code 路径下。\n\n``` php\necho 'Hello World!';\n```\n\n打开浏览器，访问192.168.10.10，看看浏览器是否打印出了 _Hello World!_ 。\n\n \n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2\n\n ","slug":"2016-10-23@Homestead 开发环境配置","published":1,"updated":"2020-06-29T03:32:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48p005hrqgjgdhy3mae","content":"<p>Laravel Homestead 是一套完整的 PHP 开发环境，类似 WampServer 。不同的是，Homestead 运行于虚拟机之中，而 WampServer 则直接将服务端软件安装在本机上。</p>\n<a id=\"more\"></a>\n\n<p>Homestead 的安装依赖于虚拟机软件和 Vagrant 。Vagrant 是一个快速搭建开发环境的工具，类似装系统用的 Ghost ，可以直接把别人打包好的开发环境（包括系统和服务端软件），Copy/Paste 到一台设备中，省去逐一安装服务端软件的麻烦。</p>\n<p>接下来的实践完全基于官方文档，并且已成功在 Win7 64bit 下安装了 Homestead 。</p>\n<h3 id=\"安装虚拟机软件\"><a href=\"#安装虚拟机软件\" class=\"headerlink\" title=\"安装虚拟机软件\"></a>安装虚拟机软件</h3><p>虚拟机软件可选择 VirtualBox 或 VMware ，虽然官方推荐使用效率更高的 VMware ，但为了节约时间我安装了开源且免费的 <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> ，版本5.1.8。</p>\n<h3 id=\"安装-Vagrant\"><a href=\"#安装-Vagrant\" class=\"headerlink\" title=\"安装 Vagrant\"></a>安装 Vagrant</h3><p>访问<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">官网</a>下载并安装 Vagrant 。</p>\n<h3 id=\"添加-Vagrant-Box\"><a href=\"#添加-Vagrant-Box\" class=\"headerlink\" title=\"添加 Vagrant Box\"></a>添加 Vagrant Box</h3><p>Vagrant Box 是使用 Vagrant 将一整套开发环境打包成的 .box 镜像文件。在命令行工具中执行以下命令即可添加 Homestead 镜像，等待下载/安装完毕。如果下载失败，可参考<a href=\"http://www.caiyiming.com/article/20161024.html\" target=\"_blank\" rel=\"noopener\">解决方案</a>。</p>\n<pre><code>vagrant box add laravel/homestead</code></pre><h3 id=\"安装-Homestead\"><a href=\"#安装-Homestead\" class=\"headerlink\" title=\"安装 Homestead\"></a>安装 Homestead</h3><p>使用 Git 命令拷贝 Homestead 的代码并保存到 Home 目录的 Homestead 文件夹下。命令行中的 ~ 目录即为 Home 目录，如果你不知道 Home 目录的路径，尝试在“计算机”的地址栏输入 <code>%homepath%</code> 访问。</p>\n<pre><code>cd ~\ngit clone https://github.com/laravel/homestead.git Homestead</code></pre><p>定位到 Homestead 文件夹，创建 Homestead 配置文件。</p>\n<pre><code>cd ~/Homestead\nbash init.sh</code></pre><h3 id=\"配置-Homestead\"><a href=\"#配置-Homestead\" class=\"headerlink\" title=\"配置 Homestead\"></a>配置 Homestead</h3><p>用编辑器打开 Home 目录下的隐藏文件夹 .homestead 中的 Homestead.yaml 文件，该文件为 Homestead 的配置文件。</p>\n<pre><code># 服务器的局域网 IP 地址\nip: &quot;192.168.10.10&quot;\n\n# 服务器可用内存\nmemory: 2048\n\n# 服务器可用 CPU 核心数\ncpus: 1\n\n# 虚拟机软件\nprovider: virtualbox\n\n# SSH 公钥\nauthorize: ~/.ssh/id_rsa.pub\n\n# SSH 私钥\nkeys:\n  - ~/.ssh/id_rsa\n\n# 本机与虚拟机的路径关联\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\n\n# 域名绑定\nsites:\n    - map: 192.168.10.10\n      to: /home/vagrant/Code\n\n# 默认数据库名称\ndatabases:\n    - homestead</code></pre><p><em>provider</em> 应该根据本机已安装的虚拟机软件，设为 <code>virtualbox</code> 、 <code>vmware_fusion</code> 或 <code>vmware_workstation</code> 。<em>authorize/keys</em> 必须与 ~/.ssh 下的对应的密钥文件名称一致。<em>folders</em> 用于关联本机与虚拟机目录，即本机 ~/Code 路径下的文件，相当于也存在于虚拟机的代码根目录 /home/vagrant/Code 路径下，map 路径必须存在。<em>sites</em> 关联域名与虚拟机目录，可设置多站点，此处直接关联了 IP 访问根目录。</p>\n<p>运行虚拟机</p>\n<p>在 ~\\Homestead 目录下，执行该命令。</p>\n<pre><code>vagrant up</code></pre><p>测试开发环境</p>\n<p>写一个 PHP 文件放到 ~\\Code 路径下。</p>\n<pre><code class=\"php\">echo &#39;Hello World!&#39;;</code></pre>\n<p>打开浏览器，访问192.168.10.10，看看浏览器是否打印出了 <em>Hello World!</em> 。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>Laravel Homestead 是一套完整的 PHP 开发环境，类似 WampServer 。不同的是，Homestead 运行于虚拟机之中，而 WampServer 则直接将服务端软件安装在本机上。</p>","more":"<p>Homestead 的安装依赖于虚拟机软件和 Vagrant 。Vagrant 是一个快速搭建开发环境的工具，类似装系统用的 Ghost ，可以直接把别人打包好的开发环境（包括系统和服务端软件），Copy/Paste 到一台设备中，省去逐一安装服务端软件的麻烦。</p>\n<p>接下来的实践完全基于官方文档，并且已成功在 Win7 64bit 下安装了 Homestead 。</p>\n<h3 id=\"安装虚拟机软件\"><a href=\"#安装虚拟机软件\" class=\"headerlink\" title=\"安装虚拟机软件\"></a>安装虚拟机软件</h3><p>虚拟机软件可选择 VirtualBox 或 VMware ，虽然官方推荐使用效率更高的 VMware ，但为了节约时间我安装了开源且免费的 <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">VirtualBox</a> ，版本5.1.8。</p>\n<h3 id=\"安装-Vagrant\"><a href=\"#安装-Vagrant\" class=\"headerlink\" title=\"安装 Vagrant\"></a>安装 Vagrant</h3><p>访问<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">官网</a>下载并安装 Vagrant 。</p>\n<h3 id=\"添加-Vagrant-Box\"><a href=\"#添加-Vagrant-Box\" class=\"headerlink\" title=\"添加 Vagrant Box\"></a>添加 Vagrant Box</h3><p>Vagrant Box 是使用 Vagrant 将一整套开发环境打包成的 .box 镜像文件。在命令行工具中执行以下命令即可添加 Homestead 镜像，等待下载/安装完毕。如果下载失败，可参考<a href=\"http://www.caiyiming.com/article/20161024.html\" target=\"_blank\" rel=\"noopener\">解决方案</a>。</p>\n<pre><code>vagrant box add laravel/homestead</code></pre><h3 id=\"安装-Homestead\"><a href=\"#安装-Homestead\" class=\"headerlink\" title=\"安装 Homestead\"></a>安装 Homestead</h3><p>使用 Git 命令拷贝 Homestead 的代码并保存到 Home 目录的 Homestead 文件夹下。命令行中的 ~ 目录即为 Home 目录，如果你不知道 Home 目录的路径，尝试在“计算机”的地址栏输入 <code>%homepath%</code> 访问。</p>\n<pre><code>cd ~\ngit clone https://github.com/laravel/homestead.git Homestead</code></pre><p>定位到 Homestead 文件夹，创建 Homestead 配置文件。</p>\n<pre><code>cd ~/Homestead\nbash init.sh</code></pre><h3 id=\"配置-Homestead\"><a href=\"#配置-Homestead\" class=\"headerlink\" title=\"配置 Homestead\"></a>配置 Homestead</h3><p>用编辑器打开 Home 目录下的隐藏文件夹 .homestead 中的 Homestead.yaml 文件，该文件为 Homestead 的配置文件。</p>\n<pre><code># 服务器的局域网 IP 地址\nip: &quot;192.168.10.10&quot;\n\n# 服务器可用内存\nmemory: 2048\n\n# 服务器可用 CPU 核心数\ncpus: 1\n\n# 虚拟机软件\nprovider: virtualbox\n\n# SSH 公钥\nauthorize: ~/.ssh/id_rsa.pub\n\n# SSH 私钥\nkeys:\n  - ~/.ssh/id_rsa\n\n# 本机与虚拟机的路径关联\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\n\n# 域名绑定\nsites:\n    - map: 192.168.10.10\n      to: /home/vagrant/Code\n\n# 默认数据库名称\ndatabases:\n    - homestead</code></pre><p><em>provider</em> 应该根据本机已安装的虚拟机软件，设为 <code>virtualbox</code> 、 <code>vmware_fusion</code> 或 <code>vmware_workstation</code> 。<em>authorize/keys</em> 必须与 ~/.ssh 下的对应的密钥文件名称一致。<em>folders</em> 用于关联本机与虚拟机目录，即本机 ~/Code 路径下的文件，相当于也存在于虚拟机的代码根目录 /home/vagrant/Code 路径下，map 路径必须存在。<em>sites</em> 关联域名与虚拟机目录，可设置多站点，此处直接关联了 IP 访问根目录。</p>\n<p>运行虚拟机</p>\n<p>在 ~\\Homestead 目录下，执行该命令。</p>\n<pre><code>vagrant up</code></pre><p>测试开发环境</p>\n<p>写一个 PHP 文件放到 ~\\Code 路径下。</p>\n<pre><code class=\"php\">echo &#39;Hello World!&#39;;</code></pre>\n<p>打开浏览器，访问192.168.10.10，看看浏览器是否打印出了 <em>Hello World!</em> 。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"手动下载和安装 Homestead","date":"2016-10-24T06:09:43.000Z","_content":"\n在配置 Homestead 开发环境的过程中，执行以下命令将下载1G左右的镜像文件（Vagrant Box），然后安装包含完整 Homestead 环境的虚拟机。由于资源服务器位于海外，经常导致下载速度缓慢、下载失败等问题。\n\n<!-- more -->\n\n```\nvagrant box add laravel/homestead\n```\n\n我们可在命令行中找到 _box: Downloading_ 开头的一行，后面就是 Vagrant Box 文件的下载链接。将链接复制到迅雷等工具下载，得到拓展名为 box 的镜像文件。\n\n```\nvagrant box add laravel/homestead\n==> box: Loading metadata for box 'laravel/homestead'\n...\nbox: Downloading:  https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.5.0/providers/virtualbox.box\n```\n\n然后选择以下任意一种方式安装虚拟机。\n\n\n### 方法一\n\n第一步，执行以下命令通过刚刚下载的镜像文件添加虚拟机。\n\n```\n# Linux\nvagrant box add laravel/homestead ~/virtualbox.box\n\n# Windows\nvagrant box add laravel/homestead file:///d:/virtualbox.box\n```\n\n注意，此时通过 `vagrant up` 命令启动虚拟机时，仍会下载镜像文件。这是因为 Vagrant 认为该虚拟机的版本过低，于是自动下载最新版本的镜像（即使刚刚离线安装的虚拟机已是最新版）。\n\n第二步，解决版本识别错误问题。只需修改 Vagant 的索引文件即可解决，该文件参考路径如下。\n\n```\nC:\\Users\\YIMING\\\\.vagrant.d\\data\\machine-index\\index\n```\n\n```\n\"box\":{\n\t\"name\":\"laravel/homestead\",\n\t\"provider\":\"virtualbox\",\n\t\"version\":\"0.5.0\"}\n}\n```\n\n该方法需目录下已存在 index 文件可供修改，或者你已经很熟悉这个文件的格式。index 文件以 JSON 格式存储着已（通过Vagrant）安装的虚拟机的信息。将 version 字段修改为可用的版本号即可，然后再次尝试 `vagrant up` 启动虚拟机。\n\n### 方法二\n\n第一步，执行 `vagrant box add laravel/homestead` 触发下载镜像文件，然后马上按 Ctrl+C 取消。\n\n第二步，在 ~\\\\.vagrant.d\\tmp 目录下找到下载时生成的缓存文件。文件名类似：\n\n```\nboxb1926d351572dd849646d59563156601f026e2a5\n```\n\n第三步，将之前手动下载的镜像文件重命名为缓存文件的文件名，并覆盖缓存文件。\n\n第四步，执行 `vagrant box add laravel/homestead` ，下载进度将直接显示为100%，并开始添加虚拟机。\n\n简单总结一下。这两种方法都是我探索后发现的、退而求其次地安装 Homestead 虚拟机的方法。前者直接用命令通过本地镜像安装，但会出现 Vagrant 认错版本的尴尬（或许日后的版本更新可以修复）。后者则用本地镜像文件，替换掉缓存文件，欺骗 Vagrant 下载已完成从而执行安装。后者不需要纠正版本识别错误。\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead","source":"_posts/2016-10-24@手动下载和安装 Homestead.md","raw":"---\ntitle: 手动下载和安装 Homestead\ncategories:\n  - Web Back-end\ndate: 2016-10-24 14:09:43\ntags:\n  - Homestead\n---\n\n在配置 Homestead 开发环境的过程中，执行以下命令将下载1G左右的镜像文件（Vagrant Box），然后安装包含完整 Homestead 环境的虚拟机。由于资源服务器位于海外，经常导致下载速度缓慢、下载失败等问题。\n\n<!-- more -->\n\n```\nvagrant box add laravel/homestead\n```\n\n我们可在命令行中找到 _box: Downloading_ 开头的一行，后面就是 Vagrant Box 文件的下载链接。将链接复制到迅雷等工具下载，得到拓展名为 box 的镜像文件。\n\n```\nvagrant box add laravel/homestead\n==> box: Loading metadata for box 'laravel/homestead'\n...\nbox: Downloading:  https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.5.0/providers/virtualbox.box\n```\n\n然后选择以下任意一种方式安装虚拟机。\n\n\n### 方法一\n\n第一步，执行以下命令通过刚刚下载的镜像文件添加虚拟机。\n\n```\n# Linux\nvagrant box add laravel/homestead ~/virtualbox.box\n\n# Windows\nvagrant box add laravel/homestead file:///d:/virtualbox.box\n```\n\n注意，此时通过 `vagrant up` 命令启动虚拟机时，仍会下载镜像文件。这是因为 Vagrant 认为该虚拟机的版本过低，于是自动下载最新版本的镜像（即使刚刚离线安装的虚拟机已是最新版）。\n\n第二步，解决版本识别错误问题。只需修改 Vagant 的索引文件即可解决，该文件参考路径如下。\n\n```\nC:\\Users\\YIMING\\\\.vagrant.d\\data\\machine-index\\index\n```\n\n```\n\"box\":{\n\t\"name\":\"laravel/homestead\",\n\t\"provider\":\"virtualbox\",\n\t\"version\":\"0.5.0\"}\n}\n```\n\n该方法需目录下已存在 index 文件可供修改，或者你已经很熟悉这个文件的格式。index 文件以 JSON 格式存储着已（通过Vagrant）安装的虚拟机的信息。将 version 字段修改为可用的版本号即可，然后再次尝试 `vagrant up` 启动虚拟机。\n\n### 方法二\n\n第一步，执行 `vagrant box add laravel/homestead` 触发下载镜像文件，然后马上按 Ctrl+C 取消。\n\n第二步，在 ~\\\\.vagrant.d\\tmp 目录下找到下载时生成的缓存文件。文件名类似：\n\n```\nboxb1926d351572dd849646d59563156601f026e2a5\n```\n\n第三步，将之前手动下载的镜像文件重命名为缓存文件的文件名，并覆盖缓存文件。\n\n第四步，执行 `vagrant box add laravel/homestead` ，下载进度将直接显示为100%，并开始添加虚拟机。\n\n简单总结一下。这两种方法都是我探索后发现的、退而求其次地安装 Homestead 虚拟机的方法。前者直接用命令通过本地镜像安装，但会出现 Vagrant 认错版本的尴尬（或许日后的版本更新可以修复）。后者则用本地镜像文件，替换掉缓存文件，欺骗 Vagrant 下载已完成从而执行安装。后者不需要纠正版本识别错误。\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead","slug":"2016-10-24@手动下载和安装 Homestead","published":1,"updated":"2020-06-29T03:32:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48q005krqgjbsf4d07u","content":"<p>在配置 Homestead 开发环境的过程中，执行以下命令将下载1G左右的镜像文件（Vagrant Box），然后安装包含完整 Homestead 环境的虚拟机。由于资源服务器位于海外，经常导致下载速度缓慢、下载失败等问题。</p>\n<a id=\"more\"></a>\n\n<pre><code>vagrant box add laravel/homestead</code></pre><p>我们可在命令行中找到 <em>box: Downloading</em> 开头的一行，后面就是 Vagrant Box 文件的下载链接。将链接复制到迅雷等工具下载，得到拓展名为 box 的镜像文件。</p>\n<pre><code>vagrant box add laravel/homestead\n==&gt; box: Loading metadata for box &#39;laravel/homestead&#39;\n...\nbox: Downloading:  https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.5.0/providers/virtualbox.box</code></pre><p>然后选择以下任意一种方式安装虚拟机。</p>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>第一步，执行以下命令通过刚刚下载的镜像文件添加虚拟机。</p>\n<pre><code># Linux\nvagrant box add laravel/homestead ~/virtualbox.box\n\n# Windows\nvagrant box add laravel/homestead file:///d:/virtualbox.box</code></pre><p>注意，此时通过 <code>vagrant up</code> 命令启动虚拟机时，仍会下载镜像文件。这是因为 Vagrant 认为该虚拟机的版本过低，于是自动下载最新版本的镜像（即使刚刚离线安装的虚拟机已是最新版）。</p>\n<p>第二步，解决版本识别错误问题。只需修改 Vagant 的索引文件即可解决，该文件参考路径如下。</p>\n<pre><code>C:\\Users\\YIMING\\\\.vagrant.d\\data\\machine-index\\index</code></pre><pre><code>&quot;box&quot;:{\n    &quot;name&quot;:&quot;laravel/homestead&quot;,\n    &quot;provider&quot;:&quot;virtualbox&quot;,\n    &quot;version&quot;:&quot;0.5.0&quot;}\n}</code></pre><p>该方法需目录下已存在 index 文件可供修改，或者你已经很熟悉这个文件的格式。index 文件以 JSON 格式存储着已（通过Vagrant）安装的虚拟机的信息。将 version 字段修改为可用的版本号即可，然后再次尝试 <code>vagrant up</code> 启动虚拟机。</p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>第一步，执行 <code>vagrant box add laravel/homestead</code> 触发下载镜像文件，然后马上按 Ctrl+C 取消。</p>\n<p>第二步，在 ~\\.vagrant.d\\tmp 目录下找到下载时生成的缓存文件。文件名类似：</p>\n<pre><code>boxb1926d351572dd849646d59563156601f026e2a5</code></pre><p>第三步，将之前手动下载的镜像文件重命名为缓存文件的文件名，并覆盖缓存文件。</p>\n<p>第四步，执行 <code>vagrant box add laravel/homestead</code> ，下载进度将直接显示为100%，并开始添加虚拟机。</p>\n<p>简单总结一下。这两种方法都是我探索后发现的、退而求其次地安装 Homestead 虚拟机的方法。前者直接用命令通过本地镜像安装，但会出现 Vagrant 认错版本的尴尬（或许日后的版本更新可以修复）。后者则用本地镜像文件，替换掉缓存文件，欺骗 Vagrant 下载已完成从而执行安装。后者不需要纠正版本识别错误。</p>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead</p>\n","site":{"data":{}},"excerpt":"<p>在配置 Homestead 开发环境的过程中，执行以下命令将下载1G左右的镜像文件（Vagrant Box），然后安装包含完整 Homestead 环境的虚拟机。由于资源服务器位于海外，经常导致下载速度缓慢、下载失败等问题。</p>","more":"<pre><code>vagrant box add laravel/homestead</code></pre><p>我们可在命令行中找到 <em>box: Downloading</em> 开头的一行，后面就是 Vagrant Box 文件的下载链接。将链接复制到迅雷等工具下载，得到拓展名为 box 的镜像文件。</p>\n<pre><code>vagrant box add laravel/homestead\n==&gt; box: Loading metadata for box &#39;laravel/homestead&#39;\n...\nbox: Downloading:  https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.5.0/providers/virtualbox.box</code></pre><p>然后选择以下任意一种方式安装虚拟机。</p>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>第一步，执行以下命令通过刚刚下载的镜像文件添加虚拟机。</p>\n<pre><code># Linux\nvagrant box add laravel/homestead ~/virtualbox.box\n\n# Windows\nvagrant box add laravel/homestead file:///d:/virtualbox.box</code></pre><p>注意，此时通过 <code>vagrant up</code> 命令启动虚拟机时，仍会下载镜像文件。这是因为 Vagrant 认为该虚拟机的版本过低，于是自动下载最新版本的镜像（即使刚刚离线安装的虚拟机已是最新版）。</p>\n<p>第二步，解决版本识别错误问题。只需修改 Vagant 的索引文件即可解决，该文件参考路径如下。</p>\n<pre><code>C:\\Users\\YIMING\\\\.vagrant.d\\data\\machine-index\\index</code></pre><pre><code>&quot;box&quot;:{\n    &quot;name&quot;:&quot;laravel/homestead&quot;,\n    &quot;provider&quot;:&quot;virtualbox&quot;,\n    &quot;version&quot;:&quot;0.5.0&quot;}\n}</code></pre><p>该方法需目录下已存在 index 文件可供修改，或者你已经很熟悉这个文件的格式。index 文件以 JSON 格式存储着已（通过Vagrant）安装的虚拟机的信息。将 version 字段修改为可用的版本号即可，然后再次尝试 <code>vagrant up</code> 启动虚拟机。</p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>第一步，执行 <code>vagrant box add laravel/homestead</code> 触发下载镜像文件，然后马上按 Ctrl+C 取消。</p>\n<p>第二步，在 ~\\.vagrant.d\\tmp 目录下找到下载时生成的缓存文件。文件名类似：</p>\n<pre><code>boxb1926d351572dd849646d59563156601f026e2a5</code></pre><p>第三步，将之前手动下载的镜像文件重命名为缓存文件的文件名，并覆盖缓存文件。</p>\n<p>第四步，执行 <code>vagrant box add laravel/homestead</code> ，下载进度将直接显示为100%，并开始添加虚拟机。</p>\n<p>简单总结一下。这两种方法都是我探索后发现的、退而求其次地安装 Homestead 虚拟机的方法。前者直接用命令通过本地镜像安装，但会出现 Vagrant 认错版本的尴尬（或许日后的版本更新可以修复）。后者则用本地镜像文件，替换掉缓存文件，欺骗 Vagrant 下载已完成从而执行安装。后者不需要纠正版本识别错误。</p>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead</p>"},{"title":"局域网访问 Homestead 站点","date":"2016-10-27T06:24:26.000Z","_content":"\n设置 Homestead 服务器为可被局域网内的其他设备访问，可以非常方便地测试移动端浏览效果，同时也可以把页面分享给团队的其他成员浏览。\n\n<!-- more -->\n\n第一步，修改脚本文件 `~\\Homestead\\scripts\\homestead.rb` ，允许局域网中的其他设备访问虚拟机。 将 _config.vm.network_ 属性的值修改为 `public_network` 。\n\n```\nconfig.vm.network :public_network, ip: settings[\"ip\"] ||= \"192.168.10.10\"\n```\n\n第二步，修改配置文件`~/.homestead/Homestead.yaml`，将虚拟机的 ip 修改为当前局域网网段中的 ip 。\n\n```\nip: \"192.168.1.200\"\n```\n\n第三步，新增一个站点，将 ip 的访问指向代码根目录。\n\n```\nsites:\n  - map: 192.168.1.200\n    to: /home/vagrant/Code/\n```\n\n然后使用命令行重启虚拟机。\n\n```\nvagrant halt\nvagrant up\n```\n\n同时刷新一下虚拟机的配置。\n\n```\nvagrant provision\n```\n\n现在你已可以使用同一 WIFI 下（局域网内）的手机、平板等设备通过 ip 地址访问 Homestead 服务器。\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","source":"_posts/2016-10-27@局域网访问 Homestead 站点.md","raw":"---\ntitle: 局域网访问 Homestead 站点\ncategories:\n  - Web Back-end\ndate: 2016-10-27 14:24:26\ntags:\n  - Homestead\n---\n\n设置 Homestead 服务器为可被局域网内的其他设备访问，可以非常方便地测试移动端浏览效果，同时也可以把页面分享给团队的其他成员浏览。\n\n<!-- more -->\n\n第一步，修改脚本文件 `~\\Homestead\\scripts\\homestead.rb` ，允许局域网中的其他设备访问虚拟机。 将 _config.vm.network_ 属性的值修改为 `public_network` 。\n\n```\nconfig.vm.network :public_network, ip: settings[\"ip\"] ||= \"192.168.10.10\"\n```\n\n第二步，修改配置文件`~/.homestead/Homestead.yaml`，将虚拟机的 ip 修改为当前局域网网段中的 ip 。\n\n```\nip: \"192.168.1.200\"\n```\n\n第三步，新增一个站点，将 ip 的访问指向代码根目录。\n\n```\nsites:\n  - map: 192.168.1.200\n    to: /home/vagrant/Code/\n```\n\n然后使用命令行重启虚拟机。\n\n```\nvagrant halt\nvagrant up\n```\n\n同时刷新一下虚拟机的配置。\n\n```\nvagrant provision\n```\n\n现在你已可以使用同一 WIFI 下（局域网内）的手机、平板等设备通过 ip 地址访问 Homestead 服务器。\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","slug":"2016-10-27@局域网访问 Homestead 站点","published":1,"updated":"2020-06-29T03:32:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48r005orqgj4dr45t6d","content":"<p>设置 Homestead 服务器为可被局域网内的其他设备访问，可以非常方便地测试移动端浏览效果，同时也可以把页面分享给团队的其他成员浏览。</p>\n<a id=\"more\"></a>\n\n<p>第一步，修改脚本文件 <code>~\\Homestead\\scripts\\homestead.rb</code> ，允许局域网中的其他设备访问虚拟机。 将 <em>config.vm.network</em> 属性的值修改为 <code>public_network</code> 。</p>\n<pre><code>config.vm.network :public_network, ip: settings[&quot;ip&quot;] ||= &quot;192.168.10.10&quot;</code></pre><p>第二步，修改配置文件<code>~/.homestead/Homestead.yaml</code>，将虚拟机的 ip 修改为当前局域网网段中的 ip 。</p>\n<pre><code>ip: &quot;192.168.1.200&quot;</code></pre><p>第三步，新增一个站点，将 ip 的访问指向代码根目录。</p>\n<pre><code>sites:\n  - map: 192.168.1.200\n    to: /home/vagrant/Code/</code></pre><p>然后使用命令行重启虚拟机。</p>\n<pre><code>vagrant halt\nvagrant up</code></pre><p>同时刷新一下虚拟机的配置。</p>\n<pre><code>vagrant provision</code></pre><p>现在你已可以使用同一 WIFI 下（局域网内）的手机、平板等设备通过 ip 地址访问 Homestead 服务器。</p>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>设置 Homestead 服务器为可被局域网内的其他设备访问，可以非常方便地测试移动端浏览效果，同时也可以把页面分享给团队的其他成员浏览。</p>","more":"<p>第一步，修改脚本文件 <code>~\\Homestead\\scripts\\homestead.rb</code> ，允许局域网中的其他设备访问虚拟机。 将 <em>config.vm.network</em> 属性的值修改为 <code>public_network</code> 。</p>\n<pre><code>config.vm.network :public_network, ip: settings[&quot;ip&quot;] ||= &quot;192.168.10.10&quot;</code></pre><p>第二步，修改配置文件<code>~/.homestead/Homestead.yaml</code>，将虚拟机的 ip 修改为当前局域网网段中的 ip 。</p>\n<pre><code>ip: &quot;192.168.1.200&quot;</code></pre><p>第三步，新增一个站点，将 ip 的访问指向代码根目录。</p>\n<pre><code>sites:\n  - map: 192.168.1.200\n    to: /home/vagrant/Code/</code></pre><p>然后使用命令行重启虚拟机。</p>\n<pre><code>vagrant halt\nvagrant up</code></pre><p>同时刷新一下虚拟机的配置。</p>\n<pre><code>vagrant provision</code></pre><p>现在你已可以使用同一 WIFI 下（局域网内）的手机、平板等设备通过 ip 地址访问 Homestead 服务器。</p>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"在 Homestead 上安装 phpMyAdmin","date":"2016-10-29T04:36:39.000Z","_content":"\n近期使用 Homestead 作为开发环境，由于命令行方式操作数据库效率低（学艺不精），于是准备安装一个 GUI 工具来辅助学习/开发，首选已经熟练使用的 phpMyAdmin 。\n\n<!-- more -->\n\n第一步，[下载](https://www.phpmyadmin.net/) 最新版本的 phpMyAdmin ，解压到代码目录下。\n\n第二步，修改服务器的配置文件 `~\\.homestead\\Homestead.yaml` ，添加一个新的站点。\n\n```\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\nsites:\n  - map: phpmyadmin.app\n    to: /home/vagrant/Code/phpmyadmin/\n    ...\n```\n\n第三步，修改 hosts 文件，新增一行内容，注意 ip 需要和 Homestead 配置文件中的一致。\n\n```\n192.168.10.10 phpmyadmin.app\n```\n\n好了！现在访问 phpmyadmin.app 即可使用 phpMyAdmin 。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","source":"_posts/2016-10-29@在 Homestead 上安装 phpMyAdmin.md","raw":"---\ntitle: 在 Homestead 上安装 phpMyAdmin\ncategories:\n  - Web Back-end\ndate: 2016-10-29 12:36:39\ntags:\n  - Homestead\n  - phpMyAdmin\n---\n\n近期使用 Homestead 作为开发环境，由于命令行方式操作数据库效率低（学艺不精），于是准备安装一个 GUI 工具来辅助学习/开发，首选已经熟练使用的 phpMyAdmin 。\n\n<!-- more -->\n\n第一步，[下载](https://www.phpmyadmin.net/) 最新版本的 phpMyAdmin ，解压到代码目录下。\n\n第二步，修改服务器的配置文件 `~\\.homestead\\Homestead.yaml` ，添加一个新的站点。\n\n```\nfolders:\n  - map: ~/Code\n    to: /home/vagrant/Code\nsites:\n  - map: phpmyadmin.app\n    to: /home/vagrant/Code/phpmyadmin/\n    ...\n```\n\n第三步，修改 hosts 文件，新增一行内容，注意 ip 需要和 Homestead 配置文件中的一致。\n\n```\n192.168.10.10 phpmyadmin.app\n```\n\n好了！现在访问 phpmyadmin.app 即可使用 phpMyAdmin 。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","slug":"2016-10-29@在 Homestead 上安装 phpMyAdmin","published":1,"updated":"2020-06-29T03:32:42.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48t005srqgj9orsbktg","content":"<p>近期使用 Homestead 作为开发环境，由于命令行方式操作数据库效率低（学艺不精），于是准备安装一个 GUI 工具来辅助学习/开发，首选已经熟练使用的 phpMyAdmin 。</p>\n<a id=\"more\"></a>\n\n<p>第一步，<a href=\"https://www.phpmyadmin.net/\" target=\"_blank\" rel=\"noopener\">下载</a> 最新版本的 phpMyAdmin ，解压到代码目录下。</p>\n<p>第二步，修改服务器的配置文件 <code>~\\.homestead\\Homestead.yaml</code> ，添加一个新的站点。</p>\n<pre><code>folders:\n  - map: ~/Code\n    to: /home/vagrant/Code\nsites:\n  - map: phpmyadmin.app\n    to: /home/vagrant/Code/phpmyadmin/\n    ...</code></pre><p>第三步，修改 hosts 文件，新增一行内容，注意 ip 需要和 Homestead 配置文件中的一致。</p>\n<pre><code>192.168.10.10 phpmyadmin.app</code></pre><p>好了！现在访问 phpmyadmin.app 即可使用 phpMyAdmin 。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>近期使用 Homestead 作为开发环境，由于命令行方式操作数据库效率低（学艺不精），于是准备安装一个 GUI 工具来辅助学习/开发，首选已经熟练使用的 phpMyAdmin 。</p>","more":"<p>第一步，<a href=\"https://www.phpmyadmin.net/\" target=\"_blank\" rel=\"noopener\">下载</a> 最新版本的 phpMyAdmin ，解压到代码目录下。</p>\n<p>第二步，修改服务器的配置文件 <code>~\\.homestead\\Homestead.yaml</code> ，添加一个新的站点。</p>\n<pre><code>folders:\n  - map: ~/Code\n    to: /home/vagrant/Code\nsites:\n  - map: phpmyadmin.app\n    to: /home/vagrant/Code/phpmyadmin/\n    ...</code></pre><p>第三步，修改 hosts 文件，新增一行内容，注意 ip 需要和 Homestead 配置文件中的一致。</p>\n<pre><code>192.168.10.10 phpmyadmin.app</code></pre><p>好了！现在访问 phpmyadmin.app 即可使用 phpMyAdmin 。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"使用 Vue.js 实现模态窗口","date":"2016-10-30T09:18:43.000Z","_content":"\nVue.js 是一个前端 MVVM 框架。由于公司的项目中有用到这个框架，我也开始接触和学习它。在阅读了官方文档后，我着手尝试用 Vue.js 实现模态窗口。\n\n<!-- more -->\n\n第一步，将必要的样式表添加到页面中。（代码位于文末）\n\n第二步，添加模态窗口的模板。什么是模板？可以理解为基本、通用的结构代码。每个弹窗的内容可能不同，但结构是一致的，这些一致的部分就是模板。\n注意模板中的预留的 `<slot>` 标签，在生成模态窗口时，可以在 `<slot>` 标签的位置插入不同的内容。下面这个模板把模态窗口分成上中下三个区域。\n\n```\n<!-- 模板 -->\n<script type=\"text/x-template\" id=\"modal-template\">\n  <transition name=\"modal\">\n    <div class=\"modal-mask\">\n      <div class=\"modal-wrapper\">\n        <div class=\"modal-container\">\n          <div class=\"modal-header\">\n            <slot name=\"header\">default header</slot>\n          </div>\n          <div class=\"modal-body\">\n            <slot name=\"body\">default body</slot>\n          </div>\n          <div class=\"modal-footer\">\n            <slot name=\"footer\">default footer\n              <button class=\"modal-default-button\" @click=\"$emit('close')\">OK</button>\n            </slot>\n          </div>\n        </div>\n      </div>\n    </div>\n  </transition>\n</script>\n```\n\n`<script>` 标签的 _id_ 属性用于定义模板的名称，在同一页面中可以创建多个模态窗口模板，以实现不同需求。\n\n第三步，在模板的基础上添加具体内容。\n\n``` xhtml\n<!-- 容器 -->\n<div id=\"app\">\n  <button id=\"show-modal\" @click=\"showModal = true\">Show Modal</button>\n  <modal v-if=\"showModal\" @close=\"showModal = false\">\n    <!-- 在此覆写模板内容 -->\n    <h3 slot=\"header\">custom header</h3>\n  </modal>\n</div>\n```\n\n给任意标签加上 _slot_ 属性，即可用于覆盖模板中对应名称的 `<slot>` 标签。在上面的代码中，`h3` 标签的 _slot_ 属性值等于 header ，所以它覆盖了模板中的 `<slot name=\"header\">default header</slot>` 。\n\n第四步，注册一个模态窗口组件。\n\n```\nVue.component('modal', {\n  template: '#modal-template'\n})\n```\n\n`Vue.component` 方法的第一个参数是该组件在容器中的标签，第二个参数是一个对象，定义了使用的模板 id 为 modal-template 。\n\n如果页面中存在多个模态窗口，并且分别绑定不同的模板，应该定义不同的标签，例如 `<modal-dialog>` 、`<modal-login>` 等。\n\n第五步，创建视图模型对象。el 是容器的 id , showModal 是一个布尔值，用于控制窗口的打开和关闭。\n\n```\nnew Vue({\n  el: '#app',\n  data: {\n    showModal: false\n  }\n})\n```\n\n好了，现在回头再看一遍之前的代码，尝试理解 Vue.js 的一些逻辑。\n\n`v-if=\"showModal\"` 表示监听 showModal 参数，当值为 `false` 时移除容器 div 中的代码（关闭窗口），当值为 `true` 时往容器 div 中填充代码（显示窗口）。\n\n`@click=\"showModal = true\"` 表示点击该元素时修改 `showModal` 值为 `true` ，类似 JavaScript 的 onclick 事件。\n\n`@click=\"$emit('close')` 表示点击该元素时当前元素的 `@close` 中的代码。\n \n\n本例样式表：\n``` css\n.modal-mask {\n  position: fixed;\n  z-index: 9998;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, .5);\n  display: table;\n  transition: opacity .3s ease;\n}\n.modal-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n}\n.modal-container {\n  width: 300px;\n  margin: 0px auto;\n  padding: 20px 30px;\n  background-color: #fff;\n  border-radius: 2px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, .33);\n  transition: all .3s ease;\n  font-family: Helvetica, Arial, sans-serif;\n}\n.modal-header h3 {\n  margin-top: 0;\n  color: #42b983;\n}\n.modal-body {\n  margin: 20px 0;\n}\n.modal-default-button {\n  float: right;\n}\n.modal-enter {\n  opacity: 0;\n}\n.modal-leave-active {\n  opacity: 0;\n}\n.modal-enter .modal-container,\n.modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}\n```\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2 ","source":"_posts/2016-10-30@使用 Vue.js 实现模态窗口.md","raw":"---\ntitle: 使用 Vue.js 实现模态窗口\ncategories:\n  - Web Front-end\ndate: 2016-10-30 17:18:43\ntags:\n  - Vue.js\n---\n\nVue.js 是一个前端 MVVM 框架。由于公司的项目中有用到这个框架，我也开始接触和学习它。在阅读了官方文档后，我着手尝试用 Vue.js 实现模态窗口。\n\n<!-- more -->\n\n第一步，将必要的样式表添加到页面中。（代码位于文末）\n\n第二步，添加模态窗口的模板。什么是模板？可以理解为基本、通用的结构代码。每个弹窗的内容可能不同，但结构是一致的，这些一致的部分就是模板。\n注意模板中的预留的 `<slot>` 标签，在生成模态窗口时，可以在 `<slot>` 标签的位置插入不同的内容。下面这个模板把模态窗口分成上中下三个区域。\n\n```\n<!-- 模板 -->\n<script type=\"text/x-template\" id=\"modal-template\">\n  <transition name=\"modal\">\n    <div class=\"modal-mask\">\n      <div class=\"modal-wrapper\">\n        <div class=\"modal-container\">\n          <div class=\"modal-header\">\n            <slot name=\"header\">default header</slot>\n          </div>\n          <div class=\"modal-body\">\n            <slot name=\"body\">default body</slot>\n          </div>\n          <div class=\"modal-footer\">\n            <slot name=\"footer\">default footer\n              <button class=\"modal-default-button\" @click=\"$emit('close')\">OK</button>\n            </slot>\n          </div>\n        </div>\n      </div>\n    </div>\n  </transition>\n</script>\n```\n\n`<script>` 标签的 _id_ 属性用于定义模板的名称，在同一页面中可以创建多个模态窗口模板，以实现不同需求。\n\n第三步，在模板的基础上添加具体内容。\n\n``` xhtml\n<!-- 容器 -->\n<div id=\"app\">\n  <button id=\"show-modal\" @click=\"showModal = true\">Show Modal</button>\n  <modal v-if=\"showModal\" @close=\"showModal = false\">\n    <!-- 在此覆写模板内容 -->\n    <h3 slot=\"header\">custom header</h3>\n  </modal>\n</div>\n```\n\n给任意标签加上 _slot_ 属性，即可用于覆盖模板中对应名称的 `<slot>` 标签。在上面的代码中，`h3` 标签的 _slot_ 属性值等于 header ，所以它覆盖了模板中的 `<slot name=\"header\">default header</slot>` 。\n\n第四步，注册一个模态窗口组件。\n\n```\nVue.component('modal', {\n  template: '#modal-template'\n})\n```\n\n`Vue.component` 方法的第一个参数是该组件在容器中的标签，第二个参数是一个对象，定义了使用的模板 id 为 modal-template 。\n\n如果页面中存在多个模态窗口，并且分别绑定不同的模板，应该定义不同的标签，例如 `<modal-dialog>` 、`<modal-login>` 等。\n\n第五步，创建视图模型对象。el 是容器的 id , showModal 是一个布尔值，用于控制窗口的打开和关闭。\n\n```\nnew Vue({\n  el: '#app',\n  data: {\n    showModal: false\n  }\n})\n```\n\n好了，现在回头再看一遍之前的代码，尝试理解 Vue.js 的一些逻辑。\n\n`v-if=\"showModal\"` 表示监听 showModal 参数，当值为 `false` 时移除容器 div 中的代码（关闭窗口），当值为 `true` 时往容器 div 中填充代码（显示窗口）。\n\n`@click=\"showModal = true\"` 表示点击该元素时修改 `showModal` 值为 `true` ，类似 JavaScript 的 onclick 事件。\n\n`@click=\"$emit('close')` 表示点击该元素时当前元素的 `@close` 中的代码。\n \n\n本例样式表：\n``` css\n.modal-mask {\n  position: fixed;\n  z-index: 9998;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, .5);\n  display: table;\n  transition: opacity .3s ease;\n}\n.modal-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n}\n.modal-container {\n  width: 300px;\n  margin: 0px auto;\n  padding: 20px 30px;\n  background-color: #fff;\n  border-radius: 2px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, .33);\n  transition: all .3s ease;\n  font-family: Helvetica, Arial, sans-serif;\n}\n.modal-header h3 {\n  margin-top: 0;\n  color: #42b983;\n}\n.modal-body {\n  margin: 20px 0;\n}\n.modal-default-button {\n  float: right;\n}\n.modal-enter {\n  opacity: 0;\n}\n.modal-leave-active {\n  opacity: 0;\n}\n.modal-enter .modal-container,\n.modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}\n```\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2 ","slug":"2016-10-30@使用 Vue.js 实现模态窗口","published":1,"updated":"2020-06-29T03:32:42.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48v005vrqgj2azzh3dm","content":"<p>Vue.js 是一个前端 MVVM 框架。由于公司的项目中有用到这个框架，我也开始接触和学习它。在阅读了官方文档后，我着手尝试用 Vue.js 实现模态窗口。</p>\n<a id=\"more\"></a>\n\n<p>第一步，将必要的样式表添加到页面中。（代码位于文末）</p>\n<p>第二步，添加模态窗口的模板。什么是模板？可以理解为基本、通用的结构代码。每个弹窗的内容可能不同，但结构是一致的，这些一致的部分就是模板。<br>注意模板中的预留的 <code>&lt;slot&gt;</code> 标签，在生成模态窗口时，可以在 <code>&lt;slot&gt;</code> 标签的位置插入不同的内容。下面这个模板把模态窗口分成上中下三个区域。</p>\n<pre><code>&lt;!-- 模板 --&gt;\n&lt;script type=&quot;text/x-template&quot; id=&quot;modal-template&quot;&gt;\n  &lt;transition name=&quot;modal&quot;&gt;\n    &lt;div class=&quot;modal-mask&quot;&gt;\n      &lt;div class=&quot;modal-wrapper&quot;&gt;\n        &lt;div class=&quot;modal-container&quot;&gt;\n          &lt;div class=&quot;modal-header&quot;&gt;\n            &lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;modal-body&quot;&gt;\n            &lt;slot name=&quot;body&quot;&gt;default body&lt;/slot&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;modal-footer&quot;&gt;\n            &lt;slot name=&quot;footer&quot;&gt;default footer\n              &lt;button class=&quot;modal-default-button&quot; @click=&quot;$emit(&#39;close&#39;)&quot;&gt;OK&lt;/button&gt;\n            &lt;/slot&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/transition&gt;\n&lt;/script&gt;</code></pre><p><code>&lt;script&gt;</code> 标签的 <em>id</em> 属性用于定义模板的名称，在同一页面中可以创建多个模态窗口模板，以实现不同需求。</p>\n<p>第三步，在模板的基础上添加具体内容。</p>\n<pre><code class=\"xhtml\">&lt;!-- 容器 --&gt;\n&lt;div id=&quot;app&quot;&gt;\n  &lt;button id=&quot;show-modal&quot; @click=&quot;showModal = true&quot;&gt;Show Modal&lt;/button&gt;\n  &lt;modal v-if=&quot;showModal&quot; @close=&quot;showModal = false&quot;&gt;\n    &lt;!-- 在此覆写模板内容 --&gt;\n    &lt;h3 slot=&quot;header&quot;&gt;custom header&lt;/h3&gt;\n  &lt;/modal&gt;\n&lt;/div&gt;</code></pre>\n<p>给任意标签加上 <em>slot</em> 属性，即可用于覆盖模板中对应名称的 <code>&lt;slot&gt;</code> 标签。在上面的代码中，<code>h3</code> 标签的 <em>slot</em> 属性值等于 header ，所以它覆盖了模板中的 <code>&lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt;</code> 。</p>\n<p>第四步，注册一个模态窗口组件。</p>\n<pre><code>Vue.component(&#39;modal&#39;, {\n  template: &#39;#modal-template&#39;\n})</code></pre><p><code>Vue.component</code> 方法的第一个参数是该组件在容器中的标签，第二个参数是一个对象，定义了使用的模板 id 为 modal-template 。</p>\n<p>如果页面中存在多个模态窗口，并且分别绑定不同的模板，应该定义不同的标签，例如 <code>&lt;modal-dialog&gt;</code> 、<code>&lt;modal-login&gt;</code> 等。</p>\n<p>第五步，创建视图模型对象。el 是容器的 id , showModal 是一个布尔值，用于控制窗口的打开和关闭。</p>\n<pre><code>new Vue({\n  el: &#39;#app&#39;,\n  data: {\n    showModal: false\n  }\n})</code></pre><p>好了，现在回头再看一遍之前的代码，尝试理解 Vue.js 的一些逻辑。</p>\n<p><code>v-if=&quot;showModal&quot;</code> 表示监听 showModal 参数，当值为 <code>false</code> 时移除容器 div 中的代码（关闭窗口），当值为 <code>true</code> 时往容器 div 中填充代码（显示窗口）。</p>\n<p><code>@click=&quot;showModal = true&quot;</code> 表示点击该元素时修改 <code>showModal</code> 值为 <code>true</code> ，类似 JavaScript 的 onclick 事件。</p>\n<p><code>@click=&quot;$emit(&#39;close&#39;)</code> 表示点击该元素时当前元素的 <code>@close</code> 中的代码。</p>\n<p>本例样式表：</p>\n<pre><code class=\"css\">.modal-mask {\n  position: fixed;\n  z-index: 9998;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, .5);\n  display: table;\n  transition: opacity .3s ease;\n}\n.modal-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n}\n.modal-container {\n  width: 300px;\n  margin: 0px auto;\n  padding: 20px 30px;\n  background-color: #fff;\n  border-radius: 2px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, .33);\n  transition: all .3s ease;\n  font-family: Helvetica, Arial, sans-serif;\n}\n.modal-header h3 {\n  margin-top: 0;\n  color: #42b983;\n}\n.modal-body {\n  margin: 20px 0;\n}\n.modal-default-button {\n  float: right;\n}\n.modal-enter {\n  opacity: 0;\n}\n.modal-leave-active {\n  opacity: 0;\n}\n.modal-enter .modal-container,\n.modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}</code></pre>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2 </p>\n","site":{"data":{}},"excerpt":"<p>Vue.js 是一个前端 MVVM 框架。由于公司的项目中有用到这个框架，我也开始接触和学习它。在阅读了官方文档后，我着手尝试用 Vue.js 实现模态窗口。</p>","more":"<p>第一步，将必要的样式表添加到页面中。（代码位于文末）</p>\n<p>第二步，添加模态窗口的模板。什么是模板？可以理解为基本、通用的结构代码。每个弹窗的内容可能不同，但结构是一致的，这些一致的部分就是模板。<br>注意模板中的预留的 <code>&lt;slot&gt;</code> 标签，在生成模态窗口时，可以在 <code>&lt;slot&gt;</code> 标签的位置插入不同的内容。下面这个模板把模态窗口分成上中下三个区域。</p>\n<pre><code>&lt;!-- 模板 --&gt;\n&lt;script type=&quot;text/x-template&quot; id=&quot;modal-template&quot;&gt;\n  &lt;transition name=&quot;modal&quot;&gt;\n    &lt;div class=&quot;modal-mask&quot;&gt;\n      &lt;div class=&quot;modal-wrapper&quot;&gt;\n        &lt;div class=&quot;modal-container&quot;&gt;\n          &lt;div class=&quot;modal-header&quot;&gt;\n            &lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;modal-body&quot;&gt;\n            &lt;slot name=&quot;body&quot;&gt;default body&lt;/slot&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;modal-footer&quot;&gt;\n            &lt;slot name=&quot;footer&quot;&gt;default footer\n              &lt;button class=&quot;modal-default-button&quot; @click=&quot;$emit(&#39;close&#39;)&quot;&gt;OK&lt;/button&gt;\n            &lt;/slot&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/transition&gt;\n&lt;/script&gt;</code></pre><p><code>&lt;script&gt;</code> 标签的 <em>id</em> 属性用于定义模板的名称，在同一页面中可以创建多个模态窗口模板，以实现不同需求。</p>\n<p>第三步，在模板的基础上添加具体内容。</p>\n<pre><code class=\"xhtml\">&lt;!-- 容器 --&gt;\n&lt;div id=&quot;app&quot;&gt;\n  &lt;button id=&quot;show-modal&quot; @click=&quot;showModal = true&quot;&gt;Show Modal&lt;/button&gt;\n  &lt;modal v-if=&quot;showModal&quot; @close=&quot;showModal = false&quot;&gt;\n    &lt;!-- 在此覆写模板内容 --&gt;\n    &lt;h3 slot=&quot;header&quot;&gt;custom header&lt;/h3&gt;\n  &lt;/modal&gt;\n&lt;/div&gt;</code></pre>\n<p>给任意标签加上 <em>slot</em> 属性，即可用于覆盖模板中对应名称的 <code>&lt;slot&gt;</code> 标签。在上面的代码中，<code>h3</code> 标签的 <em>slot</em> 属性值等于 header ，所以它覆盖了模板中的 <code>&lt;slot name=&quot;header&quot;&gt;default header&lt;/slot&gt;</code> 。</p>\n<p>第四步，注册一个模态窗口组件。</p>\n<pre><code>Vue.component(&#39;modal&#39;, {\n  template: &#39;#modal-template&#39;\n})</code></pre><p><code>Vue.component</code> 方法的第一个参数是该组件在容器中的标签，第二个参数是一个对象，定义了使用的模板 id 为 modal-template 。</p>\n<p>如果页面中存在多个模态窗口，并且分别绑定不同的模板，应该定义不同的标签，例如 <code>&lt;modal-dialog&gt;</code> 、<code>&lt;modal-login&gt;</code> 等。</p>\n<p>第五步，创建视图模型对象。el 是容器的 id , showModal 是一个布尔值，用于控制窗口的打开和关闭。</p>\n<pre><code>new Vue({\n  el: &#39;#app&#39;,\n  data: {\n    showModal: false\n  }\n})</code></pre><p>好了，现在回头再看一遍之前的代码，尝试理解 Vue.js 的一些逻辑。</p>\n<p><code>v-if=&quot;showModal&quot;</code> 表示监听 showModal 参数，当值为 <code>false</code> 时移除容器 div 中的代码（关闭窗口），当值为 <code>true</code> 时往容器 div 中填充代码（显示窗口）。</p>\n<p><code>@click=&quot;showModal = true&quot;</code> 表示点击该元素时修改 <code>showModal</code> 值为 <code>true</code> ，类似 JavaScript 的 onclick 事件。</p>\n<p><code>@click=&quot;$emit(&#39;close&#39;)</code> 表示点击该元素时当前元素的 <code>@close</code> 中的代码。</p>\n<p>本例样式表：</p>\n<pre><code class=\"css\">.modal-mask {\n  position: fixed;\n  z-index: 9998;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, .5);\n  display: table;\n  transition: opacity .3s ease;\n}\n.modal-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n}\n.modal-container {\n  width: 300px;\n  margin: 0px auto;\n  padding: 20px 30px;\n  background-color: #fff;\n  border-radius: 2px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, .33);\n  transition: all .3s ease;\n  font-family: Helvetica, Arial, sans-serif;\n}\n.modal-header h3 {\n  margin-top: 0;\n  color: #42b983;\n}\n.modal-body {\n  margin: 20px 0;\n}\n.modal-default-button {\n  float: right;\n}\n.modal-enter {\n  opacity: 0;\n}\n.modal-leave-active {\n  opacity: 0;\n}\n.modal-enter .modal-container,\n.modal-leave-active .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}</code></pre>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2 </p>"},{"title":"Laravel 框架操作数据库","date":"2016-11-05T07:52:55.000Z","_content":"\nLaravel 提供 DB Facade 、Query Builder 和 Eloquent ORM 三种操作数据库的方式。\n\n### 原始查找\n\n原始查找（DB Facade）直接使用 SQL 语句操作数据库。\n\n<!-- more -->\n\n``` php\n// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;\n```\n\n``` php\n// 新增，返回布尔值。\n$bol = DB::insert('INSERT INTO users(email, password) VALUES(?, ?)', ['example@example.com', '123456']);\n// 删除，返回影响行数。\n$row = DB::delete('DELETE FROM users WHERE id = ?', [1]);\n// 修改，返回影响行数。\n$row = DB::update('UPDATE users SET password = ? WHERE email = ?', ['654321', 'example@example.com']);\n// 查询，返回数组。\n$arr = DB::select('SELECT * FROM users');\n```\n\n在 SQL 语句中可以用 `?` 占位符，引用数组中参数。\n\n### 查询构建器\n\n查询构建器（Query Builder）使用高度封装的接口操作数据库。\n\n``` php\n// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;\n```\n\n``` php\n// 新增，返回布尔值。\n$bol = DB::table('users')->insert(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n// 新增，返回该条数据的id。\n$id  = DB::table('users')->insertGetId(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n```\n\n``` php\n// 删除，返回影响行数。\n$row = DB::table('users')->where('id', 1)->delete();\n$row = DB::table('users')->where('id', '<', 3)->delete();\n// 清空数据表，无返回值。\nDB::table('users')->truncate();\n```\n\n``` php\n// 修改，返回影响行数。\n$row = DB::table('users')\n  ->where('email', 'example@example.com')\n  ->update(['password', '654321']);\n// 修改，自增并返回影响行数。\n$row = DB::table('users')->increment('age');\n$row = DB::table('users')->increment('age', 3);\n// 修改，自减并返回影响行数。\n$row = DB::table('users')->decrement('age');\n$row = DB::table('users')->decrement('age', 3);\n// 修改，自增的同时修改字段，返回影响行数。\n$row = DB::table('users')->increment('age', 3, ['password' => '654321']);\n```\n\n``` php\n// 查询，所有数据，返回数组。\n$arr = DB::table('users')->get();\n// 查询，第一条数据，返回对象。\n$obj = DB::table('users')\n  ->orderBy('id', 'desc')\n  ->first();\n// 查询，符合某一条件的所有数据，返回数组。\n$arr = DB::table('users')\n  ->where('id', '<=', 3)\n  ->get();\n// 查询，符合多个条件的所有数据，返回数组。\n$arr = DB::table('users')\n  ->whereRaw('id < ? and age > ?', [10,20])\n  ->get();\n// 查询，指定某一字段，返回数组。\n$arr = DB::table('users')->pluck('email');\n// 查询，指定多个字段，返回数组。\n$arr = DB::table('users')\n  ->select('id', 'email', 'name')\n  ->get();\n// 查询，指定字段并指定键值，返回数组。\n$arr = DB::table('users')->lists('email', 'id');\n// 查询，返回记录数。\n$int = DB::table('users')->count();\n// 查询，返回某列的最大/最小值。\n$num = DB::table('users')->max('age');\n$num = DB::table('users')->min('age');\n// 查询，返回某列的平均值。\n$num = DB::table('users')->avg('age');\n// 查询，返回某列的和。\n$num = DB::table('users')->sum('age');\n```\n\n### 对象关系模型\n\n对象关系模型（Eloquent ORM）是在查询构建器的基础上，使用与数据表一一对应的模型类来操作数据库。\n\n首先，在 app 目录下创建一个 User 模型，命名为 User.php ，它默认对应数据库的 users 表。\n\n``` php\nnamespace App;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    // 指定表名，不指定默认使用类名的复数。\n    protected $table = 'users';\n    // 指定主键。\n    protected $primaryKey = 'id';\n    // 允许批量赋值的字段。\n    protected $fillable = [\n        'name', 'email', 'password',\n    ];\n}\n```\n\n然后在控制器中使用：\n\n``` php\n// 引用命名空间\nuse App\\User;\n```\n\n``` php\n// 新增，使用模型。\n$user = new User();\n$user->email = 'example@example.com';\n$user->password = '123456';\n$bol = $user->save();\n// 新增，使用模型的create方法。\nUser::create(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n// 新增，当查询不到时新增一条记录，返回User对象。\nUser::firstOrCreate(\n  ['email' => 'example@example.com']\n);\n// 新增，当查询不到时创建新的对象，返回User对象。\nUser::firstOrNew(\n  ['email' => 'example@example.com']\n);\n```\n\n``` php\n// 删除，使用模型。\n$user = User::find(1);\n$bol = $user->delete();\n// 删除，指定主键的数据。\n$row = User::destory(1);\n$row = User::destory(1, 2, 3);\n// 删除，符合条件的数据。\n$row = User::where('id', '<', 3)->delete();\n```\n\n``` php\n// 修改，使用模型。\n$user = User::find(1);\n$user->password = '654321';\n$bol = $user->save();\n// 修改，使用模型的update方法。\n$row = User::where('email', 'example@example.com')->update(\n  ['password' => '654321']\n);\n```\n\n``` php\n// 查询，所有数据，返回集合。\n$col = User::all();\n$col = User::get();\n// 查询，指定主键，返回对象。\n$obj = User::find(1);\n// 查询，同上，无结果时报错。\n$obj = User::findOrFail(1);\n// 查询，指定条件并排序。\n$obj = User::where('id', '<', 3)->orderBy('id', 'desc');\n// 查询，第一条数据。\n$obj = User::all()->first();\n// 查询，返回结果数。\n$int = User::count();\n// 查询，某列的最大/最小值。\n$num = User::where('id', '<', 10)->max('age');\n$num = User::where('id', '<', 10)->min('age');\n```\n\n实际上，无论使用何种方式操作数据库，最终都是在执行 SQL 语句。相较于 DB Facade ，后两者把构造 SQL 语句的工作交给了 Laravel 。另外，我感觉 Eloquent ORM 和 Query Builder 是很接近的，只不过多了模型的概念，不过后者的代码确实要更加简洁、一目了然。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","source":"_posts/2016-11-05@Laravel 框架操作数据库.md","raw":"---\ntitle: Laravel 框架操作数据库\ncategories:\n  - Web Back-end\ndate: 2016-11-05 15:52:55\ntags:\n  - Laravel\n  - MySQL\n---\n\nLaravel 提供 DB Facade 、Query Builder 和 Eloquent ORM 三种操作数据库的方式。\n\n### 原始查找\n\n原始查找（DB Facade）直接使用 SQL 语句操作数据库。\n\n<!-- more -->\n\n``` php\n// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;\n```\n\n``` php\n// 新增，返回布尔值。\n$bol = DB::insert('INSERT INTO users(email, password) VALUES(?, ?)', ['example@example.com', '123456']);\n// 删除，返回影响行数。\n$row = DB::delete('DELETE FROM users WHERE id = ?', [1]);\n// 修改，返回影响行数。\n$row = DB::update('UPDATE users SET password = ? WHERE email = ?', ['654321', 'example@example.com']);\n// 查询，返回数组。\n$arr = DB::select('SELECT * FROM users');\n```\n\n在 SQL 语句中可以用 `?` 占位符，引用数组中参数。\n\n### 查询构建器\n\n查询构建器（Query Builder）使用高度封装的接口操作数据库。\n\n``` php\n// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;\n```\n\n``` php\n// 新增，返回布尔值。\n$bol = DB::table('users')->insert(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n// 新增，返回该条数据的id。\n$id  = DB::table('users')->insertGetId(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n```\n\n``` php\n// 删除，返回影响行数。\n$row = DB::table('users')->where('id', 1)->delete();\n$row = DB::table('users')->where('id', '<', 3)->delete();\n// 清空数据表，无返回值。\nDB::table('users')->truncate();\n```\n\n``` php\n// 修改，返回影响行数。\n$row = DB::table('users')\n  ->where('email', 'example@example.com')\n  ->update(['password', '654321']);\n// 修改，自增并返回影响行数。\n$row = DB::table('users')->increment('age');\n$row = DB::table('users')->increment('age', 3);\n// 修改，自减并返回影响行数。\n$row = DB::table('users')->decrement('age');\n$row = DB::table('users')->decrement('age', 3);\n// 修改，自增的同时修改字段，返回影响行数。\n$row = DB::table('users')->increment('age', 3, ['password' => '654321']);\n```\n\n``` php\n// 查询，所有数据，返回数组。\n$arr = DB::table('users')->get();\n// 查询，第一条数据，返回对象。\n$obj = DB::table('users')\n  ->orderBy('id', 'desc')\n  ->first();\n// 查询，符合某一条件的所有数据，返回数组。\n$arr = DB::table('users')\n  ->where('id', '<=', 3)\n  ->get();\n// 查询，符合多个条件的所有数据，返回数组。\n$arr = DB::table('users')\n  ->whereRaw('id < ? and age > ?', [10,20])\n  ->get();\n// 查询，指定某一字段，返回数组。\n$arr = DB::table('users')->pluck('email');\n// 查询，指定多个字段，返回数组。\n$arr = DB::table('users')\n  ->select('id', 'email', 'name')\n  ->get();\n// 查询，指定字段并指定键值，返回数组。\n$arr = DB::table('users')->lists('email', 'id');\n// 查询，返回记录数。\n$int = DB::table('users')->count();\n// 查询，返回某列的最大/最小值。\n$num = DB::table('users')->max('age');\n$num = DB::table('users')->min('age');\n// 查询，返回某列的平均值。\n$num = DB::table('users')->avg('age');\n// 查询，返回某列的和。\n$num = DB::table('users')->sum('age');\n```\n\n### 对象关系模型\n\n对象关系模型（Eloquent ORM）是在查询构建器的基础上，使用与数据表一一对应的模型类来操作数据库。\n\n首先，在 app 目录下创建一个 User 模型，命名为 User.php ，它默认对应数据库的 users 表。\n\n``` php\nnamespace App;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    // 指定表名，不指定默认使用类名的复数。\n    protected $table = 'users';\n    // 指定主键。\n    protected $primaryKey = 'id';\n    // 允许批量赋值的字段。\n    protected $fillable = [\n        'name', 'email', 'password',\n    ];\n}\n```\n\n然后在控制器中使用：\n\n``` php\n// 引用命名空间\nuse App\\User;\n```\n\n``` php\n// 新增，使用模型。\n$user = new User();\n$user->email = 'example@example.com';\n$user->password = '123456';\n$bol = $user->save();\n// 新增，使用模型的create方法。\nUser::create(\n  ['email' => 'example@example.com', 'password' => '123456']\n);\n// 新增，当查询不到时新增一条记录，返回User对象。\nUser::firstOrCreate(\n  ['email' => 'example@example.com']\n);\n// 新增，当查询不到时创建新的对象，返回User对象。\nUser::firstOrNew(\n  ['email' => 'example@example.com']\n);\n```\n\n``` php\n// 删除，使用模型。\n$user = User::find(1);\n$bol = $user->delete();\n// 删除，指定主键的数据。\n$row = User::destory(1);\n$row = User::destory(1, 2, 3);\n// 删除，符合条件的数据。\n$row = User::where('id', '<', 3)->delete();\n```\n\n``` php\n// 修改，使用模型。\n$user = User::find(1);\n$user->password = '654321';\n$bol = $user->save();\n// 修改，使用模型的update方法。\n$row = User::where('email', 'example@example.com')->update(\n  ['password' => '654321']\n);\n```\n\n``` php\n// 查询，所有数据，返回集合。\n$col = User::all();\n$col = User::get();\n// 查询，指定主键，返回对象。\n$obj = User::find(1);\n// 查询，同上，无结果时报错。\n$obj = User::findOrFail(1);\n// 查询，指定条件并排序。\n$obj = User::where('id', '<', 3)->orderBy('id', 'desc');\n// 查询，第一条数据。\n$obj = User::all()->first();\n// 查询，返回结果数。\n$int = User::count();\n// 查询，某列的最大/最小值。\n$num = User::where('id', '<', 10)->max('age');\n$num = User::where('id', '<', 10)->min('age');\n```\n\n实际上，无论使用何种方式操作数据库，最终都是在执行 SQL 语句。相较于 DB Facade ，后两者把构造 SQL 语句的工作交给了 Laravel 。另外，我感觉 Eloquent ORM 和 Query Builder 是很接近的，只不过多了模型的概念，不过后者的代码确实要更加简洁、一目了然。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","slug":"2016-11-05@Laravel 框架操作数据库","published":1,"updated":"2020-06-29T03:32:42.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48x005zrqgj0om0blmu","content":"<p>Laravel 提供 DB Facade 、Query Builder 和 Eloquent ORM 三种操作数据库的方式。</p>\n<h3 id=\"原始查找\"><a href=\"#原始查找\" class=\"headerlink\" title=\"原始查找\"></a>原始查找</h3><p>原始查找（DB Facade）直接使用 SQL 语句操作数据库。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"php\">// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;</code></pre>\n<pre><code class=\"php\">// 新增，返回布尔值。\n$bol = DB::insert(&#39;INSERT INTO users(email, password) VALUES(?, ?)&#39;, [&#39;example@example.com&#39;, &#39;123456&#39;]);\n// 删除，返回影响行数。\n$row = DB::delete(&#39;DELETE FROM users WHERE id = ?&#39;, [1]);\n// 修改，返回影响行数。\n$row = DB::update(&#39;UPDATE users SET password = ? WHERE email = ?&#39;, [&#39;654321&#39;, &#39;example@example.com&#39;]);\n// 查询，返回数组。\n$arr = DB::select(&#39;SELECT * FROM users&#39;);</code></pre>\n<p>在 SQL 语句中可以用 <code>?</code> 占位符，引用数组中参数。</p>\n<h3 id=\"查询构建器\"><a href=\"#查询构建器\" class=\"headerlink\" title=\"查询构建器\"></a>查询构建器</h3><p>查询构建器（Query Builder）使用高度封装的接口操作数据库。</p>\n<pre><code class=\"php\">// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;</code></pre>\n<pre><code class=\"php\">// 新增，返回布尔值。\n$bol = DB::table(&#39;users&#39;)-&gt;insert(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);\n// 新增，返回该条数据的id。\n$id  = DB::table(&#39;users&#39;)-&gt;insertGetId(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 删除，返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;delete();\n$row = DB::table(&#39;users&#39;)-&gt;where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;delete();\n// 清空数据表，无返回值。\nDB::table(&#39;users&#39;)-&gt;truncate();</code></pre>\n<pre><code class=\"php\">// 修改，返回影响行数。\n$row = DB::table(&#39;users&#39;)\n  -&gt;where(&#39;email&#39;, &#39;example@example.com&#39;)\n  -&gt;update([&#39;password&#39;, &#39;654321&#39;]);\n// 修改，自增并返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;);\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;, 3);\n// 修改，自减并返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;decrement(&#39;age&#39;);\n$row = DB::table(&#39;users&#39;)-&gt;decrement(&#39;age&#39;, 3);\n// 修改，自增的同时修改字段，返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;, 3, [&#39;password&#39; =&gt; &#39;654321&#39;]);</code></pre>\n<pre><code class=\"php\">// 查询，所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;get();\n// 查询，第一条数据，返回对象。\n$obj = DB::table(&#39;users&#39;)\n  -&gt;orderBy(&#39;id&#39;, &#39;desc&#39;)\n  -&gt;first();\n// 查询，符合某一条件的所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;where(&#39;id&#39;, &#39;&lt;=&#39;, 3)\n  -&gt;get();\n// 查询，符合多个条件的所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;whereRaw(&#39;id &lt; ? and age &gt; ?&#39;, [10,20])\n  -&gt;get();\n// 查询，指定某一字段，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;pluck(&#39;email&#39;);\n// 查询，指定多个字段，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;select(&#39;id&#39;, &#39;email&#39;, &#39;name&#39;)\n  -&gt;get();\n// 查询，指定字段并指定键值，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;lists(&#39;email&#39;, &#39;id&#39;);\n// 查询，返回记录数。\n$int = DB::table(&#39;users&#39;)-&gt;count();\n// 查询，返回某列的最大/最小值。\n$num = DB::table(&#39;users&#39;)-&gt;max(&#39;age&#39;);\n$num = DB::table(&#39;users&#39;)-&gt;min(&#39;age&#39;);\n// 查询，返回某列的平均值。\n$num = DB::table(&#39;users&#39;)-&gt;avg(&#39;age&#39;);\n// 查询，返回某列的和。\n$num = DB::table(&#39;users&#39;)-&gt;sum(&#39;age&#39;);</code></pre>\n<h3 id=\"对象关系模型\"><a href=\"#对象关系模型\" class=\"headerlink\" title=\"对象关系模型\"></a>对象关系模型</h3><p>对象关系模型（Eloquent ORM）是在查询构建器的基础上，使用与数据表一一对应的模型类来操作数据库。</p>\n<p>首先，在 app 目录下创建一个 User 模型，命名为 User.php ，它默认对应数据库的 users 表。</p>\n<pre><code class=\"php\">namespace App;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    // 指定表名，不指定默认使用类名的复数。\n    protected $table = &#39;users&#39;;\n    // 指定主键。\n    protected $primaryKey = &#39;id&#39;;\n    // 允许批量赋值的字段。\n    protected $fillable = [\n        &#39;name&#39;, &#39;email&#39;, &#39;password&#39;,\n    ];\n}</code></pre>\n<p>然后在控制器中使用：</p>\n<pre><code class=\"php\">// 引用命名空间\nuse App\\User;</code></pre>\n<pre><code class=\"php\">// 新增，使用模型。\n$user = new User();\n$user-&gt;email = &#39;example@example.com&#39;;\n$user-&gt;password = &#39;123456&#39;;\n$bol = $user-&gt;save();\n// 新增，使用模型的create方法。\nUser::create(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);\n// 新增，当查询不到时新增一条记录，返回User对象。\nUser::firstOrCreate(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;]\n);\n// 新增，当查询不到时创建新的对象，返回User对象。\nUser::firstOrNew(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 删除，使用模型。\n$user = User::find(1);\n$bol = $user-&gt;delete();\n// 删除，指定主键的数据。\n$row = User::destory(1);\n$row = User::destory(1, 2, 3);\n// 删除，符合条件的数据。\n$row = User::where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;delete();</code></pre>\n<pre><code class=\"php\">// 修改，使用模型。\n$user = User::find(1);\n$user-&gt;password = &#39;654321&#39;;\n$bol = $user-&gt;save();\n// 修改，使用模型的update方法。\n$row = User::where(&#39;email&#39;, &#39;example@example.com&#39;)-&gt;update(\n  [&#39;password&#39; =&gt; &#39;654321&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 查询，所有数据，返回集合。\n$col = User::all();\n$col = User::get();\n// 查询，指定主键，返回对象。\n$obj = User::find(1);\n// 查询，同上，无结果时报错。\n$obj = User::findOrFail(1);\n// 查询，指定条件并排序。\n$obj = User::where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;orderBy(&#39;id&#39;, &#39;desc&#39;);\n// 查询，第一条数据。\n$obj = User::all()-&gt;first();\n// 查询，返回结果数。\n$int = User::count();\n// 查询，某列的最大/最小值。\n$num = User::where(&#39;id&#39;, &#39;&lt;&#39;, 10)-&gt;max(&#39;age&#39;);\n$num = User::where(&#39;id&#39;, &#39;&lt;&#39;, 10)-&gt;min(&#39;age&#39;);</code></pre>\n<p>实际上，无论使用何种方式操作数据库，最终都是在执行 SQL 语句。相较于 DB Facade ，后两者把构造 SQL 语句的工作交给了 Laravel 。另外，我感觉 Eloquent ORM 和 Query Builder 是很接近的，只不过多了模型的概念，不过后者的代码确实要更加简洁、一目了然。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>Laravel 提供 DB Facade 、Query Builder 和 Eloquent ORM 三种操作数据库的方式。</p>\n<h3 id=\"原始查找\"><a href=\"#原始查找\" class=\"headerlink\" title=\"原始查找\"></a>原始查找</h3><p>原始查找（DB Facade）直接使用 SQL 语句操作数据库。</p>","more":"<pre><code class=\"php\">// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;</code></pre>\n<pre><code class=\"php\">// 新增，返回布尔值。\n$bol = DB::insert(&#39;INSERT INTO users(email, password) VALUES(?, ?)&#39;, [&#39;example@example.com&#39;, &#39;123456&#39;]);\n// 删除，返回影响行数。\n$row = DB::delete(&#39;DELETE FROM users WHERE id = ?&#39;, [1]);\n// 修改，返回影响行数。\n$row = DB::update(&#39;UPDATE users SET password = ? WHERE email = ?&#39;, [&#39;654321&#39;, &#39;example@example.com&#39;]);\n// 查询，返回数组。\n$arr = DB::select(&#39;SELECT * FROM users&#39;);</code></pre>\n<p>在 SQL 语句中可以用 <code>?</code> 占位符，引用数组中参数。</p>\n<h3 id=\"查询构建器\"><a href=\"#查询构建器\" class=\"headerlink\" title=\"查询构建器\"></a>查询构建器</h3><p>查询构建器（Query Builder）使用高度封装的接口操作数据库。</p>\n<pre><code class=\"php\">// 引用命名空间\nuse Illuminate\\Support\\Facades\\DB;</code></pre>\n<pre><code class=\"php\">// 新增，返回布尔值。\n$bol = DB::table(&#39;users&#39;)-&gt;insert(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);\n// 新增，返回该条数据的id。\n$id  = DB::table(&#39;users&#39;)-&gt;insertGetId(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 删除，返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;where(&#39;id&#39;, 1)-&gt;delete();\n$row = DB::table(&#39;users&#39;)-&gt;where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;delete();\n// 清空数据表，无返回值。\nDB::table(&#39;users&#39;)-&gt;truncate();</code></pre>\n<pre><code class=\"php\">// 修改，返回影响行数。\n$row = DB::table(&#39;users&#39;)\n  -&gt;where(&#39;email&#39;, &#39;example@example.com&#39;)\n  -&gt;update([&#39;password&#39;, &#39;654321&#39;]);\n// 修改，自增并返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;);\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;, 3);\n// 修改，自减并返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;decrement(&#39;age&#39;);\n$row = DB::table(&#39;users&#39;)-&gt;decrement(&#39;age&#39;, 3);\n// 修改，自增的同时修改字段，返回影响行数。\n$row = DB::table(&#39;users&#39;)-&gt;increment(&#39;age&#39;, 3, [&#39;password&#39; =&gt; &#39;654321&#39;]);</code></pre>\n<pre><code class=\"php\">// 查询，所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;get();\n// 查询，第一条数据，返回对象。\n$obj = DB::table(&#39;users&#39;)\n  -&gt;orderBy(&#39;id&#39;, &#39;desc&#39;)\n  -&gt;first();\n// 查询，符合某一条件的所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;where(&#39;id&#39;, &#39;&lt;=&#39;, 3)\n  -&gt;get();\n// 查询，符合多个条件的所有数据，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;whereRaw(&#39;id &lt; ? and age &gt; ?&#39;, [10,20])\n  -&gt;get();\n// 查询，指定某一字段，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;pluck(&#39;email&#39;);\n// 查询，指定多个字段，返回数组。\n$arr = DB::table(&#39;users&#39;)\n  -&gt;select(&#39;id&#39;, &#39;email&#39;, &#39;name&#39;)\n  -&gt;get();\n// 查询，指定字段并指定键值，返回数组。\n$arr = DB::table(&#39;users&#39;)-&gt;lists(&#39;email&#39;, &#39;id&#39;);\n// 查询，返回记录数。\n$int = DB::table(&#39;users&#39;)-&gt;count();\n// 查询，返回某列的最大/最小值。\n$num = DB::table(&#39;users&#39;)-&gt;max(&#39;age&#39;);\n$num = DB::table(&#39;users&#39;)-&gt;min(&#39;age&#39;);\n// 查询，返回某列的平均值。\n$num = DB::table(&#39;users&#39;)-&gt;avg(&#39;age&#39;);\n// 查询，返回某列的和。\n$num = DB::table(&#39;users&#39;)-&gt;sum(&#39;age&#39;);</code></pre>\n<h3 id=\"对象关系模型\"><a href=\"#对象关系模型\" class=\"headerlink\" title=\"对象关系模型\"></a>对象关系模型</h3><p>对象关系模型（Eloquent ORM）是在查询构建器的基础上，使用与数据表一一对应的模型类来操作数据库。</p>\n<p>首先，在 app 目录下创建一个 User 模型，命名为 User.php ，它默认对应数据库的 users 表。</p>\n<pre><code class=\"php\">namespace App;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    // 指定表名，不指定默认使用类名的复数。\n    protected $table = &#39;users&#39;;\n    // 指定主键。\n    protected $primaryKey = &#39;id&#39;;\n    // 允许批量赋值的字段。\n    protected $fillable = [\n        &#39;name&#39;, &#39;email&#39;, &#39;password&#39;,\n    ];\n}</code></pre>\n<p>然后在控制器中使用：</p>\n<pre><code class=\"php\">// 引用命名空间\nuse App\\User;</code></pre>\n<pre><code class=\"php\">// 新增，使用模型。\n$user = new User();\n$user-&gt;email = &#39;example@example.com&#39;;\n$user-&gt;password = &#39;123456&#39;;\n$bol = $user-&gt;save();\n// 新增，使用模型的create方法。\nUser::create(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;, &#39;password&#39; =&gt; &#39;123456&#39;]\n);\n// 新增，当查询不到时新增一条记录，返回User对象。\nUser::firstOrCreate(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;]\n);\n// 新增，当查询不到时创建新的对象，返回User对象。\nUser::firstOrNew(\n  [&#39;email&#39; =&gt; &#39;example@example.com&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 删除，使用模型。\n$user = User::find(1);\n$bol = $user-&gt;delete();\n// 删除，指定主键的数据。\n$row = User::destory(1);\n$row = User::destory(1, 2, 3);\n// 删除，符合条件的数据。\n$row = User::where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;delete();</code></pre>\n<pre><code class=\"php\">// 修改，使用模型。\n$user = User::find(1);\n$user-&gt;password = &#39;654321&#39;;\n$bol = $user-&gt;save();\n// 修改，使用模型的update方法。\n$row = User::where(&#39;email&#39;, &#39;example@example.com&#39;)-&gt;update(\n  [&#39;password&#39; =&gt; &#39;654321&#39;]\n);</code></pre>\n<pre><code class=\"php\">// 查询，所有数据，返回集合。\n$col = User::all();\n$col = User::get();\n// 查询，指定主键，返回对象。\n$obj = User::find(1);\n// 查询，同上，无结果时报错。\n$obj = User::findOrFail(1);\n// 查询，指定条件并排序。\n$obj = User::where(&#39;id&#39;, &#39;&lt;&#39;, 3)-&gt;orderBy(&#39;id&#39;, &#39;desc&#39;);\n// 查询，第一条数据。\n$obj = User::all()-&gt;first();\n// 查询，返回结果数。\n$int = User::count();\n// 查询，某列的最大/最小值。\n$num = User::where(&#39;id&#39;, &#39;&lt;&#39;, 10)-&gt;max(&#39;age&#39;);\n$num = User::where(&#39;id&#39;, &#39;&lt;&#39;, 10)-&gt;min(&#39;age&#39;);</code></pre>\n<p>实际上，无论使用何种方式操作数据库，最终都是在执行 SQL 语句。相较于 DB Facade ，后两者把构造 SQL 语句的工作交给了 Laravel 。另外，我感觉 Eloquent ORM 和 Query Builder 是很接近的，只不过多了模型的概念，不过后者的代码确实要更加简洁、一目了然。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"Laravel 使用 SMTP 发送邮件","date":"2016-11-06T08:01:44.000Z","_content":"\nLaravel 基于 SwiftMailer 库提供了一套邮件 API 。我在阅读文档后尝试使用 SMTP 发送邮件，并测试成功，下面简单记录一下过程。\n\n<!-- more -->\n\n第一步，修改 .env 文件中的邮件设置，包括邮件驱动、服务器地址、端口、用户名、密码。邮件驱动自然是 smtp ，其他选项根据你的邮箱填写。\n\n```\nMAIL_DRIVER=smtp\nMAIL_HOST=smtp.example.com\nMAIL_PORT=25\nMAIL_USERNAME=example@example.com\nMAIL_PASSWORD=example\n```\n\n第二步，创建一个视图文件，作为邮件正文的来源。例如，我新建了 resources/views/emails/content.blade.php 并在里面添加了一些文本。\n\n第三步，在控制器中调用 Mail 门面的 `send` 方法发送邮件。\n\n``` php\n// 导入命名空间\nuse Mail;\n```\n\n``` php\nMail::send('emails.content', ['data'=>$data], function($m)use($email) {\n  // 设置发件邮箱、发件姓名、收件邮箱\n  $m->from('example@example.com','Example'])->to($email);\n  // 设置邮件标题\n  $m->subject('Subject');\n});\n```\n\n`send` 方法的第一个参数是要引用的视图，第二个参数是要传给视图的参数，第三个参数是用来设置邮件的匿名函数。`send` 方法始终返回1，无论 SMTP 服务器最终是否发送成功，这点我是使用一个不可能存在的收件地址测试的，说明其返回值仅表示成功与服务器通信。\n\n对于传给视图的参数，可以这样在视图文件中输出：（参考 Blade 模板引擎用法）\n\n```\n密码重置链接：{{ $data }}\n```\n\n另外，在匿名函数中设置邮件时，你可以使用 `env`方法引用 .env 文件中的参数。这样，如果以后需要更换 SMTP 账号，只需修改 .env 文件即可。\n\n``` php\n$m->from(env('MAIL_USERNAME'), env('CUS_MAILALIAS'));\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","source":"_posts/2016-11-06@Laravel 使用 SMTP 发送邮件.md","raw":"---\ntitle: Laravel 使用 SMTP 发送邮件\ncategories:\n  - Web Back-end\ndate: 2016-11-06 16:01:44\ntags:\n  - Laravel\n  - SMTP\n---\n\nLaravel 基于 SwiftMailer 库提供了一套邮件 API 。我在阅读文档后尝试使用 SMTP 发送邮件，并测试成功，下面简单记录一下过程。\n\n<!-- more -->\n\n第一步，修改 .env 文件中的邮件设置，包括邮件驱动、服务器地址、端口、用户名、密码。邮件驱动自然是 smtp ，其他选项根据你的邮箱填写。\n\n```\nMAIL_DRIVER=smtp\nMAIL_HOST=smtp.example.com\nMAIL_PORT=25\nMAIL_USERNAME=example@example.com\nMAIL_PASSWORD=example\n```\n\n第二步，创建一个视图文件，作为邮件正文的来源。例如，我新建了 resources/views/emails/content.blade.php 并在里面添加了一些文本。\n\n第三步，在控制器中调用 Mail 门面的 `send` 方法发送邮件。\n\n``` php\n// 导入命名空间\nuse Mail;\n```\n\n``` php\nMail::send('emails.content', ['data'=>$data], function($m)use($email) {\n  // 设置发件邮箱、发件姓名、收件邮箱\n  $m->from('example@example.com','Example'])->to($email);\n  // 设置邮件标题\n  $m->subject('Subject');\n});\n```\n\n`send` 方法的第一个参数是要引用的视图，第二个参数是要传给视图的参数，第三个参数是用来设置邮件的匿名函数。`send` 方法始终返回1，无论 SMTP 服务器最终是否发送成功，这点我是使用一个不可能存在的收件地址测试的，说明其返回值仅表示成功与服务器通信。\n\n对于传给视图的参数，可以这样在视图文件中输出：（参考 Blade 模板引擎用法）\n\n```\n密码重置链接：{{ $data }}\n```\n\n另外，在匿名函数中设置邮件时，你可以使用 `env`方法引用 .env 文件中的参数。这样，如果以后需要更换 SMTP 账号，只需修改 .env 文件即可。\n\n``` php\n$m->from(env('MAIL_USERNAME'), env('CUS_MAILALIAS'));\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","slug":"2016-11-06@Laravel 使用 SMTP 发送邮件","published":1,"updated":"2020-06-29T03:32:42.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48x0062rqgj5sx77hay","content":"<p>Laravel 基于 SwiftMailer 库提供了一套邮件 API 。我在阅读文档后尝试使用 SMTP 发送邮件，并测试成功，下面简单记录一下过程。</p>\n<a id=\"more\"></a>\n\n<p>第一步，修改 .env 文件中的邮件设置，包括邮件驱动、服务器地址、端口、用户名、密码。邮件驱动自然是 smtp ，其他选项根据你的邮箱填写。</p>\n<pre><code>MAIL_DRIVER=smtp\nMAIL_HOST=smtp.example.com\nMAIL_PORT=25\nMAIL_USERNAME=example@example.com\nMAIL_PASSWORD=example</code></pre><p>第二步，创建一个视图文件，作为邮件正文的来源。例如，我新建了 resources/views/emails/content.blade.php 并在里面添加了一些文本。</p>\n<p>第三步，在控制器中调用 Mail 门面的 <code>send</code> 方法发送邮件。</p>\n<pre><code class=\"php\">// 导入命名空间\nuse Mail;</code></pre>\n<pre><code class=\"php\">Mail::send(&#39;emails.content&#39;, [&#39;data&#39;=&gt;$data], function($m)use($email) {\n  // 设置发件邮箱、发件姓名、收件邮箱\n  $m-&gt;from(&#39;example@example.com&#39;,&#39;Example&#39;])-&gt;to($email);\n  // 设置邮件标题\n  $m-&gt;subject(&#39;Subject&#39;);\n});</code></pre>\n<p><code>send</code> 方法的第一个参数是要引用的视图，第二个参数是要传给视图的参数，第三个参数是用来设置邮件的匿名函数。<code>send</code> 方法始终返回1，无论 SMTP 服务器最终是否发送成功，这点我是使用一个不可能存在的收件地址测试的，说明其返回值仅表示成功与服务器通信。</p>\n<p>对于传给视图的参数，可以这样在视图文件中输出：（参考 Blade 模板引擎用法）</p>\n<pre><code>密码重置链接：{{ $data }}</code></pre><p>另外，在匿名函数中设置邮件时，你可以使用 <code>env</code>方法引用 .env 文件中的参数。这样，如果以后需要更换 SMTP 账号，只需修改 .env 文件即可。</p>\n<pre><code class=\"php\">$m-&gt;from(env(&#39;MAIL_USERNAME&#39;), env(&#39;CUS_MAILALIAS&#39;));</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>Laravel 基于 SwiftMailer 库提供了一套邮件 API 。我在阅读文档后尝试使用 SMTP 发送邮件，并测试成功，下面简单记录一下过程。</p>","more":"<p>第一步，修改 .env 文件中的邮件设置，包括邮件驱动、服务器地址、端口、用户名、密码。邮件驱动自然是 smtp ，其他选项根据你的邮箱填写。</p>\n<pre><code>MAIL_DRIVER=smtp\nMAIL_HOST=smtp.example.com\nMAIL_PORT=25\nMAIL_USERNAME=example@example.com\nMAIL_PASSWORD=example</code></pre><p>第二步，创建一个视图文件，作为邮件正文的来源。例如，我新建了 resources/views/emails/content.blade.php 并在里面添加了一些文本。</p>\n<p>第三步，在控制器中调用 Mail 门面的 <code>send</code> 方法发送邮件。</p>\n<pre><code class=\"php\">// 导入命名空间\nuse Mail;</code></pre>\n<pre><code class=\"php\">Mail::send(&#39;emails.content&#39;, [&#39;data&#39;=&gt;$data], function($m)use($email) {\n  // 设置发件邮箱、发件姓名、收件邮箱\n  $m-&gt;from(&#39;example@example.com&#39;,&#39;Example&#39;])-&gt;to($email);\n  // 设置邮件标题\n  $m-&gt;subject(&#39;Subject&#39;);\n});</code></pre>\n<p><code>send</code> 方法的第一个参数是要引用的视图，第二个参数是要传给视图的参数，第三个参数是用来设置邮件的匿名函数。<code>send</code> 方法始终返回1，无论 SMTP 服务器最终是否发送成功，这点我是使用一个不可能存在的收件地址测试的，说明其返回值仅表示成功与服务器通信。</p>\n<p>对于传给视图的参数，可以这样在视图文件中输出：（参考 Blade 模板引擎用法）</p>\n<pre><code>密码重置链接：{{ $data }}</code></pre><p>另外，在匿名函数中设置邮件时，你可以使用 <code>env</code>方法引用 .env 文件中的参数。这样，如果以后需要更换 SMTP 账号，只需修改 .env 文件即可。</p>\n<pre><code class=\"php\">$m-&gt;from(env(&#39;MAIL_USERNAME&#39;), env(&#39;CUS_MAILALIAS&#39;));</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"WampServer 配置虚拟主机","date":"2016-11-21T06:14:18.000Z","_content":"\nWampServer 默认创建一个站点，以 www 目录作为网站的根目录，通过 `http://localhost/` 访问。通过修改配置文件可以创建虚拟主机，即实现多站点。\n\n<!-- more -->\n\n第一步，启用 Apache 的 mod_rewrite 模块。打开配置文件 bin\\apache\\apache2.4.9\\conf\\httpd.conf ，找到下行并去掉前面的 `#` 号。\n\n```\nLoadModule rewrite_module modules/mod_rewrite.so\n```\n\n第二步，启用虚拟主机配置文件。同样是在 httpd.conf 文件中，找到下行并去掉前面的 `#` 号。\n\n```\nInclude conf/extra/httpd-vhosts.conf\n```\n\n第三步，修改虚拟主机配置文件。打开 bin\\apache\\apache2.4.9\\conf\\extra\\httpd-vhosts.conf ，该文件中已包含示例，直接修改即可。\n\n```\n<VirtualHost *:80>\n    DocumentRoot \"d:/vhosts/example\" // 文件目录\n    ServerName example.com // 绑定域名\n</VirtualHost>\n```\n\n第四步，允许访问文件目录。如果虚拟主机的文件目录不在 www 目录下，继续编辑 httpd-vhosts.conf 文件，添加 `<Directory>` 标签中的内容。\n\n```\n<VirtualHost *:80>\n\tDocumentRoot \"d:/vhosts/example\"\n\tServerName example.com\n\t<Directory \"d:/vhosts/example\">\n\t\tOptions Indexes FollowSymLinks\n\t\tAllowOverride all\n\t\tRequire local\n\t</Directory>\n</VirtualHost>\n```\n\n第五步，将域名指向本机。编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加以下内容，表示由本机响应对 `example.com` 的访问。\n\n```\n127.0.0.1       example.com\n```\n\n最后，重启 WampServer 即可。\n\n相关环境：Windows 7 x64 / WampServer 2.5","source":"_posts/2016-11-21@WampServer 配置虚拟主机.md","raw":"---\ntitle: WampServer 配置虚拟主机\ncategories:\n  - Web Back-end\ndate: 2016-11-21 14:14:18\ntags:\n  - WampServer\n---\n\nWampServer 默认创建一个站点，以 www 目录作为网站的根目录，通过 `http://localhost/` 访问。通过修改配置文件可以创建虚拟主机，即实现多站点。\n\n<!-- more -->\n\n第一步，启用 Apache 的 mod_rewrite 模块。打开配置文件 bin\\apache\\apache2.4.9\\conf\\httpd.conf ，找到下行并去掉前面的 `#` 号。\n\n```\nLoadModule rewrite_module modules/mod_rewrite.so\n```\n\n第二步，启用虚拟主机配置文件。同样是在 httpd.conf 文件中，找到下行并去掉前面的 `#` 号。\n\n```\nInclude conf/extra/httpd-vhosts.conf\n```\n\n第三步，修改虚拟主机配置文件。打开 bin\\apache\\apache2.4.9\\conf\\extra\\httpd-vhosts.conf ，该文件中已包含示例，直接修改即可。\n\n```\n<VirtualHost *:80>\n    DocumentRoot \"d:/vhosts/example\" // 文件目录\n    ServerName example.com // 绑定域名\n</VirtualHost>\n```\n\n第四步，允许访问文件目录。如果虚拟主机的文件目录不在 www 目录下，继续编辑 httpd-vhosts.conf 文件，添加 `<Directory>` 标签中的内容。\n\n```\n<VirtualHost *:80>\n\tDocumentRoot \"d:/vhosts/example\"\n\tServerName example.com\n\t<Directory \"d:/vhosts/example\">\n\t\tOptions Indexes FollowSymLinks\n\t\tAllowOverride all\n\t\tRequire local\n\t</Directory>\n</VirtualHost>\n```\n\n第五步，将域名指向本机。编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加以下内容，表示由本机响应对 `example.com` 的访问。\n\n```\n127.0.0.1       example.com\n```\n\n最后，重启 WampServer 即可。\n\n相关环境：Windows 7 x64 / WampServer 2.5","slug":"2016-11-21@WampServer 配置虚拟主机","published":1,"updated":"2020-06-29T03:32:42.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48y0066rqgjfwwpal9x","content":"<p>WampServer 默认创建一个站点，以 www 目录作为网站的根目录，通过 <code>http://localhost/</code> 访问。通过修改配置文件可以创建虚拟主机，即实现多站点。</p>\n<a id=\"more\"></a>\n\n<p>第一步，启用 Apache 的 mod_rewrite 模块。打开配置文件 bin\\apache\\apache2.4.9\\conf\\httpd.conf ，找到下行并去掉前面的 <code>#</code> 号。</p>\n<pre><code>LoadModule rewrite_module modules/mod_rewrite.so</code></pre><p>第二步，启用虚拟主机配置文件。同样是在 httpd.conf 文件中，找到下行并去掉前面的 <code>#</code> 号。</p>\n<pre><code>Include conf/extra/httpd-vhosts.conf</code></pre><p>第三步，修改虚拟主机配置文件。打开 bin\\apache\\apache2.4.9\\conf\\extra\\httpd-vhosts.conf ，该文件中已包含示例，直接修改即可。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n    DocumentRoot &quot;d:/vhosts/example&quot; // 文件目录\n    ServerName example.com // 绑定域名\n&lt;/VirtualHost&gt;</code></pre><p>第四步，允许访问文件目录。如果虚拟主机的文件目录不在 www 目录下，继续编辑 httpd-vhosts.conf 文件，添加 <code>&lt;Directory&gt;</code> 标签中的内容。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n    DocumentRoot &quot;d:/vhosts/example&quot;\n    ServerName example.com\n    &lt;Directory &quot;d:/vhosts/example&quot;&gt;\n        Options Indexes FollowSymLinks\n        AllowOverride all\n        Require local\n    &lt;/Directory&gt;\n&lt;/VirtualHost&gt;</code></pre><p>第五步，将域名指向本机。编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加以下内容，表示由本机响应对 <code>example.com</code> 的访问。</p>\n<pre><code>127.0.0.1       example.com</code></pre><p>最后，重启 WampServer 即可。</p>\n<p>相关环境：Windows 7 x64 / WampServer 2.5</p>\n","site":{"data":{}},"excerpt":"<p>WampServer 默认创建一个站点，以 www 目录作为网站的根目录，通过 <code>http://localhost/</code> 访问。通过修改配置文件可以创建虚拟主机，即实现多站点。</p>","more":"<p>第一步，启用 Apache 的 mod_rewrite 模块。打开配置文件 bin\\apache\\apache2.4.9\\conf\\httpd.conf ，找到下行并去掉前面的 <code>#</code> 号。</p>\n<pre><code>LoadModule rewrite_module modules/mod_rewrite.so</code></pre><p>第二步，启用虚拟主机配置文件。同样是在 httpd.conf 文件中，找到下行并去掉前面的 <code>#</code> 号。</p>\n<pre><code>Include conf/extra/httpd-vhosts.conf</code></pre><p>第三步，修改虚拟主机配置文件。打开 bin\\apache\\apache2.4.9\\conf\\extra\\httpd-vhosts.conf ，该文件中已包含示例，直接修改即可。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n    DocumentRoot &quot;d:/vhosts/example&quot; // 文件目录\n    ServerName example.com // 绑定域名\n&lt;/VirtualHost&gt;</code></pre><p>第四步，允许访问文件目录。如果虚拟主机的文件目录不在 www 目录下，继续编辑 httpd-vhosts.conf 文件，添加 <code>&lt;Directory&gt;</code> 标签中的内容。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n    DocumentRoot &quot;d:/vhosts/example&quot;\n    ServerName example.com\n    &lt;Directory &quot;d:/vhosts/example&quot;&gt;\n        Options Indexes FollowSymLinks\n        AllowOverride all\n        Require local\n    &lt;/Directory&gt;\n&lt;/VirtualHost&gt;</code></pre><p>第五步，将域名指向本机。编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加以下内容，表示由本机响应对 <code>example.com</code> 的访问。</p>\n<pre><code>127.0.0.1       example.com</code></pre><p>最后，重启 WampServer 即可。</p>\n<p>相关环境：Windows 7 x64 / WampServer 2.5</p>"},{"title":"解决 iOS 下 click 点击事件失效","date":"2016-11-28T15:40:54.000Z","_content":"\n前段时间在写一个 Web 小游戏，使用了 jQuery 绑定元素的点击事件。测试后发现，在 PC 和 Android 上均正常运行，但是在 iOS 上需要多次触摸才勉强响应一次点击。\n\n<!-- more -->\n\n搜索后未能找到问题原因及解决方案。于是我尝试更换多种绑定方式，包括但不限于 `click()` 、`mousedown()` 、`on('click', function)` 、`on(\"tap\", function)` ，均不见起色。\n\n在不断地尝试后，终于在使用了 `on('touchend', function)` 方法后解决了这个问题。\n\n据说出现这个问题是因为 click 事件在 iOS 上存在延迟，所以需要用 touchstart / touchmove / touchend 事件替代传统的点击事件。当然代价是存在的，PC 端可能不会响应 touch 事件。如果需要同时兼容 PC ，只能判断设备并采用不同的绑定方式。","source":"_posts/2016-11-28@解决 iOS 下 click 点击事件失效.md","raw":"---\ntitle: 解决 iOS 下 click 点击事件失效\ncategories:\n  - Web Front-end\ndate: 2016-11-28 23:40:54\ntags:\n  - jQuery\n  - JavaScript\n---\n\n前段时间在写一个 Web 小游戏，使用了 jQuery 绑定元素的点击事件。测试后发现，在 PC 和 Android 上均正常运行，但是在 iOS 上需要多次触摸才勉强响应一次点击。\n\n<!-- more -->\n\n搜索后未能找到问题原因及解决方案。于是我尝试更换多种绑定方式，包括但不限于 `click()` 、`mousedown()` 、`on('click', function)` 、`on(\"tap\", function)` ，均不见起色。\n\n在不断地尝试后，终于在使用了 `on('touchend', function)` 方法后解决了这个问题。\n\n据说出现这个问题是因为 click 事件在 iOS 上存在延迟，所以需要用 touchstart / touchmove / touchend 事件替代传统的点击事件。当然代价是存在的，PC 端可能不会响应 touch 事件。如果需要同时兼容 PC ，只能判断设备并采用不同的绑定方式。","slug":"2016-11-28@解决 iOS 下 click 点击事件失效","published":1,"updated":"2020-06-29T03:32:42.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt48z0069rqgjfo6obx66","content":"<p>前段时间在写一个 Web 小游戏，使用了 jQuery 绑定元素的点击事件。测试后发现，在 PC 和 Android 上均正常运行，但是在 iOS 上需要多次触摸才勉强响应一次点击。</p>\n<a id=\"more\"></a>\n\n<p>搜索后未能找到问题原因及解决方案。于是我尝试更换多种绑定方式，包括但不限于 <code>click()</code> 、<code>mousedown()</code> 、<code>on(&#39;click&#39;, function)</code> 、<code>on(&quot;tap&quot;, function)</code> ，均不见起色。</p>\n<p>在不断地尝试后，终于在使用了 <code>on(&#39;touchend&#39;, function)</code> 方法后解决了这个问题。</p>\n<p>据说出现这个问题是因为 click 事件在 iOS 上存在延迟，所以需要用 touchstart / touchmove / touchend 事件替代传统的点击事件。当然代价是存在的，PC 端可能不会响应 touch 事件。如果需要同时兼容 PC ，只能判断设备并采用不同的绑定方式。</p>\n","site":{"data":{}},"excerpt":"<p>前段时间在写一个 Web 小游戏，使用了 jQuery 绑定元素的点击事件。测试后发现，在 PC 和 Android 上均正常运行，但是在 iOS 上需要多次触摸才勉强响应一次点击。</p>","more":"<p>搜索后未能找到问题原因及解决方案。于是我尝试更换多种绑定方式，包括但不限于 <code>click()</code> 、<code>mousedown()</code> 、<code>on(&#39;click&#39;, function)</code> 、<code>on(&quot;tap&quot;, function)</code> ，均不见起色。</p>\n<p>在不断地尝试后，终于在使用了 <code>on(&#39;touchend&#39;, function)</code> 方法后解决了这个问题。</p>\n<p>据说出现这个问题是因为 click 事件在 iOS 上存在延迟，所以需要用 touchstart / touchmove / touchend 事件替代传统的点击事件。当然代价是存在的，PC 端可能不会响应 touch 事件。如果需要同时兼容 PC ，只能判断设备并采用不同的绑定方式。</p>"},{"title":"使用 CSS 实现 DIV 垂直居中","date":"2016-12-02T15:08:01.000Z","_content":"\n项目中经常会用到内容相对屏幕完全居中的布局。水平居中通常写一句代码即可实现，而垂直居中就稍微麻烦一些。其实，让 DIV 垂直居中的方法有很多，我个人常用两种 DIV+CSS 的方式实现。\n\n<!-- more -->\n\n两种方式的 HTML 代码是一样的，类名为 content 的 DIV 是放置居中内容的容器，外层的两个 DIV 则用来辅助实现居中布局。下文使用类名表示三个不同的 DIV 。\n\n```\n<div class=\"outer-wrap\">\n  <div class=\"inner-wrap\">\n    <div class=\"content\">\n    </div>\n  </div>\n</div>\n```\n\n**第一种方法，利用 table-cell 实现垂直居中。**\n\n``` css\n.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  display: table;\n}\n.inner-wrap {\n  display: table-cell;\n  vertical-align: middle;\n}\n.content {\n  width: 100px;\n  height: 100px;\n  background: #000;\n  margin: 0 auto;\n}\n```\n\n分别将 outer-wrap 和 inner-wrap 类名的 _display_ 属性设为 `table` 和 `table-cell`，然后给 inner-wrap 添加 `vertical-align: middle` ，实现垂直居中。最后给 content 添加 `margin: 0 auto` ，实现水平居中。\n\n此方法不兼容过时浏览器（<IE8），不过我反而用得比较多，毕竟移动端基本不需要考虑IE6/7/8的兼容问题。\n\n**第二种方法，利用绝对布局实现垂直居中。**\n\n``` css\n.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  position: relative;\n}\n.inner-wrap {\n  width: 100px;\n  height: 100px;\n  background: #888;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n.content {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  position: absolute;\n  top: -50%;\n  left: -50%;\n}\n```\n\n首先将 outer-wrap 设为相对布局 `position: relative` ，同时将 inner-wrap 、content 设为绝对布局 `position: absolute` 。此时，inner-wrap 将根据 outer-wrap 的位置定位，content 将相对于 inner-wrap 的位置定位。然后为 inner-wrap 添加 `top: 50%` 、 `left: 50%` ，使其（左上角）定位到 outer-wrap 的中点位置，实现大致的居中定位。最后为 content 添加 `top: -50%` 、 `left: -50%` ，实现精确的居中定位。\n\n此方法仅适用于内容容器 DIV 的宽度、高度固定的情况。","source":"_posts/2016-12-02@使用 CSS 实现 DIV 垂直居中.md","raw":"---\ntitle: 使用 CSS 实现 DIV 垂直居中\ncategories:\n  - Web Front-end\ndate: 2016-12-02 23:08:01\ntags:\n  - CSS\n---\n\n项目中经常会用到内容相对屏幕完全居中的布局。水平居中通常写一句代码即可实现，而垂直居中就稍微麻烦一些。其实，让 DIV 垂直居中的方法有很多，我个人常用两种 DIV+CSS 的方式实现。\n\n<!-- more -->\n\n两种方式的 HTML 代码是一样的，类名为 content 的 DIV 是放置居中内容的容器，外层的两个 DIV 则用来辅助实现居中布局。下文使用类名表示三个不同的 DIV 。\n\n```\n<div class=\"outer-wrap\">\n  <div class=\"inner-wrap\">\n    <div class=\"content\">\n    </div>\n  </div>\n</div>\n```\n\n**第一种方法，利用 table-cell 实现垂直居中。**\n\n``` css\n.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  display: table;\n}\n.inner-wrap {\n  display: table-cell;\n  vertical-align: middle;\n}\n.content {\n  width: 100px;\n  height: 100px;\n  background: #000;\n  margin: 0 auto;\n}\n```\n\n分别将 outer-wrap 和 inner-wrap 类名的 _display_ 属性设为 `table` 和 `table-cell`，然后给 inner-wrap 添加 `vertical-align: middle` ，实现垂直居中。最后给 content 添加 `margin: 0 auto` ，实现水平居中。\n\n此方法不兼容过时浏览器（<IE8），不过我反而用得比较多，毕竟移动端基本不需要考虑IE6/7/8的兼容问题。\n\n**第二种方法，利用绝对布局实现垂直居中。**\n\n``` css\n.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  position: relative;\n}\n.inner-wrap {\n  width: 100px;\n  height: 100px;\n  background: #888;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n.content {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  position: absolute;\n  top: -50%;\n  left: -50%;\n}\n```\n\n首先将 outer-wrap 设为相对布局 `position: relative` ，同时将 inner-wrap 、content 设为绝对布局 `position: absolute` 。此时，inner-wrap 将根据 outer-wrap 的位置定位，content 将相对于 inner-wrap 的位置定位。然后为 inner-wrap 添加 `top: 50%` 、 `left: 50%` ，使其（左上角）定位到 outer-wrap 的中点位置，实现大致的居中定位。最后为 content 添加 `top: -50%` 、 `left: -50%` ，实现精确的居中定位。\n\n此方法仅适用于内容容器 DIV 的宽度、高度固定的情况。","slug":"2016-12-02@使用 CSS 实现 DIV 垂直居中","published":1,"updated":"2020-06-29T03:32:42.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt492006drqgj5kjg59na","content":"<p>项目中经常会用到内容相对屏幕完全居中的布局。水平居中通常写一句代码即可实现，而垂直居中就稍微麻烦一些。其实，让 DIV 垂直居中的方法有很多，我个人常用两种 DIV+CSS 的方式实现。</p>\n<a id=\"more\"></a>\n\n<p>两种方式的 HTML 代码是一样的，类名为 content 的 DIV 是放置居中内容的容器，外层的两个 DIV 则用来辅助实现居中布局。下文使用类名表示三个不同的 DIV 。</p>\n<pre><code>&lt;div class=&quot;outer-wrap&quot;&gt;\n  &lt;div class=&quot;inner-wrap&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre><p><strong>第一种方法，利用 table-cell 实现垂直居中。</strong></p>\n<pre><code class=\"css\">.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  display: table;\n}\n.inner-wrap {\n  display: table-cell;\n  vertical-align: middle;\n}\n.content {\n  width: 100px;\n  height: 100px;\n  background: #000;\n  margin: 0 auto;\n}</code></pre>\n<p>分别将 outer-wrap 和 inner-wrap 类名的 <em>display</em> 属性设为 <code>table</code> 和 <code>table-cell</code>，然后给 inner-wrap 添加 <code>vertical-align: middle</code> ，实现垂直居中。最后给 content 添加 <code>margin: 0 auto</code> ，实现水平居中。</p>\n<p>此方法不兼容过时浏览器（&lt;IE8），不过我反而用得比较多，毕竟移动端基本不需要考虑IE6/7/8的兼容问题。</p>\n<p><strong>第二种方法，利用绝对布局实现垂直居中。</strong></p>\n<pre><code class=\"css\">.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  position: relative;\n}\n.inner-wrap {\n  width: 100px;\n  height: 100px;\n  background: #888;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n.content {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  position: absolute;\n  top: -50%;\n  left: -50%;\n}</code></pre>\n<p>首先将 outer-wrap 设为相对布局 <code>position: relative</code> ，同时将 inner-wrap 、content 设为绝对布局 <code>position: absolute</code> 。此时，inner-wrap 将根据 outer-wrap 的位置定位，content 将相对于 inner-wrap 的位置定位。然后为 inner-wrap 添加 <code>top: 50%</code> 、 <code>left: 50%</code> ，使其（左上角）定位到 outer-wrap 的中点位置，实现大致的居中定位。最后为 content 添加 <code>top: -50%</code> 、 <code>left: -50%</code> ，实现精确的居中定位。</p>\n<p>此方法仅适用于内容容器 DIV 的宽度、高度固定的情况。</p>\n","site":{"data":{}},"excerpt":"<p>项目中经常会用到内容相对屏幕完全居中的布局。水平居中通常写一句代码即可实现，而垂直居中就稍微麻烦一些。其实，让 DIV 垂直居中的方法有很多，我个人常用两种 DIV+CSS 的方式实现。</p>","more":"<p>两种方式的 HTML 代码是一样的，类名为 content 的 DIV 是放置居中内容的容器，外层的两个 DIV 则用来辅助实现居中布局。下文使用类名表示三个不同的 DIV 。</p>\n<pre><code>&lt;div class=&quot;outer-wrap&quot;&gt;\n  &lt;div class=&quot;inner-wrap&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre><p><strong>第一种方法，利用 table-cell 实现垂直居中。</strong></p>\n<pre><code class=\"css\">.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  display: table;\n}\n.inner-wrap {\n  display: table-cell;\n  vertical-align: middle;\n}\n.content {\n  width: 100px;\n  height: 100px;\n  background: #000;\n  margin: 0 auto;\n}</code></pre>\n<p>分别将 outer-wrap 和 inner-wrap 类名的 <em>display</em> 属性设为 <code>table</code> 和 <code>table-cell</code>，然后给 inner-wrap 添加 <code>vertical-align: middle</code> ，实现垂直居中。最后给 content 添加 <code>margin: 0 auto</code> ，实现水平居中。</p>\n<p>此方法不兼容过时浏览器（&lt;IE8），不过我反而用得比较多，毕竟移动端基本不需要考虑IE6/7/8的兼容问题。</p>\n<p><strong>第二种方法，利用绝对布局实现垂直居中。</strong></p>\n<pre><code class=\"css\">.outer-wrap {\n  width: 400px;\n  height: 400px;\n  background: #cacaca;\n  position: relative;\n}\n.inner-wrap {\n  width: 100px;\n  height: 100px;\n  background: #888;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n.content {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  position: absolute;\n  top: -50%;\n  left: -50%;\n}</code></pre>\n<p>首先将 outer-wrap 设为相对布局 <code>position: relative</code> ，同时将 inner-wrap 、content 设为绝对布局 <code>position: absolute</code> 。此时，inner-wrap 将根据 outer-wrap 的位置定位，content 将相对于 inner-wrap 的位置定位。然后为 inner-wrap 添加 <code>top: 50%</code> 、 <code>left: 50%</code> ，使其（左上角）定位到 outer-wrap 的中点位置，实现大致的居中定位。最后为 content 添加 <code>top: -50%</code> 、 <code>left: -50%</code> ，实现精确的居中定位。</p>\n<p>此方法仅适用于内容容器 DIV 的宽度、高度固定的情况。</p>"},{"title":"SSH 登录 VirtualBox 虚拟机","date":"2016-12-03T10:12:47.000Z","_content":"\n近期通过虚拟机学习服务端，感觉在 VirtualBox 窗口上操作虚拟机并不流畅，同时不能方便地从本机将文本复制到虚拟机。于是，我开始试图在本机 SSH 登录虚拟机，并直接在本机的命令行工具中操作。\n\n<!-- more -->\n\n查阅资料后发现可以用端口转发的方式实现。\n\n第一步，在 VirtualBox 界面中选中虚拟机，右键打开“设置”，然后切换到“网络”标签页。\n\n第二步，在网卡1的“高级”菜单中打开“端口转发”，点击加号按钮添加新的端口转发规则。将“主机端口”设为2222（本机任一未被占用的端口），“子系统端口”设为22（即默认的 SSH 端口），保存设置。\n\n第三步，打开命令行工具（如 Git Bash ），使用 SSH 命令登录到虚拟机。\n\n```\nssh -p 2222 root@127.0.0.1\n```\n\n该命令表示使用 root 账号登录 IP 为127.0.0.1（即本机）的设备，服务端口为2222。由于本机的2222端口已被转发到虚拟机的22端口，所以实际上是登录的设备是虚拟机。此处使用的端口号可以是本机上任一未被占用的端口，只需保证与“端口转发”规则中设置的端口一致即可。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / CentOS 7 / Git Bash","source":"_posts/2016-12-03@SSH 登录 VirtualBox 虚拟机.md","raw":"---\ntitle: SSH 登录 VirtualBox 虚拟机\ncategories:\n  - Web Back-end\ndate: 2016-12-03 18:12:47\ntags:\n  - SSH\n  - 虚拟机\n---\n\n近期通过虚拟机学习服务端，感觉在 VirtualBox 窗口上操作虚拟机并不流畅，同时不能方便地从本机将文本复制到虚拟机。于是，我开始试图在本机 SSH 登录虚拟机，并直接在本机的命令行工具中操作。\n\n<!-- more -->\n\n查阅资料后发现可以用端口转发的方式实现。\n\n第一步，在 VirtualBox 界面中选中虚拟机，右键打开“设置”，然后切换到“网络”标签页。\n\n第二步，在网卡1的“高级”菜单中打开“端口转发”，点击加号按钮添加新的端口转发规则。将“主机端口”设为2222（本机任一未被占用的端口），“子系统端口”设为22（即默认的 SSH 端口），保存设置。\n\n第三步，打开命令行工具（如 Git Bash ），使用 SSH 命令登录到虚拟机。\n\n```\nssh -p 2222 root@127.0.0.1\n```\n\n该命令表示使用 root 账号登录 IP 为127.0.0.1（即本机）的设备，服务端口为2222。由于本机的2222端口已被转发到虚拟机的22端口，所以实际上是登录的设备是虚拟机。此处使用的端口号可以是本机上任一未被占用的端口，只需保证与“端口转发”规则中设置的端口一致即可。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / CentOS 7 / Git Bash","slug":"2016-12-03@SSH 登录 VirtualBox 虚拟机","published":1,"updated":"2020-06-29T03:32:42.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt492006grqgj1osa1db8","content":"<p>近期通过虚拟机学习服务端，感觉在 VirtualBox 窗口上操作虚拟机并不流畅，同时不能方便地从本机将文本复制到虚拟机。于是，我开始试图在本机 SSH 登录虚拟机，并直接在本机的命令行工具中操作。</p>\n<a id=\"more\"></a>\n\n<p>查阅资料后发现可以用端口转发的方式实现。</p>\n<p>第一步，在 VirtualBox 界面中选中虚拟机，右键打开“设置”，然后切换到“网络”标签页。</p>\n<p>第二步，在网卡1的“高级”菜单中打开“端口转发”，点击加号按钮添加新的端口转发规则。将“主机端口”设为2222（本机任一未被占用的端口），“子系统端口”设为22（即默认的 SSH 端口），保存设置。</p>\n<p>第三步，打开命令行工具（如 Git Bash ），使用 SSH 命令登录到虚拟机。</p>\n<pre><code>ssh -p 2222 root@127.0.0.1</code></pre><p>该命令表示使用 root 账号登录 IP 为127.0.0.1（即本机）的设备，服务端口为2222。由于本机的2222端口已被转发到虚拟机的22端口，所以实际上是登录的设备是虚拟机。此处使用的端口号可以是本机上任一未被占用的端口，只需保证与“端口转发”规则中设置的端口一致即可。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / CentOS 7 / Git Bash</p>\n","site":{"data":{}},"excerpt":"<p>近期通过虚拟机学习服务端，感觉在 VirtualBox 窗口上操作虚拟机并不流畅，同时不能方便地从本机将文本复制到虚拟机。于是，我开始试图在本机 SSH 登录虚拟机，并直接在本机的命令行工具中操作。</p>","more":"<p>查阅资料后发现可以用端口转发的方式实现。</p>\n<p>第一步，在 VirtualBox 界面中选中虚拟机，右键打开“设置”，然后切换到“网络”标签页。</p>\n<p>第二步，在网卡1的“高级”菜单中打开“端口转发”，点击加号按钮添加新的端口转发规则。将“主机端口”设为2222（本机任一未被占用的端口），“子系统端口”设为22（即默认的 SSH 端口），保存设置。</p>\n<p>第三步，打开命令行工具（如 Git Bash ），使用 SSH 命令登录到虚拟机。</p>\n<pre><code>ssh -p 2222 root@127.0.0.1</code></pre><p>该命令表示使用 root 账号登录 IP 为127.0.0.1（即本机）的设备，服务端口为2222。由于本机的2222端口已被转发到虚拟机的22端口，所以实际上是登录的设备是虚拟机。此处使用的端口号可以是本机上任一未被占用的端口，只需保证与“端口转发”规则中设置的端口一致即可。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / CentOS 7 / Git Bash</p>"},{"title":"VirtualBox 创建 Linux 虚拟机","date":"2016-12-03T04:45:17.000Z","_content":"\n第一步，下载 CentOS 镜像。[访问](http://www.centos.org) CentOS 官方网站，下载 ISO 镜像文件。\n\n第二步，新建虚拟机。在 VittualBox 中点击“新建”，设置名称为“CentOS”。可以看到类型和版本已被 VirtualBox 自动改成了“Linux”和“Red Hat (64-bit)”。一路继续直到创建完成即可。\n\n<!-- more -->\n\n第三步，安装 CentOS 系统。在 VittualBox 中点击“启动”，选中本地镜像文件并启动，在字符界面中使用方向键选中“Install CentOS 7”后回车。在随后出现的图形界面中，设置语言为简体中文，在安装位置中选择本地标准磁盘，在网络和主机名中开启以太网，然后开始安装。\n\n第四步，完成 CentOS 配置。设置 ROOT 密码并创建用户，然后点击“完成配置”，等待 CentOS 配置完成后重启即可。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8","source":"_posts/2016-12-03@VirtualBox 创建 Linux 虚拟机.md","raw":"---\ntitle: VirtualBox 创建 Linux 虚拟机\ncategories:\n  - Web Back-end\ndate: 2016-12-03 12:45:17\ntags:\n  - 虚拟机\n---\n\n第一步，下载 CentOS 镜像。[访问](http://www.centos.org) CentOS 官方网站，下载 ISO 镜像文件。\n\n第二步，新建虚拟机。在 VittualBox 中点击“新建”，设置名称为“CentOS”。可以看到类型和版本已被 VirtualBox 自动改成了“Linux”和“Red Hat (64-bit)”。一路继续直到创建完成即可。\n\n<!-- more -->\n\n第三步，安装 CentOS 系统。在 VittualBox 中点击“启动”，选中本地镜像文件并启动，在字符界面中使用方向键选中“Install CentOS 7”后回车。在随后出现的图形界面中，设置语言为简体中文，在安装位置中选择本地标准磁盘，在网络和主机名中开启以太网，然后开始安装。\n\n第四步，完成 CentOS 配置。设置 ROOT 密码并创建用户，然后点击“完成配置”，等待 CentOS 配置完成后重启即可。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8","slug":"2016-12-03@VirtualBox 创建 Linux 虚拟机","published":1,"updated":"2020-06-29T03:32:42.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt493006krqgjgqlc8211","content":"<p>第一步，下载 CentOS 镜像。<a href=\"http://www.centos.org\" target=\"_blank\" rel=\"noopener\">访问</a> CentOS 官方网站，下载 ISO 镜像文件。</p>\n<p>第二步，新建虚拟机。在 VittualBox 中点击“新建”，设置名称为“CentOS”。可以看到类型和版本已被 VirtualBox 自动改成了“Linux”和“Red Hat (64-bit)”。一路继续直到创建完成即可。</p>\n<a id=\"more\"></a>\n\n<p>第三步，安装 CentOS 系统。在 VittualBox 中点击“启动”，选中本地镜像文件并启动，在字符界面中使用方向键选中“Install CentOS 7”后回车。在随后出现的图形界面中，设置语言为简体中文，在安装位置中选择本地标准磁盘，在网络和主机名中开启以太网，然后开始安装。</p>\n<p>第四步，完成 CentOS 配置。设置 ROOT 密码并创建用户，然后点击“完成配置”，等待 CentOS 配置完成后重启即可。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8</p>\n","site":{"data":{}},"excerpt":"<p>第一步，下载 CentOS 镜像。<a href=\"http://www.centos.org\" target=\"_blank\" rel=\"noopener\">访问</a> CentOS 官方网站，下载 ISO 镜像文件。</p>\n<p>第二步，新建虚拟机。在 VittualBox 中点击“新建”，设置名称为“CentOS”。可以看到类型和版本已被 VirtualBox 自动改成了“Linux”和“Red Hat (64-bit)”。一路继续直到创建完成即可。</p>","more":"<p>第三步，安装 CentOS 系统。在 VittualBox 中点击“启动”，选中本地镜像文件并启动，在字符界面中使用方向键选中“Install CentOS 7”后回车。在随后出现的图形界面中，设置语言为简体中文，在安装位置中选择本地标准磁盘，在网络和主机名中开启以太网，然后开始安装。</p>\n<p>第四步，完成 CentOS 配置。设置 ROOT 密码并创建用户，然后点击“完成配置”，等待 CentOS 配置完成后重启即可。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8</p>"},{"title":"Linux 编译安装 Apache2.4","date":"2016-12-13T07:10:53.000Z","_content":"\n第一步，确认系统中已安装 C 、C++ 编译器，否则运行 yum 命令安装。\n\n```\nyum install -y gcc gcc-c++\n```\n<!-- more -->\n\n第二步，编译安装依赖。包括 APR、APR-Util、PCRE 。\n\n```\nwget http://mirrors.ustc.edu.cn/apache/apr/apr-1.5.2.tar.gz\ntar xvf apr-1.5.2.tar.gz\ncd apr-1.5.2\n./configure --prefix=/usr/local/apr\nmake\nmake install\n```\n\n```\nwget http://mirrors.ustc.edu.cn/apache/apr/apr-util-1.5.4.tar.gz\ntar xvf apr-util-1.5.4.tar.gz\ncd apr-util-1.5.4\n./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin\nmake\nmake install\n```\n\n```\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz\ntar xvf pcre-8.38.tar.gz\ncd pcre-8.38\n./configure --prefix=/usr/local/pcre\nmake \nmake install\n```\n第三步，编译安装 Apache 。\n\n```\nwget http://mirrors.ustc.edu.cn/apache/httpd/httpd-2.4.23.tar.gz\ntar xvf httpd-2.4.23.tar.gz\ncd httpd-2.4.23\n./configure --prefix=/usr/local/apache2.4 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre\nmake\nmake install\n```\n\n第四步，修改配置文件。使用编辑器打开 Apache 的配置文件 httpd.conf ，搜索关键字 `#ServerName`，添加域名并去除注释。\n\n```\nvim /usr/local/apache2.4/conf/httpd.conf\n```\n\n```\nServerName localhost:80\n```\n\n第五步，测试是否安装成功。执行以下代码，若提示 _httpd already running_ ，表示安装成功。此时使用浏览器访问服务器的 IP 地址，屏幕将输出 _It works!_ 。\n\n```\n/usr/local/apache2.4/bin/apachectl -k start\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64","source":"_posts/2016-12-13@Linux 编译安装 Apache2.4.md","raw":"---\ntitle: Linux 编译安装 Apache2.4\ncategories:\n  - Web Back-end\ndate: 2016-12-13 15:10:53\ntags:\n  - Apache\n  - Linux\n---\n\n第一步，确认系统中已安装 C 、C++ 编译器，否则运行 yum 命令安装。\n\n```\nyum install -y gcc gcc-c++\n```\n<!-- more -->\n\n第二步，编译安装依赖。包括 APR、APR-Util、PCRE 。\n\n```\nwget http://mirrors.ustc.edu.cn/apache/apr/apr-1.5.2.tar.gz\ntar xvf apr-1.5.2.tar.gz\ncd apr-1.5.2\n./configure --prefix=/usr/local/apr\nmake\nmake install\n```\n\n```\nwget http://mirrors.ustc.edu.cn/apache/apr/apr-util-1.5.4.tar.gz\ntar xvf apr-util-1.5.4.tar.gz\ncd apr-util-1.5.4\n./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin\nmake\nmake install\n```\n\n```\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz\ntar xvf pcre-8.38.tar.gz\ncd pcre-8.38\n./configure --prefix=/usr/local/pcre\nmake \nmake install\n```\n第三步，编译安装 Apache 。\n\n```\nwget http://mirrors.ustc.edu.cn/apache/httpd/httpd-2.4.23.tar.gz\ntar xvf httpd-2.4.23.tar.gz\ncd httpd-2.4.23\n./configure --prefix=/usr/local/apache2.4 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre\nmake\nmake install\n```\n\n第四步，修改配置文件。使用编辑器打开 Apache 的配置文件 httpd.conf ，搜索关键字 `#ServerName`，添加域名并去除注释。\n\n```\nvim /usr/local/apache2.4/conf/httpd.conf\n```\n\n```\nServerName localhost:80\n```\n\n第五步，测试是否安装成功。执行以下代码，若提示 _httpd already running_ ，表示安装成功。此时使用浏览器访问服务器的 IP 地址，屏幕将输出 _It works!_ 。\n\n```\n/usr/local/apache2.4/bin/apachectl -k start\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64","slug":"2016-12-13@Linux 编译安装 Apache2.4","published":1,"updated":"2020-06-29T03:32:42.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt494006nrqgjha50f8od","content":"<p>第一步，确认系统中已安装 C 、C++ 编译器，否则运行 yum 命令安装。</p>\n<pre><code>yum install -y gcc gcc-c++</code></pre><a id=\"more\"></a>\n\n<p>第二步，编译安装依赖。包括 APR、APR-Util、PCRE 。</p>\n<pre><code>wget http://mirrors.ustc.edu.cn/apache/apr/apr-1.5.2.tar.gz\ntar xvf apr-1.5.2.tar.gz\ncd apr-1.5.2\n./configure --prefix=/usr/local/apr\nmake\nmake install</code></pre><pre><code>wget http://mirrors.ustc.edu.cn/apache/apr/apr-util-1.5.4.tar.gz\ntar xvf apr-util-1.5.4.tar.gz\ncd apr-util-1.5.4\n./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin\nmake\nmake install</code></pre><pre><code>wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz\ntar xvf pcre-8.38.tar.gz\ncd pcre-8.38\n./configure --prefix=/usr/local/pcre\nmake \nmake install</code></pre><p>第三步，编译安装 Apache 。</p>\n<pre><code>wget http://mirrors.ustc.edu.cn/apache/httpd/httpd-2.4.23.tar.gz\ntar xvf httpd-2.4.23.tar.gz\ncd httpd-2.4.23\n./configure --prefix=/usr/local/apache2.4 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre\nmake\nmake install</code></pre><p>第四步，修改配置文件。使用编辑器打开 Apache 的配置文件 httpd.conf ，搜索关键字 <code>#ServerName</code>，添加域名并去除注释。</p>\n<pre><code>vim /usr/local/apache2.4/conf/httpd.conf</code></pre><pre><code>ServerName localhost:80</code></pre><p>第五步，测试是否安装成功。执行以下代码，若提示 <em>httpd already running</em> ，表示安装成功。此时使用浏览器访问服务器的 IP 地址，屏幕将输出 <em>It works!</em> 。</p>\n<pre><code>/usr/local/apache2.4/bin/apachectl -k start</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64</p>\n","site":{"data":{}},"excerpt":"<p>第一步，确认系统中已安装 C 、C++ 编译器，否则运行 yum 命令安装。</p>\n<pre><code>yum install -y gcc gcc-c++</code></pre>","more":"<p>第二步，编译安装依赖。包括 APR、APR-Util、PCRE 。</p>\n<pre><code>wget http://mirrors.ustc.edu.cn/apache/apr/apr-1.5.2.tar.gz\ntar xvf apr-1.5.2.tar.gz\ncd apr-1.5.2\n./configure --prefix=/usr/local/apr\nmake\nmake install</code></pre><pre><code>wget http://mirrors.ustc.edu.cn/apache/apr/apr-util-1.5.4.tar.gz\ntar xvf apr-util-1.5.4.tar.gz\ncd apr-util-1.5.4\n./configure --prefix=/usr/local/apr-util -with-apr=/usr/local/apr/bin\nmake\nmake install</code></pre><pre><code>wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz\ntar xvf pcre-8.38.tar.gz\ncd pcre-8.38\n./configure --prefix=/usr/local/pcre\nmake \nmake install</code></pre><p>第三步，编译安装 Apache 。</p>\n<pre><code>wget http://mirrors.ustc.edu.cn/apache/httpd/httpd-2.4.23.tar.gz\ntar xvf httpd-2.4.23.tar.gz\ncd httpd-2.4.23\n./configure --prefix=/usr/local/apache2.4 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --with-pcre=/usr/local/pcre\nmake\nmake install</code></pre><p>第四步，修改配置文件。使用编辑器打开 Apache 的配置文件 httpd.conf ，搜索关键字 <code>#ServerName</code>，添加域名并去除注释。</p>\n<pre><code>vim /usr/local/apache2.4/conf/httpd.conf</code></pre><pre><code>ServerName localhost:80</code></pre><p>第五步，测试是否安装成功。执行以下代码，若提示 <em>httpd already running</em> ，表示安装成功。此时使用浏览器访问服务器的 IP 地址，屏幕将输出 <em>It works!</em> 。</p>\n<pre><code>/usr/local/apache2.4/bin/apachectl -k start</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64</p>"},{"title":"解决 jQuery 事件重复绑定","date":"2016-12-13T02:44:48.000Z","_content":"\n昨天开发中发现一个 Bug ：前端点击事件正常执行、后端也正常响应，但数据库中的字段没有发生预期的变化。\n\n原来是 jQuery 的点击事件存在重复绑定。\n\n<!-- more -->\n\n若一个按钮多次绑定过点击事件，在点击时会触发其绑定的所有事件，而非最近一次绑定的事件。\n\n解决方法是先解绑事件，再绑定新的点击事件。\n\n``` js\n$('#example').unbind('click');\n```\n\n``` js\n$('#example').unbind('click').click(function(){\n\t// 你的点击事件\n});\n```","source":"_posts/2016-12-13@解决 jQuery 事件重复绑定.md","raw":"---\ntitle: 解决 jQuery 事件重复绑定\ncategories:\n  - Web Front-end\ndate: 2016-12-13 10:44:48\ntags:\n  - jQuery\n  - JavaScript\n---\n\n昨天开发中发现一个 Bug ：前端点击事件正常执行、后端也正常响应，但数据库中的字段没有发生预期的变化。\n\n原来是 jQuery 的点击事件存在重复绑定。\n\n<!-- more -->\n\n若一个按钮多次绑定过点击事件，在点击时会触发其绑定的所有事件，而非最近一次绑定的事件。\n\n解决方法是先解绑事件，再绑定新的点击事件。\n\n``` js\n$('#example').unbind('click');\n```\n\n``` js\n$('#example').unbind('click').click(function(){\n\t// 你的点击事件\n});\n```","slug":"2016-12-13@解决 jQuery 事件重复绑定","published":1,"updated":"2020-06-29T03:32:42.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt495006rrqgjhe527p8n","content":"<p>昨天开发中发现一个 Bug ：前端点击事件正常执行、后端也正常响应，但数据库中的字段没有发生预期的变化。</p>\n<p>原来是 jQuery 的点击事件存在重复绑定。</p>\n<a id=\"more\"></a>\n\n<p>若一个按钮多次绑定过点击事件，在点击时会触发其绑定的所有事件，而非最近一次绑定的事件。</p>\n<p>解决方法是先解绑事件，再绑定新的点击事件。</p>\n<pre><code class=\"js\">$(&#39;#example&#39;).unbind(&#39;click&#39;);</code></pre>\n<pre><code class=\"js\">$(&#39;#example&#39;).unbind(&#39;click&#39;).click(function(){\n    // 你的点击事件\n});</code></pre>\n","site":{"data":{}},"excerpt":"<p>昨天开发中发现一个 Bug ：前端点击事件正常执行、后端也正常响应，但数据库中的字段没有发生预期的变化。</p>\n<p>原来是 jQuery 的点击事件存在重复绑定。</p>","more":"<p>若一个按钮多次绑定过点击事件，在点击时会触发其绑定的所有事件，而非最近一次绑定的事件。</p>\n<p>解决方法是先解绑事件，再绑定新的点击事件。</p>\n<pre><code class=\"js\">$(&#39;#example&#39;).unbind(&#39;click&#39;);</code></pre>\n<pre><code class=\"js\">$(&#39;#example&#39;).unbind(&#39;click&#39;).click(function(){\n    // 你的点击事件\n});</code></pre>"},{"title":"Linux 编译安装 MySQL5.6","date":"2016-12-15T07:31:58.000Z","_content":"\n第一步，安装依赖。包括编译工具和需要用到的库。\n\n```\nyum -y install make gcc-c++ cmake bison-devel  ncurses-devel perl-Module-Install.noarch\n```\n<!-- more -->\n\n第二步，从 [官网](http://www.mysql.com/) 下载并解压 MySQL 源码（Source Code）的压缩包。\n\n```\nwget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gz\ntar xvf mysql-5.6.35.tar.gz\ncd mysql-5.6.35\n```\n\n第三步，简单配置并编译安装 MySQL 。更多配置项可参阅官方文档。\n\n```\ncmake \\\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql5.6 \\\n-DMYSQL_DATADIR=/usr/local/mysql5.6/data \\\n-DMYSQL_UNIX_ADDR=/usr/local/mysql5.6/mysql.sock \\\n-DDEFAULT_CHARSET=utf8 \\\n-DDEFAULT_COLLATION=utf8_general_ci\nmake\nmake install\n```\n\n第四步，创建系统账户，然后赋予数据库文件存放目录的使用权限。`data` 目录的位置可以自行修改，但必须与配置 MySQL 时设置的 `DMYSQL_DATADIR` 一致。\n\n```\ngroupadd mysql\nuseradd -g mysql mysql\nchmod 755 /usr/local/mysql5.6/data\nchown –R mysql:mysql /usr/local/mysql5.6/data\n```\n\n第五步，执行 MySQL 的初始化脚本。这一步将创建一些必要的数据库和数据表。\n\n```\ncd /usr/local/mysql5.6\nscripts/mysql_install_db --basedir=/usr/local/mysql5.6 --datadir=/usr/local/mysql5.6/data --user=mysql\n```\n\n第六步，添加服务并设置开机运行，启动 MySQL 。\n\n```\ncp support-files/mysql.server /etc/init.d/mysql\nchkconfig mysql on\nservice mysql start\n```\n\n第七步，配置环境变量。使用编辑器编辑 /etc/profile ，在末尾添加以下内容，保存，然后执行 `source /etc/profile` 使设置立即生效。\n\n```\n# MySQL\nexport PATH=$PATH:/usr/local/mysql5.6/bin\n```\n\n第八步，执行 `mysql` 命令登录 MySQL 。\n\n相关环境：Aliyun ECS / CentOS 7 x64","source":"_posts/2016-12-15@Linux 编译安装 MySQL5.66.md","raw":"---\ntitle: Linux 编译安装 MySQL5.6\ncategories:\n  - Web Back-end\ndate: 2016-12-15 15:31:58\ntags:\n  - MySQL\n  - Linux\n---\n\n第一步，安装依赖。包括编译工具和需要用到的库。\n\n```\nyum -y install make gcc-c++ cmake bison-devel  ncurses-devel perl-Module-Install.noarch\n```\n<!-- more -->\n\n第二步，从 [官网](http://www.mysql.com/) 下载并解压 MySQL 源码（Source Code）的压缩包。\n\n```\nwget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gz\ntar xvf mysql-5.6.35.tar.gz\ncd mysql-5.6.35\n```\n\n第三步，简单配置并编译安装 MySQL 。更多配置项可参阅官方文档。\n\n```\ncmake \\\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql5.6 \\\n-DMYSQL_DATADIR=/usr/local/mysql5.6/data \\\n-DMYSQL_UNIX_ADDR=/usr/local/mysql5.6/mysql.sock \\\n-DDEFAULT_CHARSET=utf8 \\\n-DDEFAULT_COLLATION=utf8_general_ci\nmake\nmake install\n```\n\n第四步，创建系统账户，然后赋予数据库文件存放目录的使用权限。`data` 目录的位置可以自行修改，但必须与配置 MySQL 时设置的 `DMYSQL_DATADIR` 一致。\n\n```\ngroupadd mysql\nuseradd -g mysql mysql\nchmod 755 /usr/local/mysql5.6/data\nchown –R mysql:mysql /usr/local/mysql5.6/data\n```\n\n第五步，执行 MySQL 的初始化脚本。这一步将创建一些必要的数据库和数据表。\n\n```\ncd /usr/local/mysql5.6\nscripts/mysql_install_db --basedir=/usr/local/mysql5.6 --datadir=/usr/local/mysql5.6/data --user=mysql\n```\n\n第六步，添加服务并设置开机运行，启动 MySQL 。\n\n```\ncp support-files/mysql.server /etc/init.d/mysql\nchkconfig mysql on\nservice mysql start\n```\n\n第七步，配置环境变量。使用编辑器编辑 /etc/profile ，在末尾添加以下内容，保存，然后执行 `source /etc/profile` 使设置立即生效。\n\n```\n# MySQL\nexport PATH=$PATH:/usr/local/mysql5.6/bin\n```\n\n第八步，执行 `mysql` 命令登录 MySQL 。\n\n相关环境：Aliyun ECS / CentOS 7 x64","slug":"2016-12-15@Linux 编译安装 MySQL5.66","published":1,"updated":"2020-06-29T03:32:42.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt496006urqgjfx9674z0","content":"<p>第一步，安装依赖。包括编译工具和需要用到的库。</p>\n<pre><code>yum -y install make gcc-c++ cmake bison-devel  ncurses-devel perl-Module-Install.noarch</code></pre><a id=\"more\"></a>\n\n<p>第二步，从 <a href=\"http://www.mysql.com/\" target=\"_blank\" rel=\"noopener\">官网</a> 下载并解压 MySQL 源码（Source Code）的压缩包。</p>\n<pre><code>wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gz\ntar xvf mysql-5.6.35.tar.gz\ncd mysql-5.6.35</code></pre><p>第三步，简单配置并编译安装 MySQL 。更多配置项可参阅官方文档。</p>\n<pre><code>cmake \\\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql5.6 \\\n-DMYSQL_DATADIR=/usr/local/mysql5.6/data \\\n-DMYSQL_UNIX_ADDR=/usr/local/mysql5.6/mysql.sock \\\n-DDEFAULT_CHARSET=utf8 \\\n-DDEFAULT_COLLATION=utf8_general_ci\nmake\nmake install</code></pre><p>第四步，创建系统账户，然后赋予数据库文件存放目录的使用权限。<code>data</code> 目录的位置可以自行修改，但必须与配置 MySQL 时设置的 <code>DMYSQL_DATADIR</code> 一致。</p>\n<pre><code>groupadd mysql\nuseradd -g mysql mysql\nchmod 755 /usr/local/mysql5.6/data\nchown –R mysql:mysql /usr/local/mysql5.6/data</code></pre><p>第五步，执行 MySQL 的初始化脚本。这一步将创建一些必要的数据库和数据表。</p>\n<pre><code>cd /usr/local/mysql5.6\nscripts/mysql_install_db --basedir=/usr/local/mysql5.6 --datadir=/usr/local/mysql5.6/data --user=mysql</code></pre><p>第六步，添加服务并设置开机运行，启动 MySQL 。</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql\nchkconfig mysql on\nservice mysql start</code></pre><p>第七步，配置环境变量。使用编辑器编辑 /etc/profile ，在末尾添加以下内容，保存，然后执行 <code>source /etc/profile</code> 使设置立即生效。</p>\n<pre><code># MySQL\nexport PATH=$PATH:/usr/local/mysql5.6/bin</code></pre><p>第八步，执行 <code>mysql</code> 命令登录 MySQL 。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64</p>\n","site":{"data":{}},"excerpt":"<p>第一步，安装依赖。包括编译工具和需要用到的库。</p>\n<pre><code>yum -y install make gcc-c++ cmake bison-devel  ncurses-devel perl-Module-Install.noarch</code></pre>","more":"<p>第二步，从 <a href=\"http://www.mysql.com/\" target=\"_blank\" rel=\"noopener\">官网</a> 下载并解压 MySQL 源码（Source Code）的压缩包。</p>\n<pre><code>wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gz\ntar xvf mysql-5.6.35.tar.gz\ncd mysql-5.6.35</code></pre><p>第三步，简单配置并编译安装 MySQL 。更多配置项可参阅官方文档。</p>\n<pre><code>cmake \\\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql5.6 \\\n-DMYSQL_DATADIR=/usr/local/mysql5.6/data \\\n-DMYSQL_UNIX_ADDR=/usr/local/mysql5.6/mysql.sock \\\n-DDEFAULT_CHARSET=utf8 \\\n-DDEFAULT_COLLATION=utf8_general_ci\nmake\nmake install</code></pre><p>第四步，创建系统账户，然后赋予数据库文件存放目录的使用权限。<code>data</code> 目录的位置可以自行修改，但必须与配置 MySQL 时设置的 <code>DMYSQL_DATADIR</code> 一致。</p>\n<pre><code>groupadd mysql\nuseradd -g mysql mysql\nchmod 755 /usr/local/mysql5.6/data\nchown –R mysql:mysql /usr/local/mysql5.6/data</code></pre><p>第五步，执行 MySQL 的初始化脚本。这一步将创建一些必要的数据库和数据表。</p>\n<pre><code>cd /usr/local/mysql5.6\nscripts/mysql_install_db --basedir=/usr/local/mysql5.6 --datadir=/usr/local/mysql5.6/data --user=mysql</code></pre><p>第六步，添加服务并设置开机运行，启动 MySQL 。</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql\nchkconfig mysql on\nservice mysql start</code></pre><p>第七步，配置环境变量。使用编辑器编辑 /etc/profile ，在末尾添加以下内容，保存，然后执行 <code>source /etc/profile</code> 使设置立即生效。</p>\n<pre><code># MySQL\nexport PATH=$PATH:/usr/local/mysql5.6/bin</code></pre><p>第八步，执行 <code>mysql</code> 命令登录 MySQL 。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64</p>"},{"title":"Linux 编译安装 PHP7.1","date":"2016-12-15T08:02:21.000Z","_content":"\n第一步，安装相关依赖。\n\n```\nyum install –y gcc gcc++ libxml2-devel perl\n```\n<!-- more -->\n\n第二步，添加 PHP 支持。如果你使用的是 Apache 引擎，稍后编译 PHP 时需要加一个 `--with-apxs2` 参数使 Apache 添加 PHP 支持（依赖Perl），编辑 Apache 目录下的 `/bin/apxs\n` 文件，找到 `#!/replace/with/path/to/perl/interpreter –w` 修改成 `#!/usr/bin/perl -w` ，即 Perl 的安装路径。\n\n第三步，下载并解压 Tar 包。\n\n```\nwget http://cn2.php.net/get/php-7.1.0.tar.gz/from/this/mirror \ntar xvf mirror\ncd php-7.1.0\n```\n\n第四步，编译安装 PHP7.1 。\n\n```\n./configure --prefix=/usr/local/php7.1 --enable-fpm --with-apxs2=/usr/local/apache2.4/bin/apxs --enable-mysqlnd --with-pdo-mysql=mysqlnd --disable-fileinfo \nmake\nmake install\n```\n\n`-disable-fileinfo` 参数并不是必要的。如果服务器内存不大（一般认为小于1G），并且在编译时报错，加上该参数可能会解决问题。\n\n第五步，添加配置文件。拷贝一份 php.ini-production 到 /usr/local/php7.1/lib/ 目录下，并将文件名修改为 php.ini ，该文件将作为 PHP 的配置文件。路径必须与安装时配置的一致，即 PHP 安装目录下的 lib 目录。虽然无需这一步 PHP 也可以正常使用，但考虑后续总会用到配置文件，最好在安装时就拷贝。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4","source":"_posts/2016-12-15@Linux 编译安装 PHP7.1.md","raw":"---\ntitle: Linux 编译安装 PHP7.1\ncategories:\n  - Web Back-end\ndate: 2016-12-15 16:02:21\ntags:\n  - PHP\n  - Linux\n---\n\n第一步，安装相关依赖。\n\n```\nyum install –y gcc gcc++ libxml2-devel perl\n```\n<!-- more -->\n\n第二步，添加 PHP 支持。如果你使用的是 Apache 引擎，稍后编译 PHP 时需要加一个 `--with-apxs2` 参数使 Apache 添加 PHP 支持（依赖Perl），编辑 Apache 目录下的 `/bin/apxs\n` 文件，找到 `#!/replace/with/path/to/perl/interpreter –w` 修改成 `#!/usr/bin/perl -w` ，即 Perl 的安装路径。\n\n第三步，下载并解压 Tar 包。\n\n```\nwget http://cn2.php.net/get/php-7.1.0.tar.gz/from/this/mirror \ntar xvf mirror\ncd php-7.1.0\n```\n\n第四步，编译安装 PHP7.1 。\n\n```\n./configure --prefix=/usr/local/php7.1 --enable-fpm --with-apxs2=/usr/local/apache2.4/bin/apxs --enable-mysqlnd --with-pdo-mysql=mysqlnd --disable-fileinfo \nmake\nmake install\n```\n\n`-disable-fileinfo` 参数并不是必要的。如果服务器内存不大（一般认为小于1G），并且在编译时报错，加上该参数可能会解决问题。\n\n第五步，添加配置文件。拷贝一份 php.ini-production 到 /usr/local/php7.1/lib/ 目录下，并将文件名修改为 php.ini ，该文件将作为 PHP 的配置文件。路径必须与安装时配置的一致，即 PHP 安装目录下的 lib 目录。虽然无需这一步 PHP 也可以正常使用，但考虑后续总会用到配置文件，最好在安装时就拷贝。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4","slug":"2016-12-15@Linux 编译安装 PHP7.1","published":1,"updated":"2020-06-29T03:32:42.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt496006yrqgj56muc8om","content":"<p>第一步，安装相关依赖。</p>\n<pre><code>yum install –y gcc gcc++ libxml2-devel perl</code></pre><a id=\"more\"></a>\n\n<p>第二步，添加 PHP 支持。如果你使用的是 Apache 引擎，稍后编译 PHP 时需要加一个 <code>--with-apxs2</code> 参数使 Apache 添加 PHP 支持（依赖Perl），编辑 Apache 目录下的 <code>/bin/apxs</code> 文件，找到 <code>#!/replace/with/path/to/perl/interpreter –w</code> 修改成 <code>#!/usr/bin/perl -w</code> ，即 Perl 的安装路径。</p>\n<p>第三步，下载并解压 Tar 包。</p>\n<pre><code>wget http://cn2.php.net/get/php-7.1.0.tar.gz/from/this/mirror \ntar xvf mirror\ncd php-7.1.0</code></pre><p>第四步，编译安装 PHP7.1 。</p>\n<pre><code>./configure --prefix=/usr/local/php7.1 --enable-fpm --with-apxs2=/usr/local/apache2.4/bin/apxs --enable-mysqlnd --with-pdo-mysql=mysqlnd --disable-fileinfo \nmake\nmake install</code></pre><p><code>-disable-fileinfo</code> 参数并不是必要的。如果服务器内存不大（一般认为小于1G），并且在编译时报错，加上该参数可能会解决问题。</p>\n<p>第五步，添加配置文件。拷贝一份 php.ini-production 到 /usr/local/php7.1/lib/ 目录下，并将文件名修改为 php.ini ，该文件将作为 PHP 的配置文件。路径必须与安装时配置的一致，即 PHP 安装目录下的 lib 目录。虽然无需这一步 PHP 也可以正常使用，但考虑后续总会用到配置文件，最好在安装时就拷贝。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4</p>\n","site":{"data":{}},"excerpt":"<p>第一步，安装相关依赖。</p>\n<pre><code>yum install –y gcc gcc++ libxml2-devel perl</code></pre>","more":"<p>第二步，添加 PHP 支持。如果你使用的是 Apache 引擎，稍后编译 PHP 时需要加一个 <code>--with-apxs2</code> 参数使 Apache 添加 PHP 支持（依赖Perl），编辑 Apache 目录下的 <code>/bin/apxs</code> 文件，找到 <code>#!/replace/with/path/to/perl/interpreter –w</code> 修改成 <code>#!/usr/bin/perl -w</code> ，即 Perl 的安装路径。</p>\n<p>第三步，下载并解压 Tar 包。</p>\n<pre><code>wget http://cn2.php.net/get/php-7.1.0.tar.gz/from/this/mirror \ntar xvf mirror\ncd php-7.1.0</code></pre><p>第四步，编译安装 PHP7.1 。</p>\n<pre><code>./configure --prefix=/usr/local/php7.1 --enable-fpm --with-apxs2=/usr/local/apache2.4/bin/apxs --enable-mysqlnd --with-pdo-mysql=mysqlnd --disable-fileinfo \nmake\nmake install</code></pre><p><code>-disable-fileinfo</code> 参数并不是必要的。如果服务器内存不大（一般认为小于1G），并且在编译时报错，加上该参数可能会解决问题。</p>\n<p>第五步，添加配置文件。拷贝一份 php.ini-production 到 /usr/local/php7.1/lib/ 目录下，并将文件名修改为 php.ini ，该文件将作为 PHP 的配置文件。路径必须与安装时配置的一致，即 PHP 安装目录下的 lib 目录。虽然无需这一步 PHP 也可以正常使用，但考虑后续总会用到配置文件，最好在安装时就拷贝。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4</p>"},{"title":"Apache 禁止使用 IP 访问网站","date":"2016-12-18T15:14:45.000Z","_content":"\nApache 默认允许使用服务器的 IP 地址访问网站。不过，无论是出于用户体验还是安全性考虑，禁止使用 IP 访问网站都是很有必要的。对我这个处女座来讲，能用 IP 访问自己写的网站是不能忍的。使用 Apache 的虚拟主机配置就可以实现禁止使用 IP 访问网站。\n\n<!-- more -->\n\n第一步，启用虚拟主机配置文件。编辑 /conf/httpd.conf ，去掉 `# Include conf/extra/httpd-vhosts.conf` 前面的 # 号。\n\n第二步，禁止使用 IP 访问网站。编辑 /conf/extra/httpd-vhosts.conf  ，添加以下内容，注意将 127.0.0.1 修改为你的服务器的 IP 地址。这一步将无条件禁止使用 IP 地址访问。\n\n```\n<VirtualHost *:80>\n  ServerName 127.0.0.1\n  <Location />\n    Order Allow,Deny\n    Deny from all\n  </Location>\n</VirtualHost>\n```\n\n第三步，允许用域名访问网站。仍然编辑 httpd-vhosts.conf 文件，添加以下内容，ServerName 填写网站域名，DocumentRoot 填写网站的根目录。\n\n```\n<VirtualHost *:80>\n  DocumentRoot \"/usr/local/apache/htdocs\"\n  ServerName www.example.com\n</VirtualHost>\n```\n\n现在，使用 IP 访问将提示 Forbidden，使用域名访问将正常显示根目录下的主页。如果觉得前者不够友好，你也可以将 IP 的访问指向一个目录，显示一个友好的错误页面。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4","source":"_posts/2016-12-18@Apache 禁止使用 IP 访问网站.md","raw":"---\ntitle: Apache 禁止使用 IP 访问网站\ncategories:\n  - Web Back-end\ndate: 2016-12-18 23:14:45\ntags:\n  - Apache\n---\n\nApache 默认允许使用服务器的 IP 地址访问网站。不过，无论是出于用户体验还是安全性考虑，禁止使用 IP 访问网站都是很有必要的。对我这个处女座来讲，能用 IP 访问自己写的网站是不能忍的。使用 Apache 的虚拟主机配置就可以实现禁止使用 IP 访问网站。\n\n<!-- more -->\n\n第一步，启用虚拟主机配置文件。编辑 /conf/httpd.conf ，去掉 `# Include conf/extra/httpd-vhosts.conf` 前面的 # 号。\n\n第二步，禁止使用 IP 访问网站。编辑 /conf/extra/httpd-vhosts.conf  ，添加以下内容，注意将 127.0.0.1 修改为你的服务器的 IP 地址。这一步将无条件禁止使用 IP 地址访问。\n\n```\n<VirtualHost *:80>\n  ServerName 127.0.0.1\n  <Location />\n    Order Allow,Deny\n    Deny from all\n  </Location>\n</VirtualHost>\n```\n\n第三步，允许用域名访问网站。仍然编辑 httpd-vhosts.conf 文件，添加以下内容，ServerName 填写网站域名，DocumentRoot 填写网站的根目录。\n\n```\n<VirtualHost *:80>\n  DocumentRoot \"/usr/local/apache/htdocs\"\n  ServerName www.example.com\n</VirtualHost>\n```\n\n现在，使用 IP 访问将提示 Forbidden，使用域名访问将正常显示根目录下的主页。如果觉得前者不够友好，你也可以将 IP 的访问指向一个目录，显示一个友好的错误页面。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4","slug":"2016-12-18@Apache 禁止使用 IP 访问网站","published":1,"updated":"2020-06-29T03:32:42.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4970071rqgj0a9q867l","content":"<p>Apache 默认允许使用服务器的 IP 地址访问网站。不过，无论是出于用户体验还是安全性考虑，禁止使用 IP 访问网站都是很有必要的。对我这个处女座来讲，能用 IP 访问自己写的网站是不能忍的。使用 Apache 的虚拟主机配置就可以实现禁止使用 IP 访问网站。</p>\n<a id=\"more\"></a>\n\n<p>第一步，启用虚拟主机配置文件。编辑 /conf/httpd.conf ，去掉 <code># Include conf/extra/httpd-vhosts.conf</code> 前面的 # 号。</p>\n<p>第二步，禁止使用 IP 访问网站。编辑 /conf/extra/httpd-vhosts.conf  ，添加以下内容，注意将 127.0.0.1 修改为你的服务器的 IP 地址。这一步将无条件禁止使用 IP 地址访问。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  ServerName 127.0.0.1\n  &lt;Location /&gt;\n    Order Allow,Deny\n    Deny from all\n  &lt;/Location&gt;\n&lt;/VirtualHost&gt;</code></pre><p>第三步，允许用域名访问网站。仍然编辑 httpd-vhosts.conf 文件，添加以下内容，ServerName 填写网站域名，DocumentRoot 填写网站的根目录。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  DocumentRoot &quot;/usr/local/apache/htdocs&quot;\n  ServerName www.example.com\n&lt;/VirtualHost&gt;</code></pre><p>现在，使用 IP 访问将提示 Forbidden，使用域名访问将正常显示根目录下的主页。如果觉得前者不够友好，你也可以将 IP 的访问指向一个目录，显示一个友好的错误页面。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4</p>\n","site":{"data":{}},"excerpt":"<p>Apache 默认允许使用服务器的 IP 地址访问网站。不过，无论是出于用户体验还是安全性考虑，禁止使用 IP 访问网站都是很有必要的。对我这个处女座来讲，能用 IP 访问自己写的网站是不能忍的。使用 Apache 的虚拟主机配置就可以实现禁止使用 IP 访问网站。</p>","more":"<p>第一步，启用虚拟主机配置文件。编辑 /conf/httpd.conf ，去掉 <code># Include conf/extra/httpd-vhosts.conf</code> 前面的 # 号。</p>\n<p>第二步，禁止使用 IP 访问网站。编辑 /conf/extra/httpd-vhosts.conf  ，添加以下内容，注意将 127.0.0.1 修改为你的服务器的 IP 地址。这一步将无条件禁止使用 IP 地址访问。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  ServerName 127.0.0.1\n  &lt;Location /&gt;\n    Order Allow,Deny\n    Deny from all\n  &lt;/Location&gt;\n&lt;/VirtualHost&gt;</code></pre><p>第三步，允许用域名访问网站。仍然编辑 httpd-vhosts.conf 文件，添加以下内容，ServerName 填写网站域名，DocumentRoot 填写网站的根目录。</p>\n<pre><code>&lt;VirtualHost *:80&gt;\n  DocumentRoot &quot;/usr/local/apache/htdocs&quot;\n  ServerName www.example.com\n&lt;/VirtualHost&gt;</code></pre><p>现在，使用 IP 访问将提示 Forbidden，使用域名访问将正常显示根目录下的主页。如果觉得前者不够友好，你也可以将 IP 的访问指向一个目录，显示一个友好的错误页面。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4</p>"},{"title":"编译安装 PHP 拓展","date":"2016-12-20T15:27:09.000Z","_content":"\n在使用 PHP 的过程中可能用到各种拓展，包括 mbstring 等。我们可以按需安装拓展，这里以 mbstring 为例演示如何编译安装拓展。\n\n第一步，确认已安装必要依赖。\n\n<!-- more -->\n\n```\nyum install -y m4 autoconf\n```\n\n第二步，编译安装 mbstring 拓展。进入 PHP 源码下的 ext/mbstring 目录，使用 phpize 编译拓展。注意第二行的路径指向的是已安装好的 PHP 目录下的 bin 文件夹中的 phpize 文件。\n\n```\ncd ~/php-7.1.0/ext/mbstring\n/usr/local/php7.1/bin/phpize\n./configure -with-php-config=/usr/local/php7.1/bin/php-config\nmake\nmake install\n```\n\n看到以下提示说明拓展安装成功，Linux 可在拓展目录下找到新增的 mbstring.so 文件。\n\n```\nInstalling shared extensions:     /usr/local/php7.1/lib/php/extensions/no-debug-zts-20160303/\nInstalling header files:           /usr/local/php7.1/include/php/\n```\n\n第三步，编辑 php.ini ，启用相应的拓展，重启 Apache 。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / PHP 7.1","source":"_posts/2016-12-20@编译安装 PHP 拓展.md","raw":"---\ntitle: 编译安装 PHP 拓展\ncategories:\n  - Web Back-end\ndate: 2016-12-20 23:27:09\ntags:\n  - PHP\n---\n\n在使用 PHP 的过程中可能用到各种拓展，包括 mbstring 等。我们可以按需安装拓展，这里以 mbstring 为例演示如何编译安装拓展。\n\n第一步，确认已安装必要依赖。\n\n<!-- more -->\n\n```\nyum install -y m4 autoconf\n```\n\n第二步，编译安装 mbstring 拓展。进入 PHP 源码下的 ext/mbstring 目录，使用 phpize 编译拓展。注意第二行的路径指向的是已安装好的 PHP 目录下的 bin 文件夹中的 phpize 文件。\n\n```\ncd ~/php-7.1.0/ext/mbstring\n/usr/local/php7.1/bin/phpize\n./configure -with-php-config=/usr/local/php7.1/bin/php-config\nmake\nmake install\n```\n\n看到以下提示说明拓展安装成功，Linux 可在拓展目录下找到新增的 mbstring.so 文件。\n\n```\nInstalling shared extensions:     /usr/local/php7.1/lib/php/extensions/no-debug-zts-20160303/\nInstalling header files:           /usr/local/php7.1/include/php/\n```\n\n第三步，编辑 php.ini ，启用相应的拓展，重启 Apache 。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / PHP 7.1","slug":"2016-12-20@编译安装 PHP 拓展","published":1,"updated":"2020-06-29T03:32:42.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49b0074rqgj7ohn11g9","content":"<p>在使用 PHP 的过程中可能用到各种拓展，包括 mbstring 等。我们可以按需安装拓展，这里以 mbstring 为例演示如何编译安装拓展。</p>\n<p>第一步，确认已安装必要依赖。</p>\n<a id=\"more\"></a>\n\n<pre><code>yum install -y m4 autoconf</code></pre><p>第二步，编译安装 mbstring 拓展。进入 PHP 源码下的 ext/mbstring 目录，使用 phpize 编译拓展。注意第二行的路径指向的是已安装好的 PHP 目录下的 bin 文件夹中的 phpize 文件。</p>\n<pre><code>cd ~/php-7.1.0/ext/mbstring\n/usr/local/php7.1/bin/phpize\n./configure -with-php-config=/usr/local/php7.1/bin/php-config\nmake\nmake install</code></pre><p>看到以下提示说明拓展安装成功，Linux 可在拓展目录下找到新增的 mbstring.so 文件。</p>\n<pre><code>Installing shared extensions:     /usr/local/php7.1/lib/php/extensions/no-debug-zts-20160303/\nInstalling header files:           /usr/local/php7.1/include/php/</code></pre><p>第三步，编辑 php.ini ，启用相应的拓展，重启 Apache 。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / PHP 7.1</p>\n","site":{"data":{}},"excerpt":"<p>在使用 PHP 的过程中可能用到各种拓展，包括 mbstring 等。我们可以按需安装拓展，这里以 mbstring 为例演示如何编译安装拓展。</p>\n<p>第一步，确认已安装必要依赖。</p>","more":"<pre><code>yum install -y m4 autoconf</code></pre><p>第二步，编译安装 mbstring 拓展。进入 PHP 源码下的 ext/mbstring 目录，使用 phpize 编译拓展。注意第二行的路径指向的是已安装好的 PHP 目录下的 bin 文件夹中的 phpize 文件。</p>\n<pre><code>cd ~/php-7.1.0/ext/mbstring\n/usr/local/php7.1/bin/phpize\n./configure -with-php-config=/usr/local/php7.1/bin/php-config\nmake\nmake install</code></pre><p>看到以下提示说明拓展安装成功，Linux 可在拓展目录下找到新增的 mbstring.so 文件。</p>\n<pre><code>Installing shared extensions:     /usr/local/php7.1/lib/php/extensions/no-debug-zts-20160303/\nInstalling header files:           /usr/local/php7.1/include/php/</code></pre><p>第三步，编辑 php.ini ，启用相应的拓展，重启 Apache 。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / PHP 7.1</p>"},{"title":"解决无法用 localhost 连接 MySQL","date":"2016-12-22T16:17:27.000Z","_content":"\n今天尝试往云主机上迁移博客，遇到不少麻烦，其中就包括无法用 localhost 连接 MySQL 。用了一个晚上才得以解决，记录一下解决过程。\n\n第一步，检查 `/etc/hosts` 文件。确认 localhost 已映射到 127.0.0.1 ，否则添加正确的映射。经检查，确定 hosts 设置没有问题。\n\n<!-- more -->\n\n```\n127.0.0.1    localhost\n```\n\n第二步，尝试直接用 `mysql`命令登录。登录时指定主机为 localhost 。若无法登录，检查 MySQL 中的用户权限等设置。经测试，命令行可以登录，只是用 PHP 无法连接，基本锁定是 PHP 相关设置问题。\n\n```\nmysql -uusername -hlocalhost -ppassword\n```\n\n第三步，由于使用 localhost 和 127.0.0.1 连接数据库的机制不同，前者因使用 socket 而需要保证 .sock 文件路径配置正确。我的 php.ini 文件中设置的 socket 文件路径为空，这就是问题所在。编辑 php.ini 文件，根据使用的数据库连接拓展修改相应的设置，指向的 .sock 文件的路径应该和编译安装 MySQL 时设置的一致。\n\n```\nmysql.default_socket     = /usr/local/mysql5.6/mysql.sock\nmysqli.default_socket    = /usr/local/mysql5.6/mysql.sock\npdo_mysql.default_socket = /usr/local/mysql5.6/mysql.sock\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / MySQL 5.6 / PHP 7.1\n\n ","source":"_posts/2016-12-23@解决无法用 localhost 连接 MySQL.md","raw":"---\ntitle: 解决无法用 localhost 连接 MySQL\ncategories:\n  - Web Back-end\ndate: 2016-12-23 00:17:27\ntags:\n  - MySQL\n  - PHP\n---\n\n今天尝试往云主机上迁移博客，遇到不少麻烦，其中就包括无法用 localhost 连接 MySQL 。用了一个晚上才得以解决，记录一下解决过程。\n\n第一步，检查 `/etc/hosts` 文件。确认 localhost 已映射到 127.0.0.1 ，否则添加正确的映射。经检查，确定 hosts 设置没有问题。\n\n<!-- more -->\n\n```\n127.0.0.1    localhost\n```\n\n第二步，尝试直接用 `mysql`命令登录。登录时指定主机为 localhost 。若无法登录，检查 MySQL 中的用户权限等设置。经测试，命令行可以登录，只是用 PHP 无法连接，基本锁定是 PHP 相关设置问题。\n\n```\nmysql -uusername -hlocalhost -ppassword\n```\n\n第三步，由于使用 localhost 和 127.0.0.1 连接数据库的机制不同，前者因使用 socket 而需要保证 .sock 文件路径配置正确。我的 php.ini 文件中设置的 socket 文件路径为空，这就是问题所在。编辑 php.ini 文件，根据使用的数据库连接拓展修改相应的设置，指向的 .sock 文件的路径应该和编译安装 MySQL 时设置的一致。\n\n```\nmysql.default_socket     = /usr/local/mysql5.6/mysql.sock\nmysqli.default_socket    = /usr/local/mysql5.6/mysql.sock\npdo_mysql.default_socket = /usr/local/mysql5.6/mysql.sock\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / MySQL 5.6 / PHP 7.1\n\n ","slug":"2016-12-23@解决无法用 localhost 连接 MySQL","published":1,"updated":"2020-06-29T03:32:42.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49c0078rqgjgf0p3mz6","content":"<p>今天尝试往云主机上迁移博客，遇到不少麻烦，其中就包括无法用 localhost 连接 MySQL 。用了一个晚上才得以解决，记录一下解决过程。</p>\n<p>第一步，检查 <code>/etc/hosts</code> 文件。确认 localhost 已映射到 127.0.0.1 ，否则添加正确的映射。经检查，确定 hosts 设置没有问题。</p>\n<a id=\"more\"></a>\n\n<pre><code>127.0.0.1    localhost</code></pre><p>第二步，尝试直接用 <code>mysql</code>命令登录。登录时指定主机为 localhost 。若无法登录，检查 MySQL 中的用户权限等设置。经测试，命令行可以登录，只是用 PHP 无法连接，基本锁定是 PHP 相关设置问题。</p>\n<pre><code>mysql -uusername -hlocalhost -ppassword</code></pre><p>第三步，由于使用 localhost 和 127.0.0.1 连接数据库的机制不同，前者因使用 socket 而需要保证 .sock 文件路径配置正确。我的 php.ini 文件中设置的 socket 文件路径为空，这就是问题所在。编辑 php.ini 文件，根据使用的数据库连接拓展修改相应的设置，指向的 .sock 文件的路径应该和编译安装 MySQL 时设置的一致。</p>\n<pre><code>mysql.default_socket     = /usr/local/mysql5.6/mysql.sock\nmysqli.default_socket    = /usr/local/mysql5.6/mysql.sock\npdo_mysql.default_socket = /usr/local/mysql5.6/mysql.sock</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / MySQL 5.6 / PHP 7.1</p>\n","site":{"data":{}},"excerpt":"<p>今天尝试往云主机上迁移博客，遇到不少麻烦，其中就包括无法用 localhost 连接 MySQL 。用了一个晚上才得以解决，记录一下解决过程。</p>\n<p>第一步，检查 <code>/etc/hosts</code> 文件。确认 localhost 已映射到 127.0.0.1 ，否则添加正确的映射。经检查，确定 hosts 设置没有问题。</p>","more":"<pre><code>127.0.0.1    localhost</code></pre><p>第二步，尝试直接用 <code>mysql</code>命令登录。登录时指定主机为 localhost 。若无法登录，检查 MySQL 中的用户权限等设置。经测试，命令行可以登录，只是用 PHP 无法连接，基本锁定是 PHP 相关设置问题。</p>\n<pre><code>mysql -uusername -hlocalhost -ppassword</code></pre><p>第三步，由于使用 localhost 和 127.0.0.1 连接数据库的机制不同，前者因使用 socket 而需要保证 .sock 文件路径配置正确。我的 php.ini 文件中设置的 socket 文件路径为空，这就是问题所在。编辑 php.ini 文件，根据使用的数据库连接拓展修改相应的设置，指向的 .sock 文件的路径应该和编译安装 MySQL 时设置的一致。</p>\n<pre><code>mysql.default_socket     = /usr/local/mysql5.6/mysql.sock\nmysqli.default_socket    = /usr/local/mysql5.6/mysql.sock\npdo_mysql.default_socket = /usr/local/mysql5.6/mysql.sock</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Apache 2.4 / MySQL 5.6 / PHP 7.1</p>"},{"title":"使 Nginx 支持 WordPress 固定链接","date":"2016-12-29T05:29:12.000Z","_content":"\n昨天把博客从虚拟主机迁移到了云主机，同时也将引擎由 Apache 更换成了 Nginx 。迁移过程基本顺利，仅出现 WordPress 的“固定链接”功能无法正常使用，导致文章不能正常浏览。\n\n<!-- more -->\n\n在阅读官方文档后，问题已解决。编辑当前站点的 .conf 文件，在 `server` 内添加以下内容，然后重启 Web 服务即可。\n\n```\nlocation / {\n  try_files $uri $uri/ /index.php?$args;\n}\n```\n\n附 WordPress 提供的 Nginx 配置示例。\n\n```\nserver {\n  ## Your website name goes here.\n  server_name domain.tld;\n  ## Your only path reference.\n  root /var/www/wordpress;\n  ## This should be in your http block and if it is, it's not needed here.\n  index index.php;\n\n  location = /favicon.ico {\n    log_not_found off;\n    access_log off;\n  }\n\n  location = /robots.txt {\n    allow all;\n    log_not_found off;\n    access_log off;\n  }\n\n  location / {\n    # This is cool because no php is touched for static content.\n    # include the \"?$args\" part so non-default permalinks doesn't break when using query string\n    try_files $uri $uri/ /index.php?$args;\n  }\n\n  location ~ \\.php$ {\n    #NOTE: You should have \"cgi.fix_pathinfo = 0;\" in php.ini\n    include fastcgi.conf;\n    fastcgi_intercept_errors on;\n    fastcgi_pass php;\n  }\n\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n}\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7","source":"_posts/2016-12-29@使 Nginx 支持 WordPress 固定链接.md","raw":"---\ntitle: 使 Nginx 支持 WordPress 固定链接\ncategories:\n  - Other\ndate: 2016-12-29 13:29:12\ntags:\n  - WordPress\n  - Nginx\n---\n\n昨天把博客从虚拟主机迁移到了云主机，同时也将引擎由 Apache 更换成了 Nginx 。迁移过程基本顺利，仅出现 WordPress 的“固定链接”功能无法正常使用，导致文章不能正常浏览。\n\n<!-- more -->\n\n在阅读官方文档后，问题已解决。编辑当前站点的 .conf 文件，在 `server` 内添加以下内容，然后重启 Web 服务即可。\n\n```\nlocation / {\n  try_files $uri $uri/ /index.php?$args;\n}\n```\n\n附 WordPress 提供的 Nginx 配置示例。\n\n```\nserver {\n  ## Your website name goes here.\n  server_name domain.tld;\n  ## Your only path reference.\n  root /var/www/wordpress;\n  ## This should be in your http block and if it is, it's not needed here.\n  index index.php;\n\n  location = /favicon.ico {\n    log_not_found off;\n    access_log off;\n  }\n\n  location = /robots.txt {\n    allow all;\n    log_not_found off;\n    access_log off;\n  }\n\n  location / {\n    # This is cool because no php is touched for static content.\n    # include the \"?$args\" part so non-default permalinks doesn't break when using query string\n    try_files $uri $uri/ /index.php?$args;\n  }\n\n  location ~ \\.php$ {\n    #NOTE: You should have \"cgi.fix_pathinfo = 0;\" in php.ini\n    include fastcgi.conf;\n    fastcgi_intercept_errors on;\n    fastcgi_pass php;\n  }\n\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n}\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7","slug":"2016-12-29@使 Nginx 支持 WordPress 固定链接","published":1,"updated":"2020-06-29T03:32:42.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49d007brqgjcgvr50bc","content":"<p>昨天把博客从虚拟主机迁移到了云主机，同时也将引擎由 Apache 更换成了 Nginx 。迁移过程基本顺利，仅出现 WordPress 的“固定链接”功能无法正常使用，导致文章不能正常浏览。</p>\n<a id=\"more\"></a>\n\n<p>在阅读官方文档后，问题已解决。编辑当前站点的 .conf 文件，在 <code>server</code> 内添加以下内容，然后重启 Web 服务即可。</p>\n<pre><code>location / {\n  try_files $uri $uri/ /index.php?$args;\n}</code></pre><p>附 WordPress 提供的 Nginx 配置示例。</p>\n<pre><code>server {\n  ## Your website name goes here.\n  server_name domain.tld;\n  ## Your only path reference.\n  root /var/www/wordpress;\n  ## This should be in your http block and if it is, it&#39;s not needed here.\n  index index.php;\n\n  location = /favicon.ico {\n    log_not_found off;\n    access_log off;\n  }\n\n  location = /robots.txt {\n    allow all;\n    log_not_found off;\n    access_log off;\n  }\n\n  location / {\n    # This is cool because no php is touched for static content.\n    # include the &quot;?$args&quot; part so non-default permalinks doesn&#39;t break when using query string\n    try_files $uri $uri/ /index.php?$args;\n  }\n\n  location ~ \\.php$ {\n    #NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini\n    include fastcgi.conf;\n    fastcgi_intercept_errors on;\n    fastcgi_pass php;\n  }\n\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n}</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7</p>\n","site":{"data":{}},"excerpt":"<p>昨天把博客从虚拟主机迁移到了云主机，同时也将引擎由 Apache 更换成了 Nginx 。迁移过程基本顺利，仅出现 WordPress 的“固定链接”功能无法正常使用，导致文章不能正常浏览。</p>","more":"<p>在阅读官方文档后，问题已解决。编辑当前站点的 .conf 文件，在 <code>server</code> 内添加以下内容，然后重启 Web 服务即可。</p>\n<pre><code>location / {\n  try_files $uri $uri/ /index.php?$args;\n}</code></pre><p>附 WordPress 提供的 Nginx 配置示例。</p>\n<pre><code>server {\n  ## Your website name goes here.\n  server_name domain.tld;\n  ## Your only path reference.\n  root /var/www/wordpress;\n  ## This should be in your http block and if it is, it&#39;s not needed here.\n  index index.php;\n\n  location = /favicon.ico {\n    log_not_found off;\n    access_log off;\n  }\n\n  location = /robots.txt {\n    allow all;\n    log_not_found off;\n    access_log off;\n  }\n\n  location / {\n    # This is cool because no php is touched for static content.\n    # include the &quot;?$args&quot; part so non-default permalinks doesn&#39;t break when using query string\n    try_files $uri $uri/ /index.php?$args;\n  }\n\n  location ~ \\.php$ {\n    #NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini\n    include fastcgi.conf;\n    fastcgi_intercept_errors on;\n    fastcgi_pass php;\n  }\n\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n}</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7</p>"},{"title":"生成与管理 SSH Key","date":"2017-01-23T14:04:38.000Z","_content":"\n在使用 Git 的过程中经常需要用到 SSH Key 进行身份验证，即一组公钥、私钥文件，避免每次 Push 代码都需要输入密码。通常将公钥提供给 Github/OSChina 等代码托管平台，之后在使用 Git 提交代码时便会自动将云端的公钥与本地的私钥进行比对。无论是 Windows 还是 Linux 系统，SSH Key 都存放在 `~\\.ssh` 目录下。\n\n<!-- more -->\n\n生成一组 SSH Key 只需：\n\n``` sh\nssh-keygen -t rsa -C \"email@example.com\"\n```\n\n系统将提示你设置一个密码，可以直接回车跳过。如果给 SSH Key 设置了密码，通过 SSH 通讯时仍需输入此密码。\n\n现在，`~\\.ssh` 目录下应该已存在 id_rsa 和 id_rsa.pub 两个文件，使用以下命令可以查看公钥。\n\n``` sh\ncat ~/.ssh/id_rsa.pub\n```\n如果你拥有多组 SSH Key ，分别用于不同的代码托管平台，那么需要在 ~/.ssh 录下创建一个名为 config 的配置文件，使Git在通讯时根据服务器域名判断使用哪一个密钥。\n\n```\nHost github.com\n  HostName github.com\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_github\n\nHost git.oschina.net\n  HostName git.oschina.net\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_oschina\n```","source":"_posts/2017-01-23@生成与管理 SSH Key.md","raw":"---\ntitle: 生成与管理 SSH Key\ncategories:\n  - Other\ndate: 2017-01-23 22:04:38\ntags:\n  - Git\n  - SSH\n---\n\n在使用 Git 的过程中经常需要用到 SSH Key 进行身份验证，即一组公钥、私钥文件，避免每次 Push 代码都需要输入密码。通常将公钥提供给 Github/OSChina 等代码托管平台，之后在使用 Git 提交代码时便会自动将云端的公钥与本地的私钥进行比对。无论是 Windows 还是 Linux 系统，SSH Key 都存放在 `~\\.ssh` 目录下。\n\n<!-- more -->\n\n生成一组 SSH Key 只需：\n\n``` sh\nssh-keygen -t rsa -C \"email@example.com\"\n```\n\n系统将提示你设置一个密码，可以直接回车跳过。如果给 SSH Key 设置了密码，通过 SSH 通讯时仍需输入此密码。\n\n现在，`~\\.ssh` 目录下应该已存在 id_rsa 和 id_rsa.pub 两个文件，使用以下命令可以查看公钥。\n\n``` sh\ncat ~/.ssh/id_rsa.pub\n```\n如果你拥有多组 SSH Key ，分别用于不同的代码托管平台，那么需要在 ~/.ssh 录下创建一个名为 config 的配置文件，使Git在通讯时根据服务器域名判断使用哪一个密钥。\n\n```\nHost github.com\n  HostName github.com\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_github\n\nHost git.oschina.net\n  HostName git.oschina.net\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_oschina\n```","slug":"2017-01-23@生成与管理 SSH Key","published":1,"updated":"2020-06-29T03:32:42.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49e007frqgj25d4gpfb","content":"<p>在使用 Git 的过程中经常需要用到 SSH Key 进行身份验证，即一组公钥、私钥文件，避免每次 Push 代码都需要输入密码。通常将公钥提供给 Github/OSChina 等代码托管平台，之后在使用 Git 提交代码时便会自动将云端的公钥与本地的私钥进行比对。无论是 Windows 还是 Linux 系统，SSH Key 都存放在 <code>~\\.ssh</code> 目录下。</p>\n<a id=\"more\"></a>\n\n<p>生成一组 SSH Key 只需：</p>\n<pre><code class=\"sh\">ssh-keygen -t rsa -C &quot;email@example.com&quot;</code></pre>\n<p>系统将提示你设置一个密码，可以直接回车跳过。如果给 SSH Key 设置了密码，通过 SSH 通讯时仍需输入此密码。</p>\n<p>现在，<code>~\\.ssh</code> 目录下应该已存在 id_rsa 和 id_rsa.pub 两个文件，使用以下命令可以查看公钥。</p>\n<pre><code class=\"sh\">cat ~/.ssh/id_rsa.pub</code></pre>\n<p>如果你拥有多组 SSH Key ，分别用于不同的代码托管平台，那么需要在 ~/.ssh 录下创建一个名为 config 的配置文件，使Git在通讯时根据服务器域名判断使用哪一个密钥。</p>\n<pre><code>Host github.com\n  HostName github.com\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_github\n\nHost git.oschina.net\n  HostName git.oschina.net\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_oschina</code></pre>","site":{"data":{}},"excerpt":"<p>在使用 Git 的过程中经常需要用到 SSH Key 进行身份验证，即一组公钥、私钥文件，避免每次 Push 代码都需要输入密码。通常将公钥提供给 Github/OSChina 等代码托管平台，之后在使用 Git 提交代码时便会自动将云端的公钥与本地的私钥进行比对。无论是 Windows 还是 Linux 系统，SSH Key 都存放在 <code>~\\.ssh</code> 目录下。</p>","more":"<p>生成一组 SSH Key 只需：</p>\n<pre><code class=\"sh\">ssh-keygen -t rsa -C &quot;email@example.com&quot;</code></pre>\n<p>系统将提示你设置一个密码，可以直接回车跳过。如果给 SSH Key 设置了密码，通过 SSH 通讯时仍需输入此密码。</p>\n<p>现在，<code>~\\.ssh</code> 目录下应该已存在 id_rsa 和 id_rsa.pub 两个文件，使用以下命令可以查看公钥。</p>\n<pre><code class=\"sh\">cat ~/.ssh/id_rsa.pub</code></pre>\n<p>如果你拥有多组 SSH Key ，分别用于不同的代码托管平台，那么需要在 ~/.ssh 录下创建一个名为 config 的配置文件，使Git在通讯时根据服务器域名判断使用哪一个密钥。</p>\n<pre><code>Host github.com\n  HostName github.com\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_github\n\nHost git.oschina.net\n  HostName git.oschina.net\n  User your_name\n  IdentityFile ~/.ssh/id_rsa_oschina</code></pre>"},{"title":"使用 Intervention Image 库处理图片","date":"2017-02-12T05:05:49.000Z","_content":"\nIntervention Image 是一个开源图片处理库。使用它需要 PHP>=5.4、FileInfo 拓展、GD 库或 Imagick 拓展。\n\n### 安装\n\n执行以下命令使用 Composer 安装 Intervention Image 的最新版本。\n\n<!-- more -->\n\n``` sh\ncomposer require intervention/image\n```\n\n### 使用\n\nIntervention Image 并不依赖于 Laravel 或其他框架，使用时只需包含 Composer 的 autoload 文件，然后实例化 Image 对象。\n\n``` php\n// 包含autoload文件\nrequire 'vendor/autoload.php';\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManager;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\n$manager = new ImageManager(array('driver' => 'imagick'));\n\n// 创建Image实例然后操作图片\n$image = $manager->make('public/foo.jpg')->resize(300, 200);\n```\n\n也可以在导入类时设置一个别名。\n\n``` php\n// 包含autoload文件\nrequire 'vendor/autoload.php';\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManagerStatic as Image;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\nImage::configure(array('driver' => 'imagick'));\n\n// 创建Image实例然后操作图片\n$image = Image::make('public/foo.jpg')->resize(300, 200);\n```\n\n### 在 Laravel 中使用\n\nIntervention Image 提供了服务提供者、门面以便快速集成到 Laravel 框架。\n\n打开 Laravel 的配置文件 `config\\app.php` ，在 `$providers` 数组中添加一个服务提供者。\n\n``` php\nIntervention\\Image\\ImageServiceProvider::class\n```\n在 `$aliases` 数组中添加一个门面。\n\n``` php\n'Image' => Intervention\\Image\\Facades\\Image::class\n```\n\nIntervention Image 默认使用 GD 库处理图片，如果需要切换到 Imagick ，执行以下命令创建配置文件。\n\n``` sh\nphp artisan vendor:publish --provider=\"Intervention\\Image\\ImageServiceProviderLaravel5\"\n```\n\n### 常用操作\n\n``` php\n// 创建一个Image对象\n$img = Image::make('public/foo.jpg');\n\n// 获取图片文件大小\n$size = $img->filesize();\n\n// 获取图片尺寸（像素）\n$width  = $img->width();\n$height = $img->height();\n\n// 调整图片尺寸\n$img->resize(300, 200);\n\n// 调整图片的宽或高\n$img->resize(300, null);\n$img->resize(null, 200);\n\n// 调整图片的宽同时保持图片比例\n$img->resize(300, null, function ($constraint) {\n    $constraint->aspectRatio();\n});\n\n// 调整图片的高同时保持图片比例\n$img->resize(null, 200, function ($constraint) {\n    $constraint->aspectRatio();\n});\n\n// 避免处理时造成文件大小增加\n$img->resize(null, 400, function ($constraint) {\n    $constraint->aspectRatio();\n    $constraint->upsize();\n});\n\n// 转码为其他格式并压缩图片\n$img->encode('jpg', 75);\n\n// 转码为 Data URL\n$img->encode('data-url');\n\n// 裁剪图片\n$img->crop(100, 100, 25, 25);\n\n// 旋转-45度\n$img->rotate(-45);\n\n// 垂直翻转及水平翻转\n$img->flip('v');\n$img->flip('h');\n\n// 以最优方案裁剪为600*360\n$img->fit(600, 360);\n\n// 以最优方案裁剪为200*200\n$img->fit(200);\n\n// 以默认质量保存图片\n$img->save('public/bar.jpg');\n\n// 以给定质量保存图片\n$img->save('public/bar.png', 60);\n```\n\n我只记录了部分常用的接口，更多 API 及其用法可以 [阅读](http://image.intervention.io/) 官方文档了解。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3","source":"_posts/2017-02-12@使用 Intervention Image 库处理图片.md","raw":"---\ntitle: 使用 Intervention Image 库处理图片\ncategories:\n  - Web Back-end\ndate: 2017-02-12 13:05:49\ntags:\n  - Laravel\n  - PHP\n---\n\nIntervention Image 是一个开源图片处理库。使用它需要 PHP>=5.4、FileInfo 拓展、GD 库或 Imagick 拓展。\n\n### 安装\n\n执行以下命令使用 Composer 安装 Intervention Image 的最新版本。\n\n<!-- more -->\n\n``` sh\ncomposer require intervention/image\n```\n\n### 使用\n\nIntervention Image 并不依赖于 Laravel 或其他框架，使用时只需包含 Composer 的 autoload 文件，然后实例化 Image 对象。\n\n``` php\n// 包含autoload文件\nrequire 'vendor/autoload.php';\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManager;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\n$manager = new ImageManager(array('driver' => 'imagick'));\n\n// 创建Image实例然后操作图片\n$image = $manager->make('public/foo.jpg')->resize(300, 200);\n```\n\n也可以在导入类时设置一个别名。\n\n``` php\n// 包含autoload文件\nrequire 'vendor/autoload.php';\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManagerStatic as Image;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\nImage::configure(array('driver' => 'imagick'));\n\n// 创建Image实例然后操作图片\n$image = Image::make('public/foo.jpg')->resize(300, 200);\n```\n\n### 在 Laravel 中使用\n\nIntervention Image 提供了服务提供者、门面以便快速集成到 Laravel 框架。\n\n打开 Laravel 的配置文件 `config\\app.php` ，在 `$providers` 数组中添加一个服务提供者。\n\n``` php\nIntervention\\Image\\ImageServiceProvider::class\n```\n在 `$aliases` 数组中添加一个门面。\n\n``` php\n'Image' => Intervention\\Image\\Facades\\Image::class\n```\n\nIntervention Image 默认使用 GD 库处理图片，如果需要切换到 Imagick ，执行以下命令创建配置文件。\n\n``` sh\nphp artisan vendor:publish --provider=\"Intervention\\Image\\ImageServiceProviderLaravel5\"\n```\n\n### 常用操作\n\n``` php\n// 创建一个Image对象\n$img = Image::make('public/foo.jpg');\n\n// 获取图片文件大小\n$size = $img->filesize();\n\n// 获取图片尺寸（像素）\n$width  = $img->width();\n$height = $img->height();\n\n// 调整图片尺寸\n$img->resize(300, 200);\n\n// 调整图片的宽或高\n$img->resize(300, null);\n$img->resize(null, 200);\n\n// 调整图片的宽同时保持图片比例\n$img->resize(300, null, function ($constraint) {\n    $constraint->aspectRatio();\n});\n\n// 调整图片的高同时保持图片比例\n$img->resize(null, 200, function ($constraint) {\n    $constraint->aspectRatio();\n});\n\n// 避免处理时造成文件大小增加\n$img->resize(null, 400, function ($constraint) {\n    $constraint->aspectRatio();\n    $constraint->upsize();\n});\n\n// 转码为其他格式并压缩图片\n$img->encode('jpg', 75);\n\n// 转码为 Data URL\n$img->encode('data-url');\n\n// 裁剪图片\n$img->crop(100, 100, 25, 25);\n\n// 旋转-45度\n$img->rotate(-45);\n\n// 垂直翻转及水平翻转\n$img->flip('v');\n$img->flip('h');\n\n// 以最优方案裁剪为600*360\n$img->fit(600, 360);\n\n// 以最优方案裁剪为200*200\n$img->fit(200);\n\n// 以默认质量保存图片\n$img->save('public/bar.jpg');\n\n// 以给定质量保存图片\n$img->save('public/bar.png', 60);\n```\n\n我只记录了部分常用的接口，更多 API 及其用法可以 [阅读](http://image.intervention.io/) 官方文档了解。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3","slug":"2017-02-12@使用 Intervention Image 库处理图片","published":1,"updated":"2020-06-29T03:32:42.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49f007irqgjgjve1b6m","content":"<p>Intervention Image 是一个开源图片处理库。使用它需要 PHP&gt;=5.4、FileInfo 拓展、GD 库或 Imagick 拓展。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>执行以下命令使用 Composer 安装 Intervention Image 的最新版本。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"sh\">composer require intervention/image</code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Intervention Image 并不依赖于 Laravel 或其他框架，使用时只需包含 Composer 的 autoload 文件，然后实例化 Image 对象。</p>\n<pre><code class=\"php\">// 包含autoload文件\nrequire &#39;vendor/autoload.php&#39;;\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManager;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\n$manager = new ImageManager(array(&#39;driver&#39; =&gt; &#39;imagick&#39;));\n\n// 创建Image实例然后操作图片\n$image = $manager-&gt;make(&#39;public/foo.jpg&#39;)-&gt;resize(300, 200);</code></pre>\n<p>也可以在导入类时设置一个别名。</p>\n<pre><code class=\"php\">// 包含autoload文件\nrequire &#39;vendor/autoload.php&#39;;\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManagerStatic as Image;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\nImage::configure(array(&#39;driver&#39; =&gt; &#39;imagick&#39;));\n\n// 创建Image实例然后操作图片\n$image = Image::make(&#39;public/foo.jpg&#39;)-&gt;resize(300, 200);</code></pre>\n<h3 id=\"在-Laravel-中使用\"><a href=\"#在-Laravel-中使用\" class=\"headerlink\" title=\"在 Laravel 中使用\"></a>在 Laravel 中使用</h3><p>Intervention Image 提供了服务提供者、门面以便快速集成到 Laravel 框架。</p>\n<p>打开 Laravel 的配置文件 <code>config\\app.php</code> ，在 <code>$providers</code> 数组中添加一个服务提供者。</p>\n<pre><code class=\"php\">Intervention\\Image\\ImageServiceProvider::class</code></pre>\n<p>在 <code>$aliases</code> 数组中添加一个门面。</p>\n<pre><code class=\"php\">&#39;Image&#39; =&gt; Intervention\\Image\\Facades\\Image::class</code></pre>\n<p>Intervention Image 默认使用 GD 库处理图片，如果需要切换到 Imagick ，执行以下命令创建配置文件。</p>\n<pre><code class=\"sh\">php artisan vendor:publish --provider=&quot;Intervention\\Image\\ImageServiceProviderLaravel5&quot;</code></pre>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><pre><code class=\"php\">// 创建一个Image对象\n$img = Image::make(&#39;public/foo.jpg&#39;);\n\n// 获取图片文件大小\n$size = $img-&gt;filesize();\n\n// 获取图片尺寸（像素）\n$width  = $img-&gt;width();\n$height = $img-&gt;height();\n\n// 调整图片尺寸\n$img-&gt;resize(300, 200);\n\n// 调整图片的宽或高\n$img-&gt;resize(300, null);\n$img-&gt;resize(null, 200);\n\n// 调整图片的宽同时保持图片比例\n$img-&gt;resize(300, null, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n});\n\n// 调整图片的高同时保持图片比例\n$img-&gt;resize(null, 200, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n});\n\n// 避免处理时造成文件大小增加\n$img-&gt;resize(null, 400, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n    $constraint-&gt;upsize();\n});\n\n// 转码为其他格式并压缩图片\n$img-&gt;encode(&#39;jpg&#39;, 75);\n\n// 转码为 Data URL\n$img-&gt;encode(&#39;data-url&#39;);\n\n// 裁剪图片\n$img-&gt;crop(100, 100, 25, 25);\n\n// 旋转-45度\n$img-&gt;rotate(-45);\n\n// 垂直翻转及水平翻转\n$img-&gt;flip(&#39;v&#39;);\n$img-&gt;flip(&#39;h&#39;);\n\n// 以最优方案裁剪为600*360\n$img-&gt;fit(600, 360);\n\n// 以最优方案裁剪为200*200\n$img-&gt;fit(200);\n\n// 以默认质量保存图片\n$img-&gt;save(&#39;public/bar.jpg&#39;);\n\n// 以给定质量保存图片\n$img-&gt;save(&#39;public/bar.png&#39;, 60);</code></pre>\n<p>我只记录了部分常用的接口，更多 API 及其用法可以 <a href=\"http://image.intervention.io/\" target=\"_blank\" rel=\"noopener\">阅读</a> 官方文档了解。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3</p>\n","site":{"data":{}},"excerpt":"<p>Intervention Image 是一个开源图片处理库。使用它需要 PHP&gt;=5.4、FileInfo 拓展、GD 库或 Imagick 拓展。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>执行以下命令使用 Composer 安装 Intervention Image 的最新版本。</p>","more":"<pre><code class=\"sh\">composer require intervention/image</code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Intervention Image 并不依赖于 Laravel 或其他框架，使用时只需包含 Composer 的 autoload 文件，然后实例化 Image 对象。</p>\n<pre><code class=\"php\">// 包含autoload文件\nrequire &#39;vendor/autoload.php&#39;;\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManager;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\n$manager = new ImageManager(array(&#39;driver&#39; =&gt; &#39;imagick&#39;));\n\n// 创建Image实例然后操作图片\n$image = $manager-&gt;make(&#39;public/foo.jpg&#39;)-&gt;resize(300, 200);</code></pre>\n<p>也可以在导入类时设置一个别名。</p>\n<pre><code class=\"php\">// 包含autoload文件\nrequire &#39;vendor/autoload.php&#39;;\n\n// 导入ImageManager类\nuse Intervention\\Image\\ImageManagerStatic as Image;\n\n// 创建ImageManager实例并指定要使用的驱动(默认GD库)\nImage::configure(array(&#39;driver&#39; =&gt; &#39;imagick&#39;));\n\n// 创建Image实例然后操作图片\n$image = Image::make(&#39;public/foo.jpg&#39;)-&gt;resize(300, 200);</code></pre>\n<h3 id=\"在-Laravel-中使用\"><a href=\"#在-Laravel-中使用\" class=\"headerlink\" title=\"在 Laravel 中使用\"></a>在 Laravel 中使用</h3><p>Intervention Image 提供了服务提供者、门面以便快速集成到 Laravel 框架。</p>\n<p>打开 Laravel 的配置文件 <code>config\\app.php</code> ，在 <code>$providers</code> 数组中添加一个服务提供者。</p>\n<pre><code class=\"php\">Intervention\\Image\\ImageServiceProvider::class</code></pre>\n<p>在 <code>$aliases</code> 数组中添加一个门面。</p>\n<pre><code class=\"php\">&#39;Image&#39; =&gt; Intervention\\Image\\Facades\\Image::class</code></pre>\n<p>Intervention Image 默认使用 GD 库处理图片，如果需要切换到 Imagick ，执行以下命令创建配置文件。</p>\n<pre><code class=\"sh\">php artisan vendor:publish --provider=&quot;Intervention\\Image\\ImageServiceProviderLaravel5&quot;</code></pre>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><pre><code class=\"php\">// 创建一个Image对象\n$img = Image::make(&#39;public/foo.jpg&#39;);\n\n// 获取图片文件大小\n$size = $img-&gt;filesize();\n\n// 获取图片尺寸（像素）\n$width  = $img-&gt;width();\n$height = $img-&gt;height();\n\n// 调整图片尺寸\n$img-&gt;resize(300, 200);\n\n// 调整图片的宽或高\n$img-&gt;resize(300, null);\n$img-&gt;resize(null, 200);\n\n// 调整图片的宽同时保持图片比例\n$img-&gt;resize(300, null, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n});\n\n// 调整图片的高同时保持图片比例\n$img-&gt;resize(null, 200, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n});\n\n// 避免处理时造成文件大小增加\n$img-&gt;resize(null, 400, function ($constraint) {\n    $constraint-&gt;aspectRatio();\n    $constraint-&gt;upsize();\n});\n\n// 转码为其他格式并压缩图片\n$img-&gt;encode(&#39;jpg&#39;, 75);\n\n// 转码为 Data URL\n$img-&gt;encode(&#39;data-url&#39;);\n\n// 裁剪图片\n$img-&gt;crop(100, 100, 25, 25);\n\n// 旋转-45度\n$img-&gt;rotate(-45);\n\n// 垂直翻转及水平翻转\n$img-&gt;flip(&#39;v&#39;);\n$img-&gt;flip(&#39;h&#39;);\n\n// 以最优方案裁剪为600*360\n$img-&gt;fit(600, 360);\n\n// 以最优方案裁剪为200*200\n$img-&gt;fit(200);\n\n// 以默认质量保存图片\n$img-&gt;save(&#39;public/bar.jpg&#39;);\n\n// 以给定质量保存图片\n$img-&gt;save(&#39;public/bar.png&#39;, 60);</code></pre>\n<p>我只记录了部分常用的接口，更多 API 及其用法可以 <a href=\"http://image.intervention.io/\" target=\"_blank\" rel=\"noopener\">阅读</a> 官方文档了解。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3</p>"},{"title":"使用 Laravel Excel 导入导出 Excel & CSV","date":"2017-02-16T15:32:28.000Z","_content":"\nLaravel Excel 是一个开源库，使用它可以很轻易地在 Laravel 项目上实现导入和导出 Excel、CSV 文件。Laravel Excel 基于另一个开源项目 PHPExcel ，所以如果你的应用不是运行在 Laravel 上， 你也可以尝试使用 PHPExcel 。\n\n<!-- more -->\n\n### 安装\n\n在 composer.json 中添加相应的包。\n\n``` js\n\"maatwebsite/excel\": \"~2.1.0\"\n```\n然后在命令行执行以下代码安装 Laravel Excel 。\n\n``` sh\ncomposer update\n```\n修改 Laravel 的配置文件 config/app.php ，在 $providers 数组中添加一个服务提供者。\n\n``` php\n'Maatwebsite\\Excel\\ExcelServiceProvider'\n```\n接着在 $aliasses 数组中添加一个门面。\n\n``` php\n'Excel' => 'Maatwebsite\\Excel\\Facades\\Excel'\n```\n\n### 配置\n\n如果你想要查看或者修改 Laravel Excel 提供的配置，在命令行执行以下代码，然后你就会在 config 文件夹下得到一个配置文件。\n\n``` sh\nphp artisan vendor:publish\n```\n\n### 使用\n\n在控制器中引用这个包。如果之前已经添加过门面，也可以直接引用门面。\n\n``` php\nuse Maatwebsite\\Excel\\Facades\\Excel;\n```\n\n``` php\nuse Excel;\n```\n\n### 导入\n\n\n``` php\n// 加载文件\nExcel::load('file.xls', function($reader) {\n\n  // 获取数据的集合\n  $results = $reader->get();\n\n  // 获取第一行数据\n  $results = $reader->first();\n\n  // 获取前10行数据\n  $reader->take(10);\n\n  // 跳过前10行数据\n  $reader->skip(10);\n\n  // 以数组形式获取数据\n  $reader->toArray();\n\n  // 打印数据\n  $reader->dump();\n\n  // 遍历工作表\n  $reader->each(function($sheet) {\n\n    // 遍历行\n    $sheet->each(function($row) {\n\n    });\n\n  });\n\n  // 获取指定的列\n  $reader->select(array('firstname', 'lastname'))->get();\n\n  // 获取指定的列\n  $reader->get(array('firstname', 'lastname'));\n\n});\n\n// 选择名为sheet1的工作表\nExcel::selectSheets('sheet1')->load();\n\n// 根据索引选择工作表\nExcel::selectSheetsByIndex(0)->load();\n```\n\n### 导出\n\n\n``` php\n// 生成文件\nExcel::create('Filename', function($excel) {\n\n  // 设置文档标题和作者\n  $excel->setTitle('Our new awesome title');\n  $excel->setCreator('Maatwebsite')\n    ->setCompany('Maatwebsite');\n\n  // 设置文档描述\n  $excel->setDescription('A demonstration to change the file properties');\n\n  // 创建工作表\n  $excel->sheet('Sheetname', function($sheet) {\n\n    // 通过数组写入值（二维数组）\n    $sheet->fromArray($array);\n\n    // 给第一行写入值（一维数组）\n    $sheet->row(1, $array);\n\n    // 设置某一列的宽\n    $sheet->setWidth('A', 5);\n\n    // 批量设置列宽\n    $sheet->setWidth([\n        'A' => 5,\n        'B' => 10\n    ]);\n\n  });\n\n});\n\n// 生成为指定的格式并下载\nExcel::create()->export('xls');\n\n// 生成为指定的格式并存储在app/storage/exports目录\nExcel::create()->store('xls');\n\n// 生成为指定的格式并存储在指定的目录\nExcel::create()->store('xls', storage_path('excel/exports'));\n\n// 存储后返回文件数据（包含路径等）\nExcel::create()->store('xls', false, true);\n```\n\nLaravel Excel 还提供了很多包含表格样式修改在内的其他 API 。感兴趣的话可以阅读 [官方文档](http://www.maatwebsite.nl/laravel-excel/docs) 了解。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3","source":"_posts/2017-02-16@使用 Laravel Excel 导入导出 Excel & CSV.md","raw":"---\ntitle: 使用 Laravel Excel 导入导出 Excel & CSV\ncategories:\n  - Web Back-end\ndate: 2017-02-16 23:32:28\ntags:\n  - Laravel\n  - PHP\n---\n\nLaravel Excel 是一个开源库，使用它可以很轻易地在 Laravel 项目上实现导入和导出 Excel、CSV 文件。Laravel Excel 基于另一个开源项目 PHPExcel ，所以如果你的应用不是运行在 Laravel 上， 你也可以尝试使用 PHPExcel 。\n\n<!-- more -->\n\n### 安装\n\n在 composer.json 中添加相应的包。\n\n``` js\n\"maatwebsite/excel\": \"~2.1.0\"\n```\n然后在命令行执行以下代码安装 Laravel Excel 。\n\n``` sh\ncomposer update\n```\n修改 Laravel 的配置文件 config/app.php ，在 $providers 数组中添加一个服务提供者。\n\n``` php\n'Maatwebsite\\Excel\\ExcelServiceProvider'\n```\n接着在 $aliasses 数组中添加一个门面。\n\n``` php\n'Excel' => 'Maatwebsite\\Excel\\Facades\\Excel'\n```\n\n### 配置\n\n如果你想要查看或者修改 Laravel Excel 提供的配置，在命令行执行以下代码，然后你就会在 config 文件夹下得到一个配置文件。\n\n``` sh\nphp artisan vendor:publish\n```\n\n### 使用\n\n在控制器中引用这个包。如果之前已经添加过门面，也可以直接引用门面。\n\n``` php\nuse Maatwebsite\\Excel\\Facades\\Excel;\n```\n\n``` php\nuse Excel;\n```\n\n### 导入\n\n\n``` php\n// 加载文件\nExcel::load('file.xls', function($reader) {\n\n  // 获取数据的集合\n  $results = $reader->get();\n\n  // 获取第一行数据\n  $results = $reader->first();\n\n  // 获取前10行数据\n  $reader->take(10);\n\n  // 跳过前10行数据\n  $reader->skip(10);\n\n  // 以数组形式获取数据\n  $reader->toArray();\n\n  // 打印数据\n  $reader->dump();\n\n  // 遍历工作表\n  $reader->each(function($sheet) {\n\n    // 遍历行\n    $sheet->each(function($row) {\n\n    });\n\n  });\n\n  // 获取指定的列\n  $reader->select(array('firstname', 'lastname'))->get();\n\n  // 获取指定的列\n  $reader->get(array('firstname', 'lastname'));\n\n});\n\n// 选择名为sheet1的工作表\nExcel::selectSheets('sheet1')->load();\n\n// 根据索引选择工作表\nExcel::selectSheetsByIndex(0)->load();\n```\n\n### 导出\n\n\n``` php\n// 生成文件\nExcel::create('Filename', function($excel) {\n\n  // 设置文档标题和作者\n  $excel->setTitle('Our new awesome title');\n  $excel->setCreator('Maatwebsite')\n    ->setCompany('Maatwebsite');\n\n  // 设置文档描述\n  $excel->setDescription('A demonstration to change the file properties');\n\n  // 创建工作表\n  $excel->sheet('Sheetname', function($sheet) {\n\n    // 通过数组写入值（二维数组）\n    $sheet->fromArray($array);\n\n    // 给第一行写入值（一维数组）\n    $sheet->row(1, $array);\n\n    // 设置某一列的宽\n    $sheet->setWidth('A', 5);\n\n    // 批量设置列宽\n    $sheet->setWidth([\n        'A' => 5,\n        'B' => 10\n    ]);\n\n  });\n\n});\n\n// 生成为指定的格式并下载\nExcel::create()->export('xls');\n\n// 生成为指定的格式并存储在app/storage/exports目录\nExcel::create()->store('xls');\n\n// 生成为指定的格式并存储在指定的目录\nExcel::create()->store('xls', storage_path('excel/exports'));\n\n// 存储后返回文件数据（包含路径等）\nExcel::create()->store('xls', false, true);\n```\n\nLaravel Excel 还提供了很多包含表格样式修改在内的其他 API 。感兴趣的话可以阅读 [官方文档](http://www.maatwebsite.nl/laravel-excel/docs) 了解。\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3","slug":"2017-02-16@使用 Laravel Excel 导入导出 Excel & CSV","published":1,"updated":"2020-06-29T03:32:42.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49g007mrqgj94zk0qd6","content":"<p>Laravel Excel 是一个开源库，使用它可以很轻易地在 Laravel 项目上实现导入和导出 Excel、CSV 文件。Laravel Excel 基于另一个开源项目 PHPExcel ，所以如果你的应用不是运行在 Laravel 上， 你也可以尝试使用 PHPExcel 。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在 composer.json 中添加相应的包。</p>\n<pre><code class=\"js\">&quot;maatwebsite/excel&quot;: &quot;~2.1.0&quot;</code></pre>\n<p>然后在命令行执行以下代码安装 Laravel Excel 。</p>\n<pre><code class=\"sh\">composer update</code></pre>\n<p>修改 Laravel 的配置文件 config/app.php ，在 $providers 数组中添加一个服务提供者。</p>\n<pre><code class=\"php\">&#39;Maatwebsite\\Excel\\ExcelServiceProvider&#39;</code></pre>\n<p>接着在 $aliasses 数组中添加一个门面。</p>\n<pre><code class=\"php\">&#39;Excel&#39; =&gt; &#39;Maatwebsite\\Excel\\Facades\\Excel&#39;</code></pre>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>如果你想要查看或者修改 Laravel Excel 提供的配置，在命令行执行以下代码，然后你就会在 config 文件夹下得到一个配置文件。</p>\n<pre><code class=\"sh\">php artisan vendor:publish</code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>在控制器中引用这个包。如果之前已经添加过门面，也可以直接引用门面。</p>\n<pre><code class=\"php\">use Maatwebsite\\Excel\\Facades\\Excel;</code></pre>\n<pre><code class=\"php\">use Excel;</code></pre>\n<h3 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h3><pre><code class=\"php\">// 加载文件\nExcel::load(&#39;file.xls&#39;, function($reader) {\n\n  // 获取数据的集合\n  $results = $reader-&gt;get();\n\n  // 获取第一行数据\n  $results = $reader-&gt;first();\n\n  // 获取前10行数据\n  $reader-&gt;take(10);\n\n  // 跳过前10行数据\n  $reader-&gt;skip(10);\n\n  // 以数组形式获取数据\n  $reader-&gt;toArray();\n\n  // 打印数据\n  $reader-&gt;dump();\n\n  // 遍历工作表\n  $reader-&gt;each(function($sheet) {\n\n    // 遍历行\n    $sheet-&gt;each(function($row) {\n\n    });\n\n  });\n\n  // 获取指定的列\n  $reader-&gt;select(array(&#39;firstname&#39;, &#39;lastname&#39;))-&gt;get();\n\n  // 获取指定的列\n  $reader-&gt;get(array(&#39;firstname&#39;, &#39;lastname&#39;));\n\n});\n\n// 选择名为sheet1的工作表\nExcel::selectSheets(&#39;sheet1&#39;)-&gt;load();\n\n// 根据索引选择工作表\nExcel::selectSheetsByIndex(0)-&gt;load();</code></pre>\n<h3 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h3><pre><code class=\"php\">// 生成文件\nExcel::create(&#39;Filename&#39;, function($excel) {\n\n  // 设置文档标题和作者\n  $excel-&gt;setTitle(&#39;Our new awesome title&#39;);\n  $excel-&gt;setCreator(&#39;Maatwebsite&#39;)\n    -&gt;setCompany(&#39;Maatwebsite&#39;);\n\n  // 设置文档描述\n  $excel-&gt;setDescription(&#39;A demonstration to change the file properties&#39;);\n\n  // 创建工作表\n  $excel-&gt;sheet(&#39;Sheetname&#39;, function($sheet) {\n\n    // 通过数组写入值（二维数组）\n    $sheet-&gt;fromArray($array);\n\n    // 给第一行写入值（一维数组）\n    $sheet-&gt;row(1, $array);\n\n    // 设置某一列的宽\n    $sheet-&gt;setWidth(&#39;A&#39;, 5);\n\n    // 批量设置列宽\n    $sheet-&gt;setWidth([\n        &#39;A&#39; =&gt; 5,\n        &#39;B&#39; =&gt; 10\n    ]);\n\n  });\n\n});\n\n// 生成为指定的格式并下载\nExcel::create()-&gt;export(&#39;xls&#39;);\n\n// 生成为指定的格式并存储在app/storage/exports目录\nExcel::create()-&gt;store(&#39;xls&#39;);\n\n// 生成为指定的格式并存储在指定的目录\nExcel::create()-&gt;store(&#39;xls&#39;, storage_path(&#39;excel/exports&#39;));\n\n// 存储后返回文件数据（包含路径等）\nExcel::create()-&gt;store(&#39;xls&#39;, false, true);</code></pre>\n<p>Laravel Excel 还提供了很多包含表格样式修改在内的其他 API 。感兴趣的话可以阅读 <a href=\"http://www.maatwebsite.nl/laravel-excel/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a> 了解。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3</p>\n","site":{"data":{}},"excerpt":"<p>Laravel Excel 是一个开源库，使用它可以很轻易地在 Laravel 项目上实现导入和导出 Excel、CSV 文件。Laravel Excel 基于另一个开源项目 PHPExcel ，所以如果你的应用不是运行在 Laravel 上， 你也可以尝试使用 PHPExcel 。</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在 composer.json 中添加相应的包。</p>\n<pre><code class=\"js\">&quot;maatwebsite/excel&quot;: &quot;~2.1.0&quot;</code></pre>\n<p>然后在命令行执行以下代码安装 Laravel Excel 。</p>\n<pre><code class=\"sh\">composer update</code></pre>\n<p>修改 Laravel 的配置文件 config/app.php ，在 $providers 数组中添加一个服务提供者。</p>\n<pre><code class=\"php\">&#39;Maatwebsite\\Excel\\ExcelServiceProvider&#39;</code></pre>\n<p>接着在 $aliasses 数组中添加一个门面。</p>\n<pre><code class=\"php\">&#39;Excel&#39; =&gt; &#39;Maatwebsite\\Excel\\Facades\\Excel&#39;</code></pre>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>如果你想要查看或者修改 Laravel Excel 提供的配置，在命令行执行以下代码，然后你就会在 config 文件夹下得到一个配置文件。</p>\n<pre><code class=\"sh\">php artisan vendor:publish</code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>在控制器中引用这个包。如果之前已经添加过门面，也可以直接引用门面。</p>\n<pre><code class=\"php\">use Maatwebsite\\Excel\\Facades\\Excel;</code></pre>\n<pre><code class=\"php\">use Excel;</code></pre>\n<h3 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h3><pre><code class=\"php\">// 加载文件\nExcel::load(&#39;file.xls&#39;, function($reader) {\n\n  // 获取数据的集合\n  $results = $reader-&gt;get();\n\n  // 获取第一行数据\n  $results = $reader-&gt;first();\n\n  // 获取前10行数据\n  $reader-&gt;take(10);\n\n  // 跳过前10行数据\n  $reader-&gt;skip(10);\n\n  // 以数组形式获取数据\n  $reader-&gt;toArray();\n\n  // 打印数据\n  $reader-&gt;dump();\n\n  // 遍历工作表\n  $reader-&gt;each(function($sheet) {\n\n    // 遍历行\n    $sheet-&gt;each(function($row) {\n\n    });\n\n  });\n\n  // 获取指定的列\n  $reader-&gt;select(array(&#39;firstname&#39;, &#39;lastname&#39;))-&gt;get();\n\n  // 获取指定的列\n  $reader-&gt;get(array(&#39;firstname&#39;, &#39;lastname&#39;));\n\n});\n\n// 选择名为sheet1的工作表\nExcel::selectSheets(&#39;sheet1&#39;)-&gt;load();\n\n// 根据索引选择工作表\nExcel::selectSheetsByIndex(0)-&gt;load();</code></pre>\n<h3 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h3><pre><code class=\"php\">// 生成文件\nExcel::create(&#39;Filename&#39;, function($excel) {\n\n  // 设置文档标题和作者\n  $excel-&gt;setTitle(&#39;Our new awesome title&#39;);\n  $excel-&gt;setCreator(&#39;Maatwebsite&#39;)\n    -&gt;setCompany(&#39;Maatwebsite&#39;);\n\n  // 设置文档描述\n  $excel-&gt;setDescription(&#39;A demonstration to change the file properties&#39;);\n\n  // 创建工作表\n  $excel-&gt;sheet(&#39;Sheetname&#39;, function($sheet) {\n\n    // 通过数组写入值（二维数组）\n    $sheet-&gt;fromArray($array);\n\n    // 给第一行写入值（一维数组）\n    $sheet-&gt;row(1, $array);\n\n    // 设置某一列的宽\n    $sheet-&gt;setWidth(&#39;A&#39;, 5);\n\n    // 批量设置列宽\n    $sheet-&gt;setWidth([\n        &#39;A&#39; =&gt; 5,\n        &#39;B&#39; =&gt; 10\n    ]);\n\n  });\n\n});\n\n// 生成为指定的格式并下载\nExcel::create()-&gt;export(&#39;xls&#39;);\n\n// 生成为指定的格式并存储在app/storage/exports目录\nExcel::create()-&gt;store(&#39;xls&#39;);\n\n// 生成为指定的格式并存储在指定的目录\nExcel::create()-&gt;store(&#39;xls&#39;, storage_path(&#39;excel/exports&#39;));\n\n// 存储后返回文件数据（包含路径等）\nExcel::create()-&gt;store(&#39;xls&#39;, false, true);</code></pre>\n<p>Laravel Excel 还提供了很多包含表格样式修改在内的其他 API 。感兴趣的话可以阅读 <a href=\"http://www.maatwebsite.nl/laravel-excel/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a> 了解。</p>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.3</p>"},{"title":"为你的网站开启 HTTPS","date":"2017-02-17T15:59:52.000Z","_content":"\nHTTPS 是一种网络协议，是在 HTTP 协议的基础上增加了 SSL 层，用于通信过程中的数据加密。因此我习惯把 https 开头的链接称为安全链接。国内的百度和淘宝早已实现全站开启 HTTPS ，其他大部分知名站点也至少会在用户登录时使用它。\n\n<!-- more -->\n\n由于众所周知的原因，包括但不限于：现代浏览器暗示用户非 http 链接不安全，电信运营商可能给页面强行植入内容，搜索引擎更愿意收录安全链接。使得为网站开启 HTTPS 显得越来越有必要。当然最主要的原因还是我（处女座）无法容忍自己的站点缺一把小锁，于是我决定在自己的服务器上启用 HTTPS 。\n\n{% img /images/posts/2017/02/https_installed.png 480 启用 SSL 后的浏览效果 %}\n\n### 申请SSL证书\n\nSSL 证书是由受浏览器信任的机构颁发的数字证书，申请证书的过程即是验证网站所有者身份的过程。该证书分4个等级，等级越高验证越严格、费用越昂贵，同时浏览器越认为你值得信任。申请SSL证书的渠道很多，也有不少机构签发免费证书，可以说各有优缺点，这里不加赘述。\n\n### 服务器配置SSL\n\n确认你的 Web 引擎已经安装过 SSL 模块，并且已将证书和私钥上传到服务端。\n\n以 Nginx 引擎为例，编辑站点的 .conf 配置文件。由于 HTTPS 服务使用443端口，首先需要增加对443端口的监听。然后添加 SSL 的相关配置，包括配置证书及私钥的路径、使用的协议等。具体以证书颁发机构提供的示例为准。完成后重启 Web 引擎。\n\n```\nserver {\n  listen 80;\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  index  index.html index.php index.htm;\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n  ...\n\n  ssl on;\n  ssl_certificate /cert/example.pem;\n  ssl_certificate_key /cert/example.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n}\n```\n\n###  开放443端口\n\n如果上一步配置正确的话，你应该已经可以使用 https 链接访问站点了。如果无法正常访问，可能是服务器没有开放相应的端口。\n\n以 CentOS7 为例：\n\n```\n# 运行防火墙\nsystemctl start firewalld\n# 开放80端口\nfirewall-cmd --add-port=80/tcp\n# 开放443端口\nfirewall-cmd --add-port=443/tcp\n```\n\n###  强制使用 HTTPS\n\n开放端口后，使用 `https://example.com` 和 `http://example.com` 都已可以正常访问。\n\n要让用户默认使用安全链接，需要添加重写规则，强制 http 访问重定向到 https 。以 Nginx 为例：\n\n```\nserver {\n  listen 80;\n  server_name example.com www.example.com;\n  return 301 https://$server_name$request_uri;\n}\nserver {\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  ...\n}\n```\n\n最后，如果网站中引用的任何资源文件（图片、样式、脚本）使用了 http 链接，都会导致浏览器降低信任等级并打印警告。你需要用 https 或自适应协议写法替换：\n\n```\n// 使用https协议\n<link rel=\"icon\" href=\"https://example.com/favicon.png\" sizes=\"32x32\">\n// 自动使用当前页面协议\n<link rel=\"icon\" href=\"//example.com/favicon.png\" sizes=\"32x32\">\n```\n\nENV: Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7","source":"_posts/2017-02-17@为你的网站开启 HTTPS.md","raw":"---\ntitle: 为你的网站开启 HTTPS\ncategories:\n  - Web Back-end\ndate: 2017-02-17 23:59:52\ntags:\n  - SSL\n  - HTTPS\n  - Nginx\n---\n\nHTTPS 是一种网络协议，是在 HTTP 协议的基础上增加了 SSL 层，用于通信过程中的数据加密。因此我习惯把 https 开头的链接称为安全链接。国内的百度和淘宝早已实现全站开启 HTTPS ，其他大部分知名站点也至少会在用户登录时使用它。\n\n<!-- more -->\n\n由于众所周知的原因，包括但不限于：现代浏览器暗示用户非 http 链接不安全，电信运营商可能给页面强行植入内容，搜索引擎更愿意收录安全链接。使得为网站开启 HTTPS 显得越来越有必要。当然最主要的原因还是我（处女座）无法容忍自己的站点缺一把小锁，于是我决定在自己的服务器上启用 HTTPS 。\n\n{% img /images/posts/2017/02/https_installed.png 480 启用 SSL 后的浏览效果 %}\n\n### 申请SSL证书\n\nSSL 证书是由受浏览器信任的机构颁发的数字证书，申请证书的过程即是验证网站所有者身份的过程。该证书分4个等级，等级越高验证越严格、费用越昂贵，同时浏览器越认为你值得信任。申请SSL证书的渠道很多，也有不少机构签发免费证书，可以说各有优缺点，这里不加赘述。\n\n### 服务器配置SSL\n\n确认你的 Web 引擎已经安装过 SSL 模块，并且已将证书和私钥上传到服务端。\n\n以 Nginx 引擎为例，编辑站点的 .conf 配置文件。由于 HTTPS 服务使用443端口，首先需要增加对443端口的监听。然后添加 SSL 的相关配置，包括配置证书及私钥的路径、使用的协议等。具体以证书颁发机构提供的示例为准。完成后重启 Web 引擎。\n\n```\nserver {\n  listen 80;\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  index  index.html index.php index.htm;\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n  ...\n\n  ssl on;\n  ssl_certificate /cert/example.pem;\n  ssl_certificate_key /cert/example.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n}\n```\n\n###  开放443端口\n\n如果上一步配置正确的话，你应该已经可以使用 https 链接访问站点了。如果无法正常访问，可能是服务器没有开放相应的端口。\n\n以 CentOS7 为例：\n\n```\n# 运行防火墙\nsystemctl start firewalld\n# 开放80端口\nfirewall-cmd --add-port=80/tcp\n# 开放443端口\nfirewall-cmd --add-port=443/tcp\n```\n\n###  强制使用 HTTPS\n\n开放端口后，使用 `https://example.com` 和 `http://example.com` 都已可以正常访问。\n\n要让用户默认使用安全链接，需要添加重写规则，强制 http 访问重定向到 https 。以 Nginx 为例：\n\n```\nserver {\n  listen 80;\n  server_name example.com www.example.com;\n  return 301 https://$server_name$request_uri;\n}\nserver {\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  ...\n}\n```\n\n最后，如果网站中引用的任何资源文件（图片、样式、脚本）使用了 http 链接，都会导致浏览器降低信任等级并打印警告。你需要用 https 或自适应协议写法替换：\n\n```\n// 使用https协议\n<link rel=\"icon\" href=\"https://example.com/favicon.png\" sizes=\"32x32\">\n// 自动使用当前页面协议\n<link rel=\"icon\" href=\"//example.com/favicon.png\" sizes=\"32x32\">\n```\n\nENV: Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7","slug":"2017-02-17@为你的网站开启 HTTPS","published":1,"updated":"2020-06-29T03:32:42.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49h007prqgjavap7ah0","content":"<p>HTTPS 是一种网络协议，是在 HTTP 协议的基础上增加了 SSL 层，用于通信过程中的数据加密。因此我习惯把 https 开头的链接称为安全链接。国内的百度和淘宝早已实现全站开启 HTTPS ，其他大部分知名站点也至少会在用户登录时使用它。</p>\n<a id=\"more\"></a>\n\n<p>由于众所周知的原因，包括但不限于：现代浏览器暗示用户非 http 链接不安全，电信运营商可能给页面强行植入内容，搜索引擎更愿意收录安全链接。使得为网站开启 HTTPS 显得越来越有必要。当然最主要的原因还是我（处女座）无法容忍自己的站点缺一把小锁，于是我决定在自己的服务器上启用 HTTPS 。</p>\n<img src=\"/images/posts/2017/02/https_installed.png\" class=\"\" width=\"480\" title=\"启用 SSL 后的浏览效果\">\n\n<h3 id=\"申请SSL证书\"><a href=\"#申请SSL证书\" class=\"headerlink\" title=\"申请SSL证书\"></a>申请SSL证书</h3><p>SSL 证书是由受浏览器信任的机构颁发的数字证书，申请证书的过程即是验证网站所有者身份的过程。该证书分4个等级，等级越高验证越严格、费用越昂贵，同时浏览器越认为你值得信任。申请SSL证书的渠道很多，也有不少机构签发免费证书，可以说各有优缺点，这里不加赘述。</p>\n<h3 id=\"服务器配置SSL\"><a href=\"#服务器配置SSL\" class=\"headerlink\" title=\"服务器配置SSL\"></a>服务器配置SSL</h3><p>确认你的 Web 引擎已经安装过 SSL 模块，并且已将证书和私钥上传到服务端。</p>\n<p>以 Nginx 引擎为例，编辑站点的 .conf 配置文件。由于 HTTPS 服务使用443端口，首先需要增加对443端口的监听。然后添加 SSL 的相关配置，包括配置证书及私钥的路径、使用的协议等。具体以证书颁发机构提供的示例为准。完成后重启 Web 引擎。</p>\n<pre><code>server {\n  listen 80;\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  index  index.html index.php index.htm;\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n  ...\n\n  ssl on;\n  ssl_certificate /cert/example.pem;\n  ssl_certificate_key /cert/example.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n}</code></pre><h3 id=\"开放443端口\"><a href=\"#开放443端口\" class=\"headerlink\" title=\"开放443端口\"></a>开放443端口</h3><p>如果上一步配置正确的话，你应该已经可以使用 https 链接访问站点了。如果无法正常访问，可能是服务器没有开放相应的端口。</p>\n<p>以 CentOS7 为例：</p>\n<pre><code># 运行防火墙\nsystemctl start firewalld\n# 开放80端口\nfirewall-cmd --add-port=80/tcp\n# 开放443端口\nfirewall-cmd --add-port=443/tcp</code></pre><h3 id=\"强制使用-HTTPS\"><a href=\"#强制使用-HTTPS\" class=\"headerlink\" title=\"强制使用 HTTPS\"></a>强制使用 HTTPS</h3><p>开放端口后，使用 <code>https://example.com</code> 和 <code>http://example.com</code> 都已可以正常访问。</p>\n<p>要让用户默认使用安全链接，需要添加重写规则，强制 http 访问重定向到 https 。以 Nginx 为例：</p>\n<pre><code>server {\n  listen 80;\n  server_name example.com www.example.com;\n  return 301 https://$server_name$request_uri;\n}\nserver {\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  ...\n}</code></pre><p>最后，如果网站中引用的任何资源文件（图片、样式、脚本）使用了 http 链接，都会导致浏览器降低信任等级并打印警告。你需要用 https 或自适应协议写法替换：</p>\n<pre><code>// 使用https协议\n&lt;link rel=&quot;icon&quot; href=&quot;https://example.com/favicon.png&quot; sizes=&quot;32x32&quot;&gt;\n// 自动使用当前页面协议\n&lt;link rel=&quot;icon&quot; href=&quot;//example.com/favicon.png&quot; sizes=&quot;32x32&quot;&gt;</code></pre><p>ENV: Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7</p>\n","site":{"data":{}},"excerpt":"<p>HTTPS 是一种网络协议，是在 HTTP 协议的基础上增加了 SSL 层，用于通信过程中的数据加密。因此我习惯把 https 开头的链接称为安全链接。国内的百度和淘宝早已实现全站开启 HTTPS ，其他大部分知名站点也至少会在用户登录时使用它。</p>","more":"<p>由于众所周知的原因，包括但不限于：现代浏览器暗示用户非 http 链接不安全，电信运营商可能给页面强行植入内容，搜索引擎更愿意收录安全链接。使得为网站开启 HTTPS 显得越来越有必要。当然最主要的原因还是我（处女座）无法容忍自己的站点缺一把小锁，于是我决定在自己的服务器上启用 HTTPS 。</p>\n<img src=\"/images/posts/2017/02/https_installed.png\" class=\"\" width=\"480\" title=\"启用 SSL 后的浏览效果\">\n\n<h3 id=\"申请SSL证书\"><a href=\"#申请SSL证书\" class=\"headerlink\" title=\"申请SSL证书\"></a>申请SSL证书</h3><p>SSL 证书是由受浏览器信任的机构颁发的数字证书，申请证书的过程即是验证网站所有者身份的过程。该证书分4个等级，等级越高验证越严格、费用越昂贵，同时浏览器越认为你值得信任。申请SSL证书的渠道很多，也有不少机构签发免费证书，可以说各有优缺点，这里不加赘述。</p>\n<h3 id=\"服务器配置SSL\"><a href=\"#服务器配置SSL\" class=\"headerlink\" title=\"服务器配置SSL\"></a>服务器配置SSL</h3><p>确认你的 Web 引擎已经安装过 SSL 模块，并且已将证书和私钥上传到服务端。</p>\n<p>以 Nginx 引擎为例，编辑站点的 .conf 配置文件。由于 HTTPS 服务使用443端口，首先需要增加对443端口的监听。然后添加 SSL 的相关配置，包括配置证书及私钥的路径、使用的协议等。具体以证书颁发机构提供的示例为准。完成后重启 Web 引擎。</p>\n<pre><code>server {\n  listen 80;\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  index  index.html index.php index.htm;\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    expires max;\n    log_not_found off;\n  }\n  ...\n\n  ssl on;\n  ssl_certificate /cert/example.pem;\n  ssl_certificate_key /cert/example.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n}</code></pre><h3 id=\"开放443端口\"><a href=\"#开放443端口\" class=\"headerlink\" title=\"开放443端口\"></a>开放443端口</h3><p>如果上一步配置正确的话，你应该已经可以使用 https 链接访问站点了。如果无法正常访问，可能是服务器没有开放相应的端口。</p>\n<p>以 CentOS7 为例：</p>\n<pre><code># 运行防火墙\nsystemctl start firewalld\n# 开放80端口\nfirewall-cmd --add-port=80/tcp\n# 开放443端口\nfirewall-cmd --add-port=443/tcp</code></pre><h3 id=\"强制使用-HTTPS\"><a href=\"#强制使用-HTTPS\" class=\"headerlink\" title=\"强制使用 HTTPS\"></a>强制使用 HTTPS</h3><p>开放端口后，使用 <code>https://example.com</code> 和 <code>http://example.com</code> 都已可以正常访问。</p>\n<p>要让用户默认使用安全链接，需要添加重写规则，强制 http 访问重定向到 https 。以 Nginx 为例：</p>\n<pre><code>server {\n  listen 80;\n  server_name example.com www.example.com;\n  return 301 https://$server_name$request_uri;\n}\nserver {\n  listen 443;\n  root /web/example;\n  server_name example.com www.example.com;\n  ...\n}</code></pre><p>最后，如果网站中引用的任何资源文件（图片、样式、脚本）使用了 http 链接，都会导致浏览器降低信任等级并打印警告。你需要用 https 或自适应协议写法替换：</p>\n<pre><code>// 使用https协议\n&lt;link rel=&quot;icon&quot; href=&quot;https://example.com/favicon.png&quot; sizes=&quot;32x32&quot;&gt;\n// 自动使用当前页面协议\n&lt;link rel=&quot;icon&quot; href=&quot;//example.com/favicon.png&quot; sizes=&quot;32x32&quot;&gt;</code></pre><p>ENV: Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WordPress 4.7</p>"},{"title":"不用 JSSDK 自定义微信分享标题和缩略图","date":"2017-02-23T08:19:19.000Z","_content":"\n微信向网页开发者提供了 JSSDK ，通常我们要自定义“分享到朋友圈”以及“发送给朋友”时显示的标题和缩略图，都是通过调用其接口实现。\n\n微信分享接口的权限仅对已认证的公众号开放 。对于手头没有认证公众号的开发者，还有其他办法可以自定义微信分享标题和缩略图吗？答案是肯定的，效果是低配的。\n\n<!-- more -->\n\n### 自定义分享标题\n\n如果未使用 JSSDK 设置过标题，微信默认抓取网页标题，也就是 title 标签中的内容作为分享标题。这是显而易见的。\n\n``` xhtml\n<title>我是页面标题</title>\n```\n\n既然如此，我们可以判断当前访问的浏览器是不是微信浏览器，若是微信浏览器，就动态修改页面标题。\n\n以 PHP 为例：\n\n``` php\nif (strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ){\n  echo '<script type=\"text/javascript\"> document.title = '我是新标题'; </script>';\n}\n```\n\n以 JavaScript 为例：\n``` js\nvar ua = window.navigator.userAgent.toLowerCase();\nif (ua.match(/MicroMessenger/i) == 'micromessenger') {\n  document.title = '我是新标题';\n}\n```\n\n这样，用户使用微信浏览时的页面标题就是“我是新标题”，分享时自然也会以此作为分享标题，也就间接达到了自定义微信分享标题的目的。\n\n### 自定义分享缩略图\n\n如果未使用 JSSDK 设置过缩略图，微信默认抓取页面中尺寸大于300\\*300像素的第一张图片作为缩略图。\n\n既然如此，我们可以把要作为缩略图的图片放在 body 的最前面，然后隐藏它。\n\n很有人说可以给图片包一个隐藏的 div：\n\n``` xhtml\n<div style=\"display: none\">\n  <img src=\"/wechat.png\" width=\"300\" height=\"300\">\n</div>\n```\n这是错误的，至少在新版微信里面没有起到任何作用。\n\n我的办法是把图片移动到浏览器的可视区域之外：\n\n``` xhtml\n<div class=\"wechat-icon\">\n  <img src=\"/wechat.png\" width=\"300\" height=\"300\">\n</div>\n```\n\n``` css\n.wechat-icon {\n  position: fixed;\n  top: 0;\n  left: -300px;\n}\n```\n\n注：2017年3月29日，微信宣布未接入 JSSDK 的网站将统一显示默认缩略图，上述方法在新版微信中或已失效，建议接入 JSSDK 或继续使用微信 6.5.4 版本。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WeChat 6.5.4","source":"_posts/2017-02-23@不用 JSSDK 自定义微信分享标题和缩略图.md","raw":"---\ntitle: 不用 JSSDK 自定义微信分享标题和缩略图\ncategories:\n  - Web Front-end\ndate: 2017-02-23 16:19:19\ntags:\n  - 微信\n---\n\n微信向网页开发者提供了 JSSDK ，通常我们要自定义“分享到朋友圈”以及“发送给朋友”时显示的标题和缩略图，都是通过调用其接口实现。\n\n微信分享接口的权限仅对已认证的公众号开放 。对于手头没有认证公众号的开发者，还有其他办法可以自定义微信分享标题和缩略图吗？答案是肯定的，效果是低配的。\n\n<!-- more -->\n\n### 自定义分享标题\n\n如果未使用 JSSDK 设置过标题，微信默认抓取网页标题，也就是 title 标签中的内容作为分享标题。这是显而易见的。\n\n``` xhtml\n<title>我是页面标题</title>\n```\n\n既然如此，我们可以判断当前访问的浏览器是不是微信浏览器，若是微信浏览器，就动态修改页面标题。\n\n以 PHP 为例：\n\n``` php\nif (strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ){\n  echo '<script type=\"text/javascript\"> document.title = '我是新标题'; </script>';\n}\n```\n\n以 JavaScript 为例：\n``` js\nvar ua = window.navigator.userAgent.toLowerCase();\nif (ua.match(/MicroMessenger/i) == 'micromessenger') {\n  document.title = '我是新标题';\n}\n```\n\n这样，用户使用微信浏览时的页面标题就是“我是新标题”，分享时自然也会以此作为分享标题，也就间接达到了自定义微信分享标题的目的。\n\n### 自定义分享缩略图\n\n如果未使用 JSSDK 设置过缩略图，微信默认抓取页面中尺寸大于300\\*300像素的第一张图片作为缩略图。\n\n既然如此，我们可以把要作为缩略图的图片放在 body 的最前面，然后隐藏它。\n\n很有人说可以给图片包一个隐藏的 div：\n\n``` xhtml\n<div style=\"display: none\">\n  <img src=\"/wechat.png\" width=\"300\" height=\"300\">\n</div>\n```\n这是错误的，至少在新版微信里面没有起到任何作用。\n\n我的办法是把图片移动到浏览器的可视区域之外：\n\n``` xhtml\n<div class=\"wechat-icon\">\n  <img src=\"/wechat.png\" width=\"300\" height=\"300\">\n</div>\n```\n\n``` css\n.wechat-icon {\n  position: fixed;\n  top: 0;\n  left: -300px;\n}\n```\n\n注：2017年3月29日，微信宣布未接入 JSSDK 的网站将统一显示默认缩略图，上述方法在新版微信中或已失效，建议接入 JSSDK 或继续使用微信 6.5.4 版本。\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WeChat 6.5.4","slug":"2017-02-23@不用 JSSDK 自定义微信分享标题和缩略图","published":1,"updated":"2020-06-29T03:32:42.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49i007trqgj3six0l3e","content":"<p>微信向网页开发者提供了 JSSDK ，通常我们要自定义“分享到朋友圈”以及“发送给朋友”时显示的标题和缩略图，都是通过调用其接口实现。</p>\n<p>微信分享接口的权限仅对已认证的公众号开放 。对于手头没有认证公众号的开发者，还有其他办法可以自定义微信分享标题和缩略图吗？答案是肯定的，效果是低配的。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"自定义分享标题\"><a href=\"#自定义分享标题\" class=\"headerlink\" title=\"自定义分享标题\"></a>自定义分享标题</h3><p>如果未使用 JSSDK 设置过标题，微信默认抓取网页标题，也就是 title 标签中的内容作为分享标题。这是显而易见的。</p>\n<pre><code class=\"xhtml\">&lt;title&gt;我是页面标题&lt;/title&gt;</code></pre>\n<p>既然如此，我们可以判断当前访问的浏览器是不是微信浏览器，若是微信浏览器，就动态修改页面标题。</p>\n<p>以 PHP 为例：</p>\n<pre><code class=\"php\">if (strpos($_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;MicroMessenger&#39;) !== false ){\n  echo &#39;&lt;script type=&quot;text/javascript&quot;&gt; document.title = &#39;我是新标题&#39;; &lt;/script&gt;&#39;;\n}</code></pre>\n<p>以 JavaScript 为例：</p>\n<pre><code class=\"js\">var ua = window.navigator.userAgent.toLowerCase();\nif (ua.match(/MicroMessenger/i) == &#39;micromessenger&#39;) {\n  document.title = &#39;我是新标题&#39;;\n}</code></pre>\n<p>这样，用户使用微信浏览时的页面标题就是“我是新标题”，分享时自然也会以此作为分享标题，也就间接达到了自定义微信分享标题的目的。</p>\n<h3 id=\"自定义分享缩略图\"><a href=\"#自定义分享缩略图\" class=\"headerlink\" title=\"自定义分享缩略图\"></a>自定义分享缩略图</h3><p>如果未使用 JSSDK 设置过缩略图，微信默认抓取页面中尺寸大于300*300像素的第一张图片作为缩略图。</p>\n<p>既然如此，我们可以把要作为缩略图的图片放在 body 的最前面，然后隐藏它。</p>\n<p>很有人说可以给图片包一个隐藏的 div：</p>\n<pre><code class=\"xhtml\">&lt;div style=&quot;display: none&quot;&gt;\n  &lt;img src=&quot;/wechat.png&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;\n&lt;/div&gt;</code></pre>\n<p>这是错误的，至少在新版微信里面没有起到任何作用。</p>\n<p>我的办法是把图片移动到浏览器的可视区域之外：</p>\n<pre><code class=\"xhtml\">&lt;div class=&quot;wechat-icon&quot;&gt;\n  &lt;img src=&quot;/wechat.png&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;\n&lt;/div&gt;</code></pre>\n<pre><code class=\"css\">.wechat-icon {\n  position: fixed;\n  top: 0;\n  left: -300px;\n}</code></pre>\n<p>注：2017年3月29日，微信宣布未接入 JSSDK 的网站将统一显示默认缩略图，上述方法在新版微信中或已失效，建议接入 JSSDK 或继续使用微信 6.5.4 版本。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WeChat 6.5.4</p>\n","site":{"data":{}},"excerpt":"<p>微信向网页开发者提供了 JSSDK ，通常我们要自定义“分享到朋友圈”以及“发送给朋友”时显示的标题和缩略图，都是通过调用其接口实现。</p>\n<p>微信分享接口的权限仅对已认证的公众号开放 。对于手头没有认证公众号的开发者，还有其他办法可以自定义微信分享标题和缩略图吗？答案是肯定的，效果是低配的。</p>","more":"<h3 id=\"自定义分享标题\"><a href=\"#自定义分享标题\" class=\"headerlink\" title=\"自定义分享标题\"></a>自定义分享标题</h3><p>如果未使用 JSSDK 设置过标题，微信默认抓取网页标题，也就是 title 标签中的内容作为分享标题。这是显而易见的。</p>\n<pre><code class=\"xhtml\">&lt;title&gt;我是页面标题&lt;/title&gt;</code></pre>\n<p>既然如此，我们可以判断当前访问的浏览器是不是微信浏览器，若是微信浏览器，就动态修改页面标题。</p>\n<p>以 PHP 为例：</p>\n<pre><code class=\"php\">if (strpos($_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;MicroMessenger&#39;) !== false ){\n  echo &#39;&lt;script type=&quot;text/javascript&quot;&gt; document.title = &#39;我是新标题&#39;; &lt;/script&gt;&#39;;\n}</code></pre>\n<p>以 JavaScript 为例：</p>\n<pre><code class=\"js\">var ua = window.navigator.userAgent.toLowerCase();\nif (ua.match(/MicroMessenger/i) == &#39;micromessenger&#39;) {\n  document.title = &#39;我是新标题&#39;;\n}</code></pre>\n<p>这样，用户使用微信浏览时的页面标题就是“我是新标题”，分享时自然也会以此作为分享标题，也就间接达到了自定义微信分享标题的目的。</p>\n<h3 id=\"自定义分享缩略图\"><a href=\"#自定义分享缩略图\" class=\"headerlink\" title=\"自定义分享缩略图\"></a>自定义分享缩略图</h3><p>如果未使用 JSSDK 设置过缩略图，微信默认抓取页面中尺寸大于300*300像素的第一张图片作为缩略图。</p>\n<p>既然如此，我们可以把要作为缩略图的图片放在 body 的最前面，然后隐藏它。</p>\n<p>很有人说可以给图片包一个隐藏的 div：</p>\n<pre><code class=\"xhtml\">&lt;div style=&quot;display: none&quot;&gt;\n  &lt;img src=&quot;/wechat.png&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;\n&lt;/div&gt;</code></pre>\n<p>这是错误的，至少在新版微信里面没有起到任何作用。</p>\n<p>我的办法是把图片移动到浏览器的可视区域之外：</p>\n<pre><code class=\"xhtml\">&lt;div class=&quot;wechat-icon&quot;&gt;\n  &lt;img src=&quot;/wechat.png&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;\n&lt;/div&gt;</code></pre>\n<pre><code class=\"css\">.wechat-icon {\n  position: fixed;\n  top: 0;\n  left: -300px;\n}</code></pre>\n<p>注：2017年3月29日，微信宣布未接入 JSSDK 的网站将统一显示默认缩略图，上述方法在新版微信中或已失效，建议接入 JSSDK 或继续使用微信 6.5.4 版本。</p>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.8 / PHP 5.6 / WeChat 6.5.4</p>"},{"title":"解决移动端 ES6 兼容问题","date":"2017-03-03T08:19:39.000Z","_content":"\n昨天完成了一个移动端页面，开始在不同设备上测试。结果在两部华为测试机（荣耀6、荣耀7）上出现了画面错乱的情况。开始还以为是浏览器内核太旧，不兼容部分 CSS3 特性，在增加了用于提高兼容性的语句后，问题仍未解决。\n\n<!-- more -->\n\n排查后发现 **JavaScript 代码执行中断** 了，但控制台未有任何警告或报错。\n\n原来，是因为我们现在写 JavaScript 时或多或少地用到了 ES6 语法。ES6 是2015年6月发布的 JavaScript 标准。而华为手机，至少在之前测试的两个机型上，由于无法理解新语法，索性 **直接停止执行** 了。\n\n值得一提的是，同事的 iPhone5s（2013年发布）竟然正确理解了新语法，可见苹果的系统更新还算良心。\n\n导致这两部设备“罢工”的 ES6 语法：\n\n``` js\n// 对象内的方法可以简写\nvar object = {\n  method() {\n    return 'Hello!';\n  }\n};\n\n// 用箭头方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = (a, b) => a + b;\n```\n\n要解决这一问题，可以使用 Google 的 [Traceur](https://github.com/google/traceur-compiler) 转码器，它会将新语法转成旧语法，再交给浏览器执行。\n\n``` xhtml\n<!-- 在头部引入Traceur -->\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"></script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"></script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"></script>\n\n<script type=\"module\">\n  // 这里的代码将被处理\n</script>\n```\n\n实际使用下来发现，虽然两部设备已经可以正常访问，但 Traceur 的体积并不小。引用这个库将使用户多耗费 2.8mb 流量，也意味着增加1秒以上的加载时间。\n\n所以，在代码量不多，且并不迫切需要使用新语法的情况下，最佳的解决方案还是把用到 ES6 语法的语句，全部改回去！\n\n``` js\n// 传统方式声明对象的方法\nvar object = {\n  method: function() {\n    return 'Hello!';\n  }\n};\n\n// 传统方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = function(){ return a + b };\n```\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","source":"_posts/2017-03-03@解决移动端 ES6 兼容问题.md","raw":"---\ntitle: 解决移动端 ES6 兼容问题\ncategories:\n  - Web Front-end\ndate: 2017-03-03 16:19:39\ntags:\n  - JavaScript\n  - ES6\n---\n\n昨天完成了一个移动端页面，开始在不同设备上测试。结果在两部华为测试机（荣耀6、荣耀7）上出现了画面错乱的情况。开始还以为是浏览器内核太旧，不兼容部分 CSS3 特性，在增加了用于提高兼容性的语句后，问题仍未解决。\n\n<!-- more -->\n\n排查后发现 **JavaScript 代码执行中断** 了，但控制台未有任何警告或报错。\n\n原来，是因为我们现在写 JavaScript 时或多或少地用到了 ES6 语法。ES6 是2015年6月发布的 JavaScript 标准。而华为手机，至少在之前测试的两个机型上，由于无法理解新语法，索性 **直接停止执行** 了。\n\n值得一提的是，同事的 iPhone5s（2013年发布）竟然正确理解了新语法，可见苹果的系统更新还算良心。\n\n导致这两部设备“罢工”的 ES6 语法：\n\n``` js\n// 对象内的方法可以简写\nvar object = {\n  method() {\n    return 'Hello!';\n  }\n};\n\n// 用箭头方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = (a, b) => a + b;\n```\n\n要解决这一问题，可以使用 Google 的 [Traceur](https://github.com/google/traceur-compiler) 转码器，它会将新语法转成旧语法，再交给浏览器执行。\n\n``` xhtml\n<!-- 在头部引入Traceur -->\n<script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\"></script>\n<script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\"></script>\n<script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\"></script>\n\n<script type=\"module\">\n  // 这里的代码将被处理\n</script>\n```\n\n实际使用下来发现，虽然两部设备已经可以正常访问，但 Traceur 的体积并不小。引用这个库将使用户多耗费 2.8mb 流量，也意味着增加1秒以上的加载时间。\n\n所以，在代码量不多，且并不迫切需要使用新语法的情况下，最佳的解决方案还是把用到 ES6 语法的语句，全部改回去！\n\n``` js\n// 传统方式声明对象的方法\nvar object = {\n  method: function() {\n    return 'Hello!';\n  }\n};\n\n// 传统方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = function(){ return a + b };\n```\n\n相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2","slug":"2017-03-03@解决移动端 ES6 兼容问题","published":1,"updated":"2020-06-29T03:32:42.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49j007wrqgj06um02jg","content":"<p>昨天完成了一个移动端页面，开始在不同设备上测试。结果在两部华为测试机（荣耀6、荣耀7）上出现了画面错乱的情况。开始还以为是浏览器内核太旧，不兼容部分 CSS3 特性，在增加了用于提高兼容性的语句后，问题仍未解决。</p>\n<a id=\"more\"></a>\n\n<p>排查后发现 <strong>JavaScript 代码执行中断</strong> 了，但控制台未有任何警告或报错。</p>\n<p>原来，是因为我们现在写 JavaScript 时或多或少地用到了 ES6 语法。ES6 是2015年6月发布的 JavaScript 标准。而华为手机，至少在之前测试的两个机型上，由于无法理解新语法，索性 <strong>直接停止执行</strong> 了。</p>\n<p>值得一提的是，同事的 iPhone5s（2013年发布）竟然正确理解了新语法，可见苹果的系统更新还算良心。</p>\n<p>导致这两部设备“罢工”的 ES6 语法：</p>\n<pre><code class=\"js\">// 对象内的方法可以简写\nvar object = {\n  method() {\n    return &#39;Hello!&#39;;\n  }\n};\n\n// 用箭头方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = (a, b) =&gt; a + b;</code></pre>\n<p>要解决这一问题，可以使用 Google 的 <a href=\"https://github.com/google/traceur-compiler\" target=\"_blank\" rel=\"noopener\">Traceur</a> 转码器，它会将新语法转成旧语法，再交给浏览器执行。</p>\n<pre><code class=\"xhtml\">&lt;!-- 在头部引入Traceur --&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;\n\n&lt;script type=&quot;module&quot;&gt;\n  // 这里的代码将被处理\n&lt;/script&gt;</code></pre>\n<p>实际使用下来发现，虽然两部设备已经可以正常访问，但 Traceur 的体积并不小。引用这个库将使用户多耗费 2.8mb 流量，也意味着增加1秒以上的加载时间。</p>\n<p>所以，在代码量不多，且并不迫切需要使用新语法的情况下，最佳的解决方案还是把用到 ES6 语法的语句，全部改回去！</p>\n<pre><code class=\"js\">// 传统方式声明对象的方法\nvar object = {\n  method: function() {\n    return &#39;Hello!&#39;;\n  }\n};\n\n// 传统方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = function(){ return a + b };</code></pre>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>\n","site":{"data":{}},"excerpt":"<p>昨天完成了一个移动端页面，开始在不同设备上测试。结果在两部华为测试机（荣耀6、荣耀7）上出现了画面错乱的情况。开始还以为是浏览器内核太旧，不兼容部分 CSS3 特性，在增加了用于提高兼容性的语句后，问题仍未解决。</p>","more":"<p>排查后发现 <strong>JavaScript 代码执行中断</strong> 了，但控制台未有任何警告或报错。</p>\n<p>原来，是因为我们现在写 JavaScript 时或多或少地用到了 ES6 语法。ES6 是2015年6月发布的 JavaScript 标准。而华为手机，至少在之前测试的两个机型上，由于无法理解新语法，索性 <strong>直接停止执行</strong> 了。</p>\n<p>值得一提的是，同事的 iPhone5s（2013年发布）竟然正确理解了新语法，可见苹果的系统更新还算良心。</p>\n<p>导致这两部设备“罢工”的 ES6 语法：</p>\n<pre><code class=\"js\">// 对象内的方法可以简写\nvar object = {\n  method() {\n    return &#39;Hello!&#39;;\n  }\n};\n\n// 用箭头方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = (a, b) =&gt; a + b;</code></pre>\n<p>要解决这一问题，可以使用 Google 的 <a href=\"https://github.com/google/traceur-compiler\" target=\"_blank\" rel=\"noopener\">Traceur</a> 转码器，它会将新语法转成旧语法，再交给浏览器执行。</p>\n<pre><code class=\"xhtml\">&lt;!-- 在头部引入Traceur --&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;\n\n&lt;script type=&quot;module&quot;&gt;\n  // 这里的代码将被处理\n&lt;/script&gt;</code></pre>\n<p>实际使用下来发现，虽然两部设备已经可以正常访问，但 Traceur 的体积并不小。引用这个库将使用户多耗费 2.8mb 流量，也意味着增加1秒以上的加载时间。</p>\n<p>所以，在代码量不多，且并不迫切需要使用新语法的情况下，最佳的解决方案还是把用到 ES6 语法的语句，全部改回去！</p>\n<pre><code class=\"js\">// 传统方式声明对象的方法\nvar object = {\n  method: function() {\n    return &#39;Hello!&#39;;\n  }\n};\n\n// 传统方式定义函数\nvar a = 1;\nvar b = 2;\nvar sum = function(){ return a + b };</code></pre>\n<p>相关环境：Windows 10 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.2</p>"},{"title":"将 WordPress 移动到子目录","date":"2017-03-13T09:46:10.000Z","_content":"\nWordPress 默认安装在网站的根目录，这无疑会使目录结构看起来很混乱。查阅文档后发现 WordPress 本身允许用户将其文件移动到子目录。\n\n<!-- more -->\n\n首先，在根目录下创建用于存放 WordPress 文件的文件夹。例如： `wordpress` 。\n\n然后，在后台修改常规选项，将“WordPress地址”修改为指向子目录的链接。保存，不需要理会错误提示。\n\n``` xhtml\nhttp://example.com/wordpress\n```\n\n注意，“站点地址”不需要修改。\n\n最后，将 index.php 拷贝到根目录下。编辑 index.php ，修改其引用的文件路径。如果存在 .htaccess 等 Web 引擎配置文件，也要拷贝到根目录下。\n\n``` php\nrequire('./wordpress/wp-blog-header.php');\n```\n\n若设置过固定链接，需要到后台重新保存一次固定链接设置。若无法正常访问站点，检查 Rewrite 规则或目录权限。\n\n记得使用新链接登录后台。\n\n``` xhtml\nhttp://example.com/wordpress/wp-admin/\n```","source":"_posts/2017-03-13@将 WordPress 移动到子目录.md","raw":"---\ntitle: 将 WordPress 移动到子目录\ncategories:\n  - Other\ndate: 2017-03-13 17:46:10\ntags:\n  - WordPress\n---\n\nWordPress 默认安装在网站的根目录，这无疑会使目录结构看起来很混乱。查阅文档后发现 WordPress 本身允许用户将其文件移动到子目录。\n\n<!-- more -->\n\n首先，在根目录下创建用于存放 WordPress 文件的文件夹。例如： `wordpress` 。\n\n然后，在后台修改常规选项，将“WordPress地址”修改为指向子目录的链接。保存，不需要理会错误提示。\n\n``` xhtml\nhttp://example.com/wordpress\n```\n\n注意，“站点地址”不需要修改。\n\n最后，将 index.php 拷贝到根目录下。编辑 index.php ，修改其引用的文件路径。如果存在 .htaccess 等 Web 引擎配置文件，也要拷贝到根目录下。\n\n``` php\nrequire('./wordpress/wp-blog-header.php');\n```\n\n若设置过固定链接，需要到后台重新保存一次固定链接设置。若无法正常访问站点，检查 Rewrite 规则或目录权限。\n\n记得使用新链接登录后台。\n\n``` xhtml\nhttp://example.com/wordpress/wp-admin/\n```","slug":"2017-03-13@将 WordPress 移动到子目录","published":1,"updated":"2020-06-29T03:32:42.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49k0080rqgj4kdz9yss","content":"<p>WordPress 默认安装在网站的根目录，这无疑会使目录结构看起来很混乱。查阅文档后发现 WordPress 本身允许用户将其文件移动到子目录。</p>\n<a id=\"more\"></a>\n\n<p>首先，在根目录下创建用于存放 WordPress 文件的文件夹。例如： <code>wordpress</code> 。</p>\n<p>然后，在后台修改常规选项，将“WordPress地址”修改为指向子目录的链接。保存，不需要理会错误提示。</p>\n<pre><code class=\"xhtml\">http://example.com/wordpress</code></pre>\n<p>注意，“站点地址”不需要修改。</p>\n<p>最后，将 index.php 拷贝到根目录下。编辑 index.php ，修改其引用的文件路径。如果存在 .htaccess 等 Web 引擎配置文件，也要拷贝到根目录下。</p>\n<pre><code class=\"php\">require(&#39;./wordpress/wp-blog-header.php&#39;);</code></pre>\n<p>若设置过固定链接，需要到后台重新保存一次固定链接设置。若无法正常访问站点，检查 Rewrite 规则或目录权限。</p>\n<p>记得使用新链接登录后台。</p>\n<pre><code class=\"xhtml\">http://example.com/wordpress/wp-admin/</code></pre>\n","site":{"data":{}},"excerpt":"<p>WordPress 默认安装在网站的根目录，这无疑会使目录结构看起来很混乱。查阅文档后发现 WordPress 本身允许用户将其文件移动到子目录。</p>","more":"<p>首先，在根目录下创建用于存放 WordPress 文件的文件夹。例如： <code>wordpress</code> 。</p>\n<p>然后，在后台修改常规选项，将“WordPress地址”修改为指向子目录的链接。保存，不需要理会错误提示。</p>\n<pre><code class=\"xhtml\">http://example.com/wordpress</code></pre>\n<p>注意，“站点地址”不需要修改。</p>\n<p>最后，将 index.php 拷贝到根目录下。编辑 index.php ，修改其引用的文件路径。如果存在 .htaccess 等 Web 引擎配置文件，也要拷贝到根目录下。</p>\n<pre><code class=\"php\">require(&#39;./wordpress/wp-blog-header.php&#39;);</code></pre>\n<p>若设置过固定链接，需要到后台重新保存一次固定链接设置。若无法正常访问站点，检查 Rewrite 规则或目录权限。</p>\n<p>记得使用新链接登录后台。</p>\n<pre><code class=\"xhtml\">http://example.com/wordpress/wp-admin/</code></pre>"},{"title":"Sass 快速入门","date":"2017-03-16T05:08:22.000Z","_content":"\n第一次听说 Sass/Less 是在刚毕业时的面试，当时全然不知存在 CSS 预处理器这种东西，感到很羞愧。后来学了一点，发现确实蛮有意思，有不少特性可以提高效率或者让代码显得更优雅。\n\n<!-- more -->\n\n### 安装 Sass\n\n由于 Sass 使用 Ruby 语言开发，在安装 Sass 之前，需要先安装 Ruby 。Win 系统可以下载 [RubyInstaller ](http://rubyinstaller.org/downloads/)安装，安装时勾选 _Add Ruby executable to your PATH_ 添加环境变量。\n\n安装后执行 Ruby 的命令行工具 _Start Command Prompt with Ruby_ ，执行以下代码安装 Sass 。\n\n``` rb\ngem install sass\n```\n\n默认情况下 Sass 编译到中文会报错，解决该问题需要在配置文件中增加一句代码，指定编码为 utf-8 。\n\n``` rb\n# 配置文件参考路径\n# C:\\Ruby23-x64\\lib\\ruby\\gems\\2.3.0\\gems\\sass-3.4.23\\lib\\sass.rb\nEncoding.default_external = Encoding.find('utf-8')\n```\n\n### 编译文件\n\n编译当前目录下的 style.scss 文件并输出 style.css 。\n\n``` rb\nsass style.scss style.css\n```\n\n编译 sass 目录下的文件并在 css 目录下输出 css 文件。\n\n``` rb\nsass sass/:css/\n```\n\n监听文件的修改并自动编译为 css 文件。\n\n``` rb\nsass –watch style.scss style.css\n```\n\n### 代码风格\n\nSass 允许以指定的代码风格输出样式，只需在输出时带上 `--style` 参数。如果没有指定代码风格，默认使用嵌套（nested）风格输出。\n\n``` rb\nsass style.scss style.css --style nested\nsass style.scss style.css --style expanded\nsass style.scss style.css --style compact\nsass style.scss style.css --style compressed\n```\n\n``` scss\n/* 嵌套 nested */\ndiv {\n  width: 100%; }\n\n/* 膨胀 expanded */\ndiv {\n  width: 100%;\n}\n\n/* 紧凑 compact */\ndiv { width: 100%; }\n\n/* 压缩 compressed */\ndiv{width:100%}\n```\n\n### 变量\n\n使用 `$` 符号声明和调用变量。全局变量可在任何位置调用，局部变量只能在它的作用域内调用。\n\n``` scss\n/* 全局变量 */\n$small: 14px;\ndiv {\n  font-size: $small;\n}\n\n/* 局部变量 */\ndiv {\n  $black: #000;\n  color: $black;\n}\n```\n\n相同类型的变量可以进行运算。需要注意的是，除法运算必须加括号才会被编译，这是因为 `/` 符号本身在 css 中已有其他含义。\n\n``` scss\ndiv {\n  content: '一段' + '文字';\n  width: 100px + 100px;\n  height: 100px - 50px;\n  padding: 5px * 2;\n  margin: (20px / 2);\n}\n```\n\n### 嵌套\n\n使用嵌套可以更直观地描述选择器的层级关系，提高代码可读性。\n\n``` scss\n/* 编译前 */\ndiv {\n  img {\n    width: 100;\n  }\n}\n\n/* 编译后 */\ndiv img {\n  width: 100; }\n```\n\n使用嵌套可以更直观地描述具有相同前缀的属性。个人认为这项特性的意义不大，既不能有效减少代码，又不利于阅读代码。\n\n``` scss\n/* 编译前 */\ndiv {\n  padding: {\n    left: 10px;\n    right: 15px;\n  }\n}\n\n/* 编译后 */\ndiv {\n  padding-left: 10px;\n  padding-right: 15px; }\n```\n\n在嵌套中使用 `&` 可以引用上一级选择器，一般用于处理伪类。\n\n``` scss\n/* 编译前 */\ndiv {\n  &:before {\n    content: \"example\";\n  }\n}\n\n/* 编译后 */\ndiv:before {\n  content: \"example\"; }\n```\n\n### 混合\n\n使用 Mixin（混合）可以声明一个带参数的代码块，它很像一个方法，调用时将输出其中的声明。Mixin 的参数可以设置默认值。\n\n``` scss\n/* 声明一个Mixin */\n@mixin my-mixin ($color: #000, $fontSize: 14px) {\n  color: $color;\n  font-size: $fontSize;\n}\n/* 不传参数调用 */\ndiv {\n  @include my-mixin;\n}\n/* 传参数调用 */\nspan {\n  @include my-mixin(#fff, 18px);\n}\n```\n\n``` scss\n/* 编译后 */\ndiv {\n  color: #000;\n  font-size: 14px; }\nspan {\n  color: #fff;\n  font-size: 18px; }\n```\n\n在 Mixin 中可以使用 `if` 语句控制逻辑。\n\n``` scss\n@mixin my-mixin ($fontSize) {\n  @if ($fontSize == 'large') {\n    font-size: 30px;\n  }\n  @else {\n    font-size: 16px;\n  }\n}\n```\n\n### 继承\n\n使用 `@extend` 可以让一个选择器继承另一个选择器的所有声明。\n\n``` scss\n/* 编译前 */\n.btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}\n.btn-success {\n  color: #009688;\n  @extend .btn;\n}\n\n/* 编译后 */\n.btn, .btn-success {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px; }\n\n.btn-success {\n  color: #009688; }\n```\n\n一个包含 `%` 前缀的选择器被称为占位符选择器，这类选择器除非被继承，否则不会输出。\n\n``` scss\n%btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}<\n```\n\n### 插值\n\n使用 `#{}` 可以在选择器或属性的名称中调用变量。\n\n``` scss\n/* 编译前 */\n$type: success;\n$side: right;\n.btn-#{$type} {\n  margin-#{$side}: 10px;\n}\n\n/* 编译后 */\n.btn-success {\n  margin-right: 10px; }\n```\n\n### 注释\n\nSass 中有两种注释，双斜杠开头的注释不会被输出到 css 文件中。\n\n``` scss\n// 这段注释不会输出\n/* 这段注释将会输出 */\n```\n\n相关环境：Windows 10 x64 / Ruby 2.3 / Sass 3.4","source":"_posts/2017-03-16@Sass 快速入门.md","raw":"---\ntitle: Sass 快速入门\ncategories:\n  - Web Front-end\ndate: 2017-03-16 13:08:22\ntags:\n  - Sass\n  - CSS\n---\n\n第一次听说 Sass/Less 是在刚毕业时的面试，当时全然不知存在 CSS 预处理器这种东西，感到很羞愧。后来学了一点，发现确实蛮有意思，有不少特性可以提高效率或者让代码显得更优雅。\n\n<!-- more -->\n\n### 安装 Sass\n\n由于 Sass 使用 Ruby 语言开发，在安装 Sass 之前，需要先安装 Ruby 。Win 系统可以下载 [RubyInstaller ](http://rubyinstaller.org/downloads/)安装，安装时勾选 _Add Ruby executable to your PATH_ 添加环境变量。\n\n安装后执行 Ruby 的命令行工具 _Start Command Prompt with Ruby_ ，执行以下代码安装 Sass 。\n\n``` rb\ngem install sass\n```\n\n默认情况下 Sass 编译到中文会报错，解决该问题需要在配置文件中增加一句代码，指定编码为 utf-8 。\n\n``` rb\n# 配置文件参考路径\n# C:\\Ruby23-x64\\lib\\ruby\\gems\\2.3.0\\gems\\sass-3.4.23\\lib\\sass.rb\nEncoding.default_external = Encoding.find('utf-8')\n```\n\n### 编译文件\n\n编译当前目录下的 style.scss 文件并输出 style.css 。\n\n``` rb\nsass style.scss style.css\n```\n\n编译 sass 目录下的文件并在 css 目录下输出 css 文件。\n\n``` rb\nsass sass/:css/\n```\n\n监听文件的修改并自动编译为 css 文件。\n\n``` rb\nsass –watch style.scss style.css\n```\n\n### 代码风格\n\nSass 允许以指定的代码风格输出样式，只需在输出时带上 `--style` 参数。如果没有指定代码风格，默认使用嵌套（nested）风格输出。\n\n``` rb\nsass style.scss style.css --style nested\nsass style.scss style.css --style expanded\nsass style.scss style.css --style compact\nsass style.scss style.css --style compressed\n```\n\n``` scss\n/* 嵌套 nested */\ndiv {\n  width: 100%; }\n\n/* 膨胀 expanded */\ndiv {\n  width: 100%;\n}\n\n/* 紧凑 compact */\ndiv { width: 100%; }\n\n/* 压缩 compressed */\ndiv{width:100%}\n```\n\n### 变量\n\n使用 `$` 符号声明和调用变量。全局变量可在任何位置调用，局部变量只能在它的作用域内调用。\n\n``` scss\n/* 全局变量 */\n$small: 14px;\ndiv {\n  font-size: $small;\n}\n\n/* 局部变量 */\ndiv {\n  $black: #000;\n  color: $black;\n}\n```\n\n相同类型的变量可以进行运算。需要注意的是，除法运算必须加括号才会被编译，这是因为 `/` 符号本身在 css 中已有其他含义。\n\n``` scss\ndiv {\n  content: '一段' + '文字';\n  width: 100px + 100px;\n  height: 100px - 50px;\n  padding: 5px * 2;\n  margin: (20px / 2);\n}\n```\n\n### 嵌套\n\n使用嵌套可以更直观地描述选择器的层级关系，提高代码可读性。\n\n``` scss\n/* 编译前 */\ndiv {\n  img {\n    width: 100;\n  }\n}\n\n/* 编译后 */\ndiv img {\n  width: 100; }\n```\n\n使用嵌套可以更直观地描述具有相同前缀的属性。个人认为这项特性的意义不大，既不能有效减少代码，又不利于阅读代码。\n\n``` scss\n/* 编译前 */\ndiv {\n  padding: {\n    left: 10px;\n    right: 15px;\n  }\n}\n\n/* 编译后 */\ndiv {\n  padding-left: 10px;\n  padding-right: 15px; }\n```\n\n在嵌套中使用 `&` 可以引用上一级选择器，一般用于处理伪类。\n\n``` scss\n/* 编译前 */\ndiv {\n  &:before {\n    content: \"example\";\n  }\n}\n\n/* 编译后 */\ndiv:before {\n  content: \"example\"; }\n```\n\n### 混合\n\n使用 Mixin（混合）可以声明一个带参数的代码块，它很像一个方法，调用时将输出其中的声明。Mixin 的参数可以设置默认值。\n\n``` scss\n/* 声明一个Mixin */\n@mixin my-mixin ($color: #000, $fontSize: 14px) {\n  color: $color;\n  font-size: $fontSize;\n}\n/* 不传参数调用 */\ndiv {\n  @include my-mixin;\n}\n/* 传参数调用 */\nspan {\n  @include my-mixin(#fff, 18px);\n}\n```\n\n``` scss\n/* 编译后 */\ndiv {\n  color: #000;\n  font-size: 14px; }\nspan {\n  color: #fff;\n  font-size: 18px; }\n```\n\n在 Mixin 中可以使用 `if` 语句控制逻辑。\n\n``` scss\n@mixin my-mixin ($fontSize) {\n  @if ($fontSize == 'large') {\n    font-size: 30px;\n  }\n  @else {\n    font-size: 16px;\n  }\n}\n```\n\n### 继承\n\n使用 `@extend` 可以让一个选择器继承另一个选择器的所有声明。\n\n``` scss\n/* 编译前 */\n.btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}\n.btn-success {\n  color: #009688;\n  @extend .btn;\n}\n\n/* 编译后 */\n.btn, .btn-success {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px; }\n\n.btn-success {\n  color: #009688; }\n```\n\n一个包含 `%` 前缀的选择器被称为占位符选择器，这类选择器除非被继承，否则不会输出。\n\n``` scss\n%btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}<\n```\n\n### 插值\n\n使用 `#{}` 可以在选择器或属性的名称中调用变量。\n\n``` scss\n/* 编译前 */\n$type: success;\n$side: right;\n.btn-#{$type} {\n  margin-#{$side}: 10px;\n}\n\n/* 编译后 */\n.btn-success {\n  margin-right: 10px; }\n```\n\n### 注释\n\nSass 中有两种注释，双斜杠开头的注释不会被输出到 css 文件中。\n\n``` scss\n// 这段注释不会输出\n/* 这段注释将会输出 */\n```\n\n相关环境：Windows 10 x64 / Ruby 2.3 / Sass 3.4","slug":"2017-03-16@Sass 快速入门","published":1,"updated":"2020-06-29T03:32:42.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49k0083rqgjfgnggdif","content":"<p>第一次听说 Sass/Less 是在刚毕业时的面试，当时全然不知存在 CSS 预处理器这种东西，感到很羞愧。后来学了一点，发现确实蛮有意思，有不少特性可以提高效率或者让代码显得更优雅。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安装-Sass\"><a href=\"#安装-Sass\" class=\"headerlink\" title=\"安装 Sass\"></a>安装 Sass</h3><p>由于 Sass 使用 Ruby 语言开发，在安装 Sass 之前，需要先安装 Ruby 。Win 系统可以下载 <a href=\"http://rubyinstaller.org/downloads/\" target=\"_blank\" rel=\"noopener\">RubyInstaller </a>安装，安装时勾选 <em>Add Ruby executable to your PATH</em> 添加环境变量。</p>\n<p>安装后执行 Ruby 的命令行工具 <em>Start Command Prompt with Ruby</em> ，执行以下代码安装 Sass 。</p>\n<pre><code class=\"rb\">gem install sass</code></pre>\n<p>默认情况下 Sass 编译到中文会报错，解决该问题需要在配置文件中增加一句代码，指定编码为 utf-8 。</p>\n<pre><code class=\"rb\"># 配置文件参考路径\n# C:\\Ruby23-x64\\lib\\ruby\\gems\\2.3.0\\gems\\sass-3.4.23\\lib\\sass.rb\nEncoding.default_external = Encoding.find(&#39;utf-8&#39;)</code></pre>\n<h3 id=\"编译文件\"><a href=\"#编译文件\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h3><p>编译当前目录下的 style.scss 文件并输出 style.css 。</p>\n<pre><code class=\"rb\">sass style.scss style.css</code></pre>\n<p>编译 sass 目录下的文件并在 css 目录下输出 css 文件。</p>\n<pre><code class=\"rb\">sass sass/:css/</code></pre>\n<p>监听文件的修改并自动编译为 css 文件。</p>\n<pre><code class=\"rb\">sass –watch style.scss style.css</code></pre>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>Sass 允许以指定的代码风格输出样式，只需在输出时带上 <code>--style</code> 参数。如果没有指定代码风格，默认使用嵌套（nested）风格输出。</p>\n<pre><code class=\"rb\">sass style.scss style.css --style nested\nsass style.scss style.css --style expanded\nsass style.scss style.css --style compact\nsass style.scss style.css --style compressed</code></pre>\n<pre><code class=\"scss\">/* 嵌套 nested */\ndiv {\n  width: 100%; }\n\n/* 膨胀 expanded */\ndiv {\n  width: 100%;\n}\n\n/* 紧凑 compact */\ndiv { width: 100%; }\n\n/* 压缩 compressed */\ndiv{width:100%}</code></pre>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>使用 <code>$</code> 符号声明和调用变量。全局变量可在任何位置调用，局部变量只能在它的作用域内调用。</p>\n<pre><code class=\"scss\">/* 全局变量 */\n$small: 14px;\ndiv {\n  font-size: $small;\n}\n\n/* 局部变量 */\ndiv {\n  $black: #000;\n  color: $black;\n}</code></pre>\n<p>相同类型的变量可以进行运算。需要注意的是，除法运算必须加括号才会被编译，这是因为 <code>/</code> 符号本身在 css 中已有其他含义。</p>\n<pre><code class=\"scss\">div {\n  content: &#39;一段&#39; + &#39;文字&#39;;\n  width: 100px + 100px;\n  height: 100px - 50px;\n  padding: 5px * 2;\n  margin: (20px / 2);\n}</code></pre>\n<h3 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h3><p>使用嵌套可以更直观地描述选择器的层级关系，提高代码可读性。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  img {\n    width: 100;\n  }\n}\n\n/* 编译后 */\ndiv img {\n  width: 100; }</code></pre>\n<p>使用嵌套可以更直观地描述具有相同前缀的属性。个人认为这项特性的意义不大，既不能有效减少代码，又不利于阅读代码。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  padding: {\n    left: 10px;\n    right: 15px;\n  }\n}\n\n/* 编译后 */\ndiv {\n  padding-left: 10px;\n  padding-right: 15px; }</code></pre>\n<p>在嵌套中使用 <code>&amp;</code> 可以引用上一级选择器，一般用于处理伪类。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  &amp;:before {\n    content: &quot;example&quot;;\n  }\n}\n\n/* 编译后 */\ndiv:before {\n  content: &quot;example&quot;; }</code></pre>\n<h3 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h3><p>使用 Mixin（混合）可以声明一个带参数的代码块，它很像一个方法，调用时将输出其中的声明。Mixin 的参数可以设置默认值。</p>\n<pre><code class=\"scss\">/* 声明一个Mixin */\n@mixin my-mixin ($color: #000, $fontSize: 14px) {\n  color: $color;\n  font-size: $fontSize;\n}\n/* 不传参数调用 */\ndiv {\n  @include my-mixin;\n}\n/* 传参数调用 */\nspan {\n  @include my-mixin(#fff, 18px);\n}</code></pre>\n<pre><code class=\"scss\">/* 编译后 */\ndiv {\n  color: #000;\n  font-size: 14px; }\nspan {\n  color: #fff;\n  font-size: 18px; }</code></pre>\n<p>在 Mixin 中可以使用 <code>if</code> 语句控制逻辑。</p>\n<pre><code class=\"scss\">@mixin my-mixin ($fontSize) {\n  @if ($fontSize == &#39;large&#39;) {\n    font-size: 30px;\n  }\n  @else {\n    font-size: 16px;\n  }\n}</code></pre>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>使用 <code>@extend</code> 可以让一个选择器继承另一个选择器的所有声明。</p>\n<pre><code class=\"scss\">/* 编译前 */\n.btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}\n.btn-success {\n  color: #009688;\n  @extend .btn;\n}\n\n/* 编译后 */\n.btn, .btn-success {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px; }\n\n.btn-success {\n  color: #009688; }</code></pre>\n<p>一个包含 <code>%</code> 前缀的选择器被称为占位符选择器，这类选择器除非被继承，否则不会输出。</p>\n<pre><code class=\"scss\">%btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}&lt;</code></pre>\n<h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h3><p>使用 <code>#{}</code> 可以在选择器或属性的名称中调用变量。</p>\n<pre><code class=\"scss\">/* 编译前 */\n$type: success;\n$side: right;\n.btn-#{$type} {\n  margin-#{$side}: 10px;\n}\n\n/* 编译后 */\n.btn-success {\n  margin-right: 10px; }</code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>Sass 中有两种注释，双斜杠开头的注释不会被输出到 css 文件中。</p>\n<pre><code class=\"scss\">// 这段注释不会输出\n/* 这段注释将会输出 */</code></pre>\n<p>相关环境：Windows 10 x64 / Ruby 2.3 / Sass 3.4</p>\n","site":{"data":{}},"excerpt":"<p>第一次听说 Sass/Less 是在刚毕业时的面试，当时全然不知存在 CSS 预处理器这种东西，感到很羞愧。后来学了一点，发现确实蛮有意思，有不少特性可以提高效率或者让代码显得更优雅。</p>","more":"<h3 id=\"安装-Sass\"><a href=\"#安装-Sass\" class=\"headerlink\" title=\"安装 Sass\"></a>安装 Sass</h3><p>由于 Sass 使用 Ruby 语言开发，在安装 Sass 之前，需要先安装 Ruby 。Win 系统可以下载 <a href=\"http://rubyinstaller.org/downloads/\" target=\"_blank\" rel=\"noopener\">RubyInstaller </a>安装，安装时勾选 <em>Add Ruby executable to your PATH</em> 添加环境变量。</p>\n<p>安装后执行 Ruby 的命令行工具 <em>Start Command Prompt with Ruby</em> ，执行以下代码安装 Sass 。</p>\n<pre><code class=\"rb\">gem install sass</code></pre>\n<p>默认情况下 Sass 编译到中文会报错，解决该问题需要在配置文件中增加一句代码，指定编码为 utf-8 。</p>\n<pre><code class=\"rb\"># 配置文件参考路径\n# C:\\Ruby23-x64\\lib\\ruby\\gems\\2.3.0\\gems\\sass-3.4.23\\lib\\sass.rb\nEncoding.default_external = Encoding.find(&#39;utf-8&#39;)</code></pre>\n<h3 id=\"编译文件\"><a href=\"#编译文件\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h3><p>编译当前目录下的 style.scss 文件并输出 style.css 。</p>\n<pre><code class=\"rb\">sass style.scss style.css</code></pre>\n<p>编译 sass 目录下的文件并在 css 目录下输出 css 文件。</p>\n<pre><code class=\"rb\">sass sass/:css/</code></pre>\n<p>监听文件的修改并自动编译为 css 文件。</p>\n<pre><code class=\"rb\">sass –watch style.scss style.css</code></pre>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>Sass 允许以指定的代码风格输出样式，只需在输出时带上 <code>--style</code> 参数。如果没有指定代码风格，默认使用嵌套（nested）风格输出。</p>\n<pre><code class=\"rb\">sass style.scss style.css --style nested\nsass style.scss style.css --style expanded\nsass style.scss style.css --style compact\nsass style.scss style.css --style compressed</code></pre>\n<pre><code class=\"scss\">/* 嵌套 nested */\ndiv {\n  width: 100%; }\n\n/* 膨胀 expanded */\ndiv {\n  width: 100%;\n}\n\n/* 紧凑 compact */\ndiv { width: 100%; }\n\n/* 压缩 compressed */\ndiv{width:100%}</code></pre>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>使用 <code>$</code> 符号声明和调用变量。全局变量可在任何位置调用，局部变量只能在它的作用域内调用。</p>\n<pre><code class=\"scss\">/* 全局变量 */\n$small: 14px;\ndiv {\n  font-size: $small;\n}\n\n/* 局部变量 */\ndiv {\n  $black: #000;\n  color: $black;\n}</code></pre>\n<p>相同类型的变量可以进行运算。需要注意的是，除法运算必须加括号才会被编译，这是因为 <code>/</code> 符号本身在 css 中已有其他含义。</p>\n<pre><code class=\"scss\">div {\n  content: &#39;一段&#39; + &#39;文字&#39;;\n  width: 100px + 100px;\n  height: 100px - 50px;\n  padding: 5px * 2;\n  margin: (20px / 2);\n}</code></pre>\n<h3 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h3><p>使用嵌套可以更直观地描述选择器的层级关系，提高代码可读性。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  img {\n    width: 100;\n  }\n}\n\n/* 编译后 */\ndiv img {\n  width: 100; }</code></pre>\n<p>使用嵌套可以更直观地描述具有相同前缀的属性。个人认为这项特性的意义不大，既不能有效减少代码，又不利于阅读代码。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  padding: {\n    left: 10px;\n    right: 15px;\n  }\n}\n\n/* 编译后 */\ndiv {\n  padding-left: 10px;\n  padding-right: 15px; }</code></pre>\n<p>在嵌套中使用 <code>&amp;</code> 可以引用上一级选择器，一般用于处理伪类。</p>\n<pre><code class=\"scss\">/* 编译前 */\ndiv {\n  &amp;:before {\n    content: &quot;example&quot;;\n  }\n}\n\n/* 编译后 */\ndiv:before {\n  content: &quot;example&quot;; }</code></pre>\n<h3 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h3><p>使用 Mixin（混合）可以声明一个带参数的代码块，它很像一个方法，调用时将输出其中的声明。Mixin 的参数可以设置默认值。</p>\n<pre><code class=\"scss\">/* 声明一个Mixin */\n@mixin my-mixin ($color: #000, $fontSize: 14px) {\n  color: $color;\n  font-size: $fontSize;\n}\n/* 不传参数调用 */\ndiv {\n  @include my-mixin;\n}\n/* 传参数调用 */\nspan {\n  @include my-mixin(#fff, 18px);\n}</code></pre>\n<pre><code class=\"scss\">/* 编译后 */\ndiv {\n  color: #000;\n  font-size: 14px; }\nspan {\n  color: #fff;\n  font-size: 18px; }</code></pre>\n<p>在 Mixin 中可以使用 <code>if</code> 语句控制逻辑。</p>\n<pre><code class=\"scss\">@mixin my-mixin ($fontSize) {\n  @if ($fontSize == &#39;large&#39;) {\n    font-size: 30px;\n  }\n  @else {\n    font-size: 16px;\n  }\n}</code></pre>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>使用 <code>@extend</code> 可以让一个选择器继承另一个选择器的所有声明。</p>\n<pre><code class=\"scss\">/* 编译前 */\n.btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}\n.btn-success {\n  color: #009688;\n  @extend .btn;\n}\n\n/* 编译后 */\n.btn, .btn-success {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px; }\n\n.btn-success {\n  color: #009688; }</code></pre>\n<p>一个包含 <code>%</code> 前缀的选择器被称为占位符选择器，这类选择器除非被继承，否则不会输出。</p>\n<pre><code class=\"scss\">%btn {\n  width: 100%;\n  padding: 10px;\n  font-size: 14px;\n}&lt;</code></pre>\n<h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h3><p>使用 <code>#{}</code> 可以在选择器或属性的名称中调用变量。</p>\n<pre><code class=\"scss\">/* 编译前 */\n$type: success;\n$side: right;\n.btn-#{$type} {\n  margin-#{$side}: 10px;\n}\n\n/* 编译后 */\n.btn-success {\n  margin-right: 10px; }</code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>Sass 中有两种注释，双斜杠开头的注释不会被输出到 css 文件中。</p>\n<pre><code class=\"scss\">// 这段注释不会输出\n/* 这段注释将会输出 */</code></pre>\n<p>相关环境：Windows 10 x64 / Ruby 2.3 / Sass 3.4</p>"},{"title":"BAE 实现 WordPress 固定链接","date":"2017-04-16T16:54:05.000Z","_content":"\n最近试用百度应用引擎（BAE）部署站点。BAE 优势非常明显，便宜、按需升降配、支持 Git ，很适合部署小项目。我试着在上面安装了 WordPress ，发现无法正常使用伪静态功能，开启固定链接后大部分页面都报404错误。\n\n<!-- more -->\n\nBAE 使用的 Web 引擎是 lighttpd ，站点配置文件为应用根目录下的 app.conf 文件。\n\n编辑 app.conf 文件增加适用于 WordPress 的配置：\n\n``` yaml\nhandlers:\n\n  # 静态资源路由\n  - url : /(assets)/(.*)\n    static_files : assets/$2\n\n  # 基本路由规则\n  - url : /\n    script: index.php\n  - regex_url : ^/(wp-.+).*/?\n    script : $0\n  - regex_url : ^/(sitemap.xml)\n    script : $0\n  - regex_url : ^/(xmlrpc.php)\n    script : $0\n  - regex_url : ^/(.+)/?$\n    script : index.php/$1\n```\n\n部署代码后到 WordPress 后台，重新设置一次固定链接即可生效。\n\nENV: Baidu App Engine / PHP 5.5 / WordPress 4.7","source":"_posts/2017-04-17@BAE 实现 WordPress 固定链接.md","raw":"---\ntitle: BAE 实现 WordPress 固定链接\ncategories:\n  - Web Back-end\ndate: 2017-04-17 00:54:05\ntags:\n  - WordPress\n---\n\n最近试用百度应用引擎（BAE）部署站点。BAE 优势非常明显，便宜、按需升降配、支持 Git ，很适合部署小项目。我试着在上面安装了 WordPress ，发现无法正常使用伪静态功能，开启固定链接后大部分页面都报404错误。\n\n<!-- more -->\n\nBAE 使用的 Web 引擎是 lighttpd ，站点配置文件为应用根目录下的 app.conf 文件。\n\n编辑 app.conf 文件增加适用于 WordPress 的配置：\n\n``` yaml\nhandlers:\n\n  # 静态资源路由\n  - url : /(assets)/(.*)\n    static_files : assets/$2\n\n  # 基本路由规则\n  - url : /\n    script: index.php\n  - regex_url : ^/(wp-.+).*/?\n    script : $0\n  - regex_url : ^/(sitemap.xml)\n    script : $0\n  - regex_url : ^/(xmlrpc.php)\n    script : $0\n  - regex_url : ^/(.+)/?$\n    script : index.php/$1\n```\n\n部署代码后到 WordPress 后台，重新设置一次固定链接即可生效。\n\nENV: Baidu App Engine / PHP 5.5 / WordPress 4.7","slug":"2017-04-17@BAE 实现 WordPress 固定链接","published":1,"updated":"2020-06-29T03:32:42.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49l0087rqgjaivx4zjk","content":"<p>最近试用百度应用引擎（BAE）部署站点。BAE 优势非常明显，便宜、按需升降配、支持 Git ，很适合部署小项目。我试着在上面安装了 WordPress ，发现无法正常使用伪静态功能，开启固定链接后大部分页面都报404错误。</p>\n<a id=\"more\"></a>\n\n<p>BAE 使用的 Web 引擎是 lighttpd ，站点配置文件为应用根目录下的 app.conf 文件。</p>\n<p>编辑 app.conf 文件增加适用于 WordPress 的配置：</p>\n<pre><code class=\"yaml\">handlers:\n\n  # 静态资源路由\n  - url : /(assets)/(.*)\n    static_files : assets/$2\n\n  # 基本路由规则\n  - url : /\n    script: index.php\n  - regex_url : ^/(wp-.+).*/?\n    script : $0\n  - regex_url : ^/(sitemap.xml)\n    script : $0\n  - regex_url : ^/(xmlrpc.php)\n    script : $0\n  - regex_url : ^/(.+)/?$\n    script : index.php/$1</code></pre>\n<p>部署代码后到 WordPress 后台，重新设置一次固定链接即可生效。</p>\n<p>ENV: Baidu App Engine / PHP 5.5 / WordPress 4.7</p>\n","site":{"data":{}},"excerpt":"<p>最近试用百度应用引擎（BAE）部署站点。BAE 优势非常明显，便宜、按需升降配、支持 Git ，很适合部署小项目。我试着在上面安装了 WordPress ，发现无法正常使用伪静态功能，开启固定链接后大部分页面都报404错误。</p>","more":"<p>BAE 使用的 Web 引擎是 lighttpd ，站点配置文件为应用根目录下的 app.conf 文件。</p>\n<p>编辑 app.conf 文件增加适用于 WordPress 的配置：</p>\n<pre><code class=\"yaml\">handlers:\n\n  # 静态资源路由\n  - url : /(assets)/(.*)\n    static_files : assets/$2\n\n  # 基本路由规则\n  - url : /\n    script: index.php\n  - regex_url : ^/(wp-.+).*/?\n    script : $0\n  - regex_url : ^/(sitemap.xml)\n    script : $0\n  - regex_url : ^/(xmlrpc.php)\n    script : $0\n  - regex_url : ^/(.+)/?$\n    script : index.php/$1</code></pre>\n<p>部署代码后到 WordPress 后台，重新设置一次固定链接即可生效。</p>\n<p>ENV: Baidu App Engine / PHP 5.5 / WordPress 4.7</p>"},{"title":"Git 使用命令方式实现免密码操作","date":"2017-04-23T07:52:05.000Z","_content":"\n每次用 Git 操作远程仓库时都需要验证身份，反复提交账号密码不但繁琐，而且容易忙中出错、影响心情。除了用 SSH 方式访问仓库，我们还可以用命令将密码保存在本地，从频繁输入密码中解脱出来。\n\n<!-- more -->\n\n这种方式在只能用 https 方式使用 Git 的场景下简直救命。\n\n在需要保存登录信息的项目目录下执行以下命令：\n\n```\ngit config --global credential.helper store\n```\n\n该命令将用户名和密码以明文的形式保存在 `~/.git-credentials` 文件中。\n\n注意，是以 **明文形式** 保存的密码。所以这种方式是极不安全的，只建议在少数情况下使用，并且要注意保管好 .git-credentials 文件。","source":"_posts/2017-04-23@Git 使用命令方式实现免密码操作.md","raw":"---\ntitle: Git 使用命令方式实现免密码操作\ncategories:\n  - Other\ndate: 2017-04-23 15:52:05\ntags:\n  - Git\n---\n\n每次用 Git 操作远程仓库时都需要验证身份，反复提交账号密码不但繁琐，而且容易忙中出错、影响心情。除了用 SSH 方式访问仓库，我们还可以用命令将密码保存在本地，从频繁输入密码中解脱出来。\n\n<!-- more -->\n\n这种方式在只能用 https 方式使用 Git 的场景下简直救命。\n\n在需要保存登录信息的项目目录下执行以下命令：\n\n```\ngit config --global credential.helper store\n```\n\n该命令将用户名和密码以明文的形式保存在 `~/.git-credentials` 文件中。\n\n注意，是以 **明文形式** 保存的密码。所以这种方式是极不安全的，只建议在少数情况下使用，并且要注意保管好 .git-credentials 文件。","slug":"2017-04-23@Git 使用命令方式实现免密码操作","published":1,"updated":"2020-06-29T03:32:42.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49m008arqgj5b1o7ylj","content":"<p>每次用 Git 操作远程仓库时都需要验证身份，反复提交账号密码不但繁琐，而且容易忙中出错、影响心情。除了用 SSH 方式访问仓库，我们还可以用命令将密码保存在本地，从频繁输入密码中解脱出来。</p>\n<a id=\"more\"></a>\n\n<p>这种方式在只能用 https 方式使用 Git 的场景下简直救命。</p>\n<p>在需要保存登录信息的项目目录下执行以下命令：</p>\n<pre><code>git config --global credential.helper store</code></pre><p>该命令将用户名和密码以明文的形式保存在 <code>~/.git-credentials</code> 文件中。</p>\n<p>注意，是以 <strong>明文形式</strong> 保存的密码。所以这种方式是极不安全的，只建议在少数情况下使用，并且要注意保管好 .git-credentials 文件。</p>\n","site":{"data":{}},"excerpt":"<p>每次用 Git 操作远程仓库时都需要验证身份，反复提交账号密码不但繁琐，而且容易忙中出错、影响心情。除了用 SSH 方式访问仓库，我们还可以用命令将密码保存在本地，从频繁输入密码中解脱出来。</p>","more":"<p>这种方式在只能用 https 方式使用 Git 的场景下简直救命。</p>\n<p>在需要保存登录信息的项目目录下执行以下命令：</p>\n<pre><code>git config --global credential.helper store</code></pre><p>该命令将用户名和密码以明文的形式保存在 <code>~/.git-credentials</code> 文件中。</p>\n<p>注意，是以 <strong>明文形式</strong> 保存的密码。所以这种方式是极不安全的，只建议在少数情况下使用，并且要注意保管好 .git-credentials 文件。</p>"},{"title":"使用 JavaScript 清空上传控件的值","date":"2017-04-27T16:03:26.000Z","_content":"\n有时候我们可能希望在某个时间点帮用户清空上传控件（即 file 类型的 input 元素）的值，让交互更加友好。不过，上传控件本身并未提供一个简单的方法用于清除已选中的文件。\n\n<!-- more -->\n\n``` xhtml\n<input type=\"file\">\n```\n\n网上普遍存在两种方案：用 JavaScript 拷贝一个相同的 input 元素替换掉原来的元素，或者用 jQuery 的 val() 方法将元素的值设为空字符串。\n\n前者对我的页面没有奏效，后者似乎在 IE 下不能正常工作。更何况我也不想为解决一个小问题而引用 jQuery 库。其实，使用表单的 reset 方法可以很容易地清空上传控件的内容。\n\n首先，在 input 标签外包一个 form 标签。\n\n``` xhtml\n<form id=\"my-form\">\n  <input type=\"file\">\n</form>\n```\n\n然后，获得 form 元素并调用 reset 方法，该方法将清除表单中已输入的全部内容，当然也包括上传控件中已选中的文件。\n\n``` js\nlet form = document.getElementById('my-form')\nform.reset()\n```","source":"_posts/2017-04-28@使用 JavaScript 清空上传控件的值.md","raw":"---\ntitle: 使用 JavaScript 清空上传控件的值\ncategories:\n  - Web Front-end\ndate: 2017-04-28 00:03:26\ntags:\n  - JavaScript\n---\n\n有时候我们可能希望在某个时间点帮用户清空上传控件（即 file 类型的 input 元素）的值，让交互更加友好。不过，上传控件本身并未提供一个简单的方法用于清除已选中的文件。\n\n<!-- more -->\n\n``` xhtml\n<input type=\"file\">\n```\n\n网上普遍存在两种方案：用 JavaScript 拷贝一个相同的 input 元素替换掉原来的元素，或者用 jQuery 的 val() 方法将元素的值设为空字符串。\n\n前者对我的页面没有奏效，后者似乎在 IE 下不能正常工作。更何况我也不想为解决一个小问题而引用 jQuery 库。其实，使用表单的 reset 方法可以很容易地清空上传控件的内容。\n\n首先，在 input 标签外包一个 form 标签。\n\n``` xhtml\n<form id=\"my-form\">\n  <input type=\"file\">\n</form>\n```\n\n然后，获得 form 元素并调用 reset 方法，该方法将清除表单中已输入的全部内容，当然也包括上传控件中已选中的文件。\n\n``` js\nlet form = document.getElementById('my-form')\nform.reset()\n```","slug":"2017-04-28@使用 JavaScript 清空上传控件的值","published":1,"updated":"2020-06-29T03:32:42.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49n008erqgj0fim3xys","content":"<p>有时候我们可能希望在某个时间点帮用户清空上传控件（即 file 类型的 input 元素）的值，让交互更加友好。不过，上传控件本身并未提供一个简单的方法用于清除已选中的文件。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"xhtml\">&lt;input type=&quot;file&quot;&gt;</code></pre>\n<p>网上普遍存在两种方案：用 JavaScript 拷贝一个相同的 input 元素替换掉原来的元素，或者用 jQuery 的 val() 方法将元素的值设为空字符串。</p>\n<p>前者对我的页面没有奏效，后者似乎在 IE 下不能正常工作。更何况我也不想为解决一个小问题而引用 jQuery 库。其实，使用表单的 reset 方法可以很容易地清空上传控件的内容。</p>\n<p>首先，在 input 标签外包一个 form 标签。</p>\n<pre><code class=\"xhtml\">&lt;form id=&quot;my-form&quot;&gt;\n  &lt;input type=&quot;file&quot;&gt;\n&lt;/form&gt;</code></pre>\n<p>然后，获得 form 元素并调用 reset 方法，该方法将清除表单中已输入的全部内容，当然也包括上传控件中已选中的文件。</p>\n<pre><code class=\"js\">let form = document.getElementById(&#39;my-form&#39;)\nform.reset()</code></pre>\n","site":{"data":{}},"excerpt":"<p>有时候我们可能希望在某个时间点帮用户清空上传控件（即 file 类型的 input 元素）的值，让交互更加友好。不过，上传控件本身并未提供一个简单的方法用于清除已选中的文件。</p>","more":"<pre><code class=\"xhtml\">&lt;input type=&quot;file&quot;&gt;</code></pre>\n<p>网上普遍存在两种方案：用 JavaScript 拷贝一个相同的 input 元素替换掉原来的元素，或者用 jQuery 的 val() 方法将元素的值设为空字符串。</p>\n<p>前者对我的页面没有奏效，后者似乎在 IE 下不能正常工作。更何况我也不想为解决一个小问题而引用 jQuery 库。其实，使用表单的 reset 方法可以很容易地清空上传控件的内容。</p>\n<p>首先，在 input 标签外包一个 form 标签。</p>\n<pre><code class=\"xhtml\">&lt;form id=&quot;my-form&quot;&gt;\n  &lt;input type=&quot;file&quot;&gt;\n&lt;/form&gt;</code></pre>\n<p>然后，获得 form 元素并调用 reset 方法，该方法将清除表单中已输入的全部内容，当然也包括上传控件中已选中的文件。</p>\n<pre><code class=\"js\">let form = document.getElementById(&#39;my-form&#39;)\nform.reset()</code></pre>"},{"title":"PHP 使用 Guzzle 发送 http 请求","date":"2017-05-03T10:41:44.000Z","_content":"\nGuzzle 是一个开源的 PHP HTTP 客户端，同时支持同步和异步方法。使用它可以轻松发送 GET、POST 请求，实现和第三方服务器的通信。\n\n<!-- more -->\n\n### 安装\n\n使用 Composer 安装依赖包。\n\n```\ncomposer require guzzlehttp/guzzle\n```\n\n### 使用\n\n在控制器中新建一个 Client （HTTP 客户端）对象。\n\n``` php\n$client = new \\GuzzleHttp\\Client();\n```\n\n调用 Client 对象的 `request` 方法发送 HTTP 请求。\n\n``` php\n$res = $client->request('get', 'http://www.example.com');\n```\n\n使用 `getBody` 等方法可以获取响应的内容。\n\n``` php\n// 获取状态码\n$res->getStatusCode();\n\n// 获取头部信息\n$res->getHeaderLine('content-type');\n\n// 获取打印内容\n$res->getBody();\n```\n\n### 参数\n\n要在 GET 请求时传递参数，除了把参数直接写进链接，还可以把参数放到 `query` 数组中。\n\n``` php\n$client->request('GET', 'http://www.example.com', [\n  'query' => [\n    'email' => 'hi@caiyiming.com'\n  ]\n]);\n```\n\n`form_params` 数组用于设置 POST 请求的参数。\n\n``` php\n$client->request('POST', 'http://www.example.com', [\n  'form_params' => [\n    'email' => 'hi@caiyiming.com'\n  ]\n]);\n```\n\n### 头部\n\n`header` 数组用于设置 HTTP 请求的头部信息。\n\n``` php\n$client->request('GET', 'http://www.example.com', [\n  'headers' => [\n    'User-Agent' => 'Mozilla/5.0'\n  ]\n]);\n```\n\n### 异步\n\n`sendAsync` 方法用于发送异步请求，`then` 方法用于设置回调函数。\n\n``` php\n$request = new \\GuzzleHttp\\Psr7\\Request('GET', 'http://www.example.com');\n$promise = $client->sendAsync($request)->then(function ($response) {\n  // 请求完成后的操作\n  $response->getBody();\n});\n$promise->wait();\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Lumen 5.3","source":"_posts/2017-05-03@PHP 使用 Guzzle 发送 http 请求.md","raw":"---\ntitle: PHP 使用 Guzzle 发送 http 请求\ncategories:\n  - Web Back-end\ndate: 2017-05-03 18:41:44\ntags:\n  - PHP\n---\n\nGuzzle 是一个开源的 PHP HTTP 客户端，同时支持同步和异步方法。使用它可以轻松发送 GET、POST 请求，实现和第三方服务器的通信。\n\n<!-- more -->\n\n### 安装\n\n使用 Composer 安装依赖包。\n\n```\ncomposer require guzzlehttp/guzzle\n```\n\n### 使用\n\n在控制器中新建一个 Client （HTTP 客户端）对象。\n\n``` php\n$client = new \\GuzzleHttp\\Client();\n```\n\n调用 Client 对象的 `request` 方法发送 HTTP 请求。\n\n``` php\n$res = $client->request('get', 'http://www.example.com');\n```\n\n使用 `getBody` 等方法可以获取响应的内容。\n\n``` php\n// 获取状态码\n$res->getStatusCode();\n\n// 获取头部信息\n$res->getHeaderLine('content-type');\n\n// 获取打印内容\n$res->getBody();\n```\n\n### 参数\n\n要在 GET 请求时传递参数，除了把参数直接写进链接，还可以把参数放到 `query` 数组中。\n\n``` php\n$client->request('GET', 'http://www.example.com', [\n  'query' => [\n    'email' => 'hi@caiyiming.com'\n  ]\n]);\n```\n\n`form_params` 数组用于设置 POST 请求的参数。\n\n``` php\n$client->request('POST', 'http://www.example.com', [\n  'form_params' => [\n    'email' => 'hi@caiyiming.com'\n  ]\n]);\n```\n\n### 头部\n\n`header` 数组用于设置 HTTP 请求的头部信息。\n\n``` php\n$client->request('GET', 'http://www.example.com', [\n  'headers' => [\n    'User-Agent' => 'Mozilla/5.0'\n  ]\n]);\n```\n\n### 异步\n\n`sendAsync` 方法用于发送异步请求，`then` 方法用于设置回调函数。\n\n``` php\n$request = new \\GuzzleHttp\\Psr7\\Request('GET', 'http://www.example.com');\n$promise = $client->sendAsync($request)->then(function ($response) {\n  // 请求完成后的操作\n  $response->getBody();\n});\n$promise->wait();\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Lumen 5.3","slug":"2017-05-03@PHP 使用 Guzzle 发送 http 请求","published":1,"updated":"2020-06-29T03:32:42.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49p008hrqgj0phy33yi","content":"<p>Guzzle 是一个开源的 PHP HTTP 客户端，同时支持同步和异步方法。使用它可以轻松发送 GET、POST 请求，实现和第三方服务器的通信。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 Composer 安装依赖包。</p>\n<pre><code>composer require guzzlehttp/guzzle</code></pre><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>在控制器中新建一个 Client （HTTP 客户端）对象。</p>\n<pre><code class=\"php\">$client = new \\GuzzleHttp\\Client();</code></pre>\n<p>调用 Client 对象的 <code>request</code> 方法发送 HTTP 请求。</p>\n<pre><code class=\"php\">$res = $client-&gt;request(&#39;get&#39;, &#39;http://www.example.com&#39;);</code></pre>\n<p>使用 <code>getBody</code> 等方法可以获取响应的内容。</p>\n<pre><code class=\"php\">// 获取状态码\n$res-&gt;getStatusCode();\n\n// 获取头部信息\n$res-&gt;getHeaderLine(&#39;content-type&#39;);\n\n// 获取打印内容\n$res-&gt;getBody();</code></pre>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>要在 GET 请求时传递参数，除了把参数直接写进链接，还可以把参数放到 <code>query</code> 数组中。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;GET&#39;, &#39;http://www.example.com&#39;, [\n  &#39;query&#39; =&gt; [\n    &#39;email&#39; =&gt; &#39;hi@caiyiming.com&#39;\n  ]\n]);</code></pre>\n<p><code>form_params</code> 数组用于设置 POST 请求的参数。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;POST&#39;, &#39;http://www.example.com&#39;, [\n  &#39;form_params&#39; =&gt; [\n    &#39;email&#39; =&gt; &#39;hi@caiyiming.com&#39;\n  ]\n]);</code></pre>\n<h3 id=\"头部\"><a href=\"#头部\" class=\"headerlink\" title=\"头部\"></a>头部</h3><p><code>header</code> 数组用于设置 HTTP 请求的头部信息。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;GET&#39;, &#39;http://www.example.com&#39;, [\n  &#39;headers&#39; =&gt; [\n    &#39;User-Agent&#39; =&gt; &#39;Mozilla/5.0&#39;\n  ]\n]);</code></pre>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p><code>sendAsync</code> 方法用于发送异步请求，<code>then</code> 方法用于设置回调函数。</p>\n<pre><code class=\"php\">$request = new \\GuzzleHttp\\Psr7\\Request(&#39;GET&#39;, &#39;http://www.example.com&#39;);\n$promise = $client-&gt;sendAsync($request)-&gt;then(function ($response) {\n  // 请求完成后的操作\n  $response-&gt;getBody();\n});\n$promise-&gt;wait();</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Lumen 5.3</p>\n","site":{"data":{}},"excerpt":"<p>Guzzle 是一个开源的 PHP HTTP 客户端，同时支持同步和异步方法。使用它可以轻松发送 GET、POST 请求，实现和第三方服务器的通信。</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 Composer 安装依赖包。</p>\n<pre><code>composer require guzzlehttp/guzzle</code></pre><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>在控制器中新建一个 Client （HTTP 客户端）对象。</p>\n<pre><code class=\"php\">$client = new \\GuzzleHttp\\Client();</code></pre>\n<p>调用 Client 对象的 <code>request</code> 方法发送 HTTP 请求。</p>\n<pre><code class=\"php\">$res = $client-&gt;request(&#39;get&#39;, &#39;http://www.example.com&#39;);</code></pre>\n<p>使用 <code>getBody</code> 等方法可以获取响应的内容。</p>\n<pre><code class=\"php\">// 获取状态码\n$res-&gt;getStatusCode();\n\n// 获取头部信息\n$res-&gt;getHeaderLine(&#39;content-type&#39;);\n\n// 获取打印内容\n$res-&gt;getBody();</code></pre>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>要在 GET 请求时传递参数，除了把参数直接写进链接，还可以把参数放到 <code>query</code> 数组中。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;GET&#39;, &#39;http://www.example.com&#39;, [\n  &#39;query&#39; =&gt; [\n    &#39;email&#39; =&gt; &#39;hi@caiyiming.com&#39;\n  ]\n]);</code></pre>\n<p><code>form_params</code> 数组用于设置 POST 请求的参数。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;POST&#39;, &#39;http://www.example.com&#39;, [\n  &#39;form_params&#39; =&gt; [\n    &#39;email&#39; =&gt; &#39;hi@caiyiming.com&#39;\n  ]\n]);</code></pre>\n<h3 id=\"头部\"><a href=\"#头部\" class=\"headerlink\" title=\"头部\"></a>头部</h3><p><code>header</code> 数组用于设置 HTTP 请求的头部信息。</p>\n<pre><code class=\"php\">$client-&gt;request(&#39;GET&#39;, &#39;http://www.example.com&#39;, [\n  &#39;headers&#39; =&gt; [\n    &#39;User-Agent&#39; =&gt; &#39;Mozilla/5.0&#39;\n  ]\n]);</code></pre>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p><code>sendAsync</code> 方法用于发送异步请求，<code>then</code> 方法用于设置回调函数。</p>\n<pre><code class=\"php\">$request = new \\GuzzleHttp\\Psr7\\Request(&#39;GET&#39;, &#39;http://www.example.com&#39;);\n$promise = $client-&gt;sendAsync($request)-&gt;then(function ($response) {\n  // 请求完成后的操作\n  $response-&gt;getBody();\n});\n$promise-&gt;wait();</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Lumen 5.3</p>"},{"title":"使用 Hexo 搭建静态博客","date":"2017-05-14T02:50:37.000Z","_content":"\nHexo 是一个开源博客框架，更准确地说，它是一个静态博客生成工具。你用 Markdown 写文章，然后交给 Hexo 生成纯静态的网页文件、自动部署到服务器。过程优雅，体验惬意。\n\n<!-- more -->\n\n### 安装\n\nHexo 使用 JavaScript（Node.js） 编译文件，需要安装 [Node.js](https://nodejs.org/) 。\n\nHexo 使用 Git Bash 执行命令，需要安装 [Git](https://git-scm.com/) 。\n\n确保已安装 Node.js 和 Git ，在 Git Bash 中执行以下命令，全局安装 Hexo 。\n\n```\nnpm install -g hexo-cli\n```\n\n### 初始化\n\n指定一个文件夹并初始化 Hexo ，该命令将在 my-hexo 文件夹下生成一个 Hexo 项目必要的文件。\n\n```\nhexo init my-hexo\n```\n\n切换到 my-hexo 目录，然后安装依赖包。\n\n```\ncd my-hexo\nnpm install\n```\n\n得到的目录结构如下：\n\n```\n.\n├── _config.yml   # 配置文件\n├── package.json\n├── scaffolds\n├── source        # 源文件\n|   ├── _drafts   # 草稿\n|   └── _posts    # 文章\n└── themes        # 主题\n```\n_config.yml 是站点的配置文件。source 目录用于存放文章、图片等生成静态页面的原料。themes 目录用于存放主题，默认提供了 landscape 主题。\n\nHexo 将使用 source 目录下的资源文件，以及 themes 目录下的主题文件，混合生成静态页面文件，存放在 public 目录下。\n\n### 配置\n\n编辑站点配置文件 _config.yml ，添加一些基础信息。\n\n``` yaml\ntitle:        # 标题\nsubtitle:     # 副标题\ndescription:  # 描述\nauthor:       # 作者\nlanguage:     # 语言\ntimezone:     # 时区\nurl:          # 链接\n```\n\n### 写文章\n\nHexo 提供 `new` 命令用于新建文章或页面。\n\n```\nhexo new [布局] <标题>\n```\n\n使用 `new` 命令新建一篇文章。执行后将在 source\\\\_posts 目录下生成一个 .md 文件。\n\n```\nhexo new post 'Hello World'\n```\n\n编辑 Hello-World.md ，使用 Markdown 语法撰写文章内容。\n\n如果不希望文章直接发布，可以使用 draft 布局新建为草稿。\n\n```\nhexo new draft 'Hello World'\n```\n将指定的草稿发布为文章。\n\n```\nhexo publish post Hello-World.md\n```\n\n除了 Markdown 语法，Hexo 还提供了从 Octopress（另一个博客框架）移植而来的标签插件，用于在文章中添加引述、图片、代码、视频、超链接等内容。（详见 [Tag Plugins](https://hexo.io/docs/tag-plugins.html)）\n\n```\n{% codeblock lang:js %}\nalert('Hello World!');\n{% endcodeblock %}\n```\n\n### 手动部署\n\n执行以下命令在 public 目录下生成静态页面。\n\n```\nhexo generate\n```\n\n直接将静态页面上传到服务器即可。\n\n### Git 部署\n\nHexo 同时提供了其他较为优雅的部署方式，支持使用 Git、FTP 等方式自动部署到服务器。（详见 [Deployment](https://hexo.io/docs/deployment.html)）\n\n以 Git 方式为例，执行以下命令安装 deployer-git 模块。\n\n```\nnpm install hexo-deployer-git --save\n```\n\n编辑配置文件，设置代码仓库。\n\n``` yaml\ndeploy:\n  type: git\n  repo: <repository url>  # 仓库链接\n  branch: [branch]        # 目标分支\n  message: [message]\n```\n\n执行以下命令部署代码。\n\n```\nhexo deploy\n```\n\n### FTP 部署\n\n以 FTP 方式为例，执行以下命令安装 deployer-ftpsync 模块。\n\n```\nnpm install hexo-deployer-ftpsync --save\n```\n\n编辑配置文件，设置 FTP 服务器。\n\n``` yaml\ndeploy:\n  type: ftpsync\n  host: <host>      # 主机地址\n  user: <user>      # 用户名\n  pass: <password>  # 密码\n  remote: [remote]  # 网站根目录\n  port: [port]      # 端口\n  ignore: [ignore]\n  connections: [connections]\n  verbose: [true|false]\n```\n\n注意，该部署方式会删除服务器上的所有文件，再上传新的文件。部署配置中的 ignore 字段用于声明不希望被删除的文件。\n\n``` yaml\nignore: [ .htaccess, .conf ]\n```\n\n执行以下命令部署代码。\n\n```\nhexo deploy\n```\n\n### 服务器\n\n我们可以在本地启动一个 Web 服务器，实时预览文章的修改。\n\n执行以下命令安装 server 模块。\n\n```\nnpm install hexo-server --save\n```\n\n使用 `server` 命令启动 Web 服务器。\n\n```\nhexo server\n```\n\n在浏览器中使用 `http://localhost:4000` 访问。","source":"_posts/2017-05-14@使用 Hexo 搭建静态博客.md","raw":"---\ntitle: 使用 Hexo 搭建静态博客\ndate: 2017-05-14 10:50:37\ncategories:\n  - Other\ntags:\n  - Hexo\n---\n\nHexo 是一个开源博客框架，更准确地说，它是一个静态博客生成工具。你用 Markdown 写文章，然后交给 Hexo 生成纯静态的网页文件、自动部署到服务器。过程优雅，体验惬意。\n\n<!-- more -->\n\n### 安装\n\nHexo 使用 JavaScript（Node.js） 编译文件，需要安装 [Node.js](https://nodejs.org/) 。\n\nHexo 使用 Git Bash 执行命令，需要安装 [Git](https://git-scm.com/) 。\n\n确保已安装 Node.js 和 Git ，在 Git Bash 中执行以下命令，全局安装 Hexo 。\n\n```\nnpm install -g hexo-cli\n```\n\n### 初始化\n\n指定一个文件夹并初始化 Hexo ，该命令将在 my-hexo 文件夹下生成一个 Hexo 项目必要的文件。\n\n```\nhexo init my-hexo\n```\n\n切换到 my-hexo 目录，然后安装依赖包。\n\n```\ncd my-hexo\nnpm install\n```\n\n得到的目录结构如下：\n\n```\n.\n├── _config.yml   # 配置文件\n├── package.json\n├── scaffolds\n├── source        # 源文件\n|   ├── _drafts   # 草稿\n|   └── _posts    # 文章\n└── themes        # 主题\n```\n_config.yml 是站点的配置文件。source 目录用于存放文章、图片等生成静态页面的原料。themes 目录用于存放主题，默认提供了 landscape 主题。\n\nHexo 将使用 source 目录下的资源文件，以及 themes 目录下的主题文件，混合生成静态页面文件，存放在 public 目录下。\n\n### 配置\n\n编辑站点配置文件 _config.yml ，添加一些基础信息。\n\n``` yaml\ntitle:        # 标题\nsubtitle:     # 副标题\ndescription:  # 描述\nauthor:       # 作者\nlanguage:     # 语言\ntimezone:     # 时区\nurl:          # 链接\n```\n\n### 写文章\n\nHexo 提供 `new` 命令用于新建文章或页面。\n\n```\nhexo new [布局] <标题>\n```\n\n使用 `new` 命令新建一篇文章。执行后将在 source\\\\_posts 目录下生成一个 .md 文件。\n\n```\nhexo new post 'Hello World'\n```\n\n编辑 Hello-World.md ，使用 Markdown 语法撰写文章内容。\n\n如果不希望文章直接发布，可以使用 draft 布局新建为草稿。\n\n```\nhexo new draft 'Hello World'\n```\n将指定的草稿发布为文章。\n\n```\nhexo publish post Hello-World.md\n```\n\n除了 Markdown 语法，Hexo 还提供了从 Octopress（另一个博客框架）移植而来的标签插件，用于在文章中添加引述、图片、代码、视频、超链接等内容。（详见 [Tag Plugins](https://hexo.io/docs/tag-plugins.html)）\n\n```\n{% codeblock lang:js %}\nalert('Hello World!');\n{% endcodeblock %}\n```\n\n### 手动部署\n\n执行以下命令在 public 目录下生成静态页面。\n\n```\nhexo generate\n```\n\n直接将静态页面上传到服务器即可。\n\n### Git 部署\n\nHexo 同时提供了其他较为优雅的部署方式，支持使用 Git、FTP 等方式自动部署到服务器。（详见 [Deployment](https://hexo.io/docs/deployment.html)）\n\n以 Git 方式为例，执行以下命令安装 deployer-git 模块。\n\n```\nnpm install hexo-deployer-git --save\n```\n\n编辑配置文件，设置代码仓库。\n\n``` yaml\ndeploy:\n  type: git\n  repo: <repository url>  # 仓库链接\n  branch: [branch]        # 目标分支\n  message: [message]\n```\n\n执行以下命令部署代码。\n\n```\nhexo deploy\n```\n\n### FTP 部署\n\n以 FTP 方式为例，执行以下命令安装 deployer-ftpsync 模块。\n\n```\nnpm install hexo-deployer-ftpsync --save\n```\n\n编辑配置文件，设置 FTP 服务器。\n\n``` yaml\ndeploy:\n  type: ftpsync\n  host: <host>      # 主机地址\n  user: <user>      # 用户名\n  pass: <password>  # 密码\n  remote: [remote]  # 网站根目录\n  port: [port]      # 端口\n  ignore: [ignore]\n  connections: [connections]\n  verbose: [true|false]\n```\n\n注意，该部署方式会删除服务器上的所有文件，再上传新的文件。部署配置中的 ignore 字段用于声明不希望被删除的文件。\n\n``` yaml\nignore: [ .htaccess, .conf ]\n```\n\n执行以下命令部署代码。\n\n```\nhexo deploy\n```\n\n### 服务器\n\n我们可以在本地启动一个 Web 服务器，实时预览文章的修改。\n\n执行以下命令安装 server 模块。\n\n```\nnpm install hexo-server --save\n```\n\n使用 `server` 命令启动 Web 服务器。\n\n```\nhexo server\n```\n\n在浏览器中使用 `http://localhost:4000` 访问。","slug":"2017-05-14@使用 Hexo 搭建静态博客","published":1,"updated":"2020-06-29T03:32:42.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49r008krqgj7omu0d0e","content":"<p>Hexo 是一个开源博客框架，更准确地说，它是一个静态博客生成工具。你用 Markdown 写文章，然后交给 Hexo 生成纯静态的网页文件、自动部署到服务器。过程优雅，体验惬意。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>Hexo 使用 JavaScript（Node.js） 编译文件，需要安装 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> 。</p>\n<p>Hexo 使用 Git Bash 执行命令，需要安装 <a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a> 。</p>\n<p>确保已安装 Node.js 和 Git ，在 Git Bash 中执行以下命令，全局安装 Hexo 。</p>\n<pre><code>npm install -g hexo-cli</code></pre><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>指定一个文件夹并初始化 Hexo ，该命令将在 my-hexo 文件夹下生成一个 Hexo 项目必要的文件。</p>\n<pre><code>hexo init my-hexo</code></pre><p>切换到 my-hexo 目录，然后安装依赖包。</p>\n<pre><code>cd my-hexo\nnpm install</code></pre><p>得到的目录结构如下：</p>\n<pre><code>.\n├── _config.yml   # 配置文件\n├── package.json\n├── scaffolds\n├── source        # 源文件\n|   ├── _drafts   # 草稿\n|   └── _posts    # 文章\n└── themes        # 主题</code></pre><p>_config.yml 是站点的配置文件。source 目录用于存放文章、图片等生成静态页面的原料。themes 目录用于存放主题，默认提供了 landscape 主题。</p>\n<p>Hexo 将使用 source 目录下的资源文件，以及 themes 目录下的主题文件，混合生成静态页面文件，存放在 public 目录下。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>编辑站点配置文件 _config.yml ，添加一些基础信息。</p>\n<pre><code class=\"yaml\">title:        # 标题\nsubtitle:     # 副标题\ndescription:  # 描述\nauthor:       # 作者\nlanguage:     # 语言\ntimezone:     # 时区\nurl:          # 链接</code></pre>\n<h3 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a>写文章</h3><p>Hexo 提供 <code>new</code> 命令用于新建文章或页面。</p>\n<pre><code>hexo new [布局] &lt;标题&gt;</code></pre><p>使用 <code>new</code> 命令新建一篇文章。执行后将在 source\\_posts 目录下生成一个 .md 文件。</p>\n<pre><code>hexo new post &#39;Hello World&#39;</code></pre><p>编辑 Hello-World.md ，使用 Markdown 语法撰写文章内容。</p>\n<p>如果不希望文章直接发布，可以使用 draft 布局新建为草稿。</p>\n<pre><code>hexo new draft &#39;Hello World&#39;</code></pre><p>将指定的草稿发布为文章。</p>\n<pre><code>hexo publish post Hello-World.md</code></pre><p>除了 Markdown 语法，Hexo 还提供了从 Octopress（另一个博客框架）移植而来的标签插件，用于在文章中添加引述、图片、代码、视频、超链接等内容。（详见 <a href=\"https://hexo.io/docs/tag-plugins.html\" target=\"_blank\" rel=\"noopener\">Tag Plugins</a>）</p>\n<pre><code>{% codeblock lang:js %}\nalert('Hello World!');\n{% endcodeblock %}</code></pre><h3 id=\"手动部署\"><a href=\"#手动部署\" class=\"headerlink\" title=\"手动部署\"></a>手动部署</h3><p>执行以下命令在 public 目录下生成静态页面。</p>\n<pre><code>hexo generate</code></pre><p>直接将静态页面上传到服务器即可。</p>\n<h3 id=\"Git-部署\"><a href=\"#Git-部署\" class=\"headerlink\" title=\"Git 部署\"></a>Git 部署</h3><p>Hexo 同时提供了其他较为优雅的部署方式，支持使用 Git、FTP 等方式自动部署到服务器。（详见 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a>）</p>\n<p>以 Git 方式为例，执行以下命令安装 deployer-git 模块。</p>\n<pre><code>npm install hexo-deployer-git --save</code></pre><p>编辑配置文件，设置代码仓库。</p>\n<pre><code class=\"yaml\">deploy:\n  type: git\n  repo: &lt;repository url&gt;  # 仓库链接\n  branch: [branch]        # 目标分支\n  message: [message]</code></pre>\n<p>执行以下命令部署代码。</p>\n<pre><code>hexo deploy</code></pre><h3 id=\"FTP-部署\"><a href=\"#FTP-部署\" class=\"headerlink\" title=\"FTP 部署\"></a>FTP 部署</h3><p>以 FTP 方式为例，执行以下命令安装 deployer-ftpsync 模块。</p>\n<pre><code>npm install hexo-deployer-ftpsync --save</code></pre><p>编辑配置文件，设置 FTP 服务器。</p>\n<pre><code class=\"yaml\">deploy:\n  type: ftpsync\n  host: &lt;host&gt;      # 主机地址\n  user: &lt;user&gt;      # 用户名\n  pass: &lt;password&gt;  # 密码\n  remote: [remote]  # 网站根目录\n  port: [port]      # 端口\n  ignore: [ignore]\n  connections: [connections]\n  verbose: [true|false]</code></pre>\n<p>注意，该部署方式会删除服务器上的所有文件，再上传新的文件。部署配置中的 ignore 字段用于声明不希望被删除的文件。</p>\n<pre><code class=\"yaml\">ignore: [ .htaccess, .conf ]</code></pre>\n<p>执行以下命令部署代码。</p>\n<pre><code>hexo deploy</code></pre><h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>我们可以在本地启动一个 Web 服务器，实时预览文章的修改。</p>\n<p>执行以下命令安装 server 模块。</p>\n<pre><code>npm install hexo-server --save</code></pre><p>使用 <code>server</code> 命令启动 Web 服务器。</p>\n<pre><code>hexo server</code></pre><p>在浏览器中使用 <code>http://localhost:4000</code> 访问。</p>\n","site":{"data":{}},"excerpt":"<p>Hexo 是一个开源博客框架，更准确地说，它是一个静态博客生成工具。你用 Markdown 写文章，然后交给 Hexo 生成纯静态的网页文件、自动部署到服务器。过程优雅，体验惬意。</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>Hexo 使用 JavaScript（Node.js） 编译文件，需要安装 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> 。</p>\n<p>Hexo 使用 Git Bash 执行命令，需要安装 <a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a> 。</p>\n<p>确保已安装 Node.js 和 Git ，在 Git Bash 中执行以下命令，全局安装 Hexo 。</p>\n<pre><code>npm install -g hexo-cli</code></pre><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>指定一个文件夹并初始化 Hexo ，该命令将在 my-hexo 文件夹下生成一个 Hexo 项目必要的文件。</p>\n<pre><code>hexo init my-hexo</code></pre><p>切换到 my-hexo 目录，然后安装依赖包。</p>\n<pre><code>cd my-hexo\nnpm install</code></pre><p>得到的目录结构如下：</p>\n<pre><code>.\n├── _config.yml   # 配置文件\n├── package.json\n├── scaffolds\n├── source        # 源文件\n|   ├── _drafts   # 草稿\n|   └── _posts    # 文章\n└── themes        # 主题</code></pre><p>_config.yml 是站点的配置文件。source 目录用于存放文章、图片等生成静态页面的原料。themes 目录用于存放主题，默认提供了 landscape 主题。</p>\n<p>Hexo 将使用 source 目录下的资源文件，以及 themes 目录下的主题文件，混合生成静态页面文件，存放在 public 目录下。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>编辑站点配置文件 _config.yml ，添加一些基础信息。</p>\n<pre><code class=\"yaml\">title:        # 标题\nsubtitle:     # 副标题\ndescription:  # 描述\nauthor:       # 作者\nlanguage:     # 语言\ntimezone:     # 时区\nurl:          # 链接</code></pre>\n<h3 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a>写文章</h3><p>Hexo 提供 <code>new</code> 命令用于新建文章或页面。</p>\n<pre><code>hexo new [布局] &lt;标题&gt;</code></pre><p>使用 <code>new</code> 命令新建一篇文章。执行后将在 source\\_posts 目录下生成一个 .md 文件。</p>\n<pre><code>hexo new post &#39;Hello World&#39;</code></pre><p>编辑 Hello-World.md ，使用 Markdown 语法撰写文章内容。</p>\n<p>如果不希望文章直接发布，可以使用 draft 布局新建为草稿。</p>\n<pre><code>hexo new draft &#39;Hello World&#39;</code></pre><p>将指定的草稿发布为文章。</p>\n<pre><code>hexo publish post Hello-World.md</code></pre><p>除了 Markdown 语法，Hexo 还提供了从 Octopress（另一个博客框架）移植而来的标签插件，用于在文章中添加引述、图片、代码、视频、超链接等内容。（详见 <a href=\"https://hexo.io/docs/tag-plugins.html\" target=\"_blank\" rel=\"noopener\">Tag Plugins</a>）</p>\n<pre><code>{% codeblock lang:js %}\nalert('Hello World!');\n{% endcodeblock %}</code></pre><h3 id=\"手动部署\"><a href=\"#手动部署\" class=\"headerlink\" title=\"手动部署\"></a>手动部署</h3><p>执行以下命令在 public 目录下生成静态页面。</p>\n<pre><code>hexo generate</code></pre><p>直接将静态页面上传到服务器即可。</p>\n<h3 id=\"Git-部署\"><a href=\"#Git-部署\" class=\"headerlink\" title=\"Git 部署\"></a>Git 部署</h3><p>Hexo 同时提供了其他较为优雅的部署方式，支持使用 Git、FTP 等方式自动部署到服务器。（详见 <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a>）</p>\n<p>以 Git 方式为例，执行以下命令安装 deployer-git 模块。</p>\n<pre><code>npm install hexo-deployer-git --save</code></pre><p>编辑配置文件，设置代码仓库。</p>\n<pre><code class=\"yaml\">deploy:\n  type: git\n  repo: &lt;repository url&gt;  # 仓库链接\n  branch: [branch]        # 目标分支\n  message: [message]</code></pre>\n<p>执行以下命令部署代码。</p>\n<pre><code>hexo deploy</code></pre><h3 id=\"FTP-部署\"><a href=\"#FTP-部署\" class=\"headerlink\" title=\"FTP 部署\"></a>FTP 部署</h3><p>以 FTP 方式为例，执行以下命令安装 deployer-ftpsync 模块。</p>\n<pre><code>npm install hexo-deployer-ftpsync --save</code></pre><p>编辑配置文件，设置 FTP 服务器。</p>\n<pre><code class=\"yaml\">deploy:\n  type: ftpsync\n  host: &lt;host&gt;      # 主机地址\n  user: &lt;user&gt;      # 用户名\n  pass: &lt;password&gt;  # 密码\n  remote: [remote]  # 网站根目录\n  port: [port]      # 端口\n  ignore: [ignore]\n  connections: [connections]\n  verbose: [true|false]</code></pre>\n<p>注意，该部署方式会删除服务器上的所有文件，再上传新的文件。部署配置中的 ignore 字段用于声明不希望被删除的文件。</p>\n<pre><code class=\"yaml\">ignore: [ .htaccess, .conf ]</code></pre>\n<p>执行以下命令部署代码。</p>\n<pre><code>hexo deploy</code></pre><h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>我们可以在本地启动一个 Web 服务器，实时预览文章的修改。</p>\n<p>执行以下命令安装 server 模块。</p>\n<pre><code>npm install hexo-server --save</code></pre><p>使用 <code>server</code> 命令启动 Web 服务器。</p>\n<pre><code>hexo server</code></pre><p>在浏览器中使用 <code>http://localhost:4000</code> 访问。</p>"},{"title":"JavaScript 实现回到顶部","date":"2017-05-18T05:34:42.000Z","_content":"\n过去，我一般用 jQuery 的 `scrollTop` 和 `animate` 方法实现回到顶部（back to top）按钮。现在基本不在项目里引入 jQuery ，只能试着用原生写了。实际上，原生 JavaScript 实现起来也很容易。\n\n<!-- more -->\n\n滚动 body 到顶部：\n\n``` js\ndocument.body.scrollTop = 0\n```\n\n平滑地滚动 body 到顶部：\n\n``` js\nbtt: function() {\n  // 判断当前位置距离顶部的距离\n  if (window.scrollY) {\n    let that = this\n    // 每10毫秒向上滚动30像素\n    setTimeout(function() {\n      document.body.scrollTop = (window.scrollY - 30)\n      // 递归\n      that.scrollToTop()\n    }, 10)\n  }\n}\n```\n\n`window.scrollY` 返回文档在垂直方向已滚动的像素值。如果返回值不等于0，就在10毫秒后向上滚动30像素，然后递归调用 `btt` 方法。如果返回值等于0，说明当前位置已位于顶部，不执行任何操作。\n\n相关环境：Windows 7 x64 / Chrome 60","source":"_posts/2017-05-18@JavaScript 实现回到顶部.md","raw":"---\ntitle: JavaScript 实现回到顶部\ndate: 2017-05-18 13:34:42\ncategories:\n  - Web Front-end\ntags:\n  - JavaScript\n---\n\n过去，我一般用 jQuery 的 `scrollTop` 和 `animate` 方法实现回到顶部（back to top）按钮。现在基本不在项目里引入 jQuery ，只能试着用原生写了。实际上，原生 JavaScript 实现起来也很容易。\n\n<!-- more -->\n\n滚动 body 到顶部：\n\n``` js\ndocument.body.scrollTop = 0\n```\n\n平滑地滚动 body 到顶部：\n\n``` js\nbtt: function() {\n  // 判断当前位置距离顶部的距离\n  if (window.scrollY) {\n    let that = this\n    // 每10毫秒向上滚动30像素\n    setTimeout(function() {\n      document.body.scrollTop = (window.scrollY - 30)\n      // 递归\n      that.scrollToTop()\n    }, 10)\n  }\n}\n```\n\n`window.scrollY` 返回文档在垂直方向已滚动的像素值。如果返回值不等于0，就在10毫秒后向上滚动30像素，然后递归调用 `btt` 方法。如果返回值等于0，说明当前位置已位于顶部，不执行任何操作。\n\n相关环境：Windows 7 x64 / Chrome 60","slug":"2017-05-18@JavaScript 实现回到顶部","published":1,"updated":"2020-06-29T03:32:42.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49t008orqgj00xzgek7","content":"<p>过去，我一般用 jQuery 的 <code>scrollTop</code> 和 <code>animate</code> 方法实现回到顶部（back to top）按钮。现在基本不在项目里引入 jQuery ，只能试着用原生写了。实际上，原生 JavaScript 实现起来也很容易。</p>\n<a id=\"more\"></a>\n\n<p>滚动 body 到顶部：</p>\n<pre><code class=\"js\">document.body.scrollTop = 0</code></pre>\n<p>平滑地滚动 body 到顶部：</p>\n<pre><code class=\"js\">btt: function() {\n  // 判断当前位置距离顶部的距离\n  if (window.scrollY) {\n    let that = this\n    // 每10毫秒向上滚动30像素\n    setTimeout(function() {\n      document.body.scrollTop = (window.scrollY - 30)\n      // 递归\n      that.scrollToTop()\n    }, 10)\n  }\n}</code></pre>\n<p><code>window.scrollY</code> 返回文档在垂直方向已滚动的像素值。如果返回值不等于0，就在10毫秒后向上滚动30像素，然后递归调用 <code>btt</code> 方法。如果返回值等于0，说明当前位置已位于顶部，不执行任何操作。</p>\n<p>相关环境：Windows 7 x64 / Chrome 60</p>\n","site":{"data":{}},"excerpt":"<p>过去，我一般用 jQuery 的 <code>scrollTop</code> 和 <code>animate</code> 方法实现回到顶部（back to top）按钮。现在基本不在项目里引入 jQuery ，只能试着用原生写了。实际上，原生 JavaScript 实现起来也很容易。</p>","more":"<p>滚动 body 到顶部：</p>\n<pre><code class=\"js\">document.body.scrollTop = 0</code></pre>\n<p>平滑地滚动 body 到顶部：</p>\n<pre><code class=\"js\">btt: function() {\n  // 判断当前位置距离顶部的距离\n  if (window.scrollY) {\n    let that = this\n    // 每10毫秒向上滚动30像素\n    setTimeout(function() {\n      document.body.scrollTop = (window.scrollY - 30)\n      // 递归\n      that.scrollToTop()\n    }, 10)\n  }\n}</code></pre>\n<p><code>window.scrollY</code> 返回文档在垂直方向已滚动的像素值。如果返回值不等于0，就在10毫秒后向上滚动30像素，然后递归调用 <code>btt</code> 方法。如果返回值等于0，说明当前位置已位于顶部，不执行任何操作。</p>\n<p>相关环境：Windows 7 x64 / Chrome 60</p>"},{"title":"gulp 小教程","date":"2017-05-20T08:37:56.000Z","_content":"\ngulp 是一个前端代码 **自动化** 构建工具，帮助我们从令人痛苦或耗时的重复工作中解脱出来。用通俗易懂的话来说，gulp 能够帮你：拷贝资源文件、合并与压缩 JavaScript / CSS 文件、编译 CSS 预处理语言（Sass / Less）、监视文件的变化。\n\n<!-- more -->\n\n{% quote %}\n友情提示：gulp [ɡʌlp] 的读音应该是“尬噗”，而不是“顾噗”。\n{% endquote %}\n\n### 前言\n\n这玩意儿有用么？刚接触 gulp 的时候我也感到十分费解，觉得它能做的事我动动手指也搞得定。\n\n虽然这些功能看似简单，但当你管理的文件越来越多，项目越来越多的时候，你就会不时忘记做这些“简单的小事”，甚至被它们干扰思路、影响心情。所以，该由机器做的事就交给机器吧，你只需敲一行命令，琐碎的工作就能完成。\n\n使用 gulp 或类似的工具之后，变化或许是这样的：\n\n{% img /images/posts/2017/05/gulp_efficiency.png 480 耗费时间的结构变化 %}\n\n至于省下的时间用来干嘛，自己看着办咯。 : )\n\n### 安装\n\n确认电脑上已安装 [Node.js](https://nodejs.org/) 。在命令行工具中执行以下命令，全局安装 gulp-cli（gulp 命令行接口）。\n\n```\nnpm install --global gulp-cli\n```\n\n然后在项目中安装 gulp （作为开发环境的依赖模块）。当然，也可以在新建的目录中安装，gulp 将正常工作。\n\n```\nnpm install --save-dev gulp\n```\n\n注意，目录下必须存在 `package.json` 文件，否则 npm 安装时可能出错。若不存在就新建一个，内容为空对象即可。\n\n``` js\n{}\n```\n\n### 创建第一个任务\n\n在项目的根目录下新建 gulpfile.js 文件。它是 gulp 的配置文件，任何你希望 gulp 完成的工作都写在这份文档中。\n\n``` js\n// gulpfile.js\nvar gulp = require('gulp');\n\ngulp.task('default', function() {\n  // 任务内容...\n});\n```\n\n`task` 方法声明了一个名为 default 的空任务。在命令行中运行这个任务：\n\n```\ngulp default\n```\n\n通过输出的日志能够知道，default 任务已运行完毕。\n\n``` sh\n[23:39:25] Using gulpfile E:\\Code\\gulp-test\\gulpfile.js\n[23:39:25] Starting 'default'...\n[23:39:25] Finished 'default' after 78 μs\n```\n\n### 拷贝文件\n\n假设项目中存在以下2个存放图片的目录。为了用户能够正常加载图片，需要将第一个目录下的图片拷贝到第二个目录下。\n\n``` yaml\nresources\\assets\\img  # 用户不可访问（开发环境使用）\npublic\\assets\\img     # 用户可以访问（生产环境使用）\n```\n\n编辑任务，实现简单的文件拷贝。`src` 方法用于指定文件来源，`pipe` 方法用于输送文件，`dest` 方法用于写文件。`dest` 方法的参数为输出目录。显而易见，这段代码的作用是将第一个目录中的 example.jpg 拷贝到第二个目录下。\n\n``` js\ngulp.task('default', function() {\n  // 仅拷贝图片 example.jpg\n  gulp.src('resources/assets/img/example.jpg')\n    .pipe(gulp.dest('public/assets/img/'));\n});\n```\n\n运行任务，在 public\\assets\\img 目录下可以看见刚拷贝过来的 example.jpg 。\n\n如果要拷贝的图片非常多呢？使用 `**` 或 `*.jpg` 匹配目录下的全部或一整批图片。\n\n``` js\n// 拷贝全部文件\ngulp.src('resources/assets/img/**')\n  .pipe(gulp.dest('public/assets/img/'));\n\n// 拷贝所有 jpg 文件\ngulp.src('resources/assets/img/*.jpg')\n  .pipe(gulp.dest('public/assets/img/'));\n```\n\n### 监视文件\n\n你可能会发出这样的疑问：总不能每次修改过图片都要 `gulp default` 一次吧？当然不能，gulp 存在的意义就是让我们省去简单重复的劳动。\n\n使用 `watch` 方法监视目录的变化，当目录中的图片发生改变时运行 default 任务（拷贝图片）。\n\n``` js\ngulp.task('default', function() {\n  ...\n});\n\n// 监视目录\nvar watcher = gulp.watch('resources/assets/img/**');\n\nwatcher.on('change', function(event) {\n  // 在发生变化时做一些事...\n  gulp.start('default');\n});\n```\n\n然后运行 `gulp` 命令（执行配置文件的全部内容），gulp 会在运行一次 default 任务后开始监视目录，直到用 Ctrl+C 停止它。\n\n通常应该单独创建监视任务，然后执行 `gulp watch` 运行它。\n\n``` js\ngulp.task('watch', function() {\n  var watcher = gulp.watch('resources/assets/img/**');\n  watcher.on('change', function(event) {\n    gulp.start('default');\n  });\n});\n```\n\n### 压缩 JavaScript\n\n假设项目中存在以下2个存放脚本的目录。为了节约用户的流量和时间，我们希望在第二个目录中生成压缩过的 js 文件。\n\n``` yaml\nresources\\assets\\js  # 用户不可访问（开发环境使用）\npublic\\assets\\js     # 用户可以访问（生产环境使用）\n```\n\n安装 gulp-uglify 模块，用于压缩 JavaScript 文件。\n\n```\nnpm install --save-dev gulp-uglify\n```\n\n使用 `uglify` 方法压缩 js 文件。\n\n``` js\n// 加载 gulp-uglify 模块\nvar uglify = require('gulp-uglify');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/js/**')\n    .pipe(uglify())  // 压缩 JavaScript\n    .pipe(gulp.dest('public/assets/js/'));\n});\n```\n\n### 压缩 CSS\n\n假设项目中存在以下2个存放样式的目录。同样的，我们要在第二个目录中生成压缩过的 css 文件。\n\n``` yaml\nresources\\assets\\css  # 用户不可访问（开发环境使用）\npublic\\assets\\css     # 用户可以访问（生产环境使用）\n```\n\n安装 gulp-clean-css 模块，用于压缩 CSS 文件。\n\n```\nnpm install gulp-clean-css --save-dev\n```\n\n使用 `cleanCSS` 方法压缩 css 文件。\n\n``` js\n// 加载 gulp-clean-css 模块\nvar cleanCSS = require('gulp-clean-css');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/css/**')\n    .pipe(cleanCSS())  // 压缩 CSS\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 编译 Sass\n\n安装 gulp-sass 模块，用于将 scss 文件编译成 css 文件。\n\n```\nnpm install gulp-sass --save-dev\n```\n\n使用 `sass` 方法编译 scss 文件。\n\n``` js\n// 加载 gulp-sass 模块\n\nvar sass = require('gulp-sass');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/scss/**')\n    .pipe(sass())  // 编译 Sass\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 编译 Less\n\n安装 gulp-less 模块，用于将 less 文件编译成 css 文件。\n\n```\nnpm install gulp-less\n```\n\n使用 `less` 方法编译 scss 文件。\n\n``` js\n// 加载 gulp-less 模块\nvar less = require('gulp-less');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/less/**')\n    .pipe(less())  // 编译 less\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 合并文件\n\n安装 gulp-concat 模块，用于合并 JavaScript/CSS 文件。\n\n```\nnpm install --save-dev gulp-concat\n```\n\n使用 `concat` 方法合并文件，唯一的参数用于设置合并后的文件名。\n\n``` js\n// 加载 gulp-concat 模块\nvar concat = require('gulp-concat');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/js/**')\n    .pipe(concat('main.js'))  // 合并 js\n    .pipe(gulp.dest('public/assets/js/'));\n});\n```\n\n相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / gulp 3.9.1","source":"_posts/2017-05-20@gulp 小教程.md","raw":"---\ntitle: gulp 小教程\ndate: 2017-05-20 16:37:56\ncategories:\n  - Web Front-end\ntags:\n  - Gulp\n  - JavaScript\n---\n\ngulp 是一个前端代码 **自动化** 构建工具，帮助我们从令人痛苦或耗时的重复工作中解脱出来。用通俗易懂的话来说，gulp 能够帮你：拷贝资源文件、合并与压缩 JavaScript / CSS 文件、编译 CSS 预处理语言（Sass / Less）、监视文件的变化。\n\n<!-- more -->\n\n{% quote %}\n友情提示：gulp [ɡʌlp] 的读音应该是“尬噗”，而不是“顾噗”。\n{% endquote %}\n\n### 前言\n\n这玩意儿有用么？刚接触 gulp 的时候我也感到十分费解，觉得它能做的事我动动手指也搞得定。\n\n虽然这些功能看似简单，但当你管理的文件越来越多，项目越来越多的时候，你就会不时忘记做这些“简单的小事”，甚至被它们干扰思路、影响心情。所以，该由机器做的事就交给机器吧，你只需敲一行命令，琐碎的工作就能完成。\n\n使用 gulp 或类似的工具之后，变化或许是这样的：\n\n{% img /images/posts/2017/05/gulp_efficiency.png 480 耗费时间的结构变化 %}\n\n至于省下的时间用来干嘛，自己看着办咯。 : )\n\n### 安装\n\n确认电脑上已安装 [Node.js](https://nodejs.org/) 。在命令行工具中执行以下命令，全局安装 gulp-cli（gulp 命令行接口）。\n\n```\nnpm install --global gulp-cli\n```\n\n然后在项目中安装 gulp （作为开发环境的依赖模块）。当然，也可以在新建的目录中安装，gulp 将正常工作。\n\n```\nnpm install --save-dev gulp\n```\n\n注意，目录下必须存在 `package.json` 文件，否则 npm 安装时可能出错。若不存在就新建一个，内容为空对象即可。\n\n``` js\n{}\n```\n\n### 创建第一个任务\n\n在项目的根目录下新建 gulpfile.js 文件。它是 gulp 的配置文件，任何你希望 gulp 完成的工作都写在这份文档中。\n\n``` js\n// gulpfile.js\nvar gulp = require('gulp');\n\ngulp.task('default', function() {\n  // 任务内容...\n});\n```\n\n`task` 方法声明了一个名为 default 的空任务。在命令行中运行这个任务：\n\n```\ngulp default\n```\n\n通过输出的日志能够知道，default 任务已运行完毕。\n\n``` sh\n[23:39:25] Using gulpfile E:\\Code\\gulp-test\\gulpfile.js\n[23:39:25] Starting 'default'...\n[23:39:25] Finished 'default' after 78 μs\n```\n\n### 拷贝文件\n\n假设项目中存在以下2个存放图片的目录。为了用户能够正常加载图片，需要将第一个目录下的图片拷贝到第二个目录下。\n\n``` yaml\nresources\\assets\\img  # 用户不可访问（开发环境使用）\npublic\\assets\\img     # 用户可以访问（生产环境使用）\n```\n\n编辑任务，实现简单的文件拷贝。`src` 方法用于指定文件来源，`pipe` 方法用于输送文件，`dest` 方法用于写文件。`dest` 方法的参数为输出目录。显而易见，这段代码的作用是将第一个目录中的 example.jpg 拷贝到第二个目录下。\n\n``` js\ngulp.task('default', function() {\n  // 仅拷贝图片 example.jpg\n  gulp.src('resources/assets/img/example.jpg')\n    .pipe(gulp.dest('public/assets/img/'));\n});\n```\n\n运行任务，在 public\\assets\\img 目录下可以看见刚拷贝过来的 example.jpg 。\n\n如果要拷贝的图片非常多呢？使用 `**` 或 `*.jpg` 匹配目录下的全部或一整批图片。\n\n``` js\n// 拷贝全部文件\ngulp.src('resources/assets/img/**')\n  .pipe(gulp.dest('public/assets/img/'));\n\n// 拷贝所有 jpg 文件\ngulp.src('resources/assets/img/*.jpg')\n  .pipe(gulp.dest('public/assets/img/'));\n```\n\n### 监视文件\n\n你可能会发出这样的疑问：总不能每次修改过图片都要 `gulp default` 一次吧？当然不能，gulp 存在的意义就是让我们省去简单重复的劳动。\n\n使用 `watch` 方法监视目录的变化，当目录中的图片发生改变时运行 default 任务（拷贝图片）。\n\n``` js\ngulp.task('default', function() {\n  ...\n});\n\n// 监视目录\nvar watcher = gulp.watch('resources/assets/img/**');\n\nwatcher.on('change', function(event) {\n  // 在发生变化时做一些事...\n  gulp.start('default');\n});\n```\n\n然后运行 `gulp` 命令（执行配置文件的全部内容），gulp 会在运行一次 default 任务后开始监视目录，直到用 Ctrl+C 停止它。\n\n通常应该单独创建监视任务，然后执行 `gulp watch` 运行它。\n\n``` js\ngulp.task('watch', function() {\n  var watcher = gulp.watch('resources/assets/img/**');\n  watcher.on('change', function(event) {\n    gulp.start('default');\n  });\n});\n```\n\n### 压缩 JavaScript\n\n假设项目中存在以下2个存放脚本的目录。为了节约用户的流量和时间，我们希望在第二个目录中生成压缩过的 js 文件。\n\n``` yaml\nresources\\assets\\js  # 用户不可访问（开发环境使用）\npublic\\assets\\js     # 用户可以访问（生产环境使用）\n```\n\n安装 gulp-uglify 模块，用于压缩 JavaScript 文件。\n\n```\nnpm install --save-dev gulp-uglify\n```\n\n使用 `uglify` 方法压缩 js 文件。\n\n``` js\n// 加载 gulp-uglify 模块\nvar uglify = require('gulp-uglify');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/js/**')\n    .pipe(uglify())  // 压缩 JavaScript\n    .pipe(gulp.dest('public/assets/js/'));\n});\n```\n\n### 压缩 CSS\n\n假设项目中存在以下2个存放样式的目录。同样的，我们要在第二个目录中生成压缩过的 css 文件。\n\n``` yaml\nresources\\assets\\css  # 用户不可访问（开发环境使用）\npublic\\assets\\css     # 用户可以访问（生产环境使用）\n```\n\n安装 gulp-clean-css 模块，用于压缩 CSS 文件。\n\n```\nnpm install gulp-clean-css --save-dev\n```\n\n使用 `cleanCSS` 方法压缩 css 文件。\n\n``` js\n// 加载 gulp-clean-css 模块\nvar cleanCSS = require('gulp-clean-css');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/css/**')\n    .pipe(cleanCSS())  // 压缩 CSS\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 编译 Sass\n\n安装 gulp-sass 模块，用于将 scss 文件编译成 css 文件。\n\n```\nnpm install gulp-sass --save-dev\n```\n\n使用 `sass` 方法编译 scss 文件。\n\n``` js\n// 加载 gulp-sass 模块\n\nvar sass = require('gulp-sass');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/scss/**')\n    .pipe(sass())  // 编译 Sass\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 编译 Less\n\n安装 gulp-less 模块，用于将 less 文件编译成 css 文件。\n\n```\nnpm install gulp-less\n```\n\n使用 `less` 方法编译 scss 文件。\n\n``` js\n// 加载 gulp-less 模块\nvar less = require('gulp-less');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/less/**')\n    .pipe(less())  // 编译 less\n    .pipe(gulp.dest('public/assets/css/'));\n});\n```\n\n### 合并文件\n\n安装 gulp-concat 模块，用于合并 JavaScript/CSS 文件。\n\n```\nnpm install --save-dev gulp-concat\n```\n\n使用 `concat` 方法合并文件，唯一的参数用于设置合并后的文件名。\n\n``` js\n// 加载 gulp-concat 模块\nvar concat = require('gulp-concat');\n\ngulp.task('default', function() {\n  gulp.src('resources/assets/js/**')\n    .pipe(concat('main.js'))  // 合并 js\n    .pipe(gulp.dest('public/assets/js/'));\n});\n```\n\n相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / gulp 3.9.1","slug":"2017-05-20@gulp 小教程","published":1,"updated":"2020-06-29T03:32:42.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49u008rrqgjc6dq5s2w","content":"<p>gulp 是一个前端代码 <strong>自动化</strong> 构建工具，帮助我们从令人痛苦或耗时的重复工作中解脱出来。用通俗易懂的话来说，gulp 能够帮你：拷贝资源文件、合并与压缩 JavaScript / CSS 文件、编译 CSS 预处理语言（Sass / Less）、监视文件的变化。</p>\n<a id=\"more\"></a>\n\n<blockquote><p>友情提示：gulp [ɡʌlp] 的读音应该是“尬噗”，而不是“顾噗”。</p>\n</blockquote>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这玩意儿有用么？刚接触 gulp 的时候我也感到十分费解，觉得它能做的事我动动手指也搞得定。</p>\n<p>虽然这些功能看似简单，但当你管理的文件越来越多，项目越来越多的时候，你就会不时忘记做这些“简单的小事”，甚至被它们干扰思路、影响心情。所以，该由机器做的事就交给机器吧，你只需敲一行命令，琐碎的工作就能完成。</p>\n<p>使用 gulp 或类似的工具之后，变化或许是这样的：</p>\n<img src=\"/images/posts/2017/05/gulp_efficiency.png\" class=\"\" width=\"480\" title=\"耗费时间的结构变化\">\n\n<p>至于省下的时间用来干嘛，自己看着办咯。 : )</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>确认电脑上已安装 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> 。在命令行工具中执行以下命令，全局安装 gulp-cli（gulp 命令行接口）。</p>\n<pre><code>npm install --global gulp-cli</code></pre><p>然后在项目中安装 gulp （作为开发环境的依赖模块）。当然，也可以在新建的目录中安装，gulp 将正常工作。</p>\n<pre><code>npm install --save-dev gulp</code></pre><p>注意，目录下必须存在 <code>package.json</code> 文件，否则 npm 安装时可能出错。若不存在就新建一个，内容为空对象即可。</p>\n<pre><code class=\"js\">{}</code></pre>\n<h3 id=\"创建第一个任务\"><a href=\"#创建第一个任务\" class=\"headerlink\" title=\"创建第一个任务\"></a>创建第一个任务</h3><p>在项目的根目录下新建 gulpfile.js 文件。它是 gulp 的配置文件，任何你希望 gulp 完成的工作都写在这份文档中。</p>\n<pre><code class=\"js\">// gulpfile.js\nvar gulp = require(&#39;gulp&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  // 任务内容...\n});</code></pre>\n<p><code>task</code> 方法声明了一个名为 default 的空任务。在命令行中运行这个任务：</p>\n<pre><code>gulp default</code></pre><p>通过输出的日志能够知道，default 任务已运行完毕。</p>\n<pre><code class=\"sh\">[23:39:25] Using gulpfile E:\\Code\\gulp-test\\gulpfile.js\n[23:39:25] Starting &#39;default&#39;...\n[23:39:25] Finished &#39;default&#39; after 78 μs</code></pre>\n<h3 id=\"拷贝文件\"><a href=\"#拷贝文件\" class=\"headerlink\" title=\"拷贝文件\"></a>拷贝文件</h3><p>假设项目中存在以下2个存放图片的目录。为了用户能够正常加载图片，需要将第一个目录下的图片拷贝到第二个目录下。</p>\n<pre><code class=\"yaml\">resources\\assets\\img  # 用户不可访问（开发环境使用）\npublic\\assets\\img     # 用户可以访问（生产环境使用）</code></pre>\n<p>编辑任务，实现简单的文件拷贝。<code>src</code> 方法用于指定文件来源，<code>pipe</code> 方法用于输送文件，<code>dest</code> 方法用于写文件。<code>dest</code> 方法的参数为输出目录。显而易见，这段代码的作用是将第一个目录中的 example.jpg 拷贝到第二个目录下。</p>\n<pre><code class=\"js\">gulp.task(&#39;default&#39;, function() {\n  // 仅拷贝图片 example.jpg\n  gulp.src(&#39;resources/assets/img/example.jpg&#39;)\n    .pipe(gulp.dest(&#39;public/assets/img/&#39;));\n});</code></pre>\n<p>运行任务，在 public\\assets\\img 目录下可以看见刚拷贝过来的 example.jpg 。</p>\n<p>如果要拷贝的图片非常多呢？使用 <code>**</code> 或 <code>*.jpg</code> 匹配目录下的全部或一整批图片。</p>\n<pre><code class=\"js\">// 拷贝全部文件\ngulp.src(&#39;resources/assets/img/**&#39;)\n  .pipe(gulp.dest(&#39;public/assets/img/&#39;));\n\n// 拷贝所有 jpg 文件\ngulp.src(&#39;resources/assets/img/*.jpg&#39;)\n  .pipe(gulp.dest(&#39;public/assets/img/&#39;));</code></pre>\n<h3 id=\"监视文件\"><a href=\"#监视文件\" class=\"headerlink\" title=\"监视文件\"></a>监视文件</h3><p>你可能会发出这样的疑问：总不能每次修改过图片都要 <code>gulp default</code> 一次吧？当然不能，gulp 存在的意义就是让我们省去简单重复的劳动。</p>\n<p>使用 <code>watch</code> 方法监视目录的变化，当目录中的图片发生改变时运行 default 任务（拷贝图片）。</p>\n<pre><code class=\"js\">gulp.task(&#39;default&#39;, function() {\n  ...\n});\n\n// 监视目录\nvar watcher = gulp.watch(&#39;resources/assets/img/**&#39;);\n\nwatcher.on(&#39;change&#39;, function(event) {\n  // 在发生变化时做一些事...\n  gulp.start(&#39;default&#39;);\n});</code></pre>\n<p>然后运行 <code>gulp</code> 命令（执行配置文件的全部内容），gulp 会在运行一次 default 任务后开始监视目录，直到用 Ctrl+C 停止它。</p>\n<p>通常应该单独创建监视任务，然后执行 <code>gulp watch</code> 运行它。</p>\n<pre><code class=\"js\">gulp.task(&#39;watch&#39;, function() {\n  var watcher = gulp.watch(&#39;resources/assets/img/**&#39;);\n  watcher.on(&#39;change&#39;, function(event) {\n    gulp.start(&#39;default&#39;);\n  });\n});</code></pre>\n<h3 id=\"压缩-JavaScript\"><a href=\"#压缩-JavaScript\" class=\"headerlink\" title=\"压缩 JavaScript\"></a>压缩 JavaScript</h3><p>假设项目中存在以下2个存放脚本的目录。为了节约用户的流量和时间，我们希望在第二个目录中生成压缩过的 js 文件。</p>\n<pre><code class=\"yaml\">resources\\assets\\js  # 用户不可访问（开发环境使用）\npublic\\assets\\js     # 用户可以访问（生产环境使用）</code></pre>\n<p>安装 gulp-uglify 模块，用于压缩 JavaScript 文件。</p>\n<pre><code>npm install --save-dev gulp-uglify</code></pre><p>使用 <code>uglify</code> 方法压缩 js 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-uglify 模块\nvar uglify = require(&#39;gulp-uglify&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/js/**&#39;)\n    .pipe(uglify())  // 压缩 JavaScript\n    .pipe(gulp.dest(&#39;public/assets/js/&#39;));\n});</code></pre>\n<h3 id=\"压缩-CSS\"><a href=\"#压缩-CSS\" class=\"headerlink\" title=\"压缩 CSS\"></a>压缩 CSS</h3><p>假设项目中存在以下2个存放样式的目录。同样的，我们要在第二个目录中生成压缩过的 css 文件。</p>\n<pre><code class=\"yaml\">resources\\assets\\css  # 用户不可访问（开发环境使用）\npublic\\assets\\css     # 用户可以访问（生产环境使用）</code></pre>\n<p>安装 gulp-clean-css 模块，用于压缩 CSS 文件。</p>\n<pre><code>npm install gulp-clean-css --save-dev</code></pre><p>使用 <code>cleanCSS</code> 方法压缩 css 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-clean-css 模块\nvar cleanCSS = require(&#39;gulp-clean-css&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/css/**&#39;)\n    .pipe(cleanCSS())  // 压缩 CSS\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"编译-Sass\"><a href=\"#编译-Sass\" class=\"headerlink\" title=\"编译 Sass\"></a>编译 Sass</h3><p>安装 gulp-sass 模块，用于将 scss 文件编译成 css 文件。</p>\n<pre><code>npm install gulp-sass --save-dev</code></pre><p>使用 <code>sass</code> 方法编译 scss 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-sass 模块\n\nvar sass = require(&#39;gulp-sass&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/scss/**&#39;)\n    .pipe(sass())  // 编译 Sass\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"编译-Less\"><a href=\"#编译-Less\" class=\"headerlink\" title=\"编译 Less\"></a>编译 Less</h3><p>安装 gulp-less 模块，用于将 less 文件编译成 css 文件。</p>\n<pre><code>npm install gulp-less</code></pre><p>使用 <code>less</code> 方法编译 scss 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-less 模块\nvar less = require(&#39;gulp-less&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/less/**&#39;)\n    .pipe(less())  // 编译 less\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"合并文件\"><a href=\"#合并文件\" class=\"headerlink\" title=\"合并文件\"></a>合并文件</h3><p>安装 gulp-concat 模块，用于合并 JavaScript/CSS 文件。</p>\n<pre><code>npm install --save-dev gulp-concat</code></pre><p>使用 <code>concat</code> 方法合并文件，唯一的参数用于设置合并后的文件名。</p>\n<pre><code class=\"js\">// 加载 gulp-concat 模块\nvar concat = require(&#39;gulp-concat&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/js/**&#39;)\n    .pipe(concat(&#39;main.js&#39;))  // 合并 js\n    .pipe(gulp.dest(&#39;public/assets/js/&#39;));\n});</code></pre>\n<p>相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / gulp 3.9.1</p>\n","site":{"data":{}},"excerpt":"<p>gulp 是一个前端代码 <strong>自动化</strong> 构建工具，帮助我们从令人痛苦或耗时的重复工作中解脱出来。用通俗易懂的话来说，gulp 能够帮你：拷贝资源文件、合并与压缩 JavaScript / CSS 文件、编译 CSS 预处理语言（Sass / Less）、监视文件的变化。</p>","more":"<blockquote><p>友情提示：gulp [ɡʌlp] 的读音应该是“尬噗”，而不是“顾噗”。</p>\n</blockquote>\n\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这玩意儿有用么？刚接触 gulp 的时候我也感到十分费解，觉得它能做的事我动动手指也搞得定。</p>\n<p>虽然这些功能看似简单，但当你管理的文件越来越多，项目越来越多的时候，你就会不时忘记做这些“简单的小事”，甚至被它们干扰思路、影响心情。所以，该由机器做的事就交给机器吧，你只需敲一行命令，琐碎的工作就能完成。</p>\n<p>使用 gulp 或类似的工具之后，变化或许是这样的：</p>\n<img src=\"/images/posts/2017/05/gulp_efficiency.png\" class=\"\" width=\"480\" title=\"耗费时间的结构变化\">\n\n<p>至于省下的时间用来干嘛，自己看着办咯。 : )</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>确认电脑上已安装 <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> 。在命令行工具中执行以下命令，全局安装 gulp-cli（gulp 命令行接口）。</p>\n<pre><code>npm install --global gulp-cli</code></pre><p>然后在项目中安装 gulp （作为开发环境的依赖模块）。当然，也可以在新建的目录中安装，gulp 将正常工作。</p>\n<pre><code>npm install --save-dev gulp</code></pre><p>注意，目录下必须存在 <code>package.json</code> 文件，否则 npm 安装时可能出错。若不存在就新建一个，内容为空对象即可。</p>\n<pre><code class=\"js\">{}</code></pre>\n<h3 id=\"创建第一个任务\"><a href=\"#创建第一个任务\" class=\"headerlink\" title=\"创建第一个任务\"></a>创建第一个任务</h3><p>在项目的根目录下新建 gulpfile.js 文件。它是 gulp 的配置文件，任何你希望 gulp 完成的工作都写在这份文档中。</p>\n<pre><code class=\"js\">// gulpfile.js\nvar gulp = require(&#39;gulp&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  // 任务内容...\n});</code></pre>\n<p><code>task</code> 方法声明了一个名为 default 的空任务。在命令行中运行这个任务：</p>\n<pre><code>gulp default</code></pre><p>通过输出的日志能够知道，default 任务已运行完毕。</p>\n<pre><code class=\"sh\">[23:39:25] Using gulpfile E:\\Code\\gulp-test\\gulpfile.js\n[23:39:25] Starting &#39;default&#39;...\n[23:39:25] Finished &#39;default&#39; after 78 μs</code></pre>\n<h3 id=\"拷贝文件\"><a href=\"#拷贝文件\" class=\"headerlink\" title=\"拷贝文件\"></a>拷贝文件</h3><p>假设项目中存在以下2个存放图片的目录。为了用户能够正常加载图片，需要将第一个目录下的图片拷贝到第二个目录下。</p>\n<pre><code class=\"yaml\">resources\\assets\\img  # 用户不可访问（开发环境使用）\npublic\\assets\\img     # 用户可以访问（生产环境使用）</code></pre>\n<p>编辑任务，实现简单的文件拷贝。<code>src</code> 方法用于指定文件来源，<code>pipe</code> 方法用于输送文件，<code>dest</code> 方法用于写文件。<code>dest</code> 方法的参数为输出目录。显而易见，这段代码的作用是将第一个目录中的 example.jpg 拷贝到第二个目录下。</p>\n<pre><code class=\"js\">gulp.task(&#39;default&#39;, function() {\n  // 仅拷贝图片 example.jpg\n  gulp.src(&#39;resources/assets/img/example.jpg&#39;)\n    .pipe(gulp.dest(&#39;public/assets/img/&#39;));\n});</code></pre>\n<p>运行任务，在 public\\assets\\img 目录下可以看见刚拷贝过来的 example.jpg 。</p>\n<p>如果要拷贝的图片非常多呢？使用 <code>**</code> 或 <code>*.jpg</code> 匹配目录下的全部或一整批图片。</p>\n<pre><code class=\"js\">// 拷贝全部文件\ngulp.src(&#39;resources/assets/img/**&#39;)\n  .pipe(gulp.dest(&#39;public/assets/img/&#39;));\n\n// 拷贝所有 jpg 文件\ngulp.src(&#39;resources/assets/img/*.jpg&#39;)\n  .pipe(gulp.dest(&#39;public/assets/img/&#39;));</code></pre>\n<h3 id=\"监视文件\"><a href=\"#监视文件\" class=\"headerlink\" title=\"监视文件\"></a>监视文件</h3><p>你可能会发出这样的疑问：总不能每次修改过图片都要 <code>gulp default</code> 一次吧？当然不能，gulp 存在的意义就是让我们省去简单重复的劳动。</p>\n<p>使用 <code>watch</code> 方法监视目录的变化，当目录中的图片发生改变时运行 default 任务（拷贝图片）。</p>\n<pre><code class=\"js\">gulp.task(&#39;default&#39;, function() {\n  ...\n});\n\n// 监视目录\nvar watcher = gulp.watch(&#39;resources/assets/img/**&#39;);\n\nwatcher.on(&#39;change&#39;, function(event) {\n  // 在发生变化时做一些事...\n  gulp.start(&#39;default&#39;);\n});</code></pre>\n<p>然后运行 <code>gulp</code> 命令（执行配置文件的全部内容），gulp 会在运行一次 default 任务后开始监视目录，直到用 Ctrl+C 停止它。</p>\n<p>通常应该单独创建监视任务，然后执行 <code>gulp watch</code> 运行它。</p>\n<pre><code class=\"js\">gulp.task(&#39;watch&#39;, function() {\n  var watcher = gulp.watch(&#39;resources/assets/img/**&#39;);\n  watcher.on(&#39;change&#39;, function(event) {\n    gulp.start(&#39;default&#39;);\n  });\n});</code></pre>\n<h3 id=\"压缩-JavaScript\"><a href=\"#压缩-JavaScript\" class=\"headerlink\" title=\"压缩 JavaScript\"></a>压缩 JavaScript</h3><p>假设项目中存在以下2个存放脚本的目录。为了节约用户的流量和时间，我们希望在第二个目录中生成压缩过的 js 文件。</p>\n<pre><code class=\"yaml\">resources\\assets\\js  # 用户不可访问（开发环境使用）\npublic\\assets\\js     # 用户可以访问（生产环境使用）</code></pre>\n<p>安装 gulp-uglify 模块，用于压缩 JavaScript 文件。</p>\n<pre><code>npm install --save-dev gulp-uglify</code></pre><p>使用 <code>uglify</code> 方法压缩 js 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-uglify 模块\nvar uglify = require(&#39;gulp-uglify&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/js/**&#39;)\n    .pipe(uglify())  // 压缩 JavaScript\n    .pipe(gulp.dest(&#39;public/assets/js/&#39;));\n});</code></pre>\n<h3 id=\"压缩-CSS\"><a href=\"#压缩-CSS\" class=\"headerlink\" title=\"压缩 CSS\"></a>压缩 CSS</h3><p>假设项目中存在以下2个存放样式的目录。同样的，我们要在第二个目录中生成压缩过的 css 文件。</p>\n<pre><code class=\"yaml\">resources\\assets\\css  # 用户不可访问（开发环境使用）\npublic\\assets\\css     # 用户可以访问（生产环境使用）</code></pre>\n<p>安装 gulp-clean-css 模块，用于压缩 CSS 文件。</p>\n<pre><code>npm install gulp-clean-css --save-dev</code></pre><p>使用 <code>cleanCSS</code> 方法压缩 css 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-clean-css 模块\nvar cleanCSS = require(&#39;gulp-clean-css&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/css/**&#39;)\n    .pipe(cleanCSS())  // 压缩 CSS\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"编译-Sass\"><a href=\"#编译-Sass\" class=\"headerlink\" title=\"编译 Sass\"></a>编译 Sass</h3><p>安装 gulp-sass 模块，用于将 scss 文件编译成 css 文件。</p>\n<pre><code>npm install gulp-sass --save-dev</code></pre><p>使用 <code>sass</code> 方法编译 scss 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-sass 模块\n\nvar sass = require(&#39;gulp-sass&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/scss/**&#39;)\n    .pipe(sass())  // 编译 Sass\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"编译-Less\"><a href=\"#编译-Less\" class=\"headerlink\" title=\"编译 Less\"></a>编译 Less</h3><p>安装 gulp-less 模块，用于将 less 文件编译成 css 文件。</p>\n<pre><code>npm install gulp-less</code></pre><p>使用 <code>less</code> 方法编译 scss 文件。</p>\n<pre><code class=\"js\">// 加载 gulp-less 模块\nvar less = require(&#39;gulp-less&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/less/**&#39;)\n    .pipe(less())  // 编译 less\n    .pipe(gulp.dest(&#39;public/assets/css/&#39;));\n});</code></pre>\n<h3 id=\"合并文件\"><a href=\"#合并文件\" class=\"headerlink\" title=\"合并文件\"></a>合并文件</h3><p>安装 gulp-concat 模块，用于合并 JavaScript/CSS 文件。</p>\n<pre><code>npm install --save-dev gulp-concat</code></pre><p>使用 <code>concat</code> 方法合并文件，唯一的参数用于设置合并后的文件名。</p>\n<pre><code class=\"js\">// 加载 gulp-concat 模块\nvar concat = require(&#39;gulp-concat&#39;);\n\ngulp.task(&#39;default&#39;, function() {\n  gulp.src(&#39;resources/assets/js/**&#39;)\n    .pipe(concat(&#39;main.js&#39;))  // 合并 js\n    .pipe(gulp.dest(&#39;public/assets/js/&#39;));\n});</code></pre>\n<p>相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / gulp 3.9.1</p>"},{"title":"Laravel 使用 JWT 实现用户认证","date":"2017-06-11T05:00:33.000Z","_content":"\nJWT（JSON Web Token）是一个用于安全信息传输的开放标准。基于 JWT 的用户认证，用户只需登录一次，服务端生成 Token（令牌）并发送给客户端，客户端则在每次发送请求时携带该 Token ，服务端根据 Token 识别用户身份。\n\n<!-- more -->\n\n一个 JSON Web Token 是用 base64 编码的长字符串，包含了验证用户身份所需的必要信息。\n\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWx\nob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4OD\nExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ.wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4\n```\n\n这里对 JWT 规范不加赘述，只讨论如何快速实现基于 JWT 的用户认证。如果想进一步了解 JWT 规范，建议阅读 [官方文档](https://jwt.io/) 。\n\n### 安装\n\n使用 Composer 安装 jwt-auth 依赖包。\n\n```\ncomposer require tymon/jwt-auth 0.5.*\n```\n\n### 配置\n\n在 `config\\app.php` 配置文件中，注册服务提供者和门面。\n\n``` php\n'providers' => [\n  ...\n  Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class\n],\n```\n\n``` php\n'aliases' => [\n  ...\n  'JWTAuth' => Tymon\\JWTAuth\\Facades\\JWTAuth::class,\n  'JWTFactory' => Tymon\\JWTAuth\\Facades\\JWTFactory::class\n],\n```\n\n执行以下命令发布 JWT 配置文件。该命令将在 `config` 目录下生成 `jwt.php` ，通常使用默认配置即可。\n\n```\nphp artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\"\n```\n\n生成用于加密数据的密钥。\n\n```\nphp artisan jwt:generate\n```\n\n### 创建\n\n引用 `JWTAuth` 门面和异常处理类。\n\n``` php\nuse JWTAuth;\nuse Tymon\\JWTAuth\\Exceptions\\JWTException;\n```\n\n使用请求中的登录凭据（通常是邮箱和密码）创建 Token 。\n\n``` php\npublic function authenticate(Request $request)\n{\n  // 获取请求中的登录凭据\n  $credentials = $request->only('email', 'password');\n\n  try {\n    // 验证登录凭据并创建 Token\n    if (! $token = JWTAuth::attempt($credentials)) {\n      // 登录凭据无效时返回错误\n      return response()->json(['error' => 'invalid_credentials'], 401);\n    }\n  } catch (JWTException $e) {\n    // 无法正常生成 Token 时返回错误\n    return response()->json(['error' => 'could_not_create_token'], 500);\n  }\n\n  // 返回创建的 Token\n  return response()->json(compact('token'));\n}\n```\n\n登录凭据也可以是任何用户表里存在的字段，譬如手机号和密码。\n\n``` php\n$credentials = $request->only('mobile', 'password');\n```\n\n我们还可以直接基于用户模型对象创建 Token ，满足更为个性化的认证需求。\n\n``` php\n$user = User::first();\n$token = JWTAuth::fromUser($user);\nreturn $token;\n```\n\n### 认证\n\n在 `app\\Http\\Kernel.php` 中注册 JWT 提供的认证中间件。\n\n``` php\nprotected $routeMiddleware = [\n  ...\n  'jwt.auth' => \\Tymon\\JWTAuth\\Middleware\\GetUserFromToken::class\n];\n```\n\n对需要认证才能访问的路由启用该中间件。\n\n``` php\nRoute::group(['middleware' => 'jwt.auth'], function () {\n  ...\n});\n```\n\n`jwt.auth` 中间件将会解析请求中携带的 Token 。如果找不到 Token ，则返回“token_not_provided”错误；如果 Token 已过期，则返回“token_expired”错误。\n\n\n客户端在请求的头部信息或 URL 中携带有效的 Token 即可通过认证。\n\n```\nAuthorization: Bearer { Token }\n```\n\n```\nhttps://api.example.com/example?token={ Token }\n```\n\n服务端可以从 Token 中获得用户对象。\n\n``` php\n$user = JWTAuth::parseToken()->authenticate();\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.4","source":"_posts/2017-06-11@Laravel 使用 JWT 实现用户认证.md","raw":"---\ntitle: Laravel 使用 JWT 实现用户认证\ndate: 2017-06-11 13:00:33\ncategories:\n  - Web Back-end\ntags:\n  - Laravel\n  - JWT\n  - API\n---\n\nJWT（JSON Web Token）是一个用于安全信息传输的开放标准。基于 JWT 的用户认证，用户只需登录一次，服务端生成 Token（令牌）并发送给客户端，客户端则在每次发送请求时携带该 Token ，服务端根据 Token 识别用户身份。\n\n<!-- more -->\n\n一个 JSON Web Token 是用 base64 编码的长字符串，包含了验证用户身份所需的必要信息。\n\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWx\nob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4OD\nExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ.wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4\n```\n\n这里对 JWT 规范不加赘述，只讨论如何快速实现基于 JWT 的用户认证。如果想进一步了解 JWT 规范，建议阅读 [官方文档](https://jwt.io/) 。\n\n### 安装\n\n使用 Composer 安装 jwt-auth 依赖包。\n\n```\ncomposer require tymon/jwt-auth 0.5.*\n```\n\n### 配置\n\n在 `config\\app.php` 配置文件中，注册服务提供者和门面。\n\n``` php\n'providers' => [\n  ...\n  Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class\n],\n```\n\n``` php\n'aliases' => [\n  ...\n  'JWTAuth' => Tymon\\JWTAuth\\Facades\\JWTAuth::class,\n  'JWTFactory' => Tymon\\JWTAuth\\Facades\\JWTFactory::class\n],\n```\n\n执行以下命令发布 JWT 配置文件。该命令将在 `config` 目录下生成 `jwt.php` ，通常使用默认配置即可。\n\n```\nphp artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\"\n```\n\n生成用于加密数据的密钥。\n\n```\nphp artisan jwt:generate\n```\n\n### 创建\n\n引用 `JWTAuth` 门面和异常处理类。\n\n``` php\nuse JWTAuth;\nuse Tymon\\JWTAuth\\Exceptions\\JWTException;\n```\n\n使用请求中的登录凭据（通常是邮箱和密码）创建 Token 。\n\n``` php\npublic function authenticate(Request $request)\n{\n  // 获取请求中的登录凭据\n  $credentials = $request->only('email', 'password');\n\n  try {\n    // 验证登录凭据并创建 Token\n    if (! $token = JWTAuth::attempt($credentials)) {\n      // 登录凭据无效时返回错误\n      return response()->json(['error' => 'invalid_credentials'], 401);\n    }\n  } catch (JWTException $e) {\n    // 无法正常生成 Token 时返回错误\n    return response()->json(['error' => 'could_not_create_token'], 500);\n  }\n\n  // 返回创建的 Token\n  return response()->json(compact('token'));\n}\n```\n\n登录凭据也可以是任何用户表里存在的字段，譬如手机号和密码。\n\n``` php\n$credentials = $request->only('mobile', 'password');\n```\n\n我们还可以直接基于用户模型对象创建 Token ，满足更为个性化的认证需求。\n\n``` php\n$user = User::first();\n$token = JWTAuth::fromUser($user);\nreturn $token;\n```\n\n### 认证\n\n在 `app\\Http\\Kernel.php` 中注册 JWT 提供的认证中间件。\n\n``` php\nprotected $routeMiddleware = [\n  ...\n  'jwt.auth' => \\Tymon\\JWTAuth\\Middleware\\GetUserFromToken::class\n];\n```\n\n对需要认证才能访问的路由启用该中间件。\n\n``` php\nRoute::group(['middleware' => 'jwt.auth'], function () {\n  ...\n});\n```\n\n`jwt.auth` 中间件将会解析请求中携带的 Token 。如果找不到 Token ，则返回“token_not_provided”错误；如果 Token 已过期，则返回“token_expired”错误。\n\n\n客户端在请求的头部信息或 URL 中携带有效的 Token 即可通过认证。\n\n```\nAuthorization: Bearer { Token }\n```\n\n```\nhttps://api.example.com/example?token={ Token }\n```\n\n服务端可以从 Token 中获得用户对象。\n\n``` php\n$user = JWTAuth::parseToken()->authenticate();\n```\n\n相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.4","slug":"2017-06-11@Laravel 使用 JWT 实现用户认证","published":1,"updated":"2020-06-29T03:32:42.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49v008vrqgj2qld4sty","content":"<p>JWT（JSON Web Token）是一个用于安全信息传输的开放标准。基于 JWT 的用户认证，用户只需登录一次，服务端生成 Token（令牌）并发送给客户端，客户端则在每次发送请求时携带该 Token ，服务端根据 Token 识别用户身份。</p>\n<a id=\"more\"></a>\n\n<p>一个 JSON Web Token 是用 base64 编码的长字符串，包含了验证用户身份所需的必要信息。</p>\n<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWx\nob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4OD\nExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ.wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4</code></pre><p>这里对 JWT 规范不加赘述，只讨论如何快速实现基于 JWT 的用户认证。如果想进一步了解 JWT 规范，建议阅读 <a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a> 。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 Composer 安装 jwt-auth 依赖包。</p>\n<pre><code>composer require tymon/jwt-auth 0.5.*</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在 <code>config\\app.php</code> 配置文件中，注册服务提供者和门面。</p>\n<pre><code class=\"php\">&#39;providers&#39; =&gt; [\n  ...\n  Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class\n],</code></pre>\n<pre><code class=\"php\">&#39;aliases&#39; =&gt; [\n  ...\n  &#39;JWTAuth&#39; =&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class,\n  &#39;JWTFactory&#39; =&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class\n],</code></pre>\n<p>执行以下命令发布 JWT 配置文件。该命令将在 <code>config</code> 目录下生成 <code>jwt.php</code> ，通常使用默认配置即可。</p>\n<pre><code>php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider&quot;</code></pre><p>生成用于加密数据的密钥。</p>\n<pre><code>php artisan jwt:generate</code></pre><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>引用 <code>JWTAuth</code> 门面和异常处理类。</p>\n<pre><code class=\"php\">use JWTAuth;\nuse Tymon\\JWTAuth\\Exceptions\\JWTException;</code></pre>\n<p>使用请求中的登录凭据（通常是邮箱和密码）创建 Token 。</p>\n<pre><code class=\"php\">public function authenticate(Request $request)\n{\n  // 获取请求中的登录凭据\n  $credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);\n\n  try {\n    // 验证登录凭据并创建 Token\n    if (! $token = JWTAuth::attempt($credentials)) {\n      // 登录凭据无效时返回错误\n      return response()-&gt;json([&#39;error&#39; =&gt; &#39;invalid_credentials&#39;], 401);\n    }\n  } catch (JWTException $e) {\n    // 无法正常生成 Token 时返回错误\n    return response()-&gt;json([&#39;error&#39; =&gt; &#39;could_not_create_token&#39;], 500);\n  }\n\n  // 返回创建的 Token\n  return response()-&gt;json(compact(&#39;token&#39;));\n}</code></pre>\n<p>登录凭据也可以是任何用户表里存在的字段，譬如手机号和密码。</p>\n<pre><code class=\"php\">$credentials = $request-&gt;only(&#39;mobile&#39;, &#39;password&#39;);</code></pre>\n<p>我们还可以直接基于用户模型对象创建 Token ，满足更为个性化的认证需求。</p>\n<pre><code class=\"php\">$user = User::first();\n$token = JWTAuth::fromUser($user);\nreturn $token;</code></pre>\n<h3 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h3><p>在 <code>app\\Http\\Kernel.php</code> 中注册 JWT 提供的认证中间件。</p>\n<pre><code class=\"php\">protected $routeMiddleware = [\n  ...\n  &#39;jwt.auth&#39; =&gt; \\Tymon\\JWTAuth\\Middleware\\GetUserFromToken::class\n];</code></pre>\n<p>对需要认证才能访问的路由启用该中间件。</p>\n<pre><code class=\"php\">Route::group([&#39;middleware&#39; =&gt; &#39;jwt.auth&#39;], function () {\n  ...\n});</code></pre>\n<p><code>jwt.auth</code> 中间件将会解析请求中携带的 Token 。如果找不到 Token ，则返回“token_not_provided”错误；如果 Token 已过期，则返回“token_expired”错误。</p>\n<p>客户端在请求的头部信息或 URL 中携带有效的 Token 即可通过认证。</p>\n<pre><code>Authorization: Bearer { Token }</code></pre><pre><code>https://api.example.com/example?token={ Token }</code></pre><p>服务端可以从 Token 中获得用户对象。</p>\n<pre><code class=\"php\">$user = JWTAuth::parseToken()-&gt;authenticate();</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.4</p>\n","site":{"data":{}},"excerpt":"<p>JWT（JSON Web Token）是一个用于安全信息传输的开放标准。基于 JWT 的用户认证，用户只需登录一次，服务端生成 Token（令牌）并发送给客户端，客户端则在每次发送请求时携带该 Token ，服务端根据 Token 识别用户身份。</p>","more":"<p>一个 JSON Web Token 是用 base64 编码的长字符串，包含了验证用户身份所需的必要信息。</p>\n<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaXNzIjoiaHR0cDpcL1wvbG9jYWx\nob3N0OjgwMDFcL2F1dGhcL2xvZ2luIiwiaWF0IjoxNDUxODg4MTE5LCJleHAiOjE0NTQ1MTYxMTksIm5iZiI6MTQ1MTg4OD\nExOSwianRpIjoiMzdjMTA3ZTQ2MDlkZGJjYzljMDk2ZWE1ZWU3NmM2NjcifQ.wyoQ95RjAyQ2FF3aj8EvCSaUmeP0KUqcCJDENNfnaT4</code></pre><p>这里对 JWT 规范不加赘述，只讨论如何快速实现基于 JWT 的用户认证。如果想进一步了解 JWT 规范，建议阅读 <a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a> 。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 Composer 安装 jwt-auth 依赖包。</p>\n<pre><code>composer require tymon/jwt-auth 0.5.*</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在 <code>config\\app.php</code> 配置文件中，注册服务提供者和门面。</p>\n<pre><code class=\"php\">&#39;providers&#39; =&gt; [\n  ...\n  Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class\n],</code></pre>\n<pre><code class=\"php\">&#39;aliases&#39; =&gt; [\n  ...\n  &#39;JWTAuth&#39; =&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class,\n  &#39;JWTFactory&#39; =&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class\n],</code></pre>\n<p>执行以下命令发布 JWT 配置文件。该命令将在 <code>config</code> 目录下生成 <code>jwt.php</code> ，通常使用默认配置即可。</p>\n<pre><code>php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider&quot;</code></pre><p>生成用于加密数据的密钥。</p>\n<pre><code>php artisan jwt:generate</code></pre><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>引用 <code>JWTAuth</code> 门面和异常处理类。</p>\n<pre><code class=\"php\">use JWTAuth;\nuse Tymon\\JWTAuth\\Exceptions\\JWTException;</code></pre>\n<p>使用请求中的登录凭据（通常是邮箱和密码）创建 Token 。</p>\n<pre><code class=\"php\">public function authenticate(Request $request)\n{\n  // 获取请求中的登录凭据\n  $credentials = $request-&gt;only(&#39;email&#39;, &#39;password&#39;);\n\n  try {\n    // 验证登录凭据并创建 Token\n    if (! $token = JWTAuth::attempt($credentials)) {\n      // 登录凭据无效时返回错误\n      return response()-&gt;json([&#39;error&#39; =&gt; &#39;invalid_credentials&#39;], 401);\n    }\n  } catch (JWTException $e) {\n    // 无法正常生成 Token 时返回错误\n    return response()-&gt;json([&#39;error&#39; =&gt; &#39;could_not_create_token&#39;], 500);\n  }\n\n  // 返回创建的 Token\n  return response()-&gt;json(compact(&#39;token&#39;));\n}</code></pre>\n<p>登录凭据也可以是任何用户表里存在的字段，譬如手机号和密码。</p>\n<pre><code class=\"php\">$credentials = $request-&gt;only(&#39;mobile&#39;, &#39;password&#39;);</code></pre>\n<p>我们还可以直接基于用户模型对象创建 Token ，满足更为个性化的认证需求。</p>\n<pre><code class=\"php\">$user = User::first();\n$token = JWTAuth::fromUser($user);\nreturn $token;</code></pre>\n<h3 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h3><p>在 <code>app\\Http\\Kernel.php</code> 中注册 JWT 提供的认证中间件。</p>\n<pre><code class=\"php\">protected $routeMiddleware = [\n  ...\n  &#39;jwt.auth&#39; =&gt; \\Tymon\\JWTAuth\\Middleware\\GetUserFromToken::class\n];</code></pre>\n<p>对需要认证才能访问的路由启用该中间件。</p>\n<pre><code class=\"php\">Route::group([&#39;middleware&#39; =&gt; &#39;jwt.auth&#39;], function () {\n  ...\n});</code></pre>\n<p><code>jwt.auth</code> 中间件将会解析请求中携带的 Token 。如果找不到 Token ，则返回“token_not_provided”错误；如果 Token 已过期，则返回“token_expired”错误。</p>\n<p>客户端在请求的头部信息或 URL 中携带有效的 Token 即可通过认证。</p>\n<pre><code>Authorization: Bearer { Token }</code></pre><pre><code>https://api.example.com/example?token={ Token }</code></pre><p>服务端可以从 Token 中获得用户对象。</p>\n<pre><code class=\"php\">$user = JWTAuth::parseToken()-&gt;authenticate();</code></pre>\n<p>相关环境：Windows 7 x64 / VirtualBox 5.1.8 / Laravel Homestead / Laravel 5.4</p>"},{"title":"在移动端实现 0.5 像素细边框","date":"2017-06-26T16:02:28.000Z","_content":"\n在移动端，1px 的直线在物理屏幕上通常会显示成 2px（甚至更粗）。这是因为手机屏幕的物理分辨率（硬件支持的）通常是其逻辑分辨率（软件支持的）的数倍。\n\n<!-- more -->\n\n以 iPhone 6 为例，其逻辑分辨率为 667×375 ，物理分辨率为 1334x750 。这意味着物理屏幕使用 2x2 个像素点显示 1 像素的内容。换言之，如果我们希望在物理屏幕上显示 1 像素的边框，就必须在逻辑上实现 0.5 像素的边框。\n\n除了 iPhone（iOS8以上），目前绝大多数的移动设备并不支持直接渲染 0.5px 的边框。\n\n``` css\n/* 兼容性差 */\nborder: 0.5px solid #e6e6e6;\n```\n\n事实上，存在不止一种方法用于在移动端实现 0.5px 的细边框。思路基本上还是先渲染 1px 边框，然后设法将线条的宽度减少或隐藏 50% 。下面推荐两种我在移动端 Web 和小程序中常用、兼容性较优的方法。\n\n### 缩放法\n\n假设存在一个列表，其中的每一条项目都要有一个灰色下边框。\n\n我们使用 `after` 选择器在每个 item 后面插入一个宽度 100% ，高度 1px ，灰色背景的伪元素，先在视觉上实现 1 像素的下边框。然后使用 `transform` 属性的 `scale` 缩放，将伪元素的高度缩放到原来的 50% ，就可以在视觉上得到 0.5 像素的下边框。\n\n``` css\n/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: #e6e6e6;\n  transform: scaleY(0.5);\n}\n```\n\n### 渐变法\n\n类似的，先使用伪元素实现 1 像素的下边框。然后使用 `linear-gradient` 声明一个渐变色背景，由透明色（transparent）以及灰色组成。由于灰色只占这条 1 像素的下边框的一半，在视觉上也就得到了 0.5 像素的下边框。\n\n``` css\n/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: linear-gradient(transparent 0%, #e6e6e6 50%);\n}\n```\n\n相关环境：Windows 7 x64 / WeChat Web DevTools 0.18 / WeChat 6.5.8\n","source":"_posts/2017-06-27@移动端实现0.5像素细边框.md","raw":"---\ntitle: 在移动端实现 0.5 像素细边框\ndate: 2017-06-27 00:02:28\ncategories:\n  - Web Front-end\ntags:\n  - CSS\n  - 小程序\n---\n\n在移动端，1px 的直线在物理屏幕上通常会显示成 2px（甚至更粗）。这是因为手机屏幕的物理分辨率（硬件支持的）通常是其逻辑分辨率（软件支持的）的数倍。\n\n<!-- more -->\n\n以 iPhone 6 为例，其逻辑分辨率为 667×375 ，物理分辨率为 1334x750 。这意味着物理屏幕使用 2x2 个像素点显示 1 像素的内容。换言之，如果我们希望在物理屏幕上显示 1 像素的边框，就必须在逻辑上实现 0.5 像素的边框。\n\n除了 iPhone（iOS8以上），目前绝大多数的移动设备并不支持直接渲染 0.5px 的边框。\n\n``` css\n/* 兼容性差 */\nborder: 0.5px solid #e6e6e6;\n```\n\n事实上，存在不止一种方法用于在移动端实现 0.5px 的细边框。思路基本上还是先渲染 1px 边框，然后设法将线条的宽度减少或隐藏 50% 。下面推荐两种我在移动端 Web 和小程序中常用、兼容性较优的方法。\n\n### 缩放法\n\n假设存在一个列表，其中的每一条项目都要有一个灰色下边框。\n\n我们使用 `after` 选择器在每个 item 后面插入一个宽度 100% ，高度 1px ，灰色背景的伪元素，先在视觉上实现 1 像素的下边框。然后使用 `transform` 属性的 `scale` 缩放，将伪元素的高度缩放到原来的 50% ，就可以在视觉上得到 0.5 像素的下边框。\n\n``` css\n/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: #e6e6e6;\n  transform: scaleY(0.5);\n}\n```\n\n### 渐变法\n\n类似的，先使用伪元素实现 1 像素的下边框。然后使用 `linear-gradient` 声明一个渐变色背景，由透明色（transparent）以及灰色组成。由于灰色只占这条 1 像素的下边框的一半，在视觉上也就得到了 0.5 像素的下边框。\n\n``` css\n/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: '';\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: linear-gradient(transparent 0%, #e6e6e6 50%);\n}\n```\n\n相关环境：Windows 7 x64 / WeChat Web DevTools 0.18 / WeChat 6.5.8\n","slug":"2017-06-27@移动端实现0.5像素细边框","published":1,"updated":"2020-06-29T03:32:42.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49w008yrqgjc3qj3ccn","content":"<p>在移动端，1px 的直线在物理屏幕上通常会显示成 2px（甚至更粗）。这是因为手机屏幕的物理分辨率（硬件支持的）通常是其逻辑分辨率（软件支持的）的数倍。</p>\n<a id=\"more\"></a>\n\n<p>以 iPhone 6 为例，其逻辑分辨率为 667×375 ，物理分辨率为 1334x750 。这意味着物理屏幕使用 2x2 个像素点显示 1 像素的内容。换言之，如果我们希望在物理屏幕上显示 1 像素的边框，就必须在逻辑上实现 0.5 像素的边框。</p>\n<p>除了 iPhone（iOS8以上），目前绝大多数的移动设备并不支持直接渲染 0.5px 的边框。</p>\n<pre><code class=\"css\">/* 兼容性差 */\nborder: 0.5px solid #e6e6e6;</code></pre>\n<p>事实上，存在不止一种方法用于在移动端实现 0.5px 的细边框。思路基本上还是先渲染 1px 边框，然后设法将线条的宽度减少或隐藏 50% 。下面推荐两种我在移动端 Web 和小程序中常用、兼容性较优的方法。</p>\n<h3 id=\"缩放法\"><a href=\"#缩放法\" class=\"headerlink\" title=\"缩放法\"></a>缩放法</h3><p>假设存在一个列表，其中的每一条项目都要有一个灰色下边框。</p>\n<p>我们使用 <code>after</code> 选择器在每个 item 后面插入一个宽度 100% ，高度 1px ，灰色背景的伪元素，先在视觉上实现 1 像素的下边框。然后使用 <code>transform</code> 属性的 <code>scale</code> 缩放，将伪元素的高度缩放到原来的 50% ，就可以在视觉上得到 0.5 像素的下边框。</p>\n<pre><code class=\"css\">/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: &#39;&#39;;\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: #e6e6e6;\n  transform: scaleY(0.5);\n}</code></pre>\n<h3 id=\"渐变法\"><a href=\"#渐变法\" class=\"headerlink\" title=\"渐变法\"></a>渐变法</h3><p>类似的，先使用伪元素实现 1 像素的下边框。然后使用 <code>linear-gradient</code> 声明一个渐变色背景，由透明色（transparent）以及灰色组成。由于灰色只占这条 1 像素的下边框的一半，在视觉上也就得到了 0.5 像素的下边框。</p>\n<pre><code class=\"css\">/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: &#39;&#39;;\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: linear-gradient(transparent 0%, #e6e6e6 50%);\n}</code></pre>\n<p>相关环境：Windows 7 x64 / WeChat Web DevTools 0.18 / WeChat 6.5.8</p>\n","site":{"data":{}},"excerpt":"<p>在移动端，1px 的直线在物理屏幕上通常会显示成 2px（甚至更粗）。这是因为手机屏幕的物理分辨率（硬件支持的）通常是其逻辑分辨率（软件支持的）的数倍。</p>","more":"<p>以 iPhone 6 为例，其逻辑分辨率为 667×375 ，物理分辨率为 1334x750 。这意味着物理屏幕使用 2x2 个像素点显示 1 像素的内容。换言之，如果我们希望在物理屏幕上显示 1 像素的边框，就必须在逻辑上实现 0.5 像素的边框。</p>\n<p>除了 iPhone（iOS8以上），目前绝大多数的移动设备并不支持直接渲染 0.5px 的边框。</p>\n<pre><code class=\"css\">/* 兼容性差 */\nborder: 0.5px solid #e6e6e6;</code></pre>\n<p>事实上，存在不止一种方法用于在移动端实现 0.5px 的细边框。思路基本上还是先渲染 1px 边框，然后设法将线条的宽度减少或隐藏 50% 。下面推荐两种我在移动端 Web 和小程序中常用、兼容性较优的方法。</p>\n<h3 id=\"缩放法\"><a href=\"#缩放法\" class=\"headerlink\" title=\"缩放法\"></a>缩放法</h3><p>假设存在一个列表，其中的每一条项目都要有一个灰色下边框。</p>\n<p>我们使用 <code>after</code> 选择器在每个 item 后面插入一个宽度 100% ，高度 1px ，灰色背景的伪元素，先在视觉上实现 1 像素的下边框。然后使用 <code>transform</code> 属性的 <code>scale</code> 缩放，将伪元素的高度缩放到原来的 50% ，就可以在视觉上得到 0.5 像素的下边框。</p>\n<pre><code class=\"css\">/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: &#39;&#39;;\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: #e6e6e6;\n  transform: scaleY(0.5);\n}</code></pre>\n<h3 id=\"渐变法\"><a href=\"#渐变法\" class=\"headerlink\" title=\"渐变法\"></a>渐变法</h3><p>类似的，先使用伪元素实现 1 像素的下边框。然后使用 <code>linear-gradient</code> 声明一个渐变色背景，由透明色（transparent）以及灰色组成。由于灰色只占这条 1 像素的下边框的一半，在视觉上也就得到了 0.5 像素的下边框。</p>\n<pre><code class=\"css\">/* 项目 */\n.item {\n  height: 50px;\n  line-height: 50px;\n  position: relative;\n}\n\n/* 下边框 */\n.item::after {\n  position: absolute;\n  content: &#39;&#39;;\n  width: 100%;\n  left: 0;\n  bottom: 0;\n  height: 1px;\n  background: linear-gradient(transparent 0%, #e6e6e6 50%);\n}</code></pre>\n<p>相关环境：Windows 7 x64 / WeChat Web DevTools 0.18 / WeChat 6.5.8</p>"},{"title":"CSS 自定义滚动条样式","date":"2017-09-03T05:18:30.000Z","_content":"\n相比 Mac，Win 系统浏览器的默认滚动条比较粗犷，很多时候和页面设计不搭调，给用户体验减分不少。为了改善页面的整体效果，我决定用 CSS 稍微修改一下滚动条的样式。\n\n<!-- more -->\n\n`-webkit-scrollbar` 是一个作用于滚动条样式的伪元素。它并非一个通用的 CSS 标准，只作用于部分浏览器（WebKit 内核）。目前市场上六成以上的浏览器为 WebKit 内核，所以这个特性已经足够给大部分用户呈现一致、美观的滚动条了。\n\n首先，使用 `-webkit-scrollbar` 伪元素自定义滚动条整体的宽度和背景色。\n\n``` css\n::-webkit-scrollbar {\n  width: 8px;  /* 纵向滚动条宽度 */\n  height: 8px; /* 横向滚动条宽度 */\n  background: #fafafa;\n}\n```\n\n然后，使用 `-webkit-scrollbar-track` 伪元素自定义滚动条轨道的样式，这里声明了圆角和背景色。\n\n``` css\n::-webkit-scrollbar-track {\n  border-radius: 10px;\n  background: #fafafa;\n}\n```\n\n最后，使用 `-webkit-scrollbar-thumb` 伪元素自定义滚动条中间拖动部分的样式。\n\n``` css\n::-webkit-scrollbar-thumb {\n  border-radius: 10px;\n  background: #c1c1c1;\n}\n```\n\n这样就完成了简单的滚动条样式修改，页面也变得美观不少。\n\n如果不希望修改作用于全局，也可以单独定义某个元素的滚动条样式。\n\n``` css\n.element::-webkit-scrollbar {\n  display: none; /* 隐藏滚动条 */\n}\n```\n\n对于大部分需求来说，这些东西已然够用了。当然，还存在 `-webkit-scrollbar-button`、`-webkit-scrollbar-track-piece`、`-webkit-scrollbar-corner` 等相关伪元素，感兴趣的话可以自行了解。\n\n相关环境：Windows 7 x64 / Chrome 60","source":"_posts/2017-09-03@CSS3 自定义滚动条样式.md","raw":"---\ntitle: CSS 自定义滚动条样式\ndate: 2017-09-03 13:18:30\ncategories:\n  - Web Front-end\ntags:\n\t- CSS\n---\n\n相比 Mac，Win 系统浏览器的默认滚动条比较粗犷，很多时候和页面设计不搭调，给用户体验减分不少。为了改善页面的整体效果，我决定用 CSS 稍微修改一下滚动条的样式。\n\n<!-- more -->\n\n`-webkit-scrollbar` 是一个作用于滚动条样式的伪元素。它并非一个通用的 CSS 标准，只作用于部分浏览器（WebKit 内核）。目前市场上六成以上的浏览器为 WebKit 内核，所以这个特性已经足够给大部分用户呈现一致、美观的滚动条了。\n\n首先，使用 `-webkit-scrollbar` 伪元素自定义滚动条整体的宽度和背景色。\n\n``` css\n::-webkit-scrollbar {\n  width: 8px;  /* 纵向滚动条宽度 */\n  height: 8px; /* 横向滚动条宽度 */\n  background: #fafafa;\n}\n```\n\n然后，使用 `-webkit-scrollbar-track` 伪元素自定义滚动条轨道的样式，这里声明了圆角和背景色。\n\n``` css\n::-webkit-scrollbar-track {\n  border-radius: 10px;\n  background: #fafafa;\n}\n```\n\n最后，使用 `-webkit-scrollbar-thumb` 伪元素自定义滚动条中间拖动部分的样式。\n\n``` css\n::-webkit-scrollbar-thumb {\n  border-radius: 10px;\n  background: #c1c1c1;\n}\n```\n\n这样就完成了简单的滚动条样式修改，页面也变得美观不少。\n\n如果不希望修改作用于全局，也可以单独定义某个元素的滚动条样式。\n\n``` css\n.element::-webkit-scrollbar {\n  display: none; /* 隐藏滚动条 */\n}\n```\n\n对于大部分需求来说，这些东西已然够用了。当然，还存在 `-webkit-scrollbar-button`、`-webkit-scrollbar-track-piece`、`-webkit-scrollbar-corner` 等相关伪元素，感兴趣的话可以自行了解。\n\n相关环境：Windows 7 x64 / Chrome 60","slug":"2017-09-03@CSS3 自定义滚动条样式","published":1,"updated":"2020-06-29T03:32:42.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49x0092rqgj00gigcox","content":"<p>相比 Mac，Win 系统浏览器的默认滚动条比较粗犷，很多时候和页面设计不搭调，给用户体验减分不少。为了改善页面的整体效果，我决定用 CSS 稍微修改一下滚动条的样式。</p>\n<a id=\"more\"></a>\n\n<p><code>-webkit-scrollbar</code> 是一个作用于滚动条样式的伪元素。它并非一个通用的 CSS 标准，只作用于部分浏览器（WebKit 内核）。目前市场上六成以上的浏览器为 WebKit 内核，所以这个特性已经足够给大部分用户呈现一致、美观的滚动条了。</p>\n<p>首先，使用 <code>-webkit-scrollbar</code> 伪元素自定义滚动条整体的宽度和背景色。</p>\n<pre><code class=\"css\">::-webkit-scrollbar {\n  width: 8px;  /* 纵向滚动条宽度 */\n  height: 8px; /* 横向滚动条宽度 */\n  background: #fafafa;\n}</code></pre>\n<p>然后，使用 <code>-webkit-scrollbar-track</code> 伪元素自定义滚动条轨道的样式，这里声明了圆角和背景色。</p>\n<pre><code class=\"css\">::-webkit-scrollbar-track {\n  border-radius: 10px;\n  background: #fafafa;\n}</code></pre>\n<p>最后，使用 <code>-webkit-scrollbar-thumb</code> 伪元素自定义滚动条中间拖动部分的样式。</p>\n<pre><code class=\"css\">::-webkit-scrollbar-thumb {\n  border-radius: 10px;\n  background: #c1c1c1;\n}</code></pre>\n<p>这样就完成了简单的滚动条样式修改，页面也变得美观不少。</p>\n<p>如果不希望修改作用于全局，也可以单独定义某个元素的滚动条样式。</p>\n<pre><code class=\"css\">.element::-webkit-scrollbar {\n  display: none; /* 隐藏滚动条 */\n}</code></pre>\n<p>对于大部分需求来说，这些东西已然够用了。当然，还存在 <code>-webkit-scrollbar-button</code>、<code>-webkit-scrollbar-track-piece</code>、<code>-webkit-scrollbar-corner</code> 等相关伪元素，感兴趣的话可以自行了解。</p>\n<p>相关环境：Windows 7 x64 / Chrome 60</p>\n","site":{"data":{}},"excerpt":"<p>相比 Mac，Win 系统浏览器的默认滚动条比较粗犷，很多时候和页面设计不搭调，给用户体验减分不少。为了改善页面的整体效果，我决定用 CSS 稍微修改一下滚动条的样式。</p>","more":"<p><code>-webkit-scrollbar</code> 是一个作用于滚动条样式的伪元素。它并非一个通用的 CSS 标准，只作用于部分浏览器（WebKit 内核）。目前市场上六成以上的浏览器为 WebKit 内核，所以这个特性已经足够给大部分用户呈现一致、美观的滚动条了。</p>\n<p>首先，使用 <code>-webkit-scrollbar</code> 伪元素自定义滚动条整体的宽度和背景色。</p>\n<pre><code class=\"css\">::-webkit-scrollbar {\n  width: 8px;  /* 纵向滚动条宽度 */\n  height: 8px; /* 横向滚动条宽度 */\n  background: #fafafa;\n}</code></pre>\n<p>然后，使用 <code>-webkit-scrollbar-track</code> 伪元素自定义滚动条轨道的样式，这里声明了圆角和背景色。</p>\n<pre><code class=\"css\">::-webkit-scrollbar-track {\n  border-radius: 10px;\n  background: #fafafa;\n}</code></pre>\n<p>最后，使用 <code>-webkit-scrollbar-thumb</code> 伪元素自定义滚动条中间拖动部分的样式。</p>\n<pre><code class=\"css\">::-webkit-scrollbar-thumb {\n  border-radius: 10px;\n  background: #c1c1c1;\n}</code></pre>\n<p>这样就完成了简单的滚动条样式修改，页面也变得美观不少。</p>\n<p>如果不希望修改作用于全局，也可以单独定义某个元素的滚动条样式。</p>\n<pre><code class=\"css\">.element::-webkit-scrollbar {\n  display: none; /* 隐藏滚动条 */\n}</code></pre>\n<p>对于大部分需求来说，这些东西已然够用了。当然，还存在 <code>-webkit-scrollbar-button</code>、<code>-webkit-scrollbar-track-piece</code>、<code>-webkit-scrollbar-corner</code> 等相关伪元素，感兴趣的话可以自行了解。</p>\n<p>相关环境：Windows 7 x64 / Chrome 60</p>"},{"title":"解决 iOS 下日期对象 Invalid Date 错误","date":"2017-09-28T13:41:26.000Z","_content":"\nJavaScript 中的 Date 对象用于处理日期和时间，对前端开发而言几乎是每天都要打交道的一个东西，但它存在着一个奇葩、不易被注意到的兼容性问题。这是今天在处理产品经理提出的 bug 时偶然发现的。\n\n<!-- more -->\n\n\n下面这行简单的代码，仅仅用于定义一个日期对象。它在 iOS 下可能无法正确执行。\n\n``` js\nnew Date('2017-09-28') // Windows、Android 返回日期对象，iOS 返回 Invalid Date 。\n```\n\n在 iOS 环境下（先后使用 iPhone6、iPhone6 Plus 测试），这行代码始终返回 Invalid Date（无效的日期）。很显然，系统不能正确解析 `2017-09-28` 这个日期字符串。\n\n解决方法也非常简单，换一种 iOS 能够解析的日期格式即可，使用 `/` 代替日期字符串中的 `-` ：\n\n``` js\nnew Date('2017/09/28')\n```\n\n由于存储在数据库中的日期通常使用 `-` 分隔年月日，为避免出现兼容问题，前端渲染时应该默认使用 `replace` 方法批量替换。\n\n``` js\nconst str = '2017-09-28'\nnew Date(str.replace(/-/g, '/'))\n```","source":"_posts/2017-09-28@解决 iOS 下日期对象 Invalid Date 错误.md","raw":"---\ntitle: 解决 iOS 下日期对象 Invalid Date 错误\ndate: 2017-09-28 21:41:26\ncategories:\n  - Web Front-end\ntags:\n\t- JavaScript\n---\n\nJavaScript 中的 Date 对象用于处理日期和时间，对前端开发而言几乎是每天都要打交道的一个东西，但它存在着一个奇葩、不易被注意到的兼容性问题。这是今天在处理产品经理提出的 bug 时偶然发现的。\n\n<!-- more -->\n\n\n下面这行简单的代码，仅仅用于定义一个日期对象。它在 iOS 下可能无法正确执行。\n\n``` js\nnew Date('2017-09-28') // Windows、Android 返回日期对象，iOS 返回 Invalid Date 。\n```\n\n在 iOS 环境下（先后使用 iPhone6、iPhone6 Plus 测试），这行代码始终返回 Invalid Date（无效的日期）。很显然，系统不能正确解析 `2017-09-28` 这个日期字符串。\n\n解决方法也非常简单，换一种 iOS 能够解析的日期格式即可，使用 `/` 代替日期字符串中的 `-` ：\n\n``` js\nnew Date('2017/09/28')\n```\n\n由于存储在数据库中的日期通常使用 `-` 分隔年月日，为避免出现兼容问题，前端渲染时应该默认使用 `replace` 方法批量替换。\n\n``` js\nconst str = '2017-09-28'\nnew Date(str.replace(/-/g, '/'))\n```","slug":"2017-09-28@解决 iOS 下日期对象 Invalid Date 错误","published":1,"updated":"2020-06-29T03:32:42.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49x0095rqgj6x2l9xup","content":"<p>JavaScript 中的 Date 对象用于处理日期和时间，对前端开发而言几乎是每天都要打交道的一个东西，但它存在着一个奇葩、不易被注意到的兼容性问题。这是今天在处理产品经理提出的 bug 时偶然发现的。</p>\n<a id=\"more\"></a>\n\n\n<p>下面这行简单的代码，仅仅用于定义一个日期对象。它在 iOS 下可能无法正确执行。</p>\n<pre><code class=\"js\">new Date(&#39;2017-09-28&#39;) // Windows、Android 返回日期对象，iOS 返回 Invalid Date 。</code></pre>\n<p>在 iOS 环境下（先后使用 iPhone6、iPhone6 Plus 测试），这行代码始终返回 Invalid Date（无效的日期）。很显然，系统不能正确解析 <code>2017-09-28</code> 这个日期字符串。</p>\n<p>解决方法也非常简单，换一种 iOS 能够解析的日期格式即可，使用 <code>/</code> 代替日期字符串中的 <code>-</code> ：</p>\n<pre><code class=\"js\">new Date(&#39;2017/09/28&#39;)</code></pre>\n<p>由于存储在数据库中的日期通常使用 <code>-</code> 分隔年月日，为避免出现兼容问题，前端渲染时应该默认使用 <code>replace</code> 方法批量替换。</p>\n<pre><code class=\"js\">const str = &#39;2017-09-28&#39;\nnew Date(str.replace(/-/g, &#39;/&#39;))</code></pre>\n","site":{"data":{}},"excerpt":"<p>JavaScript 中的 Date 对象用于处理日期和时间，对前端开发而言几乎是每天都要打交道的一个东西，但它存在着一个奇葩、不易被注意到的兼容性问题。这是今天在处理产品经理提出的 bug 时偶然发现的。</p>","more":"<p>下面这行简单的代码，仅仅用于定义一个日期对象。它在 iOS 下可能无法正确执行。</p>\n<pre><code class=\"js\">new Date(&#39;2017-09-28&#39;) // Windows、Android 返回日期对象，iOS 返回 Invalid Date 。</code></pre>\n<p>在 iOS 环境下（先后使用 iPhone6、iPhone6 Plus 测试），这行代码始终返回 Invalid Date（无效的日期）。很显然，系统不能正确解析 <code>2017-09-28</code> 这个日期字符串。</p>\n<p>解决方法也非常简单，换一种 iOS 能够解析的日期格式即可，使用 <code>/</code> 代替日期字符串中的 <code>-</code> ：</p>\n<pre><code class=\"js\">new Date(&#39;2017/09/28&#39;)</code></pre>\n<p>由于存储在数据库中的日期通常使用 <code>-</code> 分隔年月日，为避免出现兼容问题，前端渲染时应该默认使用 <code>replace</code> 方法批量替换。</p>\n<pre><code class=\"js\">const str = &#39;2017-09-28&#39;\nnew Date(str.replace(/-/g, &#39;/&#39;))</code></pre>"},{"title":"JavaScript / Vue.js 实现时分秒倒计时","date":"2017-11-03T15:45:19.000Z","_content":"\n我们平常浏览网页的时候，经常见到“距游戏公测1天2小时3分钟4秒”这样的倒计时器。时间如沙漏般一点点的减少，不仅能挑起用户的兴趣，而且让页面提升了一点逼格，还填补掉一些尴尬的空白位置。最近写得越来越多，有用没用都让加个倒计时，干脆记录下来，免得重复造轮子。\n\n<!-- more -->\n\n\n实现的方法并不复杂，关键是理解如何计算，尤其对我这种数学不好的人而言。下面两个 demo 将分别用纯 JavaScript 、基于 Vue.js 的 JavaScript 实现。注，代码中可能包含部分 ES6 语法，但相信很容易理解。\n\n\n### JavaScript\n\n创建一个 `countdown` 方法，用于计算并在控制台打印距目标时间的日、时、分、秒数，每隔一秒递归执行一次。\n\n`msec` 是当前时间距目标时间的毫秒数，由时间戳相减得到，我们将以这个数为基础计算。我们都知道1天等于24小时，1小时等于60分钟，1分钟等于60秒，1秒等于1000毫秒。所以，`msec / 1000 / 60 / 60 / 24` 保留整数就是天数。如果换用 `%` 取余数，再保留整数后得到的就是小时数。以此类推就能算出其他所有数。\n\n``` js\nfunction countdown () {\n  // 目标日期时间戳\n  const end = Date.parse(new Date('2017-12-01'))\n  // 当前时间戳\n  const now = Date.parse(new Date())\n  // 相差的毫秒数\n  const msec = end - now\n  // 计算时分秒数\n  let day = parseInt(msec / 1000 / 60 / 60 / 24)\n  let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n  let min = parseInt(msec / 1000 / 60 % 60)\n  let sec = parseInt(msec / 1000 % 60)\n  // 个位数前补零\n  hr = hr > 9 ? hr : '0' + hr\n  min = min > 9 ? min : '0' + min\n  sec = sec > 9 ? sec : '0' + sec\n  // 控制台打印\n  console.log(`${day}天 ${hr}小时 ${min}分钟 ${sec}秒`)\n  // 一秒后递归\n  setTimeout(function () {\n    countdown()\n  }, 1000)\n}\n```\n\n控制台打印结果：\n\n```\n27天 07小时 49分钟 10秒\n27天 07小时 49分钟 09秒\n27天 07小时 49分钟 08秒\n...\n```\n\n### Vue.js\n\n如果单纯使用 JavaScript ，我们需要在每次计算后手动更新 DOM 元素（将数据显示给用户），既不方便又难以维护。实际项目中更多的是配合前端框架，将计算结果实时渲染到页面上。\n\n页面结构中的数据来自 Vue 实例的 `data` 对象。\n\n``` html\n<div id=\"app\">{{ `${day}天 ${hr}小时 ${min}分钟 ${sec}分钟` }}</div>\n```\n\n`mounted` 是 Vue 的生命周期方法，可以理解为在页面加载完毕后执行 `countdown` 方法。`countdown` 方法每隔一秒会执行一次，并将计算结果分别赋予变量 `day`、`hr`、`min`、`sec`，同时改变的还有页面上显示的内容。\n\n\n``` js\nnew Vue({\n  el: '#app',\n  data: function () {\n    return {\n      day: 0, hr: 0, min: 0, sec: 0\n    }\n  },\n  mounted: function () {\n    this.countdown()\n  },\n  methods: {\n    countdown: function () {\n      const end = Date.parse(new Date('2017-12-01'))\n      const now = Date.parse(new Date())\n      const msec = end - now\n      let day = parseInt(msec / 1000 / 60 / 60 / 24)\n      let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n      let min = parseInt(msec / 1000 / 60 % 60)\n      let sec = parseInt(msec / 1000 % 60)\n      this.day = day\n      this.hr = hr > 9 ? hr : '0' + hr\n      this.min = min > 9 ? min : '0' + min\n      this.sec = sec > 9 ? sec : '0' + sec\n      const that = this\n      setTimeout(function () {\n        that.countdown()\n      }, 1000)\n    }\n  }\n})\n```\n\n相关环境：Windows 7 x64 / Vue.js 2.4.4","source":"_posts/2017-11-03@JavaScript 或 Vue.js 实现时分秒倒计时.md","raw":"---\ntitle: JavaScript / Vue.js 实现时分秒倒计时\ndate: 2017-11-03 23:45:19\ncategories:\n  - Web Front-end\ntags:\n  - JavaScript\n  - Vue.js\n---\n\n我们平常浏览网页的时候，经常见到“距游戏公测1天2小时3分钟4秒”这样的倒计时器。时间如沙漏般一点点的减少，不仅能挑起用户的兴趣，而且让页面提升了一点逼格，还填补掉一些尴尬的空白位置。最近写得越来越多，有用没用都让加个倒计时，干脆记录下来，免得重复造轮子。\n\n<!-- more -->\n\n\n实现的方法并不复杂，关键是理解如何计算，尤其对我这种数学不好的人而言。下面两个 demo 将分别用纯 JavaScript 、基于 Vue.js 的 JavaScript 实现。注，代码中可能包含部分 ES6 语法，但相信很容易理解。\n\n\n### JavaScript\n\n创建一个 `countdown` 方法，用于计算并在控制台打印距目标时间的日、时、分、秒数，每隔一秒递归执行一次。\n\n`msec` 是当前时间距目标时间的毫秒数，由时间戳相减得到，我们将以这个数为基础计算。我们都知道1天等于24小时，1小时等于60分钟，1分钟等于60秒，1秒等于1000毫秒。所以，`msec / 1000 / 60 / 60 / 24` 保留整数就是天数。如果换用 `%` 取余数，再保留整数后得到的就是小时数。以此类推就能算出其他所有数。\n\n``` js\nfunction countdown () {\n  // 目标日期时间戳\n  const end = Date.parse(new Date('2017-12-01'))\n  // 当前时间戳\n  const now = Date.parse(new Date())\n  // 相差的毫秒数\n  const msec = end - now\n  // 计算时分秒数\n  let day = parseInt(msec / 1000 / 60 / 60 / 24)\n  let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n  let min = parseInt(msec / 1000 / 60 % 60)\n  let sec = parseInt(msec / 1000 % 60)\n  // 个位数前补零\n  hr = hr > 9 ? hr : '0' + hr\n  min = min > 9 ? min : '0' + min\n  sec = sec > 9 ? sec : '0' + sec\n  // 控制台打印\n  console.log(`${day}天 ${hr}小时 ${min}分钟 ${sec}秒`)\n  // 一秒后递归\n  setTimeout(function () {\n    countdown()\n  }, 1000)\n}\n```\n\n控制台打印结果：\n\n```\n27天 07小时 49分钟 10秒\n27天 07小时 49分钟 09秒\n27天 07小时 49分钟 08秒\n...\n```\n\n### Vue.js\n\n如果单纯使用 JavaScript ，我们需要在每次计算后手动更新 DOM 元素（将数据显示给用户），既不方便又难以维护。实际项目中更多的是配合前端框架，将计算结果实时渲染到页面上。\n\n页面结构中的数据来自 Vue 实例的 `data` 对象。\n\n``` html\n<div id=\"app\">{{ `${day}天 ${hr}小时 ${min}分钟 ${sec}分钟` }}</div>\n```\n\n`mounted` 是 Vue 的生命周期方法，可以理解为在页面加载完毕后执行 `countdown` 方法。`countdown` 方法每隔一秒会执行一次，并将计算结果分别赋予变量 `day`、`hr`、`min`、`sec`，同时改变的还有页面上显示的内容。\n\n\n``` js\nnew Vue({\n  el: '#app',\n  data: function () {\n    return {\n      day: 0, hr: 0, min: 0, sec: 0\n    }\n  },\n  mounted: function () {\n    this.countdown()\n  },\n  methods: {\n    countdown: function () {\n      const end = Date.parse(new Date('2017-12-01'))\n      const now = Date.parse(new Date())\n      const msec = end - now\n      let day = parseInt(msec / 1000 / 60 / 60 / 24)\n      let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n      let min = parseInt(msec / 1000 / 60 % 60)\n      let sec = parseInt(msec / 1000 % 60)\n      this.day = day\n      this.hr = hr > 9 ? hr : '0' + hr\n      this.min = min > 9 ? min : '0' + min\n      this.sec = sec > 9 ? sec : '0' + sec\n      const that = this\n      setTimeout(function () {\n        that.countdown()\n      }, 1000)\n    }\n  }\n})\n```\n\n相关环境：Windows 7 x64 / Vue.js 2.4.4","slug":"2017-11-03@JavaScript 或 Vue.js 实现时分秒倒计时","published":1,"updated":"2020-06-29T03:32:42.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt49z0099rqgjhitg2lx3","content":"<p>我们平常浏览网页的时候，经常见到“距游戏公测1天2小时3分钟4秒”这样的倒计时器。时间如沙漏般一点点的减少，不仅能挑起用户的兴趣，而且让页面提升了一点逼格，还填补掉一些尴尬的空白位置。最近写得越来越多，有用没用都让加个倒计时，干脆记录下来，免得重复造轮子。</p>\n<a id=\"more\"></a>\n\n\n<p>实现的方法并不复杂，关键是理解如何计算，尤其对我这种数学不好的人而言。下面两个 demo 将分别用纯 JavaScript 、基于 Vue.js 的 JavaScript 实现。注，代码中可能包含部分 ES6 语法，但相信很容易理解。</p>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><p>创建一个 <code>countdown</code> 方法，用于计算并在控制台打印距目标时间的日、时、分、秒数，每隔一秒递归执行一次。</p>\n<p><code>msec</code> 是当前时间距目标时间的毫秒数，由时间戳相减得到，我们将以这个数为基础计算。我们都知道1天等于24小时，1小时等于60分钟，1分钟等于60秒，1秒等于1000毫秒。所以，<code>msec / 1000 / 60 / 60 / 24</code> 保留整数就是天数。如果换用 <code>%</code> 取余数，再保留整数后得到的就是小时数。以此类推就能算出其他所有数。</p>\n<pre><code class=\"js\">function countdown () {\n  // 目标日期时间戳\n  const end = Date.parse(new Date(&#39;2017-12-01&#39;))\n  // 当前时间戳\n  const now = Date.parse(new Date())\n  // 相差的毫秒数\n  const msec = end - now\n  // 计算时分秒数\n  let day = parseInt(msec / 1000 / 60 / 60 / 24)\n  let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n  let min = parseInt(msec / 1000 / 60 % 60)\n  let sec = parseInt(msec / 1000 % 60)\n  // 个位数前补零\n  hr = hr &gt; 9 ? hr : &#39;0&#39; + hr\n  min = min &gt; 9 ? min : &#39;0&#39; + min\n  sec = sec &gt; 9 ? sec : &#39;0&#39; + sec\n  // 控制台打印\n  console.log(`${day}天 ${hr}小时 ${min}分钟 ${sec}秒`)\n  // 一秒后递归\n  setTimeout(function () {\n    countdown()\n  }, 1000)\n}</code></pre>\n<p>控制台打印结果：</p>\n<pre><code>27天 07小时 49分钟 10秒\n27天 07小时 49分钟 09秒\n27天 07小时 49分钟 08秒\n...</code></pre><h3 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h3><p>如果单纯使用 JavaScript ，我们需要在每次计算后手动更新 DOM 元素（将数据显示给用户），既不方便又难以维护。实际项目中更多的是配合前端框架，将计算结果实时渲染到页面上。</p>\n<p>页面结构中的数据来自 Vue 实例的 <code>data</code> 对象。</p>\n<pre><code class=\"html\">&lt;div id=&quot;app&quot;&gt;{{ `${day}天 ${hr}小时 ${min}分钟 ${sec}分钟` }}&lt;/div&gt;</code></pre>\n<p><code>mounted</code> 是 Vue 的生命周期方法，可以理解为在页面加载完毕后执行 <code>countdown</code> 方法。<code>countdown</code> 方法每隔一秒会执行一次，并将计算结果分别赋予变量 <code>day</code>、<code>hr</code>、<code>min</code>、<code>sec</code>，同时改变的还有页面上显示的内容。</p>\n<pre><code class=\"js\">new Vue({\n  el: &#39;#app&#39;,\n  data: function () {\n    return {\n      day: 0, hr: 0, min: 0, sec: 0\n    }\n  },\n  mounted: function () {\n    this.countdown()\n  },\n  methods: {\n    countdown: function () {\n      const end = Date.parse(new Date(&#39;2017-12-01&#39;))\n      const now = Date.parse(new Date())\n      const msec = end - now\n      let day = parseInt(msec / 1000 / 60 / 60 / 24)\n      let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n      let min = parseInt(msec / 1000 / 60 % 60)\n      let sec = parseInt(msec / 1000 % 60)\n      this.day = day\n      this.hr = hr &gt; 9 ? hr : &#39;0&#39; + hr\n      this.min = min &gt; 9 ? min : &#39;0&#39; + min\n      this.sec = sec &gt; 9 ? sec : &#39;0&#39; + sec\n      const that = this\n      setTimeout(function () {\n        that.countdown()\n      }, 1000)\n    }\n  }\n})</code></pre>\n<p>相关环境：Windows 7 x64 / Vue.js 2.4.4</p>\n","site":{"data":{}},"excerpt":"<p>我们平常浏览网页的时候，经常见到“距游戏公测1天2小时3分钟4秒”这样的倒计时器。时间如沙漏般一点点的减少，不仅能挑起用户的兴趣，而且让页面提升了一点逼格，还填补掉一些尴尬的空白位置。最近写得越来越多，有用没用都让加个倒计时，干脆记录下来，免得重复造轮子。</p>","more":"<p>实现的方法并不复杂，关键是理解如何计算，尤其对我这种数学不好的人而言。下面两个 demo 将分别用纯 JavaScript 、基于 Vue.js 的 JavaScript 实现。注，代码中可能包含部分 ES6 语法，但相信很容易理解。</p>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><p>创建一个 <code>countdown</code> 方法，用于计算并在控制台打印距目标时间的日、时、分、秒数，每隔一秒递归执行一次。</p>\n<p><code>msec</code> 是当前时间距目标时间的毫秒数，由时间戳相减得到，我们将以这个数为基础计算。我们都知道1天等于24小时，1小时等于60分钟，1分钟等于60秒，1秒等于1000毫秒。所以，<code>msec / 1000 / 60 / 60 / 24</code> 保留整数就是天数。如果换用 <code>%</code> 取余数，再保留整数后得到的就是小时数。以此类推就能算出其他所有数。</p>\n<pre><code class=\"js\">function countdown () {\n  // 目标日期时间戳\n  const end = Date.parse(new Date(&#39;2017-12-01&#39;))\n  // 当前时间戳\n  const now = Date.parse(new Date())\n  // 相差的毫秒数\n  const msec = end - now\n  // 计算时分秒数\n  let day = parseInt(msec / 1000 / 60 / 60 / 24)\n  let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n  let min = parseInt(msec / 1000 / 60 % 60)\n  let sec = parseInt(msec / 1000 % 60)\n  // 个位数前补零\n  hr = hr &gt; 9 ? hr : &#39;0&#39; + hr\n  min = min &gt; 9 ? min : &#39;0&#39; + min\n  sec = sec &gt; 9 ? sec : &#39;0&#39; + sec\n  // 控制台打印\n  console.log(`${day}天 ${hr}小时 ${min}分钟 ${sec}秒`)\n  // 一秒后递归\n  setTimeout(function () {\n    countdown()\n  }, 1000)\n}</code></pre>\n<p>控制台打印结果：</p>\n<pre><code>27天 07小时 49分钟 10秒\n27天 07小时 49分钟 09秒\n27天 07小时 49分钟 08秒\n...</code></pre><h3 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h3><p>如果单纯使用 JavaScript ，我们需要在每次计算后手动更新 DOM 元素（将数据显示给用户），既不方便又难以维护。实际项目中更多的是配合前端框架，将计算结果实时渲染到页面上。</p>\n<p>页面结构中的数据来自 Vue 实例的 <code>data</code> 对象。</p>\n<pre><code class=\"html\">&lt;div id=&quot;app&quot;&gt;{{ `${day}天 ${hr}小时 ${min}分钟 ${sec}分钟` }}&lt;/div&gt;</code></pre>\n<p><code>mounted</code> 是 Vue 的生命周期方法，可以理解为在页面加载完毕后执行 <code>countdown</code> 方法。<code>countdown</code> 方法每隔一秒会执行一次，并将计算结果分别赋予变量 <code>day</code>、<code>hr</code>、<code>min</code>、<code>sec</code>，同时改变的还有页面上显示的内容。</p>\n<pre><code class=\"js\">new Vue({\n  el: &#39;#app&#39;,\n  data: function () {\n    return {\n      day: 0, hr: 0, min: 0, sec: 0\n    }\n  },\n  mounted: function () {\n    this.countdown()\n  },\n  methods: {\n    countdown: function () {\n      const end = Date.parse(new Date(&#39;2017-12-01&#39;))\n      const now = Date.parse(new Date())\n      const msec = end - now\n      let day = parseInt(msec / 1000 / 60 / 60 / 24)\n      let hr = parseInt(msec / 1000 / 60 / 60 % 24)\n      let min = parseInt(msec / 1000 / 60 % 60)\n      let sec = parseInt(msec / 1000 % 60)\n      this.day = day\n      this.hr = hr &gt; 9 ? hr : &#39;0&#39; + hr\n      this.min = min &gt; 9 ? min : &#39;0&#39; + min\n      this.sec = sec &gt; 9 ? sec : &#39;0&#39; + sec\n      const that = this\n      setTimeout(function () {\n        that.countdown()\n      }, 1000)\n    }\n  }\n})</code></pre>\n<p>相关环境：Windows 7 x64 / Vue.js 2.4.4</p>"},{"title":"阻止微信浏览器下拉查看网址","date":"2017-12-04T14:39:12.000Z","_content":"用过微信的人几乎都知道，在微信中浏览网页时可以下拉查看网站的网址。这确实是一项实用的功能，使用户能够追溯内容提供者，减少被仿冒、钓鱼网站欺骗的风险。不过有时候它确实也对网页的操作产生了干扰。\n\n<!-- more -->\n\n举个例子，我想要给页面增加一个下拉刷新的功能，但是用户的手指在屏幕上滑动的时候会同时触发整个页面的下拉（显示网址）。这显然不是我想要的效果，必须想办法禁用或者阻止下拉显示网址这一默认动作。\n\n有人建议这么做：\n\n``` js\ndocument.body.addEventListener('touchmove', (event) => {\n  event.preventDefault()\n})\n```\n\n确实，这样做能够取消 `touchmove` 事件（手指滑动）的全部默认动作，但页面的滚动也被一并禁用掉了。如果你的页面不需要滚动，当然可以这么做。我的想法是，只需要在页面滚动到最顶部，且用户的触摸操作为下拉时取消默认动作即可。\n\n``` js\n// 滑动起始点坐标\nlet coordStart = null\n\n// 滑动结束点坐标\nlet coordEnd   = null\n\n// 滚动的像素数\nlet scrollTop  = null\n\nfunction preventWxPullDown () {\n  // 监听 body 的 touchstart 事件\n  document.body.addEventListener('touchstart', (event) => {\n    // 触摸屏幕时保存一次起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n  // 监听 body 的 touchmove 事件\n  document.body.addEventListener('touchmove', (event) => {\n    // 保存结束点坐标\n    coordEnd = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    // 计算X轴和Y轴移动的距离\n    const distance = [coordEnd[0] - coordStart[0], coordEnd[1] - coordStart[1]]\n    // 符合条件时取消默认动作\n    if (scrollTop == 0 && Math.abs(distance[0]) < Math.abs(distance[1]) && distance[1] > 0) {\n      event.preventDefault()\n    }\n    // 更新起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n}\n\npreventWxPullDown ()\n```\n\n`preventWxPullDown` 方法尝试在页面滚动到最顶部（即 `scrollTop` 等于0），且手指向屏幕下方滑动（即 Y 轴移动距离为正数且 Y 轴移动距离大于 X 轴移动距离）时取消默认动作。实测在阻止下拉显示网址的同时确实不会影响到页面的正常滚动，刚好满足我的需要。\n\nTips: 当手势为先上滑再下拉时无效。\n\n相关环境：Windows 7 x64 / WeChat 6.5.16","source":"_posts/2017-12-04@阻止微信浏览器下拉查看网址.md","raw":"---\ntitle: 阻止微信浏览器下拉查看网址\ndate: 2017-12-04 22:39:12\ncategories:\n  - Web Front-end\ntags:\n  - 微信\n  - JavaScript\n---\n用过微信的人几乎都知道，在微信中浏览网页时可以下拉查看网站的网址。这确实是一项实用的功能，使用户能够追溯内容提供者，减少被仿冒、钓鱼网站欺骗的风险。不过有时候它确实也对网页的操作产生了干扰。\n\n<!-- more -->\n\n举个例子，我想要给页面增加一个下拉刷新的功能，但是用户的手指在屏幕上滑动的时候会同时触发整个页面的下拉（显示网址）。这显然不是我想要的效果，必须想办法禁用或者阻止下拉显示网址这一默认动作。\n\n有人建议这么做：\n\n``` js\ndocument.body.addEventListener('touchmove', (event) => {\n  event.preventDefault()\n})\n```\n\n确实，这样做能够取消 `touchmove` 事件（手指滑动）的全部默认动作，但页面的滚动也被一并禁用掉了。如果你的页面不需要滚动，当然可以这么做。我的想法是，只需要在页面滚动到最顶部，且用户的触摸操作为下拉时取消默认动作即可。\n\n``` js\n// 滑动起始点坐标\nlet coordStart = null\n\n// 滑动结束点坐标\nlet coordEnd   = null\n\n// 滚动的像素数\nlet scrollTop  = null\n\nfunction preventWxPullDown () {\n  // 监听 body 的 touchstart 事件\n  document.body.addEventListener('touchstart', (event) => {\n    // 触摸屏幕时保存一次起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n  // 监听 body 的 touchmove 事件\n  document.body.addEventListener('touchmove', (event) => {\n    // 保存结束点坐标\n    coordEnd = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    // 计算X轴和Y轴移动的距离\n    const distance = [coordEnd[0] - coordStart[0], coordEnd[1] - coordStart[1]]\n    // 符合条件时取消默认动作\n    if (scrollTop == 0 && Math.abs(distance[0]) < Math.abs(distance[1]) && distance[1] > 0) {\n      event.preventDefault()\n    }\n    // 更新起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n}\n\npreventWxPullDown ()\n```\n\n`preventWxPullDown` 方法尝试在页面滚动到最顶部（即 `scrollTop` 等于0），且手指向屏幕下方滑动（即 Y 轴移动距离为正数且 Y 轴移动距离大于 X 轴移动距离）时取消默认动作。实测在阻止下拉显示网址的同时确实不会影响到页面的正常滚动，刚好满足我的需要。\n\nTips: 当手势为先上滑再下拉时无效。\n\n相关环境：Windows 7 x64 / WeChat 6.5.16","slug":"2017-12-04@阻止微信浏览器下拉查看网址","published":1,"updated":"2020-06-29T03:32:42.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a0009crqgj7e3taz00","content":"<p>用过微信的人几乎都知道，在微信中浏览网页时可以下拉查看网站的网址。这确实是一项实用的功能，使用户能够追溯内容提供者，减少被仿冒、钓鱼网站欺骗的风险。不过有时候它确实也对网页的操作产生了干扰。</p>\n<a id=\"more\"></a>\n\n<p>举个例子，我想要给页面增加一个下拉刷新的功能，但是用户的手指在屏幕上滑动的时候会同时触发整个页面的下拉（显示网址）。这显然不是我想要的效果，必须想办法禁用或者阻止下拉显示网址这一默认动作。</p>\n<p>有人建议这么做：</p>\n<pre><code class=\"js\">document.body.addEventListener(&#39;touchmove&#39;, (event) =&gt; {\n  event.preventDefault()\n})</code></pre>\n<p>确实，这样做能够取消 <code>touchmove</code> 事件（手指滑动）的全部默认动作，但页面的滚动也被一并禁用掉了。如果你的页面不需要滚动，当然可以这么做。我的想法是，只需要在页面滚动到最顶部，且用户的触摸操作为下拉时取消默认动作即可。</p>\n<pre><code class=\"js\">// 滑动起始点坐标\nlet coordStart = null\n\n// 滑动结束点坐标\nlet coordEnd   = null\n\n// 滚动的像素数\nlet scrollTop  = null\n\nfunction preventWxPullDown () {\n  // 监听 body 的 touchstart 事件\n  document.body.addEventListener(&#39;touchstart&#39;, (event) =&gt; {\n    // 触摸屏幕时保存一次起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n  // 监听 body 的 touchmove 事件\n  document.body.addEventListener(&#39;touchmove&#39;, (event) =&gt; {\n    // 保存结束点坐标\n    coordEnd = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    // 计算X轴和Y轴移动的距离\n    const distance = [coordEnd[0] - coordStart[0], coordEnd[1] - coordStart[1]]\n    // 符合条件时取消默认动作\n    if (scrollTop == 0 &amp;&amp; Math.abs(distance[0]) &lt; Math.abs(distance[1]) &amp;&amp; distance[1] &gt; 0) {\n      event.preventDefault()\n    }\n    // 更新起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n}\n\npreventWxPullDown ()</code></pre>\n<p><code>preventWxPullDown</code> 方法尝试在页面滚动到最顶部（即 <code>scrollTop</code> 等于0），且手指向屏幕下方滑动（即 Y 轴移动距离为正数且 Y 轴移动距离大于 X 轴移动距离）时取消默认动作。实测在阻止下拉显示网址的同时确实不会影响到页面的正常滚动，刚好满足我的需要。</p>\n<p>Tips: 当手势为先上滑再下拉时无效。</p>\n<p>相关环境：Windows 7 x64 / WeChat 6.5.16</p>\n","site":{"data":{}},"excerpt":"<p>用过微信的人几乎都知道，在微信中浏览网页时可以下拉查看网站的网址。这确实是一项实用的功能，使用户能够追溯内容提供者，减少被仿冒、钓鱼网站欺骗的风险。不过有时候它确实也对网页的操作产生了干扰。</p>","more":"<p>举个例子，我想要给页面增加一个下拉刷新的功能，但是用户的手指在屏幕上滑动的时候会同时触发整个页面的下拉（显示网址）。这显然不是我想要的效果，必须想办法禁用或者阻止下拉显示网址这一默认动作。</p>\n<p>有人建议这么做：</p>\n<pre><code class=\"js\">document.body.addEventListener(&#39;touchmove&#39;, (event) =&gt; {\n  event.preventDefault()\n})</code></pre>\n<p>确实，这样做能够取消 <code>touchmove</code> 事件（手指滑动）的全部默认动作，但页面的滚动也被一并禁用掉了。如果你的页面不需要滚动，当然可以这么做。我的想法是，只需要在页面滚动到最顶部，且用户的触摸操作为下拉时取消默认动作即可。</p>\n<pre><code class=\"js\">// 滑动起始点坐标\nlet coordStart = null\n\n// 滑动结束点坐标\nlet coordEnd   = null\n\n// 滚动的像素数\nlet scrollTop  = null\n\nfunction preventWxPullDown () {\n  // 监听 body 的 touchstart 事件\n  document.body.addEventListener(&#39;touchstart&#39;, (event) =&gt; {\n    // 触摸屏幕时保存一次起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n  // 监听 body 的 touchmove 事件\n  document.body.addEventListener(&#39;touchmove&#39;, (event) =&gt; {\n    // 保存结束点坐标\n    coordEnd = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    // 计算X轴和Y轴移动的距离\n    const distance = [coordEnd[0] - coordStart[0], coordEnd[1] - coordStart[1]]\n    // 符合条件时取消默认动作\n    if (scrollTop == 0 &amp;&amp; Math.abs(distance[0]) &lt; Math.abs(distance[1]) &amp;&amp; distance[1] &gt; 0) {\n      event.preventDefault()\n    }\n    // 更新起始点坐标和滚动像素数\n    coordStart = [event.changedTouches[0].pageX, event.changedTouches[0].pageY]\n    scrollTop = window.pageYOffset\n  })\n}\n\npreventWxPullDown ()</code></pre>\n<p><code>preventWxPullDown</code> 方法尝试在页面滚动到最顶部（即 <code>scrollTop</code> 等于0），且手指向屏幕下方滑动（即 Y 轴移动距离为正数且 Y 轴移动距离大于 X 轴移动距离）时取消默认动作。实测在阻止下拉显示网址的同时确实不会影响到页面的正常滚动，刚好满足我的需要。</p>\n<p>Tips: 当手势为先上滑再下拉时无效。</p>\n<p>相关环境：Windows 7 x64 / WeChat 6.5.16</p>"},{"title":"Let's Encrypt：免费 SSL 证书申请与部署","date":"2017-11-15T06:32:17.000Z","_content":"\n为了启用网站的 HTTPS 功能，需要向证书颁发机构（CA）申请证书。[Let's Encrypt](https://letsencrypt.org/) 是一家 CA，同时也是一个由公益组织运营的项目，致力于普及安全链接。其颁发的免费 SSL 证书有三个月的有效期（不限次数免费续期），目前已得到包括 Chrome、Firefox 在内的所有主流浏览器的信任。\n\n<!-- more -->\n\n{% img /images/posts/2017/11/lets_encrypt_logo.png 360 %}\n\nLet's Encrypt 基于 ACME 协议验证你对一个域名的控制权。以 GetSSL （Let's Encrypt 的客户端程序）为例，假设你的域名为 `yourdomain.com`，GetSSL 将随机生成一个页面，然后由 CA 服务器访问这个页面，我们假设这个页面的链接为 `https://yourdomain.com/token` 。如果可以访问，CA 服务器就会颁发该域名的 SSL 证书。\n\n\n### 获取 GetSSL\n\nLet's Encrypt 官网介绍了超过 50 种客户端程序，全部由第三方开发，都可以用于申请证书。而我选择的是上文提到的 GetSSL 。注：官方推荐 [Certbot](https://certbot.eff.org/)，我试用的时候发现出错的几率蛮高的，感兴趣的话可以自行尝试。 \n\n获取 GetSSL ： \n\n\n```\ncd ~\ngit clone https://github.com/srvrco/getssl.git\ncd getssl\n```\n\n\n### 配置 GetSSL\n\n执行命令生成配置文件，注意把 `yourdomain.com` 替换成你的域名。\n\n```\n./getssl -c yourdomain.com\n```\n\n执行后将生成 GetSSL 的全局配置文件 `~/.getssl/getssl.cfg` ，及当前域名的配置文件 `~/.getssl/yourdomain.com/getssl.cfg` 。\n\n``` sh\n# 日志\n# 创建全局配置文件\ncreating main config file /root/.getssl/getssl.cfg\n# 创建域名配置文件\nMaking domain directory - /root/.getssl/yourdomain.com\ncreating domain config file in /root/.getssl/yourdomain.com/getssl.cfg\n```\n\n编辑全局配置文件。由于默认的 CA 服务器仅用于测试，颁发的证书是不受浏览器信任的，需要修改成颁发完整证书的服务器。`RELOAD_CMD` 用于在证书颁发后自动重载 Web 服务器，使证书生效，非必填项。\n\n``` sh\n# 证书服务器地址\nCA=\"https://acme-v01.api.letsencrypt.org\"\n\n# 服务器重载命令\nRELOAD_CMD=\"service nginx reload\"\n```\n\n\n编辑当前域名的配置文件。`ACL(Acme Challenge Location)` 是用于产生随机校验文件的路径，将 `/path/to/your/website/folder/` 改成你的网站根目录的绝对路径。接着配置文件的保存路径。\n\n\n``` sh\n# 校验路径\nACL=('/path/to/your/website/folder/.well-known/acme-challenge')\n\n# 保存路径\nDOMAIN_PEM_LOCATION=\"/etc/ssl/yourdomain.com.pem\" # 证书文件路径\nDOMAIN_KEY_LOCATION=\"/etc/ssl/yourdomain.com.key\" # 私钥文件路径\n```\n\nTips: `DOMAIN_CERT_LOCATION` 和  `DOMAIN_PEM_LOCATION` 都可以配置证书文件路径，后者保存的证书包含证书链。如果不慎删除，可以在 `~/.getssl/yourdomain.com/archive` 找到每次签发的文件存档。\n\n### 配置 Nginx\n\n配置你的 Web 引擎。这是在 Nginx 上启用并强制使用 HTTPS 访问的配置参考，`ssl_certificate` 和 `ssl_certificate_key` 指向上面配置的文件保存路径。\n\n```\nserver {\n  listen 80;\n  listen 443 ssl http2;\n  ssl_certificate /etc/ssl/yourdomain.com.pem;\n  ssl_certificate_key /etc/ssl/yourdomain.com.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n  if ($ssl_protocol = \"\") { return 301 https://$host$request_uri; }\n  ...\n}\n```\n\n\n### 申请证书\n\n执行命令申请 SSL 证书。\n\n```\ncd ~/getssl\n./getssl yourdomain.com\n```\n\n\n若所有配置正确，网站的 HTTPS 应该已经生效。别忘了在你的 Web 服务器（Apache、Nginx 或 Lighttpd）上启用 SSL ，并指向刚刚申请的证书路径。\n\n``` sh\n# 日志\n# 创建随机校验文件\ncopying challenge token to /path/to/your/website/folder/.well-known/acme-challenge/2ALrFFPercPe1i9-jA-_DBEJqlrPevCIf0Fzdk3HjWI\nPending\n# 验证是否可以访问\nVerified yourdomain.com\n# 获取并保存证书\nVerification completed, obtaining certificate.\nCertificate saved in /root/.getssl/yourdomain.com/yourdomain.com.crt\nThe intermediate CA cert is in /root/.getssl/yourdomain.com/chain.crt\ncopying domain certificate to /etc/ssl/yourdomain.com.crt\ncopying private key to /etc/ssl/yourdomain.com.key\ncopying CA certificate to /etc/ssl/chain.crt\n# 重启 Web 服务器\nreloading SSL services\nReloading nginx configuration (via systemctl):             [  OK  ]\nyourdomain.com - certificate installed OK on server\ncertificate obtained for yourdomain.com\n```\n\nTips: 如遇到 `getssl: this script requires one of: nslookup drill dig host` 错误，尝试安装依赖包。\n\n```\nyum install bind-utils\n\n```\n\n### 撤销证书\n\n执行 `getssl -r path/to/cert path/to/key [CA_server]` 命令可以申请撤销已颁发的证书。需要指定证书和私钥文件的路径。`CA_server` 用于指定 CA 服务器，一般不需要填写。\n\n```\n./getssl -r /etc/ssl/yourdomain.com.crt /etc/ssl/yourdomain.com.key\n ```\n\n### 自动续期\n\n执行 `crontab -e` 编辑任务调度文件。添加一个任务。这样，GetSSL 将在每天凌晨检查一次，自动续期或更新证书版本。注意，不要删除 GetSSL 脚本文件。\n\n``` sh\n23 5 * * * /root/getssl -u -a -q\n```\n\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.12","source":"_posts/2017-11-15@Let's Encrypt：免费 SSL 证书申请与部署.md","raw":"---\ntitle: Let's Encrypt：免费 SSL 证书申请与部署\ndate: 2017-11-15 14:32:17\ncategories:\n  - Web Back-end\ntags:\n  - SSL\n  - HTTPS\n  - Nginx\n  - Let's Encrypt\n  - ACME\n---\n\n为了启用网站的 HTTPS 功能，需要向证书颁发机构（CA）申请证书。[Let's Encrypt](https://letsencrypt.org/) 是一家 CA，同时也是一个由公益组织运营的项目，致力于普及安全链接。其颁发的免费 SSL 证书有三个月的有效期（不限次数免费续期），目前已得到包括 Chrome、Firefox 在内的所有主流浏览器的信任。\n\n<!-- more -->\n\n{% img /images/posts/2017/11/lets_encrypt_logo.png 360 %}\n\nLet's Encrypt 基于 ACME 协议验证你对一个域名的控制权。以 GetSSL （Let's Encrypt 的客户端程序）为例，假设你的域名为 `yourdomain.com`，GetSSL 将随机生成一个页面，然后由 CA 服务器访问这个页面，我们假设这个页面的链接为 `https://yourdomain.com/token` 。如果可以访问，CA 服务器就会颁发该域名的 SSL 证书。\n\n\n### 获取 GetSSL\n\nLet's Encrypt 官网介绍了超过 50 种客户端程序，全部由第三方开发，都可以用于申请证书。而我选择的是上文提到的 GetSSL 。注：官方推荐 [Certbot](https://certbot.eff.org/)，我试用的时候发现出错的几率蛮高的，感兴趣的话可以自行尝试。 \n\n获取 GetSSL ： \n\n\n```\ncd ~\ngit clone https://github.com/srvrco/getssl.git\ncd getssl\n```\n\n\n### 配置 GetSSL\n\n执行命令生成配置文件，注意把 `yourdomain.com` 替换成你的域名。\n\n```\n./getssl -c yourdomain.com\n```\n\n执行后将生成 GetSSL 的全局配置文件 `~/.getssl/getssl.cfg` ，及当前域名的配置文件 `~/.getssl/yourdomain.com/getssl.cfg` 。\n\n``` sh\n# 日志\n# 创建全局配置文件\ncreating main config file /root/.getssl/getssl.cfg\n# 创建域名配置文件\nMaking domain directory - /root/.getssl/yourdomain.com\ncreating domain config file in /root/.getssl/yourdomain.com/getssl.cfg\n```\n\n编辑全局配置文件。由于默认的 CA 服务器仅用于测试，颁发的证书是不受浏览器信任的，需要修改成颁发完整证书的服务器。`RELOAD_CMD` 用于在证书颁发后自动重载 Web 服务器，使证书生效，非必填项。\n\n``` sh\n# 证书服务器地址\nCA=\"https://acme-v01.api.letsencrypt.org\"\n\n# 服务器重载命令\nRELOAD_CMD=\"service nginx reload\"\n```\n\n\n编辑当前域名的配置文件。`ACL(Acme Challenge Location)` 是用于产生随机校验文件的路径，将 `/path/to/your/website/folder/` 改成你的网站根目录的绝对路径。接着配置文件的保存路径。\n\n\n``` sh\n# 校验路径\nACL=('/path/to/your/website/folder/.well-known/acme-challenge')\n\n# 保存路径\nDOMAIN_PEM_LOCATION=\"/etc/ssl/yourdomain.com.pem\" # 证书文件路径\nDOMAIN_KEY_LOCATION=\"/etc/ssl/yourdomain.com.key\" # 私钥文件路径\n```\n\nTips: `DOMAIN_CERT_LOCATION` 和  `DOMAIN_PEM_LOCATION` 都可以配置证书文件路径，后者保存的证书包含证书链。如果不慎删除，可以在 `~/.getssl/yourdomain.com/archive` 找到每次签发的文件存档。\n\n### 配置 Nginx\n\n配置你的 Web 引擎。这是在 Nginx 上启用并强制使用 HTTPS 访问的配置参考，`ssl_certificate` 和 `ssl_certificate_key` 指向上面配置的文件保存路径。\n\n```\nserver {\n  listen 80;\n  listen 443 ssl http2;\n  ssl_certificate /etc/ssl/yourdomain.com.pem;\n  ssl_certificate_key /etc/ssl/yourdomain.com.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n  if ($ssl_protocol = \"\") { return 301 https://$host$request_uri; }\n  ...\n}\n```\n\n\n### 申请证书\n\n执行命令申请 SSL 证书。\n\n```\ncd ~/getssl\n./getssl yourdomain.com\n```\n\n\n若所有配置正确，网站的 HTTPS 应该已经生效。别忘了在你的 Web 服务器（Apache、Nginx 或 Lighttpd）上启用 SSL ，并指向刚刚申请的证书路径。\n\n``` sh\n# 日志\n# 创建随机校验文件\ncopying challenge token to /path/to/your/website/folder/.well-known/acme-challenge/2ALrFFPercPe1i9-jA-_DBEJqlrPevCIf0Fzdk3HjWI\nPending\n# 验证是否可以访问\nVerified yourdomain.com\n# 获取并保存证书\nVerification completed, obtaining certificate.\nCertificate saved in /root/.getssl/yourdomain.com/yourdomain.com.crt\nThe intermediate CA cert is in /root/.getssl/yourdomain.com/chain.crt\ncopying domain certificate to /etc/ssl/yourdomain.com.crt\ncopying private key to /etc/ssl/yourdomain.com.key\ncopying CA certificate to /etc/ssl/chain.crt\n# 重启 Web 服务器\nreloading SSL services\nReloading nginx configuration (via systemctl):             [  OK  ]\nyourdomain.com - certificate installed OK on server\ncertificate obtained for yourdomain.com\n```\n\nTips: 如遇到 `getssl: this script requires one of: nslookup drill dig host` 错误，尝试安装依赖包。\n\n```\nyum install bind-utils\n\n```\n\n### 撤销证书\n\n执行 `getssl -r path/to/cert path/to/key [CA_server]` 命令可以申请撤销已颁发的证书。需要指定证书和私钥文件的路径。`CA_server` 用于指定 CA 服务器，一般不需要填写。\n\n```\n./getssl -r /etc/ssl/yourdomain.com.crt /etc/ssl/yourdomain.com.key\n ```\n\n### 自动续期\n\n执行 `crontab -e` 编辑任务调度文件。添加一个任务。这样，GetSSL 将在每天凌晨检查一次，自动续期或更新证书版本。注意，不要删除 GetSSL 脚本文件。\n\n``` sh\n23 5 * * * /root/getssl -u -a -q\n```\n\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.12","slug":"2017-11-15@Let's Encrypt：免费 SSL 证书申请与部署","published":1,"updated":"2020-06-29T03:32:42.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a2009grqgjb1mob772","content":"<p>为了启用网站的 HTTPS 功能，需要向证书颁发机构（CA）申请证书。<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a> 是一家 CA，同时也是一个由公益组织运营的项目，致力于普及安全链接。其颁发的免费 SSL 证书有三个月的有效期（不限次数免费续期），目前已得到包括 Chrome、Firefox 在内的所有主流浏览器的信任。</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2017/11/lets_encrypt_logo.png\" class=\"\" width=\"360\">\n\n<p>Let’s Encrypt 基于 ACME 协议验证你对一个域名的控制权。以 GetSSL （Let’s Encrypt 的客户端程序）为例，假设你的域名为 <code>yourdomain.com</code>，GetSSL 将随机生成一个页面，然后由 CA 服务器访问这个页面，我们假设这个页面的链接为 <code>https://yourdomain.com/token</code> 。如果可以访问，CA 服务器就会颁发该域名的 SSL 证书。</p>\n<h3 id=\"获取-GetSSL\"><a href=\"#获取-GetSSL\" class=\"headerlink\" title=\"获取 GetSSL\"></a>获取 GetSSL</h3><p>Let’s Encrypt 官网介绍了超过 50 种客户端程序，全部由第三方开发，都可以用于申请证书。而我选择的是上文提到的 GetSSL 。注：官方推荐 <a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>，我试用的时候发现出错的几率蛮高的，感兴趣的话可以自行尝试。 </p>\n<p>获取 GetSSL ： </p>\n<pre><code>cd ~\ngit clone https://github.com/srvrco/getssl.git\ncd getssl</code></pre><h3 id=\"配置-GetSSL\"><a href=\"#配置-GetSSL\" class=\"headerlink\" title=\"配置 GetSSL\"></a>配置 GetSSL</h3><p>执行命令生成配置文件，注意把 <code>yourdomain.com</code> 替换成你的域名。</p>\n<pre><code>./getssl -c yourdomain.com</code></pre><p>执行后将生成 GetSSL 的全局配置文件 <code>~/.getssl/getssl.cfg</code> ，及当前域名的配置文件 <code>~/.getssl/yourdomain.com/getssl.cfg</code> 。</p>\n<pre><code class=\"sh\"># 日志\n# 创建全局配置文件\ncreating main config file /root/.getssl/getssl.cfg\n# 创建域名配置文件\nMaking domain directory - /root/.getssl/yourdomain.com\ncreating domain config file in /root/.getssl/yourdomain.com/getssl.cfg</code></pre>\n<p>编辑全局配置文件。由于默认的 CA 服务器仅用于测试，颁发的证书是不受浏览器信任的，需要修改成颁发完整证书的服务器。<code>RELOAD_CMD</code> 用于在证书颁发后自动重载 Web 服务器，使证书生效，非必填项。</p>\n<pre><code class=\"sh\"># 证书服务器地址\nCA=&quot;https://acme-v01.api.letsencrypt.org&quot;\n\n# 服务器重载命令\nRELOAD_CMD=&quot;service nginx reload&quot;</code></pre>\n<p>编辑当前域名的配置文件。<code>ACL(Acme Challenge Location)</code> 是用于产生随机校验文件的路径，将 <code>/path/to/your/website/folder/</code> 改成你的网站根目录的绝对路径。接着配置文件的保存路径。</p>\n<pre><code class=\"sh\"># 校验路径\nACL=(&#39;/path/to/your/website/folder/.well-known/acme-challenge&#39;)\n\n# 保存路径\nDOMAIN_PEM_LOCATION=&quot;/etc/ssl/yourdomain.com.pem&quot; # 证书文件路径\nDOMAIN_KEY_LOCATION=&quot;/etc/ssl/yourdomain.com.key&quot; # 私钥文件路径</code></pre>\n<p>Tips: <code>DOMAIN_CERT_LOCATION</code> 和  <code>DOMAIN_PEM_LOCATION</code> 都可以配置证书文件路径，后者保存的证书包含证书链。如果不慎删除，可以在 <code>~/.getssl/yourdomain.com/archive</code> 找到每次签发的文件存档。</p>\n<h3 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h3><p>配置你的 Web 引擎。这是在 Nginx 上启用并强制使用 HTTPS 访问的配置参考，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 指向上面配置的文件保存路径。</p>\n<pre><code>server {\n  listen 80;\n  listen 443 ssl http2;\n  ssl_certificate /etc/ssl/yourdomain.com.pem;\n  ssl_certificate_key /etc/ssl/yourdomain.com.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n  if ($ssl_protocol = &quot;&quot;) { return 301 https://$host$request_uri; }\n  ...\n}</code></pre><h3 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h3><p>执行命令申请 SSL 证书。</p>\n<pre><code>cd ~/getssl\n./getssl yourdomain.com</code></pre><p>若所有配置正确，网站的 HTTPS 应该已经生效。别忘了在你的 Web 服务器（Apache、Nginx 或 Lighttpd）上启用 SSL ，并指向刚刚申请的证书路径。</p>\n<pre><code class=\"sh\"># 日志\n# 创建随机校验文件\ncopying challenge token to /path/to/your/website/folder/.well-known/acme-challenge/2ALrFFPercPe1i9-jA-_DBEJqlrPevCIf0Fzdk3HjWI\nPending\n# 验证是否可以访问\nVerified yourdomain.com\n# 获取并保存证书\nVerification completed, obtaining certificate.\nCertificate saved in /root/.getssl/yourdomain.com/yourdomain.com.crt\nThe intermediate CA cert is in /root/.getssl/yourdomain.com/chain.crt\ncopying domain certificate to /etc/ssl/yourdomain.com.crt\ncopying private key to /etc/ssl/yourdomain.com.key\ncopying CA certificate to /etc/ssl/chain.crt\n# 重启 Web 服务器\nreloading SSL services\nReloading nginx configuration (via systemctl):             [  OK  ]\nyourdomain.com - certificate installed OK on server\ncertificate obtained for yourdomain.com</code></pre>\n<p>Tips: 如遇到 <code>getssl: this script requires one of: nslookup drill dig host</code> 错误，尝试安装依赖包。</p>\n<pre><code>yum install bind-utils\n</code></pre><h3 id=\"撤销证书\"><a href=\"#撤销证书\" class=\"headerlink\" title=\"撤销证书\"></a>撤销证书</h3><p>执行 <code>getssl -r path/to/cert path/to/key [CA_server]</code> 命令可以申请撤销已颁发的证书。需要指定证书和私钥文件的路径。<code>CA_server</code> 用于指定 CA 服务器，一般不需要填写。</p>\n<pre><code>./getssl -r /etc/ssl/yourdomain.com.crt /etc/ssl/yourdomain.com.key</code></pre><h3 id=\"自动续期\"><a href=\"#自动续期\" class=\"headerlink\" title=\"自动续期\"></a>自动续期</h3><p>执行 <code>crontab -e</code> 编辑任务调度文件。添加一个任务。这样，GetSSL 将在每天凌晨检查一次，自动续期或更新证书版本。注意，不要删除 GetSSL 脚本文件。</p>\n<pre><code class=\"sh\">23 5 * * * /root/getssl -u -a -q</code></pre>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.12</p>\n","site":{"data":{}},"excerpt":"<p>为了启用网站的 HTTPS 功能，需要向证书颁发机构（CA）申请证书。<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a> 是一家 CA，同时也是一个由公益组织运营的项目，致力于普及安全链接。其颁发的免费 SSL 证书有三个月的有效期（不限次数免费续期），目前已得到包括 Chrome、Firefox 在内的所有主流浏览器的信任。</p>","more":"<img src=\"/images/posts/2017/11/lets_encrypt_logo.png\" class=\"\" width=\"360\">\n\n<p>Let’s Encrypt 基于 ACME 协议验证你对一个域名的控制权。以 GetSSL （Let’s Encrypt 的客户端程序）为例，假设你的域名为 <code>yourdomain.com</code>，GetSSL 将随机生成一个页面，然后由 CA 服务器访问这个页面，我们假设这个页面的链接为 <code>https://yourdomain.com/token</code> 。如果可以访问，CA 服务器就会颁发该域名的 SSL 证书。</p>\n<h3 id=\"获取-GetSSL\"><a href=\"#获取-GetSSL\" class=\"headerlink\" title=\"获取 GetSSL\"></a>获取 GetSSL</h3><p>Let’s Encrypt 官网介绍了超过 50 种客户端程序，全部由第三方开发，都可以用于申请证书。而我选择的是上文提到的 GetSSL 。注：官方推荐 <a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>，我试用的时候发现出错的几率蛮高的，感兴趣的话可以自行尝试。 </p>\n<p>获取 GetSSL ： </p>\n<pre><code>cd ~\ngit clone https://github.com/srvrco/getssl.git\ncd getssl</code></pre><h3 id=\"配置-GetSSL\"><a href=\"#配置-GetSSL\" class=\"headerlink\" title=\"配置 GetSSL\"></a>配置 GetSSL</h3><p>执行命令生成配置文件，注意把 <code>yourdomain.com</code> 替换成你的域名。</p>\n<pre><code>./getssl -c yourdomain.com</code></pre><p>执行后将生成 GetSSL 的全局配置文件 <code>~/.getssl/getssl.cfg</code> ，及当前域名的配置文件 <code>~/.getssl/yourdomain.com/getssl.cfg</code> 。</p>\n<pre><code class=\"sh\"># 日志\n# 创建全局配置文件\ncreating main config file /root/.getssl/getssl.cfg\n# 创建域名配置文件\nMaking domain directory - /root/.getssl/yourdomain.com\ncreating domain config file in /root/.getssl/yourdomain.com/getssl.cfg</code></pre>\n<p>编辑全局配置文件。由于默认的 CA 服务器仅用于测试，颁发的证书是不受浏览器信任的，需要修改成颁发完整证书的服务器。<code>RELOAD_CMD</code> 用于在证书颁发后自动重载 Web 服务器，使证书生效，非必填项。</p>\n<pre><code class=\"sh\"># 证书服务器地址\nCA=&quot;https://acme-v01.api.letsencrypt.org&quot;\n\n# 服务器重载命令\nRELOAD_CMD=&quot;service nginx reload&quot;</code></pre>\n<p>编辑当前域名的配置文件。<code>ACL(Acme Challenge Location)</code> 是用于产生随机校验文件的路径，将 <code>/path/to/your/website/folder/</code> 改成你的网站根目录的绝对路径。接着配置文件的保存路径。</p>\n<pre><code class=\"sh\"># 校验路径\nACL=(&#39;/path/to/your/website/folder/.well-known/acme-challenge&#39;)\n\n# 保存路径\nDOMAIN_PEM_LOCATION=&quot;/etc/ssl/yourdomain.com.pem&quot; # 证书文件路径\nDOMAIN_KEY_LOCATION=&quot;/etc/ssl/yourdomain.com.key&quot; # 私钥文件路径</code></pre>\n<p>Tips: <code>DOMAIN_CERT_LOCATION</code> 和  <code>DOMAIN_PEM_LOCATION</code> 都可以配置证书文件路径，后者保存的证书包含证书链。如果不慎删除，可以在 <code>~/.getssl/yourdomain.com/archive</code> 找到每次签发的文件存档。</p>\n<h3 id=\"配置-Nginx\"><a href=\"#配置-Nginx\" class=\"headerlink\" title=\"配置 Nginx\"></a>配置 Nginx</h3><p>配置你的 Web 引擎。这是在 Nginx 上启用并强制使用 HTTPS 访问的配置参考，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 指向上面配置的文件保存路径。</p>\n<pre><code>server {\n  listen 80;\n  listen 443 ssl http2;\n  ssl_certificate /etc/ssl/yourdomain.com.pem;\n  ssl_certificate_key /etc/ssl/yourdomain.com.key;\n  ssl_session_timeout 5m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_prefer_server_ciphers on;\n  if ($ssl_protocol = &quot;&quot;) { return 301 https://$host$request_uri; }\n  ...\n}</code></pre><h3 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h3><p>执行命令申请 SSL 证书。</p>\n<pre><code>cd ~/getssl\n./getssl yourdomain.com</code></pre><p>若所有配置正确，网站的 HTTPS 应该已经生效。别忘了在你的 Web 服务器（Apache、Nginx 或 Lighttpd）上启用 SSL ，并指向刚刚申请的证书路径。</p>\n<pre><code class=\"sh\"># 日志\n# 创建随机校验文件\ncopying challenge token to /path/to/your/website/folder/.well-known/acme-challenge/2ALrFFPercPe1i9-jA-_DBEJqlrPevCIf0Fzdk3HjWI\nPending\n# 验证是否可以访问\nVerified yourdomain.com\n# 获取并保存证书\nVerification completed, obtaining certificate.\nCertificate saved in /root/.getssl/yourdomain.com/yourdomain.com.crt\nThe intermediate CA cert is in /root/.getssl/yourdomain.com/chain.crt\ncopying domain certificate to /etc/ssl/yourdomain.com.crt\ncopying private key to /etc/ssl/yourdomain.com.key\ncopying CA certificate to /etc/ssl/chain.crt\n# 重启 Web 服务器\nreloading SSL services\nReloading nginx configuration (via systemctl):             [  OK  ]\nyourdomain.com - certificate installed OK on server\ncertificate obtained for yourdomain.com</code></pre>\n<p>Tips: 如遇到 <code>getssl: this script requires one of: nslookup drill dig host</code> 错误，尝试安装依赖包。</p>\n<pre><code>yum install bind-utils\n</code></pre><h3 id=\"撤销证书\"><a href=\"#撤销证书\" class=\"headerlink\" title=\"撤销证书\"></a>撤销证书</h3><p>执行 <code>getssl -r path/to/cert path/to/key [CA_server]</code> 命令可以申请撤销已颁发的证书。需要指定证书和私钥文件的路径。<code>CA_server</code> 用于指定 CA 服务器，一般不需要填写。</p>\n<pre><code>./getssl -r /etc/ssl/yourdomain.com.crt /etc/ssl/yourdomain.com.key</code></pre><h3 id=\"自动续期\"><a href=\"#自动续期\" class=\"headerlink\" title=\"自动续期\"></a>自动续期</h3><p>执行 <code>crontab -e</code> 编辑任务调度文件。添加一个任务。这样，GetSSL 将在每天凌晨检查一次，自动续期或更新证书版本。注意，不要删除 GetSSL 脚本文件。</p>\n<pre><code class=\"sh\">23 5 * * * /root/getssl -u -a -q</code></pre>\n<p>相关环境：Aliyun ECS / CentOS 7 x64 / Nginx 1.12</p>"},{"title":"使用 apiDoc 自动生成 API 文档","date":"2017-12-26T16:23:59.000Z","_content":"\n前段时间尝试写 API 服务器，为了方便管理数量可能越来越多的接口（未雨绸缪），必须考虑创建文档的方案。我选择了 apiDoc 作为第一款文档生成工具。apiDoc 是一个通过代码中的注释生成 API 文档的工具，它简单易用，并且支持多种常用编程语言。\n\n<!-- more -->\n\n{% img /images/posts/2017/12/apidoc_ui.png 450 使用 apiDoc 生成的文档 %}\n\n### 安装\n\n使用 NPM 全局安装 apiDoc ：\n\n``` sh\nnpm install apidoc -g\n```\n\n### 配置\n\n在项目根目录下新建 `apidoc.json` 配置文件。注意：`json` 文件不能包含注释，下面的注释只是为了方便解释选项含义。\n\n``` js\n{\n  \"name\": \"example\",  // 项目名称\n  \"version\": \"0.1.0\",  // 项目版本\n  \"description\": \"apiDoc basic example\",  // 项目描述\n  \"title\": \"Custom apiDoc browser title\",  // 文档标题\n  \"url\" : \"https://api.github.com/v1\",  // 链接前缀\n  \"template\": { // 模板配置\n    \"forceLanguage\": \"zh_cn\"\n  },\n  \"order\": [ // 排列顺序\n    \"Auth\",\n    \"Users\",\n    \"Goods\"\n  ]\n}\n```\n\n其中，`title` 是文档的主标题，留空使用 `name` 渲染。\n\n`url` 是链接前缀，文档中的 API 链接都会带上这个前缀。这样做的好处是不必总是写完整的 API 链接，即使换域名也只需修改一处。\n\n模板相关配置 `template` 并不是必要的，这里我指定了渲染的语言为简体中文。\n\n`order` 同样是一个可选的配置项，用于设置分组的显示顺序。\n\n### 撰写\n\n使用注释撰写 API 信息。一个简单的接口描述只需声明 `@api`、`@apiName`、`@apiGroup` 三个参数。\n\n``` php\n/**\n * @api {get} /user/:id 获取用户\n * @apiName GetUser\n * @apiGroup User\n */\n```\n\n`@api` 必须，声明请求类型、路径、标题（显示在文档中）。`@apiName` 声明接口显示在文档中的容器 id ，官方建议必填，实际上不声明也会自动生成。`@apiGroup` 必填，声明接口分组。\n\n在此基础上进一步声明参数和响应。\n\n``` php\n/**\n * ...\n *\n * @apiParam {Number} id 用户 id\n *\n * @apiSuccess (200) {String} name  用户名\n * @apiSuccess (200) {String} email 用户的邮箱地址\n *\n * @apiSuccessExample {json} 请求成功：\n *     HTTP/1.1 200 OK\n *     {\n *       \"name\": \"张三\",\n *       \"email\": \"foo@example.com\"\n *     }\n *\n * @apiError UserNotFound 未找到指定的用户\n *\n * @apiErrorExample 请求失败：\n *     HTTP/1.1 404 Not Found\n *     {\n *       \"error\": \"UserNotFound\"\n *     }\n */\n```\n\n`@apiParam` 选填，声明一个参数的类型、参数名、描述。\n\n`@apiSuccess` 选填，声明请求成功后的响应分组、字段类型、字段（或成功代码）、字段描述。`@apiSuccessExample` 选填，声明请求成功后响应内容的格式、标题和示例。声明错误的 `@apiError` 和 `@apiSuccessExample` 与之类似。\n\nTips: 分组名称不可以直接使用中文。应该用 `@apiDefine` 声明一个值为中文组名的变量，然后在声明 API 分组时使用它。\n\n``` php\n/**\n * @apiDefine Auth 认证\n */\n\n/**\n * @api {post} /auth\n * @apiGroup Auth\n */\n```\n\n### 生成\n\n``` sh\napidoc -i ./ -o apidoc\n```\n\n`-i` 或 `--input` 参数表示输入目录。`-o` 或 `--output` 参数表示输出目录。`-i ./ -o apidoc` 的意思是：扫描当前目录下的文件，然后在当前目录下的 `apidoc` 文件夹中生成文档。\n\n另外，可以使用 `-f` 或 `--file-filters` 参数过滤文件类型。\n\n``` sh\napidoc -f \".*\\\\.js$\" -f \".*\\\\.ts$\"\n```\n\n相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / apiDoc 0.17.6","source":"_posts/2017-12-27@使用 apiDoc 自动生成 API 文档.md","raw":"---\ntitle: 使用 apiDoc 自动生成 API 文档\ndate: 2017-12-27 00:23:59\ncategories:\n  - Web Front-end\n---\n\n前段时间尝试写 API 服务器，为了方便管理数量可能越来越多的接口（未雨绸缪），必须考虑创建文档的方案。我选择了 apiDoc 作为第一款文档生成工具。apiDoc 是一个通过代码中的注释生成 API 文档的工具，它简单易用，并且支持多种常用编程语言。\n\n<!-- more -->\n\n{% img /images/posts/2017/12/apidoc_ui.png 450 使用 apiDoc 生成的文档 %}\n\n### 安装\n\n使用 NPM 全局安装 apiDoc ：\n\n``` sh\nnpm install apidoc -g\n```\n\n### 配置\n\n在项目根目录下新建 `apidoc.json` 配置文件。注意：`json` 文件不能包含注释，下面的注释只是为了方便解释选项含义。\n\n``` js\n{\n  \"name\": \"example\",  // 项目名称\n  \"version\": \"0.1.0\",  // 项目版本\n  \"description\": \"apiDoc basic example\",  // 项目描述\n  \"title\": \"Custom apiDoc browser title\",  // 文档标题\n  \"url\" : \"https://api.github.com/v1\",  // 链接前缀\n  \"template\": { // 模板配置\n    \"forceLanguage\": \"zh_cn\"\n  },\n  \"order\": [ // 排列顺序\n    \"Auth\",\n    \"Users\",\n    \"Goods\"\n  ]\n}\n```\n\n其中，`title` 是文档的主标题，留空使用 `name` 渲染。\n\n`url` 是链接前缀，文档中的 API 链接都会带上这个前缀。这样做的好处是不必总是写完整的 API 链接，即使换域名也只需修改一处。\n\n模板相关配置 `template` 并不是必要的，这里我指定了渲染的语言为简体中文。\n\n`order` 同样是一个可选的配置项，用于设置分组的显示顺序。\n\n### 撰写\n\n使用注释撰写 API 信息。一个简单的接口描述只需声明 `@api`、`@apiName`、`@apiGroup` 三个参数。\n\n``` php\n/**\n * @api {get} /user/:id 获取用户\n * @apiName GetUser\n * @apiGroup User\n */\n```\n\n`@api` 必须，声明请求类型、路径、标题（显示在文档中）。`@apiName` 声明接口显示在文档中的容器 id ，官方建议必填，实际上不声明也会自动生成。`@apiGroup` 必填，声明接口分组。\n\n在此基础上进一步声明参数和响应。\n\n``` php\n/**\n * ...\n *\n * @apiParam {Number} id 用户 id\n *\n * @apiSuccess (200) {String} name  用户名\n * @apiSuccess (200) {String} email 用户的邮箱地址\n *\n * @apiSuccessExample {json} 请求成功：\n *     HTTP/1.1 200 OK\n *     {\n *       \"name\": \"张三\",\n *       \"email\": \"foo@example.com\"\n *     }\n *\n * @apiError UserNotFound 未找到指定的用户\n *\n * @apiErrorExample 请求失败：\n *     HTTP/1.1 404 Not Found\n *     {\n *       \"error\": \"UserNotFound\"\n *     }\n */\n```\n\n`@apiParam` 选填，声明一个参数的类型、参数名、描述。\n\n`@apiSuccess` 选填，声明请求成功后的响应分组、字段类型、字段（或成功代码）、字段描述。`@apiSuccessExample` 选填，声明请求成功后响应内容的格式、标题和示例。声明错误的 `@apiError` 和 `@apiSuccessExample` 与之类似。\n\nTips: 分组名称不可以直接使用中文。应该用 `@apiDefine` 声明一个值为中文组名的变量，然后在声明 API 分组时使用它。\n\n``` php\n/**\n * @apiDefine Auth 认证\n */\n\n/**\n * @api {post} /auth\n * @apiGroup Auth\n */\n```\n\n### 生成\n\n``` sh\napidoc -i ./ -o apidoc\n```\n\n`-i` 或 `--input` 参数表示输入目录。`-o` 或 `--output` 参数表示输出目录。`-i ./ -o apidoc` 的意思是：扫描当前目录下的文件，然后在当前目录下的 `apidoc` 文件夹中生成文档。\n\n另外，可以使用 `-f` 或 `--file-filters` 参数过滤文件类型。\n\n``` sh\napidoc -f \".*\\\\.js$\" -f \".*\\\\.ts$\"\n```\n\n相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / apiDoc 0.17.6","slug":"2017-12-27@使用 apiDoc 自动生成 API 文档","published":1,"updated":"2020-06-29T03:32:42.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a3009jrqgj98qkfcyh","content":"<p>前段时间尝试写 API 服务器，为了方便管理数量可能越来越多的接口（未雨绸缪），必须考虑创建文档的方案。我选择了 apiDoc 作为第一款文档生成工具。apiDoc 是一个通过代码中的注释生成 API 文档的工具，它简单易用，并且支持多种常用编程语言。</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2017/12/apidoc_ui.png\" class=\"\" width=\"450\" title=\"使用 apiDoc 生成的文档\">\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 NPM 全局安装 apiDoc ：</p>\n<pre><code class=\"sh\">npm install apidoc -g</code></pre>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在项目根目录下新建 <code>apidoc.json</code> 配置文件。注意：<code>json</code> 文件不能包含注释，下面的注释只是为了方便解释选项含义。</p>\n<pre><code class=\"js\">{\n  &quot;name&quot;: &quot;example&quot;,  // 项目名称\n  &quot;version&quot;: &quot;0.1.0&quot;,  // 项目版本\n  &quot;description&quot;: &quot;apiDoc basic example&quot;,  // 项目描述\n  &quot;title&quot;: &quot;Custom apiDoc browser title&quot;,  // 文档标题\n  &quot;url&quot; : &quot;https://api.github.com/v1&quot;,  // 链接前缀\n  &quot;template&quot;: { // 模板配置\n    &quot;forceLanguage&quot;: &quot;zh_cn&quot;\n  },\n  &quot;order&quot;: [ // 排列顺序\n    &quot;Auth&quot;,\n    &quot;Users&quot;,\n    &quot;Goods&quot;\n  ]\n}</code></pre>\n<p>其中，<code>title</code> 是文档的主标题，留空使用 <code>name</code> 渲染。</p>\n<p><code>url</code> 是链接前缀，文档中的 API 链接都会带上这个前缀。这样做的好处是不必总是写完整的 API 链接，即使换域名也只需修改一处。</p>\n<p>模板相关配置 <code>template</code> 并不是必要的，这里我指定了渲染的语言为简体中文。</p>\n<p><code>order</code> 同样是一个可选的配置项，用于设置分组的显示顺序。</p>\n<h3 id=\"撰写\"><a href=\"#撰写\" class=\"headerlink\" title=\"撰写\"></a>撰写</h3><p>使用注释撰写 API 信息。一个简单的接口描述只需声明 <code>@api</code>、<code>@apiName</code>、<code>@apiGroup</code> 三个参数。</p>\n<pre><code class=\"php\">/**\n * @api {get} /user/:id 获取用户\n * @apiName GetUser\n * @apiGroup User\n */</code></pre>\n<p><code>@api</code> 必须，声明请求类型、路径、标题（显示在文档中）。<code>@apiName</code> 声明接口显示在文档中的容器 id ，官方建议必填，实际上不声明也会自动生成。<code>@apiGroup</code> 必填，声明接口分组。</p>\n<p>在此基础上进一步声明参数和响应。</p>\n<pre><code class=\"php\">/**\n * ...\n *\n * @apiParam {Number} id 用户 id\n *\n * @apiSuccess (200) {String} name  用户名\n * @apiSuccess (200) {String} email 用户的邮箱地址\n *\n * @apiSuccessExample {json} 请求成功：\n *     HTTP/1.1 200 OK\n *     {\n *       &quot;name&quot;: &quot;张三&quot;,\n *       &quot;email&quot;: &quot;foo@example.com&quot;\n *     }\n *\n * @apiError UserNotFound 未找到指定的用户\n *\n * @apiErrorExample 请求失败：\n *     HTTP/1.1 404 Not Found\n *     {\n *       &quot;error&quot;: &quot;UserNotFound&quot;\n *     }\n */</code></pre>\n<p><code>@apiParam</code> 选填，声明一个参数的类型、参数名、描述。</p>\n<p><code>@apiSuccess</code> 选填，声明请求成功后的响应分组、字段类型、字段（或成功代码）、字段描述。<code>@apiSuccessExample</code> 选填，声明请求成功后响应内容的格式、标题和示例。声明错误的 <code>@apiError</code> 和 <code>@apiSuccessExample</code> 与之类似。</p>\n<p>Tips: 分组名称不可以直接使用中文。应该用 <code>@apiDefine</code> 声明一个值为中文组名的变量，然后在声明 API 分组时使用它。</p>\n<pre><code class=\"php\">/**\n * @apiDefine Auth 认证\n */\n\n/**\n * @api {post} /auth\n * @apiGroup Auth\n */</code></pre>\n<h3 id=\"生成\"><a href=\"#生成\" class=\"headerlink\" title=\"生成\"></a>生成</h3><pre><code class=\"sh\">apidoc -i ./ -o apidoc</code></pre>\n<p><code>-i</code> 或 <code>--input</code> 参数表示输入目录。<code>-o</code> 或 <code>--output</code> 参数表示输出目录。<code>-i ./ -o apidoc</code> 的意思是：扫描当前目录下的文件，然后在当前目录下的 <code>apidoc</code> 文件夹中生成文档。</p>\n<p>另外，可以使用 <code>-f</code> 或 <code>--file-filters</code> 参数过滤文件类型。</p>\n<pre><code class=\"sh\">apidoc -f &quot;.*\\\\.js$&quot; -f &quot;.*\\\\.ts$&quot;</code></pre>\n<p>相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / apiDoc 0.17.6</p>\n","site":{"data":{}},"excerpt":"<p>前段时间尝试写 API 服务器，为了方便管理数量可能越来越多的接口（未雨绸缪），必须考虑创建文档的方案。我选择了 apiDoc 作为第一款文档生成工具。apiDoc 是一个通过代码中的注释生成 API 文档的工具，它简单易用，并且支持多种常用编程语言。</p>","more":"<img src=\"/images/posts/2017/12/apidoc_ui.png\" class=\"\" width=\"450\" title=\"使用 apiDoc 生成的文档\">\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 NPM 全局安装 apiDoc ：</p>\n<pre><code class=\"sh\">npm install apidoc -g</code></pre>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在项目根目录下新建 <code>apidoc.json</code> 配置文件。注意：<code>json</code> 文件不能包含注释，下面的注释只是为了方便解释选项含义。</p>\n<pre><code class=\"js\">{\n  &quot;name&quot;: &quot;example&quot;,  // 项目名称\n  &quot;version&quot;: &quot;0.1.0&quot;,  // 项目版本\n  &quot;description&quot;: &quot;apiDoc basic example&quot;,  // 项目描述\n  &quot;title&quot;: &quot;Custom apiDoc browser title&quot;,  // 文档标题\n  &quot;url&quot; : &quot;https://api.github.com/v1&quot;,  // 链接前缀\n  &quot;template&quot;: { // 模板配置\n    &quot;forceLanguage&quot;: &quot;zh_cn&quot;\n  },\n  &quot;order&quot;: [ // 排列顺序\n    &quot;Auth&quot;,\n    &quot;Users&quot;,\n    &quot;Goods&quot;\n  ]\n}</code></pre>\n<p>其中，<code>title</code> 是文档的主标题，留空使用 <code>name</code> 渲染。</p>\n<p><code>url</code> 是链接前缀，文档中的 API 链接都会带上这个前缀。这样做的好处是不必总是写完整的 API 链接，即使换域名也只需修改一处。</p>\n<p>模板相关配置 <code>template</code> 并不是必要的，这里我指定了渲染的语言为简体中文。</p>\n<p><code>order</code> 同样是一个可选的配置项，用于设置分组的显示顺序。</p>\n<h3 id=\"撰写\"><a href=\"#撰写\" class=\"headerlink\" title=\"撰写\"></a>撰写</h3><p>使用注释撰写 API 信息。一个简单的接口描述只需声明 <code>@api</code>、<code>@apiName</code>、<code>@apiGroup</code> 三个参数。</p>\n<pre><code class=\"php\">/**\n * @api {get} /user/:id 获取用户\n * @apiName GetUser\n * @apiGroup User\n */</code></pre>\n<p><code>@api</code> 必须，声明请求类型、路径、标题（显示在文档中）。<code>@apiName</code> 声明接口显示在文档中的容器 id ，官方建议必填，实际上不声明也会自动生成。<code>@apiGroup</code> 必填，声明接口分组。</p>\n<p>在此基础上进一步声明参数和响应。</p>\n<pre><code class=\"php\">/**\n * ...\n *\n * @apiParam {Number} id 用户 id\n *\n * @apiSuccess (200) {String} name  用户名\n * @apiSuccess (200) {String} email 用户的邮箱地址\n *\n * @apiSuccessExample {json} 请求成功：\n *     HTTP/1.1 200 OK\n *     {\n *       &quot;name&quot;: &quot;张三&quot;,\n *       &quot;email&quot;: &quot;foo@example.com&quot;\n *     }\n *\n * @apiError UserNotFound 未找到指定的用户\n *\n * @apiErrorExample 请求失败：\n *     HTTP/1.1 404 Not Found\n *     {\n *       &quot;error&quot;: &quot;UserNotFound&quot;\n *     }\n */</code></pre>\n<p><code>@apiParam</code> 选填，声明一个参数的类型、参数名、描述。</p>\n<p><code>@apiSuccess</code> 选填，声明请求成功后的响应分组、字段类型、字段（或成功代码）、字段描述。<code>@apiSuccessExample</code> 选填，声明请求成功后响应内容的格式、标题和示例。声明错误的 <code>@apiError</code> 和 <code>@apiSuccessExample</code> 与之类似。</p>\n<p>Tips: 分组名称不可以直接使用中文。应该用 <code>@apiDefine</code> 声明一个值为中文组名的变量，然后在声明 API 分组时使用它。</p>\n<pre><code class=\"php\">/**\n * @apiDefine Auth 认证\n */\n\n/**\n * @api {post} /auth\n * @apiGroup Auth\n */</code></pre>\n<h3 id=\"生成\"><a href=\"#生成\" class=\"headerlink\" title=\"生成\"></a>生成</h3><pre><code class=\"sh\">apidoc -i ./ -o apidoc</code></pre>\n<p><code>-i</code> 或 <code>--input</code> 参数表示输入目录。<code>-o</code> 或 <code>--output</code> 参数表示输出目录。<code>-i ./ -o apidoc</code> 的意思是：扫描当前目录下的文件，然后在当前目录下的 <code>apidoc</code> 文件夹中生成文档。</p>\n<p>另外，可以使用 <code>-f</code> 或 <code>--file-filters</code> 参数过滤文件类型。</p>\n<pre><code class=\"sh\">apidoc -f &quot;.*\\\\.js$&quot; -f &quot;.*\\\\.ts$&quot;</code></pre>\n<p>相关环境：Windows 7 x64 / Node.js 6.10.1 / npm 3.10.10 / apiDoc 0.17.6</p>"},{"title":"使用 Certbot 申请和部署 SSL 证书","date":"2018-02-21T08:38:45.000Z","_content":"\n去年写过一篇文章介绍 Let's Encrypt 免费证书，以及申请和部署的过程。最近又为站点上 HTTPS，发现官方推荐的 [Certbot](https://certbot.eff.org/) 客户端确实更好用，几乎全自动完成证书的申请、部署和更新。\n\n<!-- more -->\n\n### 安装\n\n首先启用 EPEL（企业版 Linux 附加软件包）源：\n\n```\nyum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\n```\n\n安装 Certbot 客户端：\n\n```\nyum install certbot-nginx\n```\n\n### 使用\n\n申请和部署 SSL 证书：\n\n```\ncertbot --nginx\n```\n\nCerbot 将分析 Nginx 的配置文件（默认为 `/etc/nginx/nginx.conf` ），然后自动完成证书的申请和部署，包括修改 Nginx 配置文件并重启服务。这也是我之前一直遇到错误的问题所在：如果 Nginx 的安装目录不是 `/etc/nginx` ，Cerbot 找不到配置文件就会报错。\n\n所以，需要使用 `--nginx-server-root` 指定配置文件的路径：\n\n```\ncertbot --nginx --nginx-server-root=/usr/local/nginx/conf\n```\n\n然后根据提示选择你要启用 HTTPS 的站点，等待证书部署完成。\n\n如果只希望 Cerbot 申请证书但不自动部署，使用 `certonly` 子命令：\n\n```\ncertbot --nginx certonly\n```\n\n### 续期\n\n测试证书更新命令是否正常：\n\n```\ncertbot renew --dry-run\n```\n\n执行 `crontab -e` 编辑任务调度文件，添加一个任务，定期检测证书的有效期并自动更换新的证书。\n\n```\n0 5 * * * certbot renew\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Python 2.7 / Nginx 1.12\n","source":"_posts/2018-02-21@使用 Certbot 申请和部署 SSL 证书.md","raw":"---\ntitle: 使用 Certbot 申请和部署 SSL 证书\ndate: 2018-02-21 16:38:45\ncategories:\n  - Web Back-end\ntags:\n  - SSL\n  - HTTPS\n  - Nginx\n  - Let's Encrypt\n  - ACME\n  - Certbot\n---\n\n去年写过一篇文章介绍 Let's Encrypt 免费证书，以及申请和部署的过程。最近又为站点上 HTTPS，发现官方推荐的 [Certbot](https://certbot.eff.org/) 客户端确实更好用，几乎全自动完成证书的申请、部署和更新。\n\n<!-- more -->\n\n### 安装\n\n首先启用 EPEL（企业版 Linux 附加软件包）源：\n\n```\nyum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\n```\n\n安装 Certbot 客户端：\n\n```\nyum install certbot-nginx\n```\n\n### 使用\n\n申请和部署 SSL 证书：\n\n```\ncertbot --nginx\n```\n\nCerbot 将分析 Nginx 的配置文件（默认为 `/etc/nginx/nginx.conf` ），然后自动完成证书的申请和部署，包括修改 Nginx 配置文件并重启服务。这也是我之前一直遇到错误的问题所在：如果 Nginx 的安装目录不是 `/etc/nginx` ，Cerbot 找不到配置文件就会报错。\n\n所以，需要使用 `--nginx-server-root` 指定配置文件的路径：\n\n```\ncertbot --nginx --nginx-server-root=/usr/local/nginx/conf\n```\n\n然后根据提示选择你要启用 HTTPS 的站点，等待证书部署完成。\n\n如果只希望 Cerbot 申请证书但不自动部署，使用 `certonly` 子命令：\n\n```\ncertbot --nginx certonly\n```\n\n### 续期\n\n测试证书更新命令是否正常：\n\n```\ncertbot renew --dry-run\n```\n\n执行 `crontab -e` 编辑任务调度文件，添加一个任务，定期检测证书的有效期并自动更换新的证书。\n\n```\n0 5 * * * certbot renew\n```\n\n相关环境：Aliyun ECS / CentOS 7 x64 / Python 2.7 / Nginx 1.12\n","slug":"2018-02-21@使用 Certbot 申请和部署 SSL 证书","published":1,"updated":"2020-06-29T03:32:42.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a4009nrqgja68ddgg6","content":"<p>去年写过一篇文章介绍 Let’s Encrypt 免费证书，以及申请和部署的过程。最近又为站点上 HTTPS，发现官方推荐的 <a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a> 客户端确实更好用，几乎全自动完成证书的申请、部署和更新。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先启用 EPEL（企业版 Linux 附加软件包）源：</p>\n<pre><code>yum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional</code></pre><p>安装 Certbot 客户端：</p>\n<pre><code>yum install certbot-nginx</code></pre><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>申请和部署 SSL 证书：</p>\n<pre><code>certbot --nginx</code></pre><p>Cerbot 将分析 Nginx 的配置文件（默认为 <code>/etc/nginx/nginx.conf</code> ），然后自动完成证书的申请和部署，包括修改 Nginx 配置文件并重启服务。这也是我之前一直遇到错误的问题所在：如果 Nginx 的安装目录不是 <code>/etc/nginx</code> ，Cerbot 找不到配置文件就会报错。</p>\n<p>所以，需要使用 <code>--nginx-server-root</code> 指定配置文件的路径：</p>\n<pre><code>certbot --nginx --nginx-server-root=/usr/local/nginx/conf</code></pre><p>然后根据提示选择你要启用 HTTPS 的站点，等待证书部署完成。</p>\n<p>如果只希望 Cerbot 申请证书但不自动部署，使用 <code>certonly</code> 子命令：</p>\n<pre><code>certbot --nginx certonly</code></pre><h3 id=\"续期\"><a href=\"#续期\" class=\"headerlink\" title=\"续期\"></a>续期</h3><p>测试证书更新命令是否正常：</p>\n<pre><code>certbot renew --dry-run</code></pre><p>执行 <code>crontab -e</code> 编辑任务调度文件，添加一个任务，定期检测证书的有效期并自动更换新的证书。</p>\n<pre><code>0 5 * * * certbot renew</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Python 2.7 / Nginx 1.12</p>\n","site":{"data":{}},"excerpt":"<p>去年写过一篇文章介绍 Let’s Encrypt 免费证书，以及申请和部署的过程。最近又为站点上 HTTPS，发现官方推荐的 <a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a> 客户端确实更好用，几乎全自动完成证书的申请、部署和更新。</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先启用 EPEL（企业版 Linux 附加软件包）源：</p>\n<pre><code>yum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional</code></pre><p>安装 Certbot 客户端：</p>\n<pre><code>yum install certbot-nginx</code></pre><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>申请和部署 SSL 证书：</p>\n<pre><code>certbot --nginx</code></pre><p>Cerbot 将分析 Nginx 的配置文件（默认为 <code>/etc/nginx/nginx.conf</code> ），然后自动完成证书的申请和部署，包括修改 Nginx 配置文件并重启服务。这也是我之前一直遇到错误的问题所在：如果 Nginx 的安装目录不是 <code>/etc/nginx</code> ，Cerbot 找不到配置文件就会报错。</p>\n<p>所以，需要使用 <code>--nginx-server-root</code> 指定配置文件的路径：</p>\n<pre><code>certbot --nginx --nginx-server-root=/usr/local/nginx/conf</code></pre><p>然后根据提示选择你要启用 HTTPS 的站点，等待证书部署完成。</p>\n<p>如果只希望 Cerbot 申请证书但不自动部署，使用 <code>certonly</code> 子命令：</p>\n<pre><code>certbot --nginx certonly</code></pre><h3 id=\"续期\"><a href=\"#续期\" class=\"headerlink\" title=\"续期\"></a>续期</h3><p>测试证书更新命令是否正常：</p>\n<pre><code>certbot renew --dry-run</code></pre><p>执行 <code>crontab -e</code> 编辑任务调度文件，添加一个任务，定期检测证书的有效期并自动更换新的证书。</p>\n<pre><code>0 5 * * * certbot renew</code></pre><p>相关环境：Aliyun ECS / CentOS 7 x64 / Python 2.7 / Nginx 1.12</p>"},{"title":"记博客更换域名并迁移至 GitHub Pages","date":"2018-03-20T03:14:57.000Z","_content":"\n最近在 Namecheap 注册了一个新域名 `yiming.blog` ，打算单独用于博客，替换掉原有的域名。无奈目前 `.blog` 域名无法在国内备案，只能考虑迁移到境外主机。为了避免不必要的资源浪费，我决定将其迁移到 GitHub Pages，并使用 CDN 提供 HTTPS 能力。\n\n<!-- more -->\n\n### 部署代码\n\n[GitHub Pages](https://pages.github.com/) 是 GitHub 提供的静态网页托管服务。相信不需要多余的笔墨介绍。只需创建一个名称为 `{username}.github.io` 的仓库并提交网页代码，然后在 `Settings` 中启用 GitHub Pages 即可上线你的个人静态网站。`{username}` 表示你的用户名。\n\n### 绑定域名\n\n首先，登录域名注册商的后台修改 DNS 设置，添加一条 CNAME 记录，将主域名指向 `{username}.github.io` 。然后在代码仓库的根目录下新建一个 `CNAME` 文件，写入域名。这样就可以用独立域名访问你的网站了。需要注意的是，一个 GitHub Pages 仅支持绑定一个域名，即使 `CNAME` 文件中存在多个域名也只会匹配第一个。\n\n### 启用 HTTPS\n\nGitHub Pages 支持在使用默认二级域名 `{username}.github.io` 的情况下启用 HTTPS ，绑定独立域名则无法开启。于是我决定使用 [Cloudflare](https://www.cloudflare.com) 的免费 DNS 服务为托管站点赋能 HTTPS 。\n\n首选需要将域名交给 Cloudflare 解析，登录域名注册商的后台，修改域名的 NS 服务器：\n\n```\nkiki.ns.cloudflare.com\nram.ns.cloudflare.com\n```\n\n别忘了在 Cloudflare 的控制面板中设置主域名的 CNAME 记录指向 `{username}.github.io` 。然后在 `Crypto` 标签页中将 SSL 状态设置为 `Flexible` 。这时候已经可以用 `https://{你的域名}` 访问站点了。\n\n接下来，为了使所有的 `http` 访问都重定向到 `https` ，即禁用非安全链接访问，应该启用 `Always use HTTPS` 功能。或者在 `Page Rules` 标签页中设置两条 URL 规则：\n\n```\nwww.example.com/*  Forwarding URL (301)  https://example.com/$1\nhttp://yiming.blog/*  Always Use HTTPS\n```\n\n一是将带 `www` 的二级域名永久重定向至主域名，有利于集中搜索引擎权重，二是始终使用 `https` 访问。\n\n更新：\n\n2018年5月1日，GitHub 宣布自定义域名支持 HTTPS，可以直接在 Pages 设置中启用。\n\n### 旧域名重定向\n\n搜索引擎不会立刻知晓网站更换了域名，所以依然会有访问者打开旧的链接。为了不影响访问，同时通知搜索引擎更换收录的域名，需要将旧域名的链接全部 301 重定向到新域名。\n\n假设旧域名为 `www.foo.com` ，新域名为 `bar.com` ，这是一个 Nginx 的配置示例：\n\n```\nserver {\n  listen 80;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\nserver {\n  listen 443;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\n```\n\n至此，域名更换与迁移大功告成。\n","source":"_posts/2018-03-20@记博客更换域名并迁移至 GitHub Pages.md","raw":"---\ntitle: 记博客更换域名并迁移至 GitHub Pages\ndate: 2018-03-20 11:14:57\ncategories:\n  - Web Back-end\ntags:\n  - GitHub Pages\n  - SSL\n  - HTTPS\n  - CDN\n  - DNS\n---\n\n最近在 Namecheap 注册了一个新域名 `yiming.blog` ，打算单独用于博客，替换掉原有的域名。无奈目前 `.blog` 域名无法在国内备案，只能考虑迁移到境外主机。为了避免不必要的资源浪费，我决定将其迁移到 GitHub Pages，并使用 CDN 提供 HTTPS 能力。\n\n<!-- more -->\n\n### 部署代码\n\n[GitHub Pages](https://pages.github.com/) 是 GitHub 提供的静态网页托管服务。相信不需要多余的笔墨介绍。只需创建一个名称为 `{username}.github.io` 的仓库并提交网页代码，然后在 `Settings` 中启用 GitHub Pages 即可上线你的个人静态网站。`{username}` 表示你的用户名。\n\n### 绑定域名\n\n首先，登录域名注册商的后台修改 DNS 设置，添加一条 CNAME 记录，将主域名指向 `{username}.github.io` 。然后在代码仓库的根目录下新建一个 `CNAME` 文件，写入域名。这样就可以用独立域名访问你的网站了。需要注意的是，一个 GitHub Pages 仅支持绑定一个域名，即使 `CNAME` 文件中存在多个域名也只会匹配第一个。\n\n### 启用 HTTPS\n\nGitHub Pages 支持在使用默认二级域名 `{username}.github.io` 的情况下启用 HTTPS ，绑定独立域名则无法开启。于是我决定使用 [Cloudflare](https://www.cloudflare.com) 的免费 DNS 服务为托管站点赋能 HTTPS 。\n\n首选需要将域名交给 Cloudflare 解析，登录域名注册商的后台，修改域名的 NS 服务器：\n\n```\nkiki.ns.cloudflare.com\nram.ns.cloudflare.com\n```\n\n别忘了在 Cloudflare 的控制面板中设置主域名的 CNAME 记录指向 `{username}.github.io` 。然后在 `Crypto` 标签页中将 SSL 状态设置为 `Flexible` 。这时候已经可以用 `https://{你的域名}` 访问站点了。\n\n接下来，为了使所有的 `http` 访问都重定向到 `https` ，即禁用非安全链接访问，应该启用 `Always use HTTPS` 功能。或者在 `Page Rules` 标签页中设置两条 URL 规则：\n\n```\nwww.example.com/*  Forwarding URL (301)  https://example.com/$1\nhttp://yiming.blog/*  Always Use HTTPS\n```\n\n一是将带 `www` 的二级域名永久重定向至主域名，有利于集中搜索引擎权重，二是始终使用 `https` 访问。\n\n更新：\n\n2018年5月1日，GitHub 宣布自定义域名支持 HTTPS，可以直接在 Pages 设置中启用。\n\n### 旧域名重定向\n\n搜索引擎不会立刻知晓网站更换了域名，所以依然会有访问者打开旧的链接。为了不影响访问，同时通知搜索引擎更换收录的域名，需要将旧域名的链接全部 301 重定向到新域名。\n\n假设旧域名为 `www.foo.com` ，新域名为 `bar.com` ，这是一个 Nginx 的配置示例：\n\n```\nserver {\n  listen 80;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\nserver {\n  listen 443;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\n```\n\n至此，域名更换与迁移大功告成。\n","slug":"2018-03-20@记博客更换域名并迁移至 GitHub Pages","published":1,"updated":"2020-06-29T03:32:42.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a5009qrqgj83ff9h34","content":"<p>最近在 Namecheap 注册了一个新域名 <code>yiming.blog</code> ，打算单独用于博客，替换掉原有的域名。无奈目前 <code>.blog</code> 域名无法在国内备案，只能考虑迁移到境外主机。为了避免不必要的资源浪费，我决定将其迁移到 GitHub Pages，并使用 CDN 提供 HTTPS 能力。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"部署代码\"><a href=\"#部署代码\" class=\"headerlink\" title=\"部署代码\"></a>部署代码</h3><p><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a> 是 GitHub 提供的静态网页托管服务。相信不需要多余的笔墨介绍。只需创建一个名称为 <code>{username}.github.io</code> 的仓库并提交网页代码，然后在 <code>Settings</code> 中启用 GitHub Pages 即可上线你的个人静态网站。<code>{username}</code> 表示你的用户名。</p>\n<h3 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h3><p>首先，登录域名注册商的后台修改 DNS 设置，添加一条 CNAME 记录，将主域名指向 <code>{username}.github.io</code> 。然后在代码仓库的根目录下新建一个 <code>CNAME</code> 文件，写入域名。这样就可以用独立域名访问你的网站了。需要注意的是，一个 GitHub Pages 仅支持绑定一个域名，即使 <code>CNAME</code> 文件中存在多个域名也只会匹配第一个。</p>\n<h3 id=\"启用-HTTPS\"><a href=\"#启用-HTTPS\" class=\"headerlink\" title=\"启用 HTTPS\"></a>启用 HTTPS</h3><p>GitHub Pages 支持在使用默认二级域名 <code>{username}.github.io</code> 的情况下启用 HTTPS ，绑定独立域名则无法开启。于是我决定使用 <a href=\"https://www.cloudflare.com\" target=\"_blank\" rel=\"noopener\">Cloudflare</a> 的免费 DNS 服务为托管站点赋能 HTTPS 。</p>\n<p>首选需要将域名交给 Cloudflare 解析，登录域名注册商的后台，修改域名的 NS 服务器：</p>\n<pre><code>kiki.ns.cloudflare.com\nram.ns.cloudflare.com</code></pre><p>别忘了在 Cloudflare 的控制面板中设置主域名的 CNAME 记录指向 <code>{username}.github.io</code> 。然后在 <code>Crypto</code> 标签页中将 SSL 状态设置为 <code>Flexible</code> 。这时候已经可以用 <code>https://{你的域名}</code> 访问站点了。</p>\n<p>接下来，为了使所有的 <code>http</code> 访问都重定向到 <code>https</code> ，即禁用非安全链接访问，应该启用 <code>Always use HTTPS</code> 功能。或者在 <code>Page Rules</code> 标签页中设置两条 URL 规则：</p>\n<pre><code>www.example.com/*  Forwarding URL (301)  https://example.com/$1\nhttp://yiming.blog/*  Always Use HTTPS</code></pre><p>一是将带 <code>www</code> 的二级域名永久重定向至主域名，有利于集中搜索引擎权重，二是始终使用 <code>https</code> 访问。</p>\n<p>更新：</p>\n<p>2018年5月1日，GitHub 宣布自定义域名支持 HTTPS，可以直接在 Pages 设置中启用。</p>\n<h3 id=\"旧域名重定向\"><a href=\"#旧域名重定向\" class=\"headerlink\" title=\"旧域名重定向\"></a>旧域名重定向</h3><p>搜索引擎不会立刻知晓网站更换了域名，所以依然会有访问者打开旧的链接。为了不影响访问，同时通知搜索引擎更换收录的域名，需要将旧域名的链接全部 301 重定向到新域名。</p>\n<p>假设旧域名为 <code>www.foo.com</code> ，新域名为 <code>bar.com</code> ，这是一个 Nginx 的配置示例：</p>\n<pre><code>server {\n  listen 80;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\nserver {\n  listen 443;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}</code></pre><p>至此，域名更换与迁移大功告成。</p>\n","site":{"data":{}},"excerpt":"<p>最近在 Namecheap 注册了一个新域名 <code>yiming.blog</code> ，打算单独用于博客，替换掉原有的域名。无奈目前 <code>.blog</code> 域名无法在国内备案，只能考虑迁移到境外主机。为了避免不必要的资源浪费，我决定将其迁移到 GitHub Pages，并使用 CDN 提供 HTTPS 能力。</p>","more":"<h3 id=\"部署代码\"><a href=\"#部署代码\" class=\"headerlink\" title=\"部署代码\"></a>部署代码</h3><p><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GitHub Pages</a> 是 GitHub 提供的静态网页托管服务。相信不需要多余的笔墨介绍。只需创建一个名称为 <code>{username}.github.io</code> 的仓库并提交网页代码，然后在 <code>Settings</code> 中启用 GitHub Pages 即可上线你的个人静态网站。<code>{username}</code> 表示你的用户名。</p>\n<h3 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h3><p>首先，登录域名注册商的后台修改 DNS 设置，添加一条 CNAME 记录，将主域名指向 <code>{username}.github.io</code> 。然后在代码仓库的根目录下新建一个 <code>CNAME</code> 文件，写入域名。这样就可以用独立域名访问你的网站了。需要注意的是，一个 GitHub Pages 仅支持绑定一个域名，即使 <code>CNAME</code> 文件中存在多个域名也只会匹配第一个。</p>\n<h3 id=\"启用-HTTPS\"><a href=\"#启用-HTTPS\" class=\"headerlink\" title=\"启用 HTTPS\"></a>启用 HTTPS</h3><p>GitHub Pages 支持在使用默认二级域名 <code>{username}.github.io</code> 的情况下启用 HTTPS ，绑定独立域名则无法开启。于是我决定使用 <a href=\"https://www.cloudflare.com\" target=\"_blank\" rel=\"noopener\">Cloudflare</a> 的免费 DNS 服务为托管站点赋能 HTTPS 。</p>\n<p>首选需要将域名交给 Cloudflare 解析，登录域名注册商的后台，修改域名的 NS 服务器：</p>\n<pre><code>kiki.ns.cloudflare.com\nram.ns.cloudflare.com</code></pre><p>别忘了在 Cloudflare 的控制面板中设置主域名的 CNAME 记录指向 <code>{username}.github.io</code> 。然后在 <code>Crypto</code> 标签页中将 SSL 状态设置为 <code>Flexible</code> 。这时候已经可以用 <code>https://{你的域名}</code> 访问站点了。</p>\n<p>接下来，为了使所有的 <code>http</code> 访问都重定向到 <code>https</code> ，即禁用非安全链接访问，应该启用 <code>Always use HTTPS</code> 功能。或者在 <code>Page Rules</code> 标签页中设置两条 URL 规则：</p>\n<pre><code>www.example.com/*  Forwarding URL (301)  https://example.com/$1\nhttp://yiming.blog/*  Always Use HTTPS</code></pre><p>一是将带 <code>www</code> 的二级域名永久重定向至主域名，有利于集中搜索引擎权重，二是始终使用 <code>https</code> 访问。</p>\n<p>更新：</p>\n<p>2018年5月1日，GitHub 宣布自定义域名支持 HTTPS，可以直接在 Pages 设置中启用。</p>\n<h3 id=\"旧域名重定向\"><a href=\"#旧域名重定向\" class=\"headerlink\" title=\"旧域名重定向\"></a>旧域名重定向</h3><p>搜索引擎不会立刻知晓网站更换了域名，所以依然会有访问者打开旧的链接。为了不影响访问，同时通知搜索引擎更换收录的域名，需要将旧域名的链接全部 301 重定向到新域名。</p>\n<p>假设旧域名为 <code>www.foo.com</code> ，新域名为 <code>bar.com</code> ，这是一个 Nginx 的配置示例：</p>\n<pre><code>server {\n  listen 80;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}\nserver {\n  listen 443;\n  server_name www.foo.com;\n  return 301 https://bar.com$request_uri;\n}</code></pre><p>至此，域名更换与迁移大功告成。</p>"},{"title":"使用 Node.js 部署静态资源到七牛云","date":"2018-04-03T14:48:26.000Z","_content":"\n在最近的一个项目中，为了缩短加载时间，同时减轻服务器的压力，我们决定将前端静态资源全数放到七牛云上。更新内容时只需上传 `static` 目录下的所有文件（使用 webpack 打包），然后发布 `index.html` 到网站根目录即可。\n\n<!-- more -->\n\n我决定使用 Node.js 上传资源，方便之后和 webpack 的打包脚本整合到一起，优化工作流。\n\n安装七牛云 Node.js SDK：\n\n``` sh\nnpm install qiniu --save\n```\n\n新建一个脚本 `build/deploy.js`，引入相关包。`fs` 用于读取文件和文件夹。\n\n``` js\nconst fs = require('fs')\nconst qiniu = require('qiniu')\n```\n\n声明常量：\n\n``` js\n// 授权秘钥\nconst accessKey = '{你的七牛云 AccessKey}'\nconst secretKey = '{你的七牛云 SecretKey}'\n\n// 存储空间名称\nconst bucket = '{你的 Bucket 名称}'\n\n// 要上传的资源目录\nconst staticPath = 'dist/static'\n\n// 上传后的文件前缀\nconst prefix = 'static'\n```\n\n配置 Bucket 所在的区域，然后生成上传对象 `formUploader`，同时实例化上传时需要的 `mac`、`putExtra` 对象。`mac` 用于验证身份，`putExtra` 用于在上传时传额外参数。\n\n``` js\n// 创建鉴权对象\nconst mac = new qiniu.auth.digest.Mac(accessKey, secretKey)\n\n// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)\nconst config = new qiniu.conf.Config()\nconfig.zone = qiniu.zone.Zone_z2\n\n// 创建额外内容对象\nconst putExtra = new qiniu.form_up.PutExtra()\n\n// 创建表单上传对象\nconst formUploader = new qiniu.form_up.FormUploader(config)\n```\n\n\n定义上传单个文件的方法：\n\n``` js\n// 文件上传方法\nfunction uploadFile (localFile) {\n  // 配置上传到七牛云的完整路径\n  const key = localFile.replace(staticPath, prefix)\n  const options = {\n    scope: bucket + \":\" + key\n  }\n  const putPolicy = new qiniu.rs.PutPolicy(options)\n  // 生成上传凭证\n  const uploadToken = putPolicy.uploadToken(mac)\n  // 上传文件\n  formUploader.putFile(uploadToken, key, localFile, putExtra, function(respErr,\n    respBody, respInfo) {\n    if (respErr) throw respErr\n    console.log('已上传: ', respBody.key)\n  })\n}\n```\n\n定义上传文件夹的方法：\n\n``` js\n// 目录上传方法\nfunction uploadDirectory (dirPath) {\n  fs.readdir(dirPath, function (err, files) {\n    if (err) throw err\n    // 遍历目录下的内容\n    files.forEach(item => {\n      let path = `${dirPath}/${item}`\n      fs.stat(path, function (err, stats) {\n        if (err) throw err\n        // 是目录就接着遍历 否则上传\n        if (stats.isDirectory()) uploadDirectory(path)\n        else uploadFile(path, item) \n      })\n    })\n  })\n}\n```\n\n在脚本的最后，执行 `uploadDirectory` 方法开始上传：\n\n``` js\nfs.exists(staticPath, function (exists) {\n  if (!exists) {\n    console.log('目录不存在！')\n  }\n  else {\n    console.log('开始上传...')\n    uploadDirectory(staticPath)\n  }\n})\n```\n\n运行脚本：\n\n``` sh\nnode build/deploy.js\n```\n\n相关环境：macOS 10.13 / Node.js 8.9 / npm 5.6\n","source":"_posts/2018-04-03@使用 Node.js 部署静态资源到七牛云.md","raw":"---\ntitle: 使用 Node.js 部署静态资源到七牛云\ndate: 2018-04-03 22:48:26\ncategories:\n  - Web Front-end\ntags:\n  - Node.js\n  - JavaScript\n  - 对象存储\n---\n\n在最近的一个项目中，为了缩短加载时间，同时减轻服务器的压力，我们决定将前端静态资源全数放到七牛云上。更新内容时只需上传 `static` 目录下的所有文件（使用 webpack 打包），然后发布 `index.html` 到网站根目录即可。\n\n<!-- more -->\n\n我决定使用 Node.js 上传资源，方便之后和 webpack 的打包脚本整合到一起，优化工作流。\n\n安装七牛云 Node.js SDK：\n\n``` sh\nnpm install qiniu --save\n```\n\n新建一个脚本 `build/deploy.js`，引入相关包。`fs` 用于读取文件和文件夹。\n\n``` js\nconst fs = require('fs')\nconst qiniu = require('qiniu')\n```\n\n声明常量：\n\n``` js\n// 授权秘钥\nconst accessKey = '{你的七牛云 AccessKey}'\nconst secretKey = '{你的七牛云 SecretKey}'\n\n// 存储空间名称\nconst bucket = '{你的 Bucket 名称}'\n\n// 要上传的资源目录\nconst staticPath = 'dist/static'\n\n// 上传后的文件前缀\nconst prefix = 'static'\n```\n\n配置 Bucket 所在的区域，然后生成上传对象 `formUploader`，同时实例化上传时需要的 `mac`、`putExtra` 对象。`mac` 用于验证身份，`putExtra` 用于在上传时传额外参数。\n\n``` js\n// 创建鉴权对象\nconst mac = new qiniu.auth.digest.Mac(accessKey, secretKey)\n\n// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)\nconst config = new qiniu.conf.Config()\nconfig.zone = qiniu.zone.Zone_z2\n\n// 创建额外内容对象\nconst putExtra = new qiniu.form_up.PutExtra()\n\n// 创建表单上传对象\nconst formUploader = new qiniu.form_up.FormUploader(config)\n```\n\n\n定义上传单个文件的方法：\n\n``` js\n// 文件上传方法\nfunction uploadFile (localFile) {\n  // 配置上传到七牛云的完整路径\n  const key = localFile.replace(staticPath, prefix)\n  const options = {\n    scope: bucket + \":\" + key\n  }\n  const putPolicy = new qiniu.rs.PutPolicy(options)\n  // 生成上传凭证\n  const uploadToken = putPolicy.uploadToken(mac)\n  // 上传文件\n  formUploader.putFile(uploadToken, key, localFile, putExtra, function(respErr,\n    respBody, respInfo) {\n    if (respErr) throw respErr\n    console.log('已上传: ', respBody.key)\n  })\n}\n```\n\n定义上传文件夹的方法：\n\n``` js\n// 目录上传方法\nfunction uploadDirectory (dirPath) {\n  fs.readdir(dirPath, function (err, files) {\n    if (err) throw err\n    // 遍历目录下的内容\n    files.forEach(item => {\n      let path = `${dirPath}/${item}`\n      fs.stat(path, function (err, stats) {\n        if (err) throw err\n        // 是目录就接着遍历 否则上传\n        if (stats.isDirectory()) uploadDirectory(path)\n        else uploadFile(path, item) \n      })\n    })\n  })\n}\n```\n\n在脚本的最后，执行 `uploadDirectory` 方法开始上传：\n\n``` js\nfs.exists(staticPath, function (exists) {\n  if (!exists) {\n    console.log('目录不存在！')\n  }\n  else {\n    console.log('开始上传...')\n    uploadDirectory(staticPath)\n  }\n})\n```\n\n运行脚本：\n\n``` sh\nnode build/deploy.js\n```\n\n相关环境：macOS 10.13 / Node.js 8.9 / npm 5.6\n","slug":"2018-04-03@使用 Node.js 部署静态资源到七牛云","published":1,"updated":"2020-06-29T03:32:42.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a6009trqgjhs0x89ia","content":"<p>在最近的一个项目中，为了缩短加载时间，同时减轻服务器的压力，我们决定将前端静态资源全数放到七牛云上。更新内容时只需上传 <code>static</code> 目录下的所有文件（使用 webpack 打包），然后发布 <code>index.html</code> 到网站根目录即可。</p>\n<a id=\"more\"></a>\n\n<p>我决定使用 Node.js 上传资源，方便之后和 webpack 的打包脚本整合到一起，优化工作流。</p>\n<p>安装七牛云 Node.js SDK：</p>\n<pre><code class=\"sh\">npm install qiniu --save</code></pre>\n<p>新建一个脚本 <code>build/deploy.js</code>，引入相关包。<code>fs</code> 用于读取文件和文件夹。</p>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst qiniu = require(&#39;qiniu&#39;)</code></pre>\n<p>声明常量：</p>\n<pre><code class=\"js\">// 授权秘钥\nconst accessKey = &#39;{你的七牛云 AccessKey}&#39;\nconst secretKey = &#39;{你的七牛云 SecretKey}&#39;\n\n// 存储空间名称\nconst bucket = &#39;{你的 Bucket 名称}&#39;\n\n// 要上传的资源目录\nconst staticPath = &#39;dist/static&#39;\n\n// 上传后的文件前缀\nconst prefix = &#39;static&#39;</code></pre>\n<p>配置 Bucket 所在的区域，然后生成上传对象 <code>formUploader</code>，同时实例化上传时需要的 <code>mac</code>、<code>putExtra</code> 对象。<code>mac</code> 用于验证身份，<code>putExtra</code> 用于在上传时传额外参数。</p>\n<pre><code class=\"js\">// 创建鉴权对象\nconst mac = new qiniu.auth.digest.Mac(accessKey, secretKey)\n\n// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)\nconst config = new qiniu.conf.Config()\nconfig.zone = qiniu.zone.Zone_z2\n\n// 创建额外内容对象\nconst putExtra = new qiniu.form_up.PutExtra()\n\n// 创建表单上传对象\nconst formUploader = new qiniu.form_up.FormUploader(config)</code></pre>\n<p>定义上传单个文件的方法：</p>\n<pre><code class=\"js\">// 文件上传方法\nfunction uploadFile (localFile) {\n  // 配置上传到七牛云的完整路径\n  const key = localFile.replace(staticPath, prefix)\n  const options = {\n    scope: bucket + &quot;:&quot; + key\n  }\n  const putPolicy = new qiniu.rs.PutPolicy(options)\n  // 生成上传凭证\n  const uploadToken = putPolicy.uploadToken(mac)\n  // 上传文件\n  formUploader.putFile(uploadToken, key, localFile, putExtra, function(respErr,\n    respBody, respInfo) {\n    if (respErr) throw respErr\n    console.log(&#39;已上传: &#39;, respBody.key)\n  })\n}</code></pre>\n<p>定义上传文件夹的方法：</p>\n<pre><code class=\"js\">// 目录上传方法\nfunction uploadDirectory (dirPath) {\n  fs.readdir(dirPath, function (err, files) {\n    if (err) throw err\n    // 遍历目录下的内容\n    files.forEach(item =&gt; {\n      let path = `${dirPath}/${item}`\n      fs.stat(path, function (err, stats) {\n        if (err) throw err\n        // 是目录就接着遍历 否则上传\n        if (stats.isDirectory()) uploadDirectory(path)\n        else uploadFile(path, item) \n      })\n    })\n  })\n}</code></pre>\n<p>在脚本的最后，执行 <code>uploadDirectory</code> 方法开始上传：</p>\n<pre><code class=\"js\">fs.exists(staticPath, function (exists) {\n  if (!exists) {\n    console.log(&#39;目录不存在！&#39;)\n  }\n  else {\n    console.log(&#39;开始上传...&#39;)\n    uploadDirectory(staticPath)\n  }\n})</code></pre>\n<p>运行脚本：</p>\n<pre><code class=\"sh\">node build/deploy.js</code></pre>\n<p>相关环境：macOS 10.13 / Node.js 8.9 / npm 5.6</p>\n","site":{"data":{}},"excerpt":"<p>在最近的一个项目中，为了缩短加载时间，同时减轻服务器的压力，我们决定将前端静态资源全数放到七牛云上。更新内容时只需上传 <code>static</code> 目录下的所有文件（使用 webpack 打包），然后发布 <code>index.html</code> 到网站根目录即可。</p>","more":"<p>我决定使用 Node.js 上传资源，方便之后和 webpack 的打包脚本整合到一起，优化工作流。</p>\n<p>安装七牛云 Node.js SDK：</p>\n<pre><code class=\"sh\">npm install qiniu --save</code></pre>\n<p>新建一个脚本 <code>build/deploy.js</code>，引入相关包。<code>fs</code> 用于读取文件和文件夹。</p>\n<pre><code class=\"js\">const fs = require(&#39;fs&#39;)\nconst qiniu = require(&#39;qiniu&#39;)</code></pre>\n<p>声明常量：</p>\n<pre><code class=\"js\">// 授权秘钥\nconst accessKey = &#39;{你的七牛云 AccessKey}&#39;\nconst secretKey = &#39;{你的七牛云 SecretKey}&#39;\n\n// 存储空间名称\nconst bucket = &#39;{你的 Bucket 名称}&#39;\n\n// 要上传的资源目录\nconst staticPath = &#39;dist/static&#39;\n\n// 上传后的文件前缀\nconst prefix = &#39;static&#39;</code></pre>\n<p>配置 Bucket 所在的区域，然后生成上传对象 <code>formUploader</code>，同时实例化上传时需要的 <code>mac</code>、<code>putExtra</code> 对象。<code>mac</code> 用于验证身份，<code>putExtra</code> 用于在上传时传额外参数。</p>\n<pre><code class=\"js\">// 创建鉴权对象\nconst mac = new qiniu.auth.digest.Mac(accessKey, secretKey)\n\n// 创建并修改配置对象(Zone_z0=华东 Zone_z1=华北 Zone_z2=华南 Zone_na0=北美)\nconst config = new qiniu.conf.Config()\nconfig.zone = qiniu.zone.Zone_z2\n\n// 创建额外内容对象\nconst putExtra = new qiniu.form_up.PutExtra()\n\n// 创建表单上传对象\nconst formUploader = new qiniu.form_up.FormUploader(config)</code></pre>\n<p>定义上传单个文件的方法：</p>\n<pre><code class=\"js\">// 文件上传方法\nfunction uploadFile (localFile) {\n  // 配置上传到七牛云的完整路径\n  const key = localFile.replace(staticPath, prefix)\n  const options = {\n    scope: bucket + &quot;:&quot; + key\n  }\n  const putPolicy = new qiniu.rs.PutPolicy(options)\n  // 生成上传凭证\n  const uploadToken = putPolicy.uploadToken(mac)\n  // 上传文件\n  formUploader.putFile(uploadToken, key, localFile, putExtra, function(respErr,\n    respBody, respInfo) {\n    if (respErr) throw respErr\n    console.log(&#39;已上传: &#39;, respBody.key)\n  })\n}</code></pre>\n<p>定义上传文件夹的方法：</p>\n<pre><code class=\"js\">// 目录上传方法\nfunction uploadDirectory (dirPath) {\n  fs.readdir(dirPath, function (err, files) {\n    if (err) throw err\n    // 遍历目录下的内容\n    files.forEach(item =&gt; {\n      let path = `${dirPath}/${item}`\n      fs.stat(path, function (err, stats) {\n        if (err) throw err\n        // 是目录就接着遍历 否则上传\n        if (stats.isDirectory()) uploadDirectory(path)\n        else uploadFile(path, item) \n      })\n    })\n  })\n}</code></pre>\n<p>在脚本的最后，执行 <code>uploadDirectory</code> 方法开始上传：</p>\n<pre><code class=\"js\">fs.exists(staticPath, function (exists) {\n  if (!exists) {\n    console.log(&#39;目录不存在！&#39;)\n  }\n  else {\n    console.log(&#39;开始上传...&#39;)\n    uploadDirectory(staticPath)\n  }\n})</code></pre>\n<p>运行脚本：</p>\n<pre><code class=\"sh\">node build/deploy.js</code></pre>\n<p>相关环境：macOS 10.13 / Node.js 8.9 / npm 5.6</p>"},{"title":"自定义 Vim 编辑器的注释颜色","date":"2018-05-09T08:33:09.000Z","_content":"\n在 Vim 编辑器中，注释默认显示为深蓝色，在黑色背景下几乎无法看清内容，一度影响了我的工作效率和心情。原来，只需简单的配置就能够自定义 Vim 的注释颜色。\n\n<!-- more -->\n\n{% img /images/posts/2018/05/vim_comment_before.png 450 默认高亮效果 %}\n\n编辑 Vim 的配置文件 `/etc/Vimrc` ，在文档最后加上一行配置：\n\n```\nhighlight Comment ctermfg=6\n```\n\n这里 `6` 对应暗青色，也可以用 `DarkCyan` 达到相同的效果。保存后重启 Vim 即可看到配置生效。\n\n{% img /images/posts/2018/05/vim_comment_after.png 450 修改后高亮效果 %}\n\n\n除了上面使用的 #6 暗青色，还有很多颜色可供选择，下表列举了一些在 Git Bash 中测试有效的颜色。\n\n编码 | 名称 | 描述\n- | - | -\n0 | Black | 黑色\n1 | DarkRed | 暗红色\n2 | DarkGreen | 暗绿色\n3 | Brown, DarkYellow | 暗黄色\n4 | DarkBlue | 暗蓝色\n5 | DarkMagenta | 暗紫红色\n6 | DarkCyan | 暗青色\n7 | LightGray, LightGrey, Gray, Grey | 浅灰色\n\n不同 Terminal 中编码对应的颜色可能不同，具体可以参考 [官方文档](http://vimdoc.sourceforge.net/htmldoc/syntax.html#highlight-ctermfg) 。\n\n相关环境：Tencent Cloud CVM / CentOS 7.3 / Vim 7.4 / Git Bash","source":"_posts/2018-05-09@自定义 Vim 编辑器的注释颜色.md","raw":"---\ntitle: 自定义 Vim 编辑器的注释颜色\ndate: 2018-05-09 16:33:09\ncategories:\n  - Web Front-end\ntags:\n  - Vim\n---\n\n在 Vim 编辑器中，注释默认显示为深蓝色，在黑色背景下几乎无法看清内容，一度影响了我的工作效率和心情。原来，只需简单的配置就能够自定义 Vim 的注释颜色。\n\n<!-- more -->\n\n{% img /images/posts/2018/05/vim_comment_before.png 450 默认高亮效果 %}\n\n编辑 Vim 的配置文件 `/etc/Vimrc` ，在文档最后加上一行配置：\n\n```\nhighlight Comment ctermfg=6\n```\n\n这里 `6` 对应暗青色，也可以用 `DarkCyan` 达到相同的效果。保存后重启 Vim 即可看到配置生效。\n\n{% img /images/posts/2018/05/vim_comment_after.png 450 修改后高亮效果 %}\n\n\n除了上面使用的 #6 暗青色，还有很多颜色可供选择，下表列举了一些在 Git Bash 中测试有效的颜色。\n\n编码 | 名称 | 描述\n- | - | -\n0 | Black | 黑色\n1 | DarkRed | 暗红色\n2 | DarkGreen | 暗绿色\n3 | Brown, DarkYellow | 暗黄色\n4 | DarkBlue | 暗蓝色\n5 | DarkMagenta | 暗紫红色\n6 | DarkCyan | 暗青色\n7 | LightGray, LightGrey, Gray, Grey | 浅灰色\n\n不同 Terminal 中编码对应的颜色可能不同，具体可以参考 [官方文档](http://vimdoc.sourceforge.net/htmldoc/syntax.html#highlight-ctermfg) 。\n\n相关环境：Tencent Cloud CVM / CentOS 7.3 / Vim 7.4 / Git Bash","slug":"2018-05-09@自定义 Vim 编辑器的注释颜色","published":1,"updated":"2020-06-29T03:32:42.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a7009xrqgjbzce98u5","content":"<p>在 Vim 编辑器中，注释默认显示为深蓝色，在黑色背景下几乎无法看清内容，一度影响了我的工作效率和心情。原来，只需简单的配置就能够自定义 Vim 的注释颜色。</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2018/05/vim_comment_before.png\" class=\"\" width=\"450\" title=\"默认高亮效果\">\n\n<p>编辑 Vim 的配置文件 <code>/etc/Vimrc</code> ，在文档最后加上一行配置：</p>\n<pre><code>highlight Comment ctermfg=6</code></pre><p>这里 <code>6</code> 对应暗青色，也可以用 <code>DarkCyan</code> 达到相同的效果。保存后重启 Vim 即可看到配置生效。</p>\n<img src=\"/images/posts/2018/05/vim_comment_after.png\" class=\"\" width=\"450\" title=\"修改后高亮效果\">\n\n\n<p>除了上面使用的 #6 暗青色，还有很多颜色可供选择，下表列举了一些在 Git Bash 中测试有效的颜色。</p>\n<table>\n<thead>\n<tr>\n<th>编码</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Black</td>\n<td>黑色</td>\n</tr>\n<tr>\n<td>1</td>\n<td>DarkRed</td>\n<td>暗红色</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DarkGreen</td>\n<td>暗绿色</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Brown, DarkYellow</td>\n<td>暗黄色</td>\n</tr>\n<tr>\n<td>4</td>\n<td>DarkBlue</td>\n<td>暗蓝色</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DarkMagenta</td>\n<td>暗紫红色</td>\n</tr>\n<tr>\n<td>6</td>\n<td>DarkCyan</td>\n<td>暗青色</td>\n</tr>\n<tr>\n<td>7</td>\n<td>LightGray, LightGrey, Gray, Grey</td>\n<td>浅灰色</td>\n</tr>\n</tbody></table>\n<p>不同 Terminal 中编码对应的颜色可能不同，具体可以参考 <a href=\"http://vimdoc.sourceforge.net/htmldoc/syntax.html#highlight-ctermfg\" target=\"_blank\" rel=\"noopener\">官方文档</a> 。</p>\n<p>相关环境：Tencent Cloud CVM / CentOS 7.3 / Vim 7.4 / Git Bash</p>\n","site":{"data":{}},"excerpt":"<p>在 Vim 编辑器中，注释默认显示为深蓝色，在黑色背景下几乎无法看清内容，一度影响了我的工作效率和心情。原来，只需简单的配置就能够自定义 Vim 的注释颜色。</p>","more":"<img src=\"/images/posts/2018/05/vim_comment_before.png\" class=\"\" width=\"450\" title=\"默认高亮效果\">\n\n<p>编辑 Vim 的配置文件 <code>/etc/Vimrc</code> ，在文档最后加上一行配置：</p>\n<pre><code>highlight Comment ctermfg=6</code></pre><p>这里 <code>6</code> 对应暗青色，也可以用 <code>DarkCyan</code> 达到相同的效果。保存后重启 Vim 即可看到配置生效。</p>\n<img src=\"/images/posts/2018/05/vim_comment_after.png\" class=\"\" width=\"450\" title=\"修改后高亮效果\">\n\n\n<p>除了上面使用的 #6 暗青色，还有很多颜色可供选择，下表列举了一些在 Git Bash 中测试有效的颜色。</p>\n<table>\n<thead>\n<tr>\n<th>编码</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Black</td>\n<td>黑色</td>\n</tr>\n<tr>\n<td>1</td>\n<td>DarkRed</td>\n<td>暗红色</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DarkGreen</td>\n<td>暗绿色</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Brown, DarkYellow</td>\n<td>暗黄色</td>\n</tr>\n<tr>\n<td>4</td>\n<td>DarkBlue</td>\n<td>暗蓝色</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DarkMagenta</td>\n<td>暗紫红色</td>\n</tr>\n<tr>\n<td>6</td>\n<td>DarkCyan</td>\n<td>暗青色</td>\n</tr>\n<tr>\n<td>7</td>\n<td>LightGray, LightGrey, Gray, Grey</td>\n<td>浅灰色</td>\n</tr>\n</tbody></table>\n<p>不同 Terminal 中编码对应的颜色可能不同，具体可以参考 <a href=\"http://vimdoc.sourceforge.net/htmldoc/syntax.html#highlight-ctermfg\" target=\"_blank\" rel=\"noopener\">官方文档</a> 。</p>\n<p>相关环境：Tencent Cloud CVM / CentOS 7.3 / Vim 7.4 / Git Bash</p>"},{"title":"如何优雅地和译者协作开发多语言 WebApp","date":"2018-06-10T13:24:34.000Z","_content":"\n因为工作需要，未来开发的大部分 WebApp、H5 都需要国际化。现有工作流程比较简单：不同国家的译者在 Google Docs 的表格上翻译，开发者手动拷贝文本到前端项目中。对开发而言，由于看不懂文档中的大多数语言，既费时费力又容易出错。\n\n<!-- more -->\n\n所以我迫切需要一个能优化流程的工具。首先要使翻译的同事们不需要做太多改变 —— 总不能强求非开发人员学习 JSON 吧，又必须能让我显著减少浪费在拷贝和校对文本上的时间，专注于功能开发。\n\n于是我写了一个叫 i18nCSV 的工具，主要做几件事情：\n\n- 解析 CSV 翻译文件\n- 返回多语言 Object\n- 输出各个语言的 `.json`、`.yml` 文件\n- 字符串处理\n\n译者仍然在 Google Docs 上工作，我只需把表格存为 CSV 格式再用工具跑一下，就能得到我要的东西。\n\n\n\n## 安装\n\n```\nnpm install i18n-csv --save-dev\n```\n\n\n\n## 解析\n\nCSV 文件内容：\n\n| Field name | en                     | zh-cn     | jp                    |\n| ---------- | ---------------------- | --------- | --------------------- |\n| title      | Hello World            | 你好世界  | こんにちは世界        |\n| subtitle   | The weather is great ! | 天气真好! | 天_はとても良いです！ |\n\n使用 i18nCSV 解析：\n\n```js\nconst i18nCSV = require('i18n-csv')\ni18nCSV.parse({ input: './file1.csv' })\n```\n\n返回的对象：\n\n```js\n{\n  en: {\n    title: 'Hello World',\n    subtitle: 'The weather is great !'\n  },\n  'zh-cn': {\n    title: '你好世界',\n    subtitle: '天气真好!'\n  },\n  jp: {\n    title: 'こんにちは世界',\n    subtitle: '天_はとても良いです！'\n  }\n}\n```\n\n\n\n## 设置起始列\n\n默认使用第 2 行为正文的起始行，第 2 列作为正文的起始列。\n\n有时我们需要指定正文的起始列。例如，为了和翻译人员协作，我们需要在正文前面插入两列描述内容，但是不希望这两列被当作语言解析到对象中。\n\nCSV 文件内容：\n\n| Field name | Description (Chinese) | Description (English) | en                     | zh-cn     | jp                    |\n| ---------- | -------------------- | -------------------- | ---------------------- | --------- | --------------------- |\n| title      | 标题                 | main title           | Hello World            | 你好世界  | こんにちは世界        |\n| subtitle   | 副标题               | subtitle             | The weather is great ! | 天气真好! | 天_はとても良いです！ |\n\n此时可以使用 `startCol=4` 指定正文从第 4 列开始：\n\n```js\ni18nCSV.parse({\n  input: './file2.csv',\n  startCol: 4\n})\n```\n\n类似的，使用 `startRow` 可以设置正文的起始行。\n\n\n\n## 设置语言代码\n\n默认使用正文的列标题（第一行）作为语言代码：`en`、`zh-cn`、`jp`，并用作输出的文件名：`en.json`、`zh-cn.json`、`jp.json`。\n\n当需要和其他同事，比如翻译或运营人员协作时，列标题应该更加友好、通俗易懂。此时可以用 `#` 设置语言代码。列标题中包含多个 `#` 时将始终使用最后一个 `#` 后的内容作为语言代码。\n\n示例：\n\n| Field name | English #en            | Chinese #zh-cn | Japanese #jp          |\n| ---------- | ---------------------- | -------------- | --------------------- |\n| title      | Hello World            | 你好世界       | こんにちは世界        |\n| subtitle   | The weather is great ! | 天气真好!      | 天_はとても良いです！ |\n\n\n\n\n\n## 输出\n\n使用 `ouput` 指定输出目录，解析后会在目录下生成各个语言的 `.json` 文件。\n\n```js\ni18nCSV.parse({\n  input: './file1.csv',\n  output: 'path/to/output'\n})\n```\n\n输出完毕打印的日志：\n\n```\nMulti-language files has been generated !\n\nsource:  ./file1.csv\noutput:  path/to/output\nformat:  JSON\n```\n\n如无意外，`path/to/output` 目录下已经新增了 `en.json` 、`zh-cn.json` 、`jp.json` 三个文件。\n\n生成的 `en.json` 文件内容：\n\n```json\n// path/to/output/en.json\n{\n  \"title\": \"Hello World\",\n  \"subtitle\": \"The weather is great !\"\n}\n```\n\n使用 `saveAsYAML=true` 可以输出更简洁、易于修改的 YAML 格式：\n\n```js\ni18nCSV.parse({\n  input: './file1.csv',\n  output: 'path/to/output',\n  saveAsYAML: true\n})\n```\n\n生成的 `en.yml` 文件内容：\n\n```yaml\n# path/to/output/en.yml\ntitle: Hello World\nsubtitle: The weather is great !\n```\n\n\n\n## 替换\n\n假设有 CSV 文件内容如下：\n\n| Field name | en                      | zh-cn                    | jp                        |\n| ---------- | ----------------------- | ------------------------ | ------------------------- |\n| title      | Hello World             | 你好世界                 | こんにちは世界            |\n| subtitle   | Share trips with #trips | 参与话题 #trips 分享旅程 | #trips とのシェアトリップ |\n\n为了自定义文本中的 _#trips_  的样式，我们需要对文本进行一些处理。\n\n`replace` 用于添加 __替换任务__，它的每一个元素都是一个任务。任务（数组）的第一个元素是被替换内容，可以是正则表达式或字符串，第二个元素是替换内容。\n\n例如，将所有 `#trips` 用 `<hashtag>` 标签包裹起来：\n\n```js\ni18nCSV.parse({\n  input: './file4.csv',\n  replace: [\n    [/(#\\w+)/g, '<hashtag>$1</hashtag>']\n  ]\n})\n```\n\n返回的对象：\n\n```js\n{\n  en: {\n    title: 'Hello World',\n    subtitle: 'Share trips with <hashtag>#trips</hashtag>'\n  },\n  'zh-cn': {\n    title: '你好世界',\n    subtitle: '参与话题 <hashtag>#trips</hashtag> 分享旅程'\n  },\n  jp: {\n    title: 'こんにちは世界',\n    subtitle: '<hashtag>#trips</hashtag> とのシェアトリップ'\n  }\n}\n```\n\n任务的第三个元素可以指定仅对某个字段有效：\n\n```js\ni18nCSV.parse({\n  input: './file4.csv',\n  replace: [\n    [/(#\\w+)/g, '<hashtag>$1</hashtag>', 'subtitle']\n  ]\n})\n```\n\n\n\n## 提示\n\n1. CSV 文件的第一列始终作为每一行文本的 Key 。\n2. CSV 文件的编码必须是 UTF-8 ，否则可能出现解析后的内容包含乱码。Mac 下转换编码：使用 Numbers 打开 CSV 文件，点击菜单中的 文件 > 导出到 > CSV，在 _高级选项_ 中将 _文本编码_ 修改为 _UTF-8_ 后导出。\n\n相关环境：macOS 10.13 / Node.js 8.11 / npm 5.6\n","source":"_posts/2018-06-10@如何优雅地和译者协作开发多语言 WebApp.md","raw":"---\ntitle: 如何优雅地和译者协作开发多语言 WebApp\ndate: 2018-06-10 21:24:34\ncategories:\n  - Web Front-end\ntags:\n  - Node.js\n  - i18n\n  - CSV\n  - JSON\n  - YAML\n---\n\n因为工作需要，未来开发的大部分 WebApp、H5 都需要国际化。现有工作流程比较简单：不同国家的译者在 Google Docs 的表格上翻译，开发者手动拷贝文本到前端项目中。对开发而言，由于看不懂文档中的大多数语言，既费时费力又容易出错。\n\n<!-- more -->\n\n所以我迫切需要一个能优化流程的工具。首先要使翻译的同事们不需要做太多改变 —— 总不能强求非开发人员学习 JSON 吧，又必须能让我显著减少浪费在拷贝和校对文本上的时间，专注于功能开发。\n\n于是我写了一个叫 i18nCSV 的工具，主要做几件事情：\n\n- 解析 CSV 翻译文件\n- 返回多语言 Object\n- 输出各个语言的 `.json`、`.yml` 文件\n- 字符串处理\n\n译者仍然在 Google Docs 上工作，我只需把表格存为 CSV 格式再用工具跑一下，就能得到我要的东西。\n\n\n\n## 安装\n\n```\nnpm install i18n-csv --save-dev\n```\n\n\n\n## 解析\n\nCSV 文件内容：\n\n| Field name | en                     | zh-cn     | jp                    |\n| ---------- | ---------------------- | --------- | --------------------- |\n| title      | Hello World            | 你好世界  | こんにちは世界        |\n| subtitle   | The weather is great ! | 天气真好! | 天_はとても良いです！ |\n\n使用 i18nCSV 解析：\n\n```js\nconst i18nCSV = require('i18n-csv')\ni18nCSV.parse({ input: './file1.csv' })\n```\n\n返回的对象：\n\n```js\n{\n  en: {\n    title: 'Hello World',\n    subtitle: 'The weather is great !'\n  },\n  'zh-cn': {\n    title: '你好世界',\n    subtitle: '天气真好!'\n  },\n  jp: {\n    title: 'こんにちは世界',\n    subtitle: '天_はとても良いです！'\n  }\n}\n```\n\n\n\n## 设置起始列\n\n默认使用第 2 行为正文的起始行，第 2 列作为正文的起始列。\n\n有时我们需要指定正文的起始列。例如，为了和翻译人员协作，我们需要在正文前面插入两列描述内容，但是不希望这两列被当作语言解析到对象中。\n\nCSV 文件内容：\n\n| Field name | Description (Chinese) | Description (English) | en                     | zh-cn     | jp                    |\n| ---------- | -------------------- | -------------------- | ---------------------- | --------- | --------------------- |\n| title      | 标题                 | main title           | Hello World            | 你好世界  | こんにちは世界        |\n| subtitle   | 副标题               | subtitle             | The weather is great ! | 天气真好! | 天_はとても良いです！ |\n\n此时可以使用 `startCol=4` 指定正文从第 4 列开始：\n\n```js\ni18nCSV.parse({\n  input: './file2.csv',\n  startCol: 4\n})\n```\n\n类似的，使用 `startRow` 可以设置正文的起始行。\n\n\n\n## 设置语言代码\n\n默认使用正文的列标题（第一行）作为语言代码：`en`、`zh-cn`、`jp`，并用作输出的文件名：`en.json`、`zh-cn.json`、`jp.json`。\n\n当需要和其他同事，比如翻译或运营人员协作时，列标题应该更加友好、通俗易懂。此时可以用 `#` 设置语言代码。列标题中包含多个 `#` 时将始终使用最后一个 `#` 后的内容作为语言代码。\n\n示例：\n\n| Field name | English #en            | Chinese #zh-cn | Japanese #jp          |\n| ---------- | ---------------------- | -------------- | --------------------- |\n| title      | Hello World            | 你好世界       | こんにちは世界        |\n| subtitle   | The weather is great ! | 天气真好!      | 天_はとても良いです！ |\n\n\n\n\n\n## 输出\n\n使用 `ouput` 指定输出目录，解析后会在目录下生成各个语言的 `.json` 文件。\n\n```js\ni18nCSV.parse({\n  input: './file1.csv',\n  output: 'path/to/output'\n})\n```\n\n输出完毕打印的日志：\n\n```\nMulti-language files has been generated !\n\nsource:  ./file1.csv\noutput:  path/to/output\nformat:  JSON\n```\n\n如无意外，`path/to/output` 目录下已经新增了 `en.json` 、`zh-cn.json` 、`jp.json` 三个文件。\n\n生成的 `en.json` 文件内容：\n\n```json\n// path/to/output/en.json\n{\n  \"title\": \"Hello World\",\n  \"subtitle\": \"The weather is great !\"\n}\n```\n\n使用 `saveAsYAML=true` 可以输出更简洁、易于修改的 YAML 格式：\n\n```js\ni18nCSV.parse({\n  input: './file1.csv',\n  output: 'path/to/output',\n  saveAsYAML: true\n})\n```\n\n生成的 `en.yml` 文件内容：\n\n```yaml\n# path/to/output/en.yml\ntitle: Hello World\nsubtitle: The weather is great !\n```\n\n\n\n## 替换\n\n假设有 CSV 文件内容如下：\n\n| Field name | en                      | zh-cn                    | jp                        |\n| ---------- | ----------------------- | ------------------------ | ------------------------- |\n| title      | Hello World             | 你好世界                 | こんにちは世界            |\n| subtitle   | Share trips with #trips | 参与话题 #trips 分享旅程 | #trips とのシェアトリップ |\n\n为了自定义文本中的 _#trips_  的样式，我们需要对文本进行一些处理。\n\n`replace` 用于添加 __替换任务__，它的每一个元素都是一个任务。任务（数组）的第一个元素是被替换内容，可以是正则表达式或字符串，第二个元素是替换内容。\n\n例如，将所有 `#trips` 用 `<hashtag>` 标签包裹起来：\n\n```js\ni18nCSV.parse({\n  input: './file4.csv',\n  replace: [\n    [/(#\\w+)/g, '<hashtag>$1</hashtag>']\n  ]\n})\n```\n\n返回的对象：\n\n```js\n{\n  en: {\n    title: 'Hello World',\n    subtitle: 'Share trips with <hashtag>#trips</hashtag>'\n  },\n  'zh-cn': {\n    title: '你好世界',\n    subtitle: '参与话题 <hashtag>#trips</hashtag> 分享旅程'\n  },\n  jp: {\n    title: 'こんにちは世界',\n    subtitle: '<hashtag>#trips</hashtag> とのシェアトリップ'\n  }\n}\n```\n\n任务的第三个元素可以指定仅对某个字段有效：\n\n```js\ni18nCSV.parse({\n  input: './file4.csv',\n  replace: [\n    [/(#\\w+)/g, '<hashtag>$1</hashtag>', 'subtitle']\n  ]\n})\n```\n\n\n\n## 提示\n\n1. CSV 文件的第一列始终作为每一行文本的 Key 。\n2. CSV 文件的编码必须是 UTF-8 ，否则可能出现解析后的内容包含乱码。Mac 下转换编码：使用 Numbers 打开 CSV 文件，点击菜单中的 文件 > 导出到 > CSV，在 _高级选项_ 中将 _文本编码_ 修改为 _UTF-8_ 后导出。\n\n相关环境：macOS 10.13 / Node.js 8.11 / npm 5.6\n","slug":"2018-06-10@如何优雅地和译者协作开发多语言 WebApp","published":1,"updated":"2020-06-29T03:32:42.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a800a0rqgja4mu61nv","content":"<p>因为工作需要，未来开发的大部分 WebApp、H5 都需要国际化。现有工作流程比较简单：不同国家的译者在 Google Docs 的表格上翻译，开发者手动拷贝文本到前端项目中。对开发而言，由于看不懂文档中的大多数语言，既费时费力又容易出错。</p>\n<a id=\"more\"></a>\n\n<p>所以我迫切需要一个能优化流程的工具。首先要使翻译的同事们不需要做太多改变 —— 总不能强求非开发人员学习 JSON 吧，又必须能让我显著减少浪费在拷贝和校对文本上的时间，专注于功能开发。</p>\n<p>于是我写了一个叫 i18nCSV 的工具，主要做几件事情：</p>\n<ul>\n<li>解析 CSV 翻译文件</li>\n<li>返回多语言 Object</li>\n<li>输出各个语言的 <code>.json</code>、<code>.yml</code> 文件</li>\n<li>字符串处理</li>\n</ul>\n<p>译者仍然在 Google Docs 上工作，我只需把表格存为 CSV 格式再用工具跑一下，就能得到我要的东西。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>npm install i18n-csv --save-dev</code></pre><h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>CSV 文件内容：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<p>使用 i18nCSV 解析：</p>\n<pre><code class=\"js\">const i18nCSV = require(&#39;i18n-csv&#39;)\ni18nCSV.parse({ input: &#39;./file1.csv&#39; })</code></pre>\n<p>返回的对象：</p>\n<pre><code class=\"js\">{\n  en: {\n    title: &#39;Hello World&#39;,\n    subtitle: &#39;The weather is great !&#39;\n  },\n  &#39;zh-cn&#39;: {\n    title: &#39;你好世界&#39;,\n    subtitle: &#39;天气真好!&#39;\n  },\n  jp: {\n    title: &#39;こんにちは世界&#39;,\n    subtitle: &#39;天_はとても良いです！&#39;\n  }\n}</code></pre>\n<h2 id=\"设置起始列\"><a href=\"#设置起始列\" class=\"headerlink\" title=\"设置起始列\"></a>设置起始列</h2><p>默认使用第 2 行为正文的起始行，第 2 列作为正文的起始列。</p>\n<p>有时我们需要指定正文的起始列。例如，为了和翻译人员协作，我们需要在正文前面插入两列描述内容，但是不希望这两列被当作语言解析到对象中。</p>\n<p>CSV 文件内容：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Description (Chinese)</th>\n<th>Description (English)</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>标题</td>\n<td>main title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>副标题</td>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<p>此时可以使用 <code>startCol=4</code> 指定正文从第 4 列开始：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file2.csv&#39;,\n  startCol: 4\n})</code></pre>\n<p>类似的，使用 <code>startRow</code> 可以设置正文的起始行。</p>\n<h2 id=\"设置语言代码\"><a href=\"#设置语言代码\" class=\"headerlink\" title=\"设置语言代码\"></a>设置语言代码</h2><p>默认使用正文的列标题（第一行）作为语言代码：<code>en</code>、<code>zh-cn</code>、<code>jp</code>，并用作输出的文件名：<code>en.json</code>、<code>zh-cn.json</code>、<code>jp.json</code>。</p>\n<p>当需要和其他同事，比如翻译或运营人员协作时，列标题应该更加友好、通俗易懂。此时可以用 <code>#</code> 设置语言代码。列标题中包含多个 <code>#</code> 时将始终使用最后一个 <code>#</code> 后的内容作为语言代码。</p>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>English #en</th>\n<th>Chinese #zh-cn</th>\n<th>Japanese #jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>使用 <code>ouput</code> 指定输出目录，解析后会在目录下生成各个语言的 <code>.json</code> 文件。</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file1.csv&#39;,\n  output: &#39;path/to/output&#39;\n})</code></pre>\n<p>输出完毕打印的日志：</p>\n<pre><code>Multi-language files has been generated !\n\nsource:  ./file1.csv\noutput:  path/to/output\nformat:  JSON</code></pre><p>如无意外，<code>path/to/output</code> 目录下已经新增了 <code>en.json</code> 、<code>zh-cn.json</code> 、<code>jp.json</code> 三个文件。</p>\n<p>生成的 <code>en.json</code> 文件内容：</p>\n<pre><code class=\"json\">// path/to/output/en.json\n{\n  &quot;title&quot;: &quot;Hello World&quot;,\n  &quot;subtitle&quot;: &quot;The weather is great !&quot;\n}</code></pre>\n<p>使用 <code>saveAsYAML=true</code> 可以输出更简洁、易于修改的 YAML 格式：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file1.csv&#39;,\n  output: &#39;path/to/output&#39;,\n  saveAsYAML: true\n})</code></pre>\n<p>生成的 <code>en.yml</code> 文件内容：</p>\n<pre><code class=\"yaml\"># path/to/output/en.yml\ntitle: Hello World\nsubtitle: The weather is great !</code></pre>\n<h2 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h2><p>假设有 CSV 文件内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>Share trips with #trips</td>\n<td>参与话题 #trips 分享旅程</td>\n<td>#trips とのシェアトリップ</td>\n</tr>\n</tbody></table>\n<p>为了自定义文本中的 <em>#trips</em>  的样式，我们需要对文本进行一些处理。</p>\n<p><code>replace</code> 用于添加 <strong>替换任务</strong>，它的每一个元素都是一个任务。任务（数组）的第一个元素是被替换内容，可以是正则表达式或字符串，第二个元素是替换内容。</p>\n<p>例如，将所有 <code>#trips</code> 用 <code>&lt;hashtag&gt;</code> 标签包裹起来：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file4.csv&#39;,\n  replace: [\n    [/(#\\w+)/g, &#39;&lt;hashtag&gt;$1&lt;/hashtag&gt;&#39;]\n  ]\n})</code></pre>\n<p>返回的对象：</p>\n<pre><code class=\"js\">{\n  en: {\n    title: &#39;Hello World&#39;,\n    subtitle: &#39;Share trips with &lt;hashtag&gt;#trips&lt;/hashtag&gt;&#39;\n  },\n  &#39;zh-cn&#39;: {\n    title: &#39;你好世界&#39;,\n    subtitle: &#39;参与话题 &lt;hashtag&gt;#trips&lt;/hashtag&gt; 分享旅程&#39;\n  },\n  jp: {\n    title: &#39;こんにちは世界&#39;,\n    subtitle: &#39;&lt;hashtag&gt;#trips&lt;/hashtag&gt; とのシェアトリップ&#39;\n  }\n}</code></pre>\n<p>任务的第三个元素可以指定仅对某个字段有效：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file4.csv&#39;,\n  replace: [\n    [/(#\\w+)/g, &#39;&lt;hashtag&gt;$1&lt;/hashtag&gt;&#39;, &#39;subtitle&#39;]\n  ]\n})</code></pre>\n<h2 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h2><ol>\n<li>CSV 文件的第一列始终作为每一行文本的 Key 。</li>\n<li>CSV 文件的编码必须是 UTF-8 ，否则可能出现解析后的内容包含乱码。Mac 下转换编码：使用 Numbers 打开 CSV 文件，点击菜单中的 文件 &gt; 导出到 &gt; CSV，在 <em>高级选项</em> 中将 <em>文本编码</em> 修改为 <em>UTF-8</em> 后导出。</li>\n</ol>\n<p>相关环境：macOS 10.13 / Node.js 8.11 / npm 5.6</p>\n","site":{"data":{}},"excerpt":"<p>因为工作需要，未来开发的大部分 WebApp、H5 都需要国际化。现有工作流程比较简单：不同国家的译者在 Google Docs 的表格上翻译，开发者手动拷贝文本到前端项目中。对开发而言，由于看不懂文档中的大多数语言，既费时费力又容易出错。</p>","more":"<p>所以我迫切需要一个能优化流程的工具。首先要使翻译的同事们不需要做太多改变 —— 总不能强求非开发人员学习 JSON 吧，又必须能让我显著减少浪费在拷贝和校对文本上的时间，专注于功能开发。</p>\n<p>于是我写了一个叫 i18nCSV 的工具，主要做几件事情：</p>\n<ul>\n<li>解析 CSV 翻译文件</li>\n<li>返回多语言 Object</li>\n<li>输出各个语言的 <code>.json</code>、<code>.yml</code> 文件</li>\n<li>字符串处理</li>\n</ul>\n<p>译者仍然在 Google Docs 上工作，我只需把表格存为 CSV 格式再用工具跑一下，就能得到我要的东西。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>npm install i18n-csv --save-dev</code></pre><h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>CSV 文件内容：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<p>使用 i18nCSV 解析：</p>\n<pre><code class=\"js\">const i18nCSV = require(&#39;i18n-csv&#39;)\ni18nCSV.parse({ input: &#39;./file1.csv&#39; })</code></pre>\n<p>返回的对象：</p>\n<pre><code class=\"js\">{\n  en: {\n    title: &#39;Hello World&#39;,\n    subtitle: &#39;The weather is great !&#39;\n  },\n  &#39;zh-cn&#39;: {\n    title: &#39;你好世界&#39;,\n    subtitle: &#39;天气真好!&#39;\n  },\n  jp: {\n    title: &#39;こんにちは世界&#39;,\n    subtitle: &#39;天_はとても良いです！&#39;\n  }\n}</code></pre>\n<h2 id=\"设置起始列\"><a href=\"#设置起始列\" class=\"headerlink\" title=\"设置起始列\"></a>设置起始列</h2><p>默认使用第 2 行为正文的起始行，第 2 列作为正文的起始列。</p>\n<p>有时我们需要指定正文的起始列。例如，为了和翻译人员协作，我们需要在正文前面插入两列描述内容，但是不希望这两列被当作语言解析到对象中。</p>\n<p>CSV 文件内容：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Description (Chinese)</th>\n<th>Description (English)</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>标题</td>\n<td>main title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>副标题</td>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<p>此时可以使用 <code>startCol=4</code> 指定正文从第 4 列开始：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file2.csv&#39;,\n  startCol: 4\n})</code></pre>\n<p>类似的，使用 <code>startRow</code> 可以设置正文的起始行。</p>\n<h2 id=\"设置语言代码\"><a href=\"#设置语言代码\" class=\"headerlink\" title=\"设置语言代码\"></a>设置语言代码</h2><p>默认使用正文的列标题（第一行）作为语言代码：<code>en</code>、<code>zh-cn</code>、<code>jp</code>，并用作输出的文件名：<code>en.json</code>、<code>zh-cn.json</code>、<code>jp.json</code>。</p>\n<p>当需要和其他同事，比如翻译或运营人员协作时，列标题应该更加友好、通俗易懂。此时可以用 <code>#</code> 设置语言代码。列标题中包含多个 <code>#</code> 时将始终使用最后一个 <code>#</code> 后的内容作为语言代码。</p>\n<p>示例：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>English #en</th>\n<th>Chinese #zh-cn</th>\n<th>Japanese #jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>The weather is great !</td>\n<td>天气真好!</td>\n<td>天_はとても良いです！</td>\n</tr>\n</tbody></table>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><p>使用 <code>ouput</code> 指定输出目录，解析后会在目录下生成各个语言的 <code>.json</code> 文件。</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file1.csv&#39;,\n  output: &#39;path/to/output&#39;\n})</code></pre>\n<p>输出完毕打印的日志：</p>\n<pre><code>Multi-language files has been generated !\n\nsource:  ./file1.csv\noutput:  path/to/output\nformat:  JSON</code></pre><p>如无意外，<code>path/to/output</code> 目录下已经新增了 <code>en.json</code> 、<code>zh-cn.json</code> 、<code>jp.json</code> 三个文件。</p>\n<p>生成的 <code>en.json</code> 文件内容：</p>\n<pre><code class=\"json\">// path/to/output/en.json\n{\n  &quot;title&quot;: &quot;Hello World&quot;,\n  &quot;subtitle&quot;: &quot;The weather is great !&quot;\n}</code></pre>\n<p>使用 <code>saveAsYAML=true</code> 可以输出更简洁、易于修改的 YAML 格式：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file1.csv&#39;,\n  output: &#39;path/to/output&#39;,\n  saveAsYAML: true\n})</code></pre>\n<p>生成的 <code>en.yml</code> 文件内容：</p>\n<pre><code class=\"yaml\"># path/to/output/en.yml\ntitle: Hello World\nsubtitle: The weather is great !</code></pre>\n<h2 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h2><p>假设有 CSV 文件内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>en</th>\n<th>zh-cn</th>\n<th>jp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>Hello World</td>\n<td>你好世界</td>\n<td>こんにちは世界</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>Share trips with #trips</td>\n<td>参与话题 #trips 分享旅程</td>\n<td>#trips とのシェアトリップ</td>\n</tr>\n</tbody></table>\n<p>为了自定义文本中的 <em>#trips</em>  的样式，我们需要对文本进行一些处理。</p>\n<p><code>replace</code> 用于添加 <strong>替换任务</strong>，它的每一个元素都是一个任务。任务（数组）的第一个元素是被替换内容，可以是正则表达式或字符串，第二个元素是替换内容。</p>\n<p>例如，将所有 <code>#trips</code> 用 <code>&lt;hashtag&gt;</code> 标签包裹起来：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file4.csv&#39;,\n  replace: [\n    [/(#\\w+)/g, &#39;&lt;hashtag&gt;$1&lt;/hashtag&gt;&#39;]\n  ]\n})</code></pre>\n<p>返回的对象：</p>\n<pre><code class=\"js\">{\n  en: {\n    title: &#39;Hello World&#39;,\n    subtitle: &#39;Share trips with &lt;hashtag&gt;#trips&lt;/hashtag&gt;&#39;\n  },\n  &#39;zh-cn&#39;: {\n    title: &#39;你好世界&#39;,\n    subtitle: &#39;参与话题 &lt;hashtag&gt;#trips&lt;/hashtag&gt; 分享旅程&#39;\n  },\n  jp: {\n    title: &#39;こんにちは世界&#39;,\n    subtitle: &#39;&lt;hashtag&gt;#trips&lt;/hashtag&gt; とのシェアトリップ&#39;\n  }\n}</code></pre>\n<p>任务的第三个元素可以指定仅对某个字段有效：</p>\n<pre><code class=\"js\">i18nCSV.parse({\n  input: &#39;./file4.csv&#39;,\n  replace: [\n    [/(#\\w+)/g, &#39;&lt;hashtag&gt;$1&lt;/hashtag&gt;&#39;, &#39;subtitle&#39;]\n  ]\n})</code></pre>\n<h2 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h2><ol>\n<li>CSV 文件的第一列始终作为每一行文本的 Key 。</li>\n<li>CSV 文件的编码必须是 UTF-8 ，否则可能出现解析后的内容包含乱码。Mac 下转换编码：使用 Numbers 打开 CSV 文件，点击菜单中的 文件 &gt; 导出到 &gt; CSV，在 <em>高级选项</em> 中将 <em>文本编码</em> 修改为 <em>UTF-8</em> 后导出。</li>\n</ol>\n<p>相关环境：macOS 10.13 / Node.js 8.11 / npm 5.6</p>"},{"title":"海外主流社交 APP 分享指南","date":"2018-11-15T05:17:55.000Z","_content":"\n## 了解开放图谱\n\n一个被分享到社交平台的网页，通常以包含标题、描述和缩略图等摘要的卡片形式显示。网页的内容千差万别，用户想要分享的可能是一篇文章，一首歌，亦或是一部电影。社交平台该如何呈现分享内容才能兼具准确和美观呢？\n\n<!-- more -->\n\n{% img /images/posts/2018/11/open_graph.jpg 450 开放图谱 %}\n\n开放图谱（[Open Graph](http://www.ogp.me/)）是 Facebook 公司创造的一种通讯协议，它使任何网页都能成为社交网络中的富对象（具有标题、描述等属性的数据实体）。简单地说，Web 开发者在网页中使用标记语言设置分享内容，网页被用户分享，Facebook 抓取网页上的分享内容，经过加工后显示在页面上。\n\n开放图谱能够带给用户更好的社交体验。举个例子，当用户分享一个视频网站的播放页面 Foo，实际上想要分享的是上面的视频 Bar。在网页标记了视频链接的情况下，Facebook 能够直接显示可播放的视频 Bar，而不需要用户再跳转到网页 Foo 浏览。\n\n目前海外主流的社交软件基本上都支持开放图谱。有了它，我们能够控制网页在社交网络上展示的形式和内容。\n\n在网页的 `head` 中使用 `meta` 标签添加开放图谱标记：\n\n``` html\n<head>\n  <title>Example Page</title>\n  <meta property=\"og:url\" content=\"https://example.com\">\n  <meta property=\"og:type\" content=\"website\">\n  <meta property=\"og:title\" content=\"Introducing AI Retouch\">\n  <meta property=\"og:description\" content=\"I am using BeautyPlus ...\">\n  <meta property=\"og:image\" content=\"https://example.com/image.jpg\">\n  ...\n</head>\n```\n\n上面的开放图谱标记声明了用户分享的是一个网页，并且提供了标题、描述和图片供社交平台展示。\n\n更多开放图谱骚操作请阅读 Facebook [网站管理员分享指南](https://developers.facebook.com/docs/sharing/webmasters/?translation) 。\n\n## 分享到 Facebook\n\n首先，在 Facebook 开发者平台上 [创建应用](https://developers.facebook.com/apps/) 获得 `AppId` ，在网页中 [加载和初始化 SDK](https://developers.facebook.com/docs/javascript/quickstart) 。\n\n在需要分享内容的时候调起分享对话框：\n\n``` js\nwindow.FB.ui({\n  method: 'share',\n  quote: 'some text',          // 引文\n  hashtag: '#frontend',        // 话题\n  href: 'https://example.com'  // 链接\n})\n```\n\n随后页面将跳转到 Facebook 的发帖页面。\n\n## 分享到 Twitter\n\nTwitter 提供了 [Web Intents](https://developer.twitter.com/en/docs/twitter-for-websites/web-intents/overview) 用于通过网页分享内容，只需使用户跳转到一个链接。\n\n```\nhttps://twitter.com/intent/tweet?text={推文}&hashtags={话题}&url={网页链接}\n```\n\n可以自定义预设推文 `text` ，一个或一个以上用逗号分隔的话题 `hashtags` ，以及网页链接 `url` 。URL 需要用 `encodeURIComponent` 编码，否则可能出现跳转到 Twitter 后的链接不完整。\n\n若用户安装了 App，唤醒客户端。否则通过网页版分享。\n\n## 分享到 Instagram\n\n很遗憾，目前 Instagram 暂时没有提供任何可靠的 Web 分享方式。\n\n唯一可能有用的是，官方文档中提到的用于调起客户端功能的 [iPhone Hooks](\nhttps://www.instagram.com/developer/mobile-sharing/iphone-hooks/) —— 实际上就是深度链接（[Deep Linking](https://en.wikipedia.org/wiki/Mobile_deep_linking)）。对于分享图片的场景，可以先引导用户保存图片，然后用深度链接唤醒 Instagram App，最后由用户手动选择图片发帖。\n\n```\ninstagram://app\n```\n\n注意，经测试这些深度链接在 Android 设备上并不好使，很可能只在 iOS 平台实现。\n\n## 分享到 WhatsApp\n\n目前 WhatsApp 仅支持通过深度链接调起 App 的方式分享一段文本。幸运的是，我们可以把网页链接放在 `text` 中，分享后应用会依据开放图谱友好显示。\n\n```\nwhatsapp://send?text={文本}\n```\n## 分享到 Line\n\nLine 提供了 [Social Plugins](https://media.line.me/) 用于分享网页，只需让用户跳转到一个链接。跳转后会唤醒 App 或者进入网页版 —— 取决于用户是否安装了客户端。\n\n```\nhttps://social-plugins.line.me/lineit/share?url={网页链接}\n```\n\n## 分享到 Facebook Messenger\n\nMessenger App 提供了用于分享的深度链接，允许发送一个网页。\n\n```\nfb-messenger://share/?link={网页链接}\n```\n","source":"_posts/2018-11-15@海外主流社交 APP 分享指南.md","raw":"---\ntitle: 海外主流社交 APP 分享指南\ndate: 2018-11-15 13:17:55\ncategories:\n  - Web Front-end\ntags:\n  - 社交平台\n  - 分享\n  - 深度链接\n  - Deep Linking\n  - Facebook\n  - Twitter\n  - Instagram\n  - WhatsApp\n  - Line\n  - Messenger\n\n---\n\n## 了解开放图谱\n\n一个被分享到社交平台的网页，通常以包含标题、描述和缩略图等摘要的卡片形式显示。网页的内容千差万别，用户想要分享的可能是一篇文章，一首歌，亦或是一部电影。社交平台该如何呈现分享内容才能兼具准确和美观呢？\n\n<!-- more -->\n\n{% img /images/posts/2018/11/open_graph.jpg 450 开放图谱 %}\n\n开放图谱（[Open Graph](http://www.ogp.me/)）是 Facebook 公司创造的一种通讯协议，它使任何网页都能成为社交网络中的富对象（具有标题、描述等属性的数据实体）。简单地说，Web 开发者在网页中使用标记语言设置分享内容，网页被用户分享，Facebook 抓取网页上的分享内容，经过加工后显示在页面上。\n\n开放图谱能够带给用户更好的社交体验。举个例子，当用户分享一个视频网站的播放页面 Foo，实际上想要分享的是上面的视频 Bar。在网页标记了视频链接的情况下，Facebook 能够直接显示可播放的视频 Bar，而不需要用户再跳转到网页 Foo 浏览。\n\n目前海外主流的社交软件基本上都支持开放图谱。有了它，我们能够控制网页在社交网络上展示的形式和内容。\n\n在网页的 `head` 中使用 `meta` 标签添加开放图谱标记：\n\n``` html\n<head>\n  <title>Example Page</title>\n  <meta property=\"og:url\" content=\"https://example.com\">\n  <meta property=\"og:type\" content=\"website\">\n  <meta property=\"og:title\" content=\"Introducing AI Retouch\">\n  <meta property=\"og:description\" content=\"I am using BeautyPlus ...\">\n  <meta property=\"og:image\" content=\"https://example.com/image.jpg\">\n  ...\n</head>\n```\n\n上面的开放图谱标记声明了用户分享的是一个网页，并且提供了标题、描述和图片供社交平台展示。\n\n更多开放图谱骚操作请阅读 Facebook [网站管理员分享指南](https://developers.facebook.com/docs/sharing/webmasters/?translation) 。\n\n## 分享到 Facebook\n\n首先，在 Facebook 开发者平台上 [创建应用](https://developers.facebook.com/apps/) 获得 `AppId` ，在网页中 [加载和初始化 SDK](https://developers.facebook.com/docs/javascript/quickstart) 。\n\n在需要分享内容的时候调起分享对话框：\n\n``` js\nwindow.FB.ui({\n  method: 'share',\n  quote: 'some text',          // 引文\n  hashtag: '#frontend',        // 话题\n  href: 'https://example.com'  // 链接\n})\n```\n\n随后页面将跳转到 Facebook 的发帖页面。\n\n## 分享到 Twitter\n\nTwitter 提供了 [Web Intents](https://developer.twitter.com/en/docs/twitter-for-websites/web-intents/overview) 用于通过网页分享内容，只需使用户跳转到一个链接。\n\n```\nhttps://twitter.com/intent/tweet?text={推文}&hashtags={话题}&url={网页链接}\n```\n\n可以自定义预设推文 `text` ，一个或一个以上用逗号分隔的话题 `hashtags` ，以及网页链接 `url` 。URL 需要用 `encodeURIComponent` 编码，否则可能出现跳转到 Twitter 后的链接不完整。\n\n若用户安装了 App，唤醒客户端。否则通过网页版分享。\n\n## 分享到 Instagram\n\n很遗憾，目前 Instagram 暂时没有提供任何可靠的 Web 分享方式。\n\n唯一可能有用的是，官方文档中提到的用于调起客户端功能的 [iPhone Hooks](\nhttps://www.instagram.com/developer/mobile-sharing/iphone-hooks/) —— 实际上就是深度链接（[Deep Linking](https://en.wikipedia.org/wiki/Mobile_deep_linking)）。对于分享图片的场景，可以先引导用户保存图片，然后用深度链接唤醒 Instagram App，最后由用户手动选择图片发帖。\n\n```\ninstagram://app\n```\n\n注意，经测试这些深度链接在 Android 设备上并不好使，很可能只在 iOS 平台实现。\n\n## 分享到 WhatsApp\n\n目前 WhatsApp 仅支持通过深度链接调起 App 的方式分享一段文本。幸运的是，我们可以把网页链接放在 `text` 中，分享后应用会依据开放图谱友好显示。\n\n```\nwhatsapp://send?text={文本}\n```\n## 分享到 Line\n\nLine 提供了 [Social Plugins](https://media.line.me/) 用于分享网页，只需让用户跳转到一个链接。跳转后会唤醒 App 或者进入网页版 —— 取决于用户是否安装了客户端。\n\n```\nhttps://social-plugins.line.me/lineit/share?url={网页链接}\n```\n\n## 分享到 Facebook Messenger\n\nMessenger App 提供了用于分享的深度链接，允许发送一个网页。\n\n```\nfb-messenger://share/?link={网页链接}\n```\n","slug":"2018-11-15@海外主流社交 APP 分享指南","published":1,"updated":"2020-06-29T03:32:42.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a900a4rqgj1ep9euek","content":"<h2 id=\"了解开放图谱\"><a href=\"#了解开放图谱\" class=\"headerlink\" title=\"了解开放图谱\"></a>了解开放图谱</h2><p>一个被分享到社交平台的网页，通常以包含标题、描述和缩略图等摘要的卡片形式显示。网页的内容千差万别，用户想要分享的可能是一篇文章，一首歌，亦或是一部电影。社交平台该如何呈现分享内容才能兼具准确和美观呢？</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2018/11/open_graph.jpg\" class=\"\" width=\"450\" title=\"开放图谱\">\n\n<p>开放图谱（<a href=\"http://www.ogp.me/\" target=\"_blank\" rel=\"noopener\">Open Graph</a>）是 Facebook 公司创造的一种通讯协议，它使任何网页都能成为社交网络中的富对象（具有标题、描述等属性的数据实体）。简单地说，Web 开发者在网页中使用标记语言设置分享内容，网页被用户分享，Facebook 抓取网页上的分享内容，经过加工后显示在页面上。</p>\n<p>开放图谱能够带给用户更好的社交体验。举个例子，当用户分享一个视频网站的播放页面 Foo，实际上想要分享的是上面的视频 Bar。在网页标记了视频链接的情况下，Facebook 能够直接显示可播放的视频 Bar，而不需要用户再跳转到网页 Foo 浏览。</p>\n<p>目前海外主流的社交软件基本上都支持开放图谱。有了它，我们能够控制网页在社交网络上展示的形式和内容。</p>\n<p>在网页的 <code>head</code> 中使用 <code>meta</code> 标签添加开放图谱标记：</p>\n<pre><code class=\"html\">&lt;head&gt;\n  &lt;title&gt;Example Page&lt;/title&gt;\n  &lt;meta property=&quot;og:url&quot; content=&quot;https://example.com&quot;&gt;\n  &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;\n  &lt;meta property=&quot;og:title&quot; content=&quot;Introducing AI Retouch&quot;&gt;\n  &lt;meta property=&quot;og:description&quot; content=&quot;I am using BeautyPlus ...&quot;&gt;\n  &lt;meta property=&quot;og:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt;\n  ...\n&lt;/head&gt;</code></pre>\n<p>上面的开放图谱标记声明了用户分享的是一个网页，并且提供了标题、描述和图片供社交平台展示。</p>\n<p>更多开放图谱骚操作请阅读 Facebook <a href=\"https://developers.facebook.com/docs/sharing/webmasters/?translation\" target=\"_blank\" rel=\"noopener\">网站管理员分享指南</a> 。</p>\n<h2 id=\"分享到-Facebook\"><a href=\"#分享到-Facebook\" class=\"headerlink\" title=\"分享到 Facebook\"></a>分享到 Facebook</h2><p>首先，在 Facebook 开发者平台上 <a href=\"https://developers.facebook.com/apps/\" target=\"_blank\" rel=\"noopener\">创建应用</a> 获得 <code>AppId</code> ，在网页中 <a href=\"https://developers.facebook.com/docs/javascript/quickstart\" target=\"_blank\" rel=\"noopener\">加载和初始化 SDK</a> 。</p>\n<p>在需要分享内容的时候调起分享对话框：</p>\n<pre><code class=\"js\">window.FB.ui({\n  method: &#39;share&#39;,\n  quote: &#39;some text&#39;,          // 引文\n  hashtag: &#39;#frontend&#39;,        // 话题\n  href: &#39;https://example.com&#39;  // 链接\n})</code></pre>\n<p>随后页面将跳转到 Facebook 的发帖页面。</p>\n<h2 id=\"分享到-Twitter\"><a href=\"#分享到-Twitter\" class=\"headerlink\" title=\"分享到 Twitter\"></a>分享到 Twitter</h2><p>Twitter 提供了 <a href=\"https://developer.twitter.com/en/docs/twitter-for-websites/web-intents/overview\" target=\"_blank\" rel=\"noopener\">Web Intents</a> 用于通过网页分享内容，只需使用户跳转到一个链接。</p>\n<pre><code>https://twitter.com/intent/tweet?text={推文}&amp;hashtags={话题}&amp;url={网页链接}</code></pre><p>可以自定义预设推文 <code>text</code> ，一个或一个以上用逗号分隔的话题 <code>hashtags</code> ，以及网页链接 <code>url</code> 。URL 需要用 <code>encodeURIComponent</code> 编码，否则可能出现跳转到 Twitter 后的链接不完整。</p>\n<p>若用户安装了 App，唤醒客户端。否则通过网页版分享。</p>\n<h2 id=\"分享到-Instagram\"><a href=\"#分享到-Instagram\" class=\"headerlink\" title=\"分享到 Instagram\"></a>分享到 Instagram</h2><p>很遗憾，目前 Instagram 暂时没有提供任何可靠的 Web 分享方式。</p>\n<p>唯一可能有用的是，官方文档中提到的用于调起客户端功能的 <a href=\"https://www.instagram.com/developer/mobile-sharing/iphone-hooks/\" target=\"_blank\" rel=\"noopener\">iPhone Hooks</a> —— 实际上就是深度链接（<a href=\"https://en.wikipedia.org/wiki/Mobile_deep_linking\" target=\"_blank\" rel=\"noopener\">Deep Linking</a>）。对于分享图片的场景，可以先引导用户保存图片，然后用深度链接唤醒 Instagram App，最后由用户手动选择图片发帖。</p>\n<pre><code>instagram://app</code></pre><p>注意，经测试这些深度链接在 Android 设备上并不好使，很可能只在 iOS 平台实现。</p>\n<h2 id=\"分享到-WhatsApp\"><a href=\"#分享到-WhatsApp\" class=\"headerlink\" title=\"分享到 WhatsApp\"></a>分享到 WhatsApp</h2><p>目前 WhatsApp 仅支持通过深度链接调起 App 的方式分享一段文本。幸运的是，我们可以把网页链接放在 <code>text</code> 中，分享后应用会依据开放图谱友好显示。</p>\n<pre><code>whatsapp://send?text={文本}</code></pre><h2 id=\"分享到-Line\"><a href=\"#分享到-Line\" class=\"headerlink\" title=\"分享到 Line\"></a>分享到 Line</h2><p>Line 提供了 <a href=\"https://media.line.me/\" target=\"_blank\" rel=\"noopener\">Social Plugins</a> 用于分享网页，只需让用户跳转到一个链接。跳转后会唤醒 App 或者进入网页版 —— 取决于用户是否安装了客户端。</p>\n<pre><code>https://social-plugins.line.me/lineit/share?url={网页链接}</code></pre><h2 id=\"分享到-Facebook-Messenger\"><a href=\"#分享到-Facebook-Messenger\" class=\"headerlink\" title=\"分享到 Facebook Messenger\"></a>分享到 Facebook Messenger</h2><p>Messenger App 提供了用于分享的深度链接，允许发送一个网页。</p>\n<pre><code>fb-messenger://share/?link={网页链接}</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"了解开放图谱\"><a href=\"#了解开放图谱\" class=\"headerlink\" title=\"了解开放图谱\"></a>了解开放图谱</h2><p>一个被分享到社交平台的网页，通常以包含标题、描述和缩略图等摘要的卡片形式显示。网页的内容千差万别，用户想要分享的可能是一篇文章，一首歌，亦或是一部电影。社交平台该如何呈现分享内容才能兼具准确和美观呢？</p>","more":"<img src=\"/images/posts/2018/11/open_graph.jpg\" class=\"\" width=\"450\" title=\"开放图谱\">\n\n<p>开放图谱（<a href=\"http://www.ogp.me/\" target=\"_blank\" rel=\"noopener\">Open Graph</a>）是 Facebook 公司创造的一种通讯协议，它使任何网页都能成为社交网络中的富对象（具有标题、描述等属性的数据实体）。简单地说，Web 开发者在网页中使用标记语言设置分享内容，网页被用户分享，Facebook 抓取网页上的分享内容，经过加工后显示在页面上。</p>\n<p>开放图谱能够带给用户更好的社交体验。举个例子，当用户分享一个视频网站的播放页面 Foo，实际上想要分享的是上面的视频 Bar。在网页标记了视频链接的情况下，Facebook 能够直接显示可播放的视频 Bar，而不需要用户再跳转到网页 Foo 浏览。</p>\n<p>目前海外主流的社交软件基本上都支持开放图谱。有了它，我们能够控制网页在社交网络上展示的形式和内容。</p>\n<p>在网页的 <code>head</code> 中使用 <code>meta</code> 标签添加开放图谱标记：</p>\n<pre><code class=\"html\">&lt;head&gt;\n  &lt;title&gt;Example Page&lt;/title&gt;\n  &lt;meta property=&quot;og:url&quot; content=&quot;https://example.com&quot;&gt;\n  &lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;\n  &lt;meta property=&quot;og:title&quot; content=&quot;Introducing AI Retouch&quot;&gt;\n  &lt;meta property=&quot;og:description&quot; content=&quot;I am using BeautyPlus ...&quot;&gt;\n  &lt;meta property=&quot;og:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt;\n  ...\n&lt;/head&gt;</code></pre>\n<p>上面的开放图谱标记声明了用户分享的是一个网页，并且提供了标题、描述和图片供社交平台展示。</p>\n<p>更多开放图谱骚操作请阅读 Facebook <a href=\"https://developers.facebook.com/docs/sharing/webmasters/?translation\" target=\"_blank\" rel=\"noopener\">网站管理员分享指南</a> 。</p>\n<h2 id=\"分享到-Facebook\"><a href=\"#分享到-Facebook\" class=\"headerlink\" title=\"分享到 Facebook\"></a>分享到 Facebook</h2><p>首先，在 Facebook 开发者平台上 <a href=\"https://developers.facebook.com/apps/\" target=\"_blank\" rel=\"noopener\">创建应用</a> 获得 <code>AppId</code> ，在网页中 <a href=\"https://developers.facebook.com/docs/javascript/quickstart\" target=\"_blank\" rel=\"noopener\">加载和初始化 SDK</a> 。</p>\n<p>在需要分享内容的时候调起分享对话框：</p>\n<pre><code class=\"js\">window.FB.ui({\n  method: &#39;share&#39;,\n  quote: &#39;some text&#39;,          // 引文\n  hashtag: &#39;#frontend&#39;,        // 话题\n  href: &#39;https://example.com&#39;  // 链接\n})</code></pre>\n<p>随后页面将跳转到 Facebook 的发帖页面。</p>\n<h2 id=\"分享到-Twitter\"><a href=\"#分享到-Twitter\" class=\"headerlink\" title=\"分享到 Twitter\"></a>分享到 Twitter</h2><p>Twitter 提供了 <a href=\"https://developer.twitter.com/en/docs/twitter-for-websites/web-intents/overview\" target=\"_blank\" rel=\"noopener\">Web Intents</a> 用于通过网页分享内容，只需使用户跳转到一个链接。</p>\n<pre><code>https://twitter.com/intent/tweet?text={推文}&amp;hashtags={话题}&amp;url={网页链接}</code></pre><p>可以自定义预设推文 <code>text</code> ，一个或一个以上用逗号分隔的话题 <code>hashtags</code> ，以及网页链接 <code>url</code> 。URL 需要用 <code>encodeURIComponent</code> 编码，否则可能出现跳转到 Twitter 后的链接不完整。</p>\n<p>若用户安装了 App，唤醒客户端。否则通过网页版分享。</p>\n<h2 id=\"分享到-Instagram\"><a href=\"#分享到-Instagram\" class=\"headerlink\" title=\"分享到 Instagram\"></a>分享到 Instagram</h2><p>很遗憾，目前 Instagram 暂时没有提供任何可靠的 Web 分享方式。</p>\n<p>唯一可能有用的是，官方文档中提到的用于调起客户端功能的 <a href=\"https://www.instagram.com/developer/mobile-sharing/iphone-hooks/\" target=\"_blank\" rel=\"noopener\">iPhone Hooks</a> —— 实际上就是深度链接（<a href=\"https://en.wikipedia.org/wiki/Mobile_deep_linking\" target=\"_blank\" rel=\"noopener\">Deep Linking</a>）。对于分享图片的场景，可以先引导用户保存图片，然后用深度链接唤醒 Instagram App，最后由用户手动选择图片发帖。</p>\n<pre><code>instagram://app</code></pre><p>注意，经测试这些深度链接在 Android 设备上并不好使，很可能只在 iOS 平台实现。</p>\n<h2 id=\"分享到-WhatsApp\"><a href=\"#分享到-WhatsApp\" class=\"headerlink\" title=\"分享到 WhatsApp\"></a>分享到 WhatsApp</h2><p>目前 WhatsApp 仅支持通过深度链接调起 App 的方式分享一段文本。幸运的是，我们可以把网页链接放在 <code>text</code> 中，分享后应用会依据开放图谱友好显示。</p>\n<pre><code>whatsapp://send?text={文本}</code></pre><h2 id=\"分享到-Line\"><a href=\"#分享到-Line\" class=\"headerlink\" title=\"分享到 Line\"></a>分享到 Line</h2><p>Line 提供了 <a href=\"https://media.line.me/\" target=\"_blank\" rel=\"noopener\">Social Plugins</a> 用于分享网页，只需让用户跳转到一个链接。跳转后会唤醒 App 或者进入网页版 —— 取决于用户是否安装了客户端。</p>\n<pre><code>https://social-plugins.line.me/lineit/share?url={网页链接}</code></pre><h2 id=\"分享到-Facebook-Messenger\"><a href=\"#分享到-Facebook-Messenger\" class=\"headerlink\" title=\"分享到 Facebook Messenger\"></a>分享到 Facebook Messenger</h2><p>Messenger App 提供了用于分享的深度链接，允许发送一个网页。</p>\n<pre><code>fb-messenger://share/?link={网页链接}</code></pre>"},{"title":"Android 应用接入微信分享","date":"2018-12-22T10:35:05.000Z","_content":"\n## 准备工作\n\n### 在微信开放平台注册\n\n登陆 [微信开放平台](https://open.weixin.qq.com/) 创建一个移动应用，正确填写应用 **名称**，**包名** 和 **签名**，得到一个 `AppID` 。\n\n<!-- more -->\n\n- 移动应用名称，将显示在用户分享的信息中。\n\n- 应用包名，相信接触过 Android 的开发者都已经很熟悉了，它是项目中的基础软件包的名称。包名的格式是域名的反写，例如，微信客户端的包名是 `com.tencent.mm` 。\n\n- 应用签名，是签名所用密钥的 MD5 指纹。Android 要求应用必须先使用证书进行签名，然后才能安装。所以你生成的，可供任意用户安装的应用，必然可以查询到一个密钥指纹。许多人在接入后无法调起分享，仅仅是因为获取指纹的姿势不对。为了少走弯路，建议直接通过微信提供的 [签名获取工具](https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk) 查询。\n\n### 配置 debug 版本签名\n\n默认情况下，通过开发工具直接运行在模拟器上的应用是不包含签名的。这也是签名校验失败的可能原因之一。为了方便在开发时调用微信接口，需要配置 debug 版本签名。\n\n1. 右击项目，选择 `Open Module Settings` ，打开项目结构配置。\n2. 在 `Signing` 选项卡下添加一个签名，填好密钥信息。\n3. 在 `Build Types` 选项卡下修改 debug 版本的 `Signing Config` ，选择第二步中添加的签名。\n\n{% img no-border /images/posts/2018/12/android_project_structure.png 480 Android Project Structure %}\n\n## 接入微信 SDK\n\n接入 SDK 的过程非常简单。\n\n第一步，在 Gradle 的配置文件中添加依赖，等待 SDK 下载完毕。\n\n``` java\n// build.gradle (Module: app)\ndependencies {\n  implementation 'com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+'\n}\n```\n\n第二步，在清单文件中声明必要的权限。\n\n``` xml\n<!-- AndroidManifest.xml -->\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n\n\n## 注册到微信\n\n在调用微信客户端的功能之前，需要先使用 `registerApp` 注册你申请到的 `AppID` 。这一步的目的是确认当前应用的包名、签名与微信开放平台上登记的一致。常量 `APP_ID` 的值应该是你的 `AppID` 。\n\n``` java\napi = WXAPIFactory.createWXAPI(context, APP_ID, true);\napi.registerApp(APP_ID);\n```\n\n## 分享内容到微信\n\n要分享内容到微信，你的 APP 应该向微信客户端发送一个包含 **微信媒体消息**（WXMediaMessage）的发信请求。微信媒体消息通常包含基础的标题、描述、缩略图，和一个媒体对象。\n\n分享的媒体可以是网页、文件、小程序等，微信 SDK 提供了 [丰富的对象](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&id=open1419317340) 以便发送不同类型的内容。\n\n以分享一个网页到朋友圈为例：\n\n``` java\n// 设置网址\nWXWebpageObject webpage = new WXWebpageObject();\nwebpage.webpageUrl = \"https://example.blog\";\n\n// 设置标题\nWXMediaMessage msg = new WXMediaMessage(webpage);\nmsg.title = \"My Blog\";\n\n// 设置缩略图\nBitmap thumb = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_thumb);\nmsg.thumbData = Image.bitmapToByteArray(thumb);\n\n// 构造一个发信请求\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = String.valueOf(System.currentTimeMillis());\nreq.message = msg;\nreq.scene = WXSceneTimeline;\n\n// 发送请求给微信客户端\napi.sendReq(req);\n```\n\n消息中的缩略图 `thumbData` 应该是字节数据。下面是一个将位图转换成字节数据的示例方法：\n\n``` java\npublic static byte[] bitmapToByteArray(Bitmap bitmap){\n  ByteArrayOutputStream output = new ByteArrayOutputStream();\n  bitmap.compress(Bitmap.CompressFormat.JPEG, 100, output);\n  return output.toByteArray();\n}\n```\n\n一个发信请求还应该包括场景和事务ID：\n\n\n- 分享场景 `scene` 可选对话 `WXSceneSession`、朋友圈 `WXSceneTimeline` 和收藏 `WXSceneFavorite` 三种。\n\n- 事务ID  `transaction` 用于唯一标识一个请求。\n\n相关环境：macOS 10.14 / Android Studio 3.2 / WeChat SDK for Android 5.1\n","source":"_posts/2018-12-22@Android 应用接入微信分享.md","raw":"---\ntitle: Android 应用接入微信分享\ndate: 2018-12-22 18:35:05\ntags:\n  - Android\n  - Android Studio\n  - APP\n  - Java\n  - 微信\n  - 分享\ncategories:\n  - Android\n---\n\n## 准备工作\n\n### 在微信开放平台注册\n\n登陆 [微信开放平台](https://open.weixin.qq.com/) 创建一个移动应用，正确填写应用 **名称**，**包名** 和 **签名**，得到一个 `AppID` 。\n\n<!-- more -->\n\n- 移动应用名称，将显示在用户分享的信息中。\n\n- 应用包名，相信接触过 Android 的开发者都已经很熟悉了，它是项目中的基础软件包的名称。包名的格式是域名的反写，例如，微信客户端的包名是 `com.tencent.mm` 。\n\n- 应用签名，是签名所用密钥的 MD5 指纹。Android 要求应用必须先使用证书进行签名，然后才能安装。所以你生成的，可供任意用户安装的应用，必然可以查询到一个密钥指纹。许多人在接入后无法调起分享，仅仅是因为获取指纹的姿势不对。为了少走弯路，建议直接通过微信提供的 [签名获取工具](https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk) 查询。\n\n### 配置 debug 版本签名\n\n默认情况下，通过开发工具直接运行在模拟器上的应用是不包含签名的。这也是签名校验失败的可能原因之一。为了方便在开发时调用微信接口，需要配置 debug 版本签名。\n\n1. 右击项目，选择 `Open Module Settings` ，打开项目结构配置。\n2. 在 `Signing` 选项卡下添加一个签名，填好密钥信息。\n3. 在 `Build Types` 选项卡下修改 debug 版本的 `Signing Config` ，选择第二步中添加的签名。\n\n{% img no-border /images/posts/2018/12/android_project_structure.png 480 Android Project Structure %}\n\n## 接入微信 SDK\n\n接入 SDK 的过程非常简单。\n\n第一步，在 Gradle 的配置文件中添加依赖，等待 SDK 下载完毕。\n\n``` java\n// build.gradle (Module: app)\ndependencies {\n  implementation 'com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+'\n}\n```\n\n第二步，在清单文件中声明必要的权限。\n\n``` xml\n<!-- AndroidManifest.xml -->\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n\n\n## 注册到微信\n\n在调用微信客户端的功能之前，需要先使用 `registerApp` 注册你申请到的 `AppID` 。这一步的目的是确认当前应用的包名、签名与微信开放平台上登记的一致。常量 `APP_ID` 的值应该是你的 `AppID` 。\n\n``` java\napi = WXAPIFactory.createWXAPI(context, APP_ID, true);\napi.registerApp(APP_ID);\n```\n\n## 分享内容到微信\n\n要分享内容到微信，你的 APP 应该向微信客户端发送一个包含 **微信媒体消息**（WXMediaMessage）的发信请求。微信媒体消息通常包含基础的标题、描述、缩略图，和一个媒体对象。\n\n分享的媒体可以是网页、文件、小程序等，微信 SDK 提供了 [丰富的对象](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&id=open1419317340) 以便发送不同类型的内容。\n\n以分享一个网页到朋友圈为例：\n\n``` java\n// 设置网址\nWXWebpageObject webpage = new WXWebpageObject();\nwebpage.webpageUrl = \"https://example.blog\";\n\n// 设置标题\nWXMediaMessage msg = new WXMediaMessage(webpage);\nmsg.title = \"My Blog\";\n\n// 设置缩略图\nBitmap thumb = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_thumb);\nmsg.thumbData = Image.bitmapToByteArray(thumb);\n\n// 构造一个发信请求\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = String.valueOf(System.currentTimeMillis());\nreq.message = msg;\nreq.scene = WXSceneTimeline;\n\n// 发送请求给微信客户端\napi.sendReq(req);\n```\n\n消息中的缩略图 `thumbData` 应该是字节数据。下面是一个将位图转换成字节数据的示例方法：\n\n``` java\npublic static byte[] bitmapToByteArray(Bitmap bitmap){\n  ByteArrayOutputStream output = new ByteArrayOutputStream();\n  bitmap.compress(Bitmap.CompressFormat.JPEG, 100, output);\n  return output.toByteArray();\n}\n```\n\n一个发信请求还应该包括场景和事务ID：\n\n\n- 分享场景 `scene` 可选对话 `WXSceneSession`、朋友圈 `WXSceneTimeline` 和收藏 `WXSceneFavorite` 三种。\n\n- 事务ID  `transaction` 用于唯一标识一个请求。\n\n相关环境：macOS 10.14 / Android Studio 3.2 / WeChat SDK for Android 5.1\n","slug":"2018-12-22@Android 应用接入微信分享","published":1,"updated":"2020-06-29T03:32:42.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4a900a7rqgjc80weujz","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"在微信开放平台注册\"><a href=\"#在微信开放平台注册\" class=\"headerlink\" title=\"在微信开放平台注册\"></a>在微信开放平台注册</h3><p>登陆 <a href=\"https://open.weixin.qq.com/\" target=\"_blank\" rel=\"noopener\">微信开放平台</a> 创建一个移动应用，正确填写应用 <strong>名称</strong>，<strong>包名</strong> 和 <strong>签名</strong>，得到一个 <code>AppID</code> 。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>移动应用名称，将显示在用户分享的信息中。</p>\n</li>\n<li><p>应用包名，相信接触过 Android 的开发者都已经很熟悉了，它是项目中的基础软件包的名称。包名的格式是域名的反写，例如，微信客户端的包名是 <code>com.tencent.mm</code> 。</p>\n</li>\n<li><p>应用签名，是签名所用密钥的 MD5 指纹。Android 要求应用必须先使用证书进行签名，然后才能安装。所以你生成的，可供任意用户安装的应用，必然可以查询到一个密钥指纹。许多人在接入后无法调起分享，仅仅是因为获取指纹的姿势不对。为了少走弯路，建议直接通过微信提供的 <a href=\"https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk\" target=\"_blank\" rel=\"noopener\">签名获取工具</a> 查询。</p>\n</li>\n</ul>\n<h3 id=\"配置-debug-版本签名\"><a href=\"#配置-debug-版本签名\" class=\"headerlink\" title=\"配置 debug 版本签名\"></a>配置 debug 版本签名</h3><p>默认情况下，通过开发工具直接运行在模拟器上的应用是不包含签名的。这也是签名校验失败的可能原因之一。为了方便在开发时调用微信接口，需要配置 debug 版本签名。</p>\n<ol>\n<li>右击项目，选择 <code>Open Module Settings</code> ，打开项目结构配置。</li>\n<li>在 <code>Signing</code> 选项卡下添加一个签名，填好密钥信息。</li>\n<li>在 <code>Build Types</code> 选项卡下修改 debug 版本的 <code>Signing Config</code> ，选择第二步中添加的签名。</li>\n</ol>\n<img src=\"/images/posts/2018/12/android_project_structure.png\" class=\"no-border\" width=\"480\" title=\"Android Project Structure\">\n\n<h2 id=\"接入微信-SDK\"><a href=\"#接入微信-SDK\" class=\"headerlink\" title=\"接入微信 SDK\"></a>接入微信 SDK</h2><p>接入 SDK 的过程非常简单。</p>\n<p>第一步，在 Gradle 的配置文件中添加依赖，等待 SDK 下载完毕。</p>\n<pre><code class=\"java\">// build.gradle (Module: app)\ndependencies {\n  implementation &#39;com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&#39;\n}</code></pre>\n<p>第二步，在清单文件中声明必要的权限。</p>\n<pre><code class=\"xml\">&lt;!-- AndroidManifest.xml --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre>\n<h2 id=\"注册到微信\"><a href=\"#注册到微信\" class=\"headerlink\" title=\"注册到微信\"></a>注册到微信</h2><p>在调用微信客户端的功能之前，需要先使用 <code>registerApp</code> 注册你申请到的 <code>AppID</code> 。这一步的目的是确认当前应用的包名、签名与微信开放平台上登记的一致。常量 <code>APP_ID</code> 的值应该是你的 <code>AppID</code> 。</p>\n<pre><code class=\"java\">api = WXAPIFactory.createWXAPI(context, APP_ID, true);\napi.registerApp(APP_ID);</code></pre>\n<h2 id=\"分享内容到微信\"><a href=\"#分享内容到微信\" class=\"headerlink\" title=\"分享内容到微信\"></a>分享内容到微信</h2><p>要分享内容到微信，你的 APP 应该向微信客户端发送一个包含 <strong>微信媒体消息</strong>（WXMediaMessage）的发信请求。微信媒体消息通常包含基础的标题、描述、缩略图，和一个媒体对象。</p>\n<p>分享的媒体可以是网页、文件、小程序等，微信 SDK 提供了 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&id=open1419317340\" target=\"_blank\" rel=\"noopener\">丰富的对象</a> 以便发送不同类型的内容。</p>\n<p>以分享一个网页到朋友圈为例：</p>\n<pre><code class=\"java\">// 设置网址\nWXWebpageObject webpage = new WXWebpageObject();\nwebpage.webpageUrl = &quot;https://example.blog&quot;;\n\n// 设置标题\nWXMediaMessage msg = new WXMediaMessage(webpage);\nmsg.title = &quot;My Blog&quot;;\n\n// 设置缩略图\nBitmap thumb = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_thumb);\nmsg.thumbData = Image.bitmapToByteArray(thumb);\n\n// 构造一个发信请求\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = String.valueOf(System.currentTimeMillis());\nreq.message = msg;\nreq.scene = WXSceneTimeline;\n\n// 发送请求给微信客户端\napi.sendReq(req);</code></pre>\n<p>消息中的缩略图 <code>thumbData</code> 应该是字节数据。下面是一个将位图转换成字节数据的示例方法：</p>\n<pre><code class=\"java\">public static byte[] bitmapToByteArray(Bitmap bitmap){\n  ByteArrayOutputStream output = new ByteArrayOutputStream();\n  bitmap.compress(Bitmap.CompressFormat.JPEG, 100, output);\n  return output.toByteArray();\n}</code></pre>\n<p>一个发信请求还应该包括场景和事务ID：</p>\n<ul>\n<li><p>分享场景 <code>scene</code> 可选对话 <code>WXSceneSession</code>、朋友圈 <code>WXSceneTimeline</code> 和收藏 <code>WXSceneFavorite</code> 三种。</p>\n</li>\n<li><p>事务ID  <code>transaction</code> 用于唯一标识一个请求。</p>\n</li>\n</ul>\n<p>相关环境：macOS 10.14 / Android Studio 3.2 / WeChat SDK for Android 5.1</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"在微信开放平台注册\"><a href=\"#在微信开放平台注册\" class=\"headerlink\" title=\"在微信开放平台注册\"></a>在微信开放平台注册</h3><p>登陆 <a href=\"https://open.weixin.qq.com/\" target=\"_blank\" rel=\"noopener\">微信开放平台</a> 创建一个移动应用，正确填写应用 <strong>名称</strong>，<strong>包名</strong> 和 <strong>签名</strong>，得到一个 <code>AppID</code> 。</p>","more":"<ul>\n<li><p>移动应用名称，将显示在用户分享的信息中。</p>\n</li>\n<li><p>应用包名，相信接触过 Android 的开发者都已经很熟悉了，它是项目中的基础软件包的名称。包名的格式是域名的反写，例如，微信客户端的包名是 <code>com.tencent.mm</code> 。</p>\n</li>\n<li><p>应用签名，是签名所用密钥的 MD5 指纹。Android 要求应用必须先使用证书进行签名，然后才能安装。所以你生成的，可供任意用户安装的应用，必然可以查询到一个密钥指纹。许多人在接入后无法调起分享，仅仅是因为获取指纹的姿势不对。为了少走弯路，建议直接通过微信提供的 <a href=\"https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk\" target=\"_blank\" rel=\"noopener\">签名获取工具</a> 查询。</p>\n</li>\n</ul>\n<h3 id=\"配置-debug-版本签名\"><a href=\"#配置-debug-版本签名\" class=\"headerlink\" title=\"配置 debug 版本签名\"></a>配置 debug 版本签名</h3><p>默认情况下，通过开发工具直接运行在模拟器上的应用是不包含签名的。这也是签名校验失败的可能原因之一。为了方便在开发时调用微信接口，需要配置 debug 版本签名。</p>\n<ol>\n<li>右击项目，选择 <code>Open Module Settings</code> ，打开项目结构配置。</li>\n<li>在 <code>Signing</code> 选项卡下添加一个签名，填好密钥信息。</li>\n<li>在 <code>Build Types</code> 选项卡下修改 debug 版本的 <code>Signing Config</code> ，选择第二步中添加的签名。</li>\n</ol>\n<img src=\"/images/posts/2018/12/android_project_structure.png\" class=\"no-border\" width=\"480\" title=\"Android Project Structure\">\n\n<h2 id=\"接入微信-SDK\"><a href=\"#接入微信-SDK\" class=\"headerlink\" title=\"接入微信 SDK\"></a>接入微信 SDK</h2><p>接入 SDK 的过程非常简单。</p>\n<p>第一步，在 Gradle 的配置文件中添加依赖，等待 SDK 下载完毕。</p>\n<pre><code class=\"java\">// build.gradle (Module: app)\ndependencies {\n  implementation &#39;com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+&#39;\n}</code></pre>\n<p>第二步，在清单文件中声明必要的权限。</p>\n<pre><code class=\"xml\">&lt;!-- AndroidManifest.xml --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre>\n<h2 id=\"注册到微信\"><a href=\"#注册到微信\" class=\"headerlink\" title=\"注册到微信\"></a>注册到微信</h2><p>在调用微信客户端的功能之前，需要先使用 <code>registerApp</code> 注册你申请到的 <code>AppID</code> 。这一步的目的是确认当前应用的包名、签名与微信开放平台上登记的一致。常量 <code>APP_ID</code> 的值应该是你的 <code>AppID</code> 。</p>\n<pre><code class=\"java\">api = WXAPIFactory.createWXAPI(context, APP_ID, true);\napi.registerApp(APP_ID);</code></pre>\n<h2 id=\"分享内容到微信\"><a href=\"#分享内容到微信\" class=\"headerlink\" title=\"分享内容到微信\"></a>分享内容到微信</h2><p>要分享内容到微信，你的 APP 应该向微信客户端发送一个包含 <strong>微信媒体消息</strong>（WXMediaMessage）的发信请求。微信媒体消息通常包含基础的标题、描述、缩略图，和一个媒体对象。</p>\n<p>分享的媒体可以是网页、文件、小程序等，微信 SDK 提供了 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&id=open1419317340\" target=\"_blank\" rel=\"noopener\">丰富的对象</a> 以便发送不同类型的内容。</p>\n<p>以分享一个网页到朋友圈为例：</p>\n<pre><code class=\"java\">// 设置网址\nWXWebpageObject webpage = new WXWebpageObject();\nwebpage.webpageUrl = &quot;https://example.blog&quot;;\n\n// 设置标题\nWXMediaMessage msg = new WXMediaMessage(webpage);\nmsg.title = &quot;My Blog&quot;;\n\n// 设置缩略图\nBitmap thumb = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_thumb);\nmsg.thumbData = Image.bitmapToByteArray(thumb);\n\n// 构造一个发信请求\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = String.valueOf(System.currentTimeMillis());\nreq.message = msg;\nreq.scene = WXSceneTimeline;\n\n// 发送请求给微信客户端\napi.sendReq(req);</code></pre>\n<p>消息中的缩略图 <code>thumbData</code> 应该是字节数据。下面是一个将位图转换成字节数据的示例方法：</p>\n<pre><code class=\"java\">public static byte[] bitmapToByteArray(Bitmap bitmap){\n  ByteArrayOutputStream output = new ByteArrayOutputStream();\n  bitmap.compress(Bitmap.CompressFormat.JPEG, 100, output);\n  return output.toByteArray();\n}</code></pre>\n<p>一个发信请求还应该包括场景和事务ID：</p>\n<ul>\n<li><p>分享场景 <code>scene</code> 可选对话 <code>WXSceneSession</code>、朋友圈 <code>WXSceneTimeline</code> 和收藏 <code>WXSceneFavorite</code> 三种。</p>\n</li>\n<li><p>事务ID  <code>transaction</code> 用于唯一标识一个请求。</p>\n</li>\n</ul>\n<p>相关环境：macOS 10.14 / Android Studio 3.2 / WeChat SDK for Android 5.1</p>"},{"title":"Promise 的原理与简单实现","date":"2019-03-15T13:49:54.000Z","_content":"\n\n\n## 什么是 Promise\n\n起初，人们使用回调函数进行异步编程。回调函数是指一个可被另一个函数访问，并在后者执行后调用的函数。过多的回调函数嵌套形成难以阅读和维护的回调地狱（Callback Hell / Pyramid of Doom）。\n\n<!-- more -->\n\n``` js\nlogin(function () {\n  getUserInfo(function () {\n    getProductList(function () {\n      ...\n    })\n  })\n})\n```\n\n这时候人们开始思考更佳的异步解决方案，Promise 应运而生。\n\n`promise` 这个词的原意是约定。在现实生活中，约定往往不是立即做一件事，而是在满足一定条件下做或不做某事。\n\n电影《泰坦尼克号》中杰克对罗斯说“你跳，我也跳（You jump, I jump）”。由于杰克不知道罗斯跳不跳，何时跳，后者的行为可以视为一个需要等待的异步操作。罗斯的行为可能从犹豫到跳，或者从犹豫到不跳。杰克准备好了两种情况的应对方案。所以杰克说的话实际上声明了一个 Promise。\n\nPromise 是一个表示异步操作的最终结果的对象。它帮助我们跟进异步操作的状态，并根据结果执行不同的代码。\n\n在 ES6 中我们通常会这样使用 Promise ：\n\n``` js\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作 ...\n  // 如果操作完成\n  resolve(value)\n  // 否则\n  reject(error)\n})\npromise.then(value => {\n  // 完成\n}).catch(error => {\n  // 拒绝或抛出异常\n})\n```\n\nPromise 的构造函数接收一个立即执行的函数 `executor`，这个函数通常包含异步操作。`executor` 的两个参数 `resolve` 和 `reject` 函数用于更新 Promise 的状态。\n\n`then` 方法注册完成时的回调，该回调函数能够访问终值 `value`（如果有）。`catch` 方法注册拒绝时的回调，该回调函数能够访问拒绝的原因 `error`（如果有）。Promise 的状态更新后，相应的回调函数将被执行。\n\n## Promise/A+ 规范\n\nPromise 最早由社区提出，后来逐渐形成了几种规范。目前较权威的规范是 [Promise/A+](https://promisesaplus.com/) ，ES6 正是遵循此规范实现，使 Promise 正式成为了 JavaScript 标准的一部分。\n\n简单的说一个 Promise：\n\n1. 存在三种状态：pending 表示异步操作尚未结束，fulfilled 表示完成（成功），rejected 表示拒绝（失败）。\n2. 状态的改变只能从 pending 到 fulfilled / rejected 。人生无法重来，Promise 也一样。\n3. 必须提供一个 `then` 方法用于注册回调函数。\n4. 完成时有一个终值（eventual value），拒绝时有一个不能完成的原因（reason）。\n\n经常使用 ES6 Promise 的同学应该会注意到，ES6 使用 resolved 状态替代了标准中的 fulfilled ，并且实现了标准中没有要求的 `catch`、`all` 等实用特性。\n\n此外，规范并没有说明 Promise 对象如何产生。ES6 使用构造函数创建 Promise 对象。\n\n## 实现基础的 Promise\n\n根据前述规范实现一个基础的 Promise 构造函数：\n\n``` JS\nfunction MyPromise (executor) {\n\n  var that = this\n\n  // 初始状态为 pending\n  this.status = 'pending'\n\n  this.onFulfilled = null\n  this.onRejected = null\n\n  // 用于注册完成和拒绝回调的实例方法 then\n  this.then = function (onFulfilled, onRejected) {\n    this.onFulfilled = onFulfilled\n    this.onRejected = onRejected\n  }\n\n  // 完成时执行的局部函数 fulfill\n  function fulfill (eventualValue) {\n    if (that.status === 'pending') {\n      that.status = 'fulfiled'\n      typeof that.onFulfilled === 'function' && that.onFulfilled(eventualValue)\n    }\n  }\n\n  // 拒绝时执行的局部函数 reject\n  function reject (reason) {\n    if (that.status === 'pending') {\n      that.status = 'rejected'\n      typeof that.onRejected === 'function' && that.onRejected(reason)\n    }\n  }\n\n  // 实例化时立即执行的函数 executor\n  executor(fulfill, reject)\n\n}\n```\n\n然后可以这样使用 MyPromise：\n\n``` js\nconst promise = new MyPromise((fulfill, reject) => {\n  // 异步操作 ...\n  // 如果操作完成\n  fulfill(200)\n  // 否则\n  reject('Some reasons')\n})\n\npromise.then(value => {\n  console.log('Eventual Value: ', value)\n}, reason => {\n  console.log(reason)\n})\n```\n\n## 增加链式调用\n\n你可能注意到，通过上面的构造函数创建的 Promise 只能注册一个完成回调，并不支持这样的链式调用：\n\n``` js\npromise.then(value => {\n  // 第一个回调\n}).then(value => {\n  // 第二个回调\n})\n```\n\n因此需要稍作改进：\n\n1. 为了存储多个回调函数，`onFulfilled` 属性应该是一个数组，每次调用 `then` 方法都追加一个回调函数。\n2. `then` 方法返回当前 promise 实例，以实现链式调用。（事实上也是规范的要求）\n3. 完成时执行 `onFulfilled` 数组中的所有函数。\n\n``` js\nthis.onFulfilled = []\n\nthis.then = function (onFulfilled, onRejected) {\n  this.onFulfilled.push(onFulfilled)\n  this.onRejected = onRejected\n  return this\n}\n\nfunction fulfill (eventualValue) {\n  if (that.status === 'pending') {\n    that.status = 'fulfiled'\n    for (var i = 0; i < that.onFulfilled.length; i++) {\n      typeof that.onFulfilled[i] === 'function' && that.onFulfilled[i](eventualValue)\n    }\n  }\n}\n```\n\n## 增加 catch 方法\n\n接下来实现一个类似 ES6 Promise 的 `catch` 方法。\n\n`catch` 方法可以注册拒绝回调，行为类似 `then(null, onRejected)` ，同时可以处理 `executor` 抛出的错误。\n\n首先增加一个 `catch` 方法：\n\n``` js\nthis.catch = function (onRejected) {\n  this.onRejected = onRejected\n}\n```\n\n然后修改执行 `executor` 的语句。使用 `try...catch` 语句捕获错误，并在出错时执行 `onRejected` 方法。\n\n``` js\nsetTimeout(function () {\n  try {\n    executor(fulfill, reject)\n  } catch (e) {\n    if (typeof that.onRejected === 'function') that.onRejected(e)\n    else throw e\n  }\n})\n```\n\n包裹 `setTimeout` 的目的是延迟执行，确保执行 `executor` 时失败回调已经注册完毕。\n\n## 实现 Promise.all \n\n前面实现的 Promise 已经可以胜任“等一件事完成再做另一件事”的工作。那如果我们要等两件甚至更多件事完成，最后再做某事呢？比如做菜时等菜切好、油烧热再下锅。\n\nES6 中实现的 `Promise.all` 接收一个数组，返回一个 Promise 实例。这个实例在数组内所有 `promise` 完成时才会完成，任何一个 `promise` 拒绝都将导致其拒绝。\n\n下面的代码实现了一个 `all` 方法：\n\n``` js\nMyPromise.all = function (promises) {\n  return new MyPromise(function (fulfill, reject) {\n    var index = 0\n    function next () {\n      promises[index].then(function () {\n        index++\n        if (index < promises.length) next()\n        else fulfill()\n      }).catch(function (reason) {\n        reject(reason)\n      })\n    }\n    next()\n  })\n}\n```\n\n[点此](https://github.com/ymcn/promise) 查看完整代码示例。\n","source":"_posts/2019-03-15@Promise 的原理与简单实现.md","raw":"---\ntitle: Promise 的原理与简单实现\ntags:\n  - ES6\n  - JavaScript\n  - Promise\ncategories:\n  - Web Front-end\ndate: 2019-03-15 21:49:54\n---\n\n\n\n## 什么是 Promise\n\n起初，人们使用回调函数进行异步编程。回调函数是指一个可被另一个函数访问，并在后者执行后调用的函数。过多的回调函数嵌套形成难以阅读和维护的回调地狱（Callback Hell / Pyramid of Doom）。\n\n<!-- more -->\n\n``` js\nlogin(function () {\n  getUserInfo(function () {\n    getProductList(function () {\n      ...\n    })\n  })\n})\n```\n\n这时候人们开始思考更佳的异步解决方案，Promise 应运而生。\n\n`promise` 这个词的原意是约定。在现实生活中，约定往往不是立即做一件事，而是在满足一定条件下做或不做某事。\n\n电影《泰坦尼克号》中杰克对罗斯说“你跳，我也跳（You jump, I jump）”。由于杰克不知道罗斯跳不跳，何时跳，后者的行为可以视为一个需要等待的异步操作。罗斯的行为可能从犹豫到跳，或者从犹豫到不跳。杰克准备好了两种情况的应对方案。所以杰克说的话实际上声明了一个 Promise。\n\nPromise 是一个表示异步操作的最终结果的对象。它帮助我们跟进异步操作的状态，并根据结果执行不同的代码。\n\n在 ES6 中我们通常会这样使用 Promise ：\n\n``` js\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作 ...\n  // 如果操作完成\n  resolve(value)\n  // 否则\n  reject(error)\n})\npromise.then(value => {\n  // 完成\n}).catch(error => {\n  // 拒绝或抛出异常\n})\n```\n\nPromise 的构造函数接收一个立即执行的函数 `executor`，这个函数通常包含异步操作。`executor` 的两个参数 `resolve` 和 `reject` 函数用于更新 Promise 的状态。\n\n`then` 方法注册完成时的回调，该回调函数能够访问终值 `value`（如果有）。`catch` 方法注册拒绝时的回调，该回调函数能够访问拒绝的原因 `error`（如果有）。Promise 的状态更新后，相应的回调函数将被执行。\n\n## Promise/A+ 规范\n\nPromise 最早由社区提出，后来逐渐形成了几种规范。目前较权威的规范是 [Promise/A+](https://promisesaplus.com/) ，ES6 正是遵循此规范实现，使 Promise 正式成为了 JavaScript 标准的一部分。\n\n简单的说一个 Promise：\n\n1. 存在三种状态：pending 表示异步操作尚未结束，fulfilled 表示完成（成功），rejected 表示拒绝（失败）。\n2. 状态的改变只能从 pending 到 fulfilled / rejected 。人生无法重来，Promise 也一样。\n3. 必须提供一个 `then` 方法用于注册回调函数。\n4. 完成时有一个终值（eventual value），拒绝时有一个不能完成的原因（reason）。\n\n经常使用 ES6 Promise 的同学应该会注意到，ES6 使用 resolved 状态替代了标准中的 fulfilled ，并且实现了标准中没有要求的 `catch`、`all` 等实用特性。\n\n此外，规范并没有说明 Promise 对象如何产生。ES6 使用构造函数创建 Promise 对象。\n\n## 实现基础的 Promise\n\n根据前述规范实现一个基础的 Promise 构造函数：\n\n``` JS\nfunction MyPromise (executor) {\n\n  var that = this\n\n  // 初始状态为 pending\n  this.status = 'pending'\n\n  this.onFulfilled = null\n  this.onRejected = null\n\n  // 用于注册完成和拒绝回调的实例方法 then\n  this.then = function (onFulfilled, onRejected) {\n    this.onFulfilled = onFulfilled\n    this.onRejected = onRejected\n  }\n\n  // 完成时执行的局部函数 fulfill\n  function fulfill (eventualValue) {\n    if (that.status === 'pending') {\n      that.status = 'fulfiled'\n      typeof that.onFulfilled === 'function' && that.onFulfilled(eventualValue)\n    }\n  }\n\n  // 拒绝时执行的局部函数 reject\n  function reject (reason) {\n    if (that.status === 'pending') {\n      that.status = 'rejected'\n      typeof that.onRejected === 'function' && that.onRejected(reason)\n    }\n  }\n\n  // 实例化时立即执行的函数 executor\n  executor(fulfill, reject)\n\n}\n```\n\n然后可以这样使用 MyPromise：\n\n``` js\nconst promise = new MyPromise((fulfill, reject) => {\n  // 异步操作 ...\n  // 如果操作完成\n  fulfill(200)\n  // 否则\n  reject('Some reasons')\n})\n\npromise.then(value => {\n  console.log('Eventual Value: ', value)\n}, reason => {\n  console.log(reason)\n})\n```\n\n## 增加链式调用\n\n你可能注意到，通过上面的构造函数创建的 Promise 只能注册一个完成回调，并不支持这样的链式调用：\n\n``` js\npromise.then(value => {\n  // 第一个回调\n}).then(value => {\n  // 第二个回调\n})\n```\n\n因此需要稍作改进：\n\n1. 为了存储多个回调函数，`onFulfilled` 属性应该是一个数组，每次调用 `then` 方法都追加一个回调函数。\n2. `then` 方法返回当前 promise 实例，以实现链式调用。（事实上也是规范的要求）\n3. 完成时执行 `onFulfilled` 数组中的所有函数。\n\n``` js\nthis.onFulfilled = []\n\nthis.then = function (onFulfilled, onRejected) {\n  this.onFulfilled.push(onFulfilled)\n  this.onRejected = onRejected\n  return this\n}\n\nfunction fulfill (eventualValue) {\n  if (that.status === 'pending') {\n    that.status = 'fulfiled'\n    for (var i = 0; i < that.onFulfilled.length; i++) {\n      typeof that.onFulfilled[i] === 'function' && that.onFulfilled[i](eventualValue)\n    }\n  }\n}\n```\n\n## 增加 catch 方法\n\n接下来实现一个类似 ES6 Promise 的 `catch` 方法。\n\n`catch` 方法可以注册拒绝回调，行为类似 `then(null, onRejected)` ，同时可以处理 `executor` 抛出的错误。\n\n首先增加一个 `catch` 方法：\n\n``` js\nthis.catch = function (onRejected) {\n  this.onRejected = onRejected\n}\n```\n\n然后修改执行 `executor` 的语句。使用 `try...catch` 语句捕获错误，并在出错时执行 `onRejected` 方法。\n\n``` js\nsetTimeout(function () {\n  try {\n    executor(fulfill, reject)\n  } catch (e) {\n    if (typeof that.onRejected === 'function') that.onRejected(e)\n    else throw e\n  }\n})\n```\n\n包裹 `setTimeout` 的目的是延迟执行，确保执行 `executor` 时失败回调已经注册完毕。\n\n## 实现 Promise.all \n\n前面实现的 Promise 已经可以胜任“等一件事完成再做另一件事”的工作。那如果我们要等两件甚至更多件事完成，最后再做某事呢？比如做菜时等菜切好、油烧热再下锅。\n\nES6 中实现的 `Promise.all` 接收一个数组，返回一个 Promise 实例。这个实例在数组内所有 `promise` 完成时才会完成，任何一个 `promise` 拒绝都将导致其拒绝。\n\n下面的代码实现了一个 `all` 方法：\n\n``` js\nMyPromise.all = function (promises) {\n  return new MyPromise(function (fulfill, reject) {\n    var index = 0\n    function next () {\n      promises[index].then(function () {\n        index++\n        if (index < promises.length) next()\n        else fulfill()\n      }).catch(function (reason) {\n        reject(reason)\n      })\n    }\n    next()\n  })\n}\n```\n\n[点此](https://github.com/ymcn/promise) 查看完整代码示例。\n","slug":"2019-03-15@Promise 的原理与简单实现","published":1,"updated":"2020-06-29T03:32:42.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4ac00abrqgjfhevaij2","content":"<h2 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h2><p>起初，人们使用回调函数进行异步编程。回调函数是指一个可被另一个函数访问，并在后者执行后调用的函数。过多的回调函数嵌套形成难以阅读和维护的回调地狱（Callback Hell / Pyramid of Doom）。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"js\">login(function () {\n  getUserInfo(function () {\n    getProductList(function () {\n      ...\n    })\n  })\n})</code></pre>\n<p>这时候人们开始思考更佳的异步解决方案，Promise 应运而生。</p>\n<p><code>promise</code> 这个词的原意是约定。在现实生活中，约定往往不是立即做一件事，而是在满足一定条件下做或不做某事。</p>\n<p>电影《泰坦尼克号》中杰克对罗斯说“你跳，我也跳（You jump, I jump）”。由于杰克不知道罗斯跳不跳，何时跳，后者的行为可以视为一个需要等待的异步操作。罗斯的行为可能从犹豫到跳，或者从犹豫到不跳。杰克准备好了两种情况的应对方案。所以杰克说的话实际上声明了一个 Promise。</p>\n<p>Promise 是一个表示异步操作的最终结果的对象。它帮助我们跟进异步操作的状态，并根据结果执行不同的代码。</p>\n<p>在 ES6 中我们通常会这样使用 Promise ：</p>\n<pre><code class=\"js\">const promise = new Promise((resolve, reject) =&gt; {\n  // 异步操作 ...\n  // 如果操作完成\n  resolve(value)\n  // 否则\n  reject(error)\n})\npromise.then(value =&gt; {\n  // 完成\n}).catch(error =&gt; {\n  // 拒绝或抛出异常\n})</code></pre>\n<p>Promise 的构造函数接收一个立即执行的函数 <code>executor</code>，这个函数通常包含异步操作。<code>executor</code> 的两个参数 <code>resolve</code> 和 <code>reject</code> 函数用于更新 Promise 的状态。</p>\n<p><code>then</code> 方法注册完成时的回调，该回调函数能够访问终值 <code>value</code>（如果有）。<code>catch</code> 方法注册拒绝时的回调，该回调函数能够访问拒绝的原因 <code>error</code>（如果有）。Promise 的状态更新后，相应的回调函数将被执行。</p>\n<h2 id=\"Promise-A-规范\"><a href=\"#Promise-A-规范\" class=\"headerlink\" title=\"Promise/A+ 规范\"></a>Promise/A+ 规范</h2><p>Promise 最早由社区提出，后来逐渐形成了几种规范。目前较权威的规范是 <a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">Promise/A+</a> ，ES6 正是遵循此规范实现，使 Promise 正式成为了 JavaScript 标准的一部分。</p>\n<p>简单的说一个 Promise：</p>\n<ol>\n<li>存在三种状态：pending 表示异步操作尚未结束，fulfilled 表示完成（成功），rejected 表示拒绝（失败）。</li>\n<li>状态的改变只能从 pending 到 fulfilled / rejected 。人生无法重来，Promise 也一样。</li>\n<li>必须提供一个 <code>then</code> 方法用于注册回调函数。</li>\n<li>完成时有一个终值（eventual value），拒绝时有一个不能完成的原因（reason）。</li>\n</ol>\n<p>经常使用 ES6 Promise 的同学应该会注意到，ES6 使用 resolved 状态替代了标准中的 fulfilled ，并且实现了标准中没有要求的 <code>catch</code>、<code>all</code> 等实用特性。</p>\n<p>此外，规范并没有说明 Promise 对象如何产生。ES6 使用构造函数创建 Promise 对象。</p>\n<h2 id=\"实现基础的-Promise\"><a href=\"#实现基础的-Promise\" class=\"headerlink\" title=\"实现基础的 Promise\"></a>实现基础的 Promise</h2><p>根据前述规范实现一个基础的 Promise 构造函数：</p>\n<pre><code class=\"JS\">function MyPromise (executor) {\n\n  var that = this\n\n  // 初始状态为 pending\n  this.status = &#39;pending&#39;\n\n  this.onFulfilled = null\n  this.onRejected = null\n\n  // 用于注册完成和拒绝回调的实例方法 then\n  this.then = function (onFulfilled, onRejected) {\n    this.onFulfilled = onFulfilled\n    this.onRejected = onRejected\n  }\n\n  // 完成时执行的局部函数 fulfill\n  function fulfill (eventualValue) {\n    if (that.status === &#39;pending&#39;) {\n      that.status = &#39;fulfiled&#39;\n      typeof that.onFulfilled === &#39;function&#39; &amp;&amp; that.onFulfilled(eventualValue)\n    }\n  }\n\n  // 拒绝时执行的局部函数 reject\n  function reject (reason) {\n    if (that.status === &#39;pending&#39;) {\n      that.status = &#39;rejected&#39;\n      typeof that.onRejected === &#39;function&#39; &amp;&amp; that.onRejected(reason)\n    }\n  }\n\n  // 实例化时立即执行的函数 executor\n  executor(fulfill, reject)\n\n}</code></pre>\n<p>然后可以这样使用 MyPromise：</p>\n<pre><code class=\"js\">const promise = new MyPromise((fulfill, reject) =&gt; {\n  // 异步操作 ...\n  // 如果操作完成\n  fulfill(200)\n  // 否则\n  reject(&#39;Some reasons&#39;)\n})\n\npromise.then(value =&gt; {\n  console.log(&#39;Eventual Value: &#39;, value)\n}, reason =&gt; {\n  console.log(reason)\n})</code></pre>\n<h2 id=\"增加链式调用\"><a href=\"#增加链式调用\" class=\"headerlink\" title=\"增加链式调用\"></a>增加链式调用</h2><p>你可能注意到，通过上面的构造函数创建的 Promise 只能注册一个完成回调，并不支持这样的链式调用：</p>\n<pre><code class=\"js\">promise.then(value =&gt; {\n  // 第一个回调\n}).then(value =&gt; {\n  // 第二个回调\n})</code></pre>\n<p>因此需要稍作改进：</p>\n<ol>\n<li>为了存储多个回调函数，<code>onFulfilled</code> 属性应该是一个数组，每次调用 <code>then</code> 方法都追加一个回调函数。</li>\n<li><code>then</code> 方法返回当前 promise 实例，以实现链式调用。（事实上也是规范的要求）</li>\n<li>完成时执行 <code>onFulfilled</code> 数组中的所有函数。</li>\n</ol>\n<pre><code class=\"js\">this.onFulfilled = []\n\nthis.then = function (onFulfilled, onRejected) {\n  this.onFulfilled.push(onFulfilled)\n  this.onRejected = onRejected\n  return this\n}\n\nfunction fulfill (eventualValue) {\n  if (that.status === &#39;pending&#39;) {\n    that.status = &#39;fulfiled&#39;\n    for (var i = 0; i &lt; that.onFulfilled.length; i++) {\n      typeof that.onFulfilled[i] === &#39;function&#39; &amp;&amp; that.onFulfilled[i](eventualValue)\n    }\n  }\n}</code></pre>\n<h2 id=\"增加-catch-方法\"><a href=\"#增加-catch-方法\" class=\"headerlink\" title=\"增加 catch 方法\"></a>增加 catch 方法</h2><p>接下来实现一个类似 ES6 Promise 的 <code>catch</code> 方法。</p>\n<p><code>catch</code> 方法可以注册拒绝回调，行为类似 <code>then(null, onRejected)</code> ，同时可以处理 <code>executor</code> 抛出的错误。</p>\n<p>首先增加一个 <code>catch</code> 方法：</p>\n<pre><code class=\"js\">this.catch = function (onRejected) {\n  this.onRejected = onRejected\n}</code></pre>\n<p>然后修改执行 <code>executor</code> 的语句。使用 <code>try...catch</code> 语句捕获错误，并在出错时执行 <code>onRejected</code> 方法。</p>\n<pre><code class=\"js\">setTimeout(function () {\n  try {\n    executor(fulfill, reject)\n  } catch (e) {\n    if (typeof that.onRejected === &#39;function&#39;) that.onRejected(e)\n    else throw e\n  }\n})</code></pre>\n<p>包裹 <code>setTimeout</code> 的目的是延迟执行，确保执行 <code>executor</code> 时失败回调已经注册完毕。</p>\n<h2 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h2><p>前面实现的 Promise 已经可以胜任“等一件事完成再做另一件事”的工作。那如果我们要等两件甚至更多件事完成，最后再做某事呢？比如做菜时等菜切好、油烧热再下锅。</p>\n<p>ES6 中实现的 <code>Promise.all</code> 接收一个数组，返回一个 Promise 实例。这个实例在数组内所有 <code>promise</code> 完成时才会完成，任何一个 <code>promise</code> 拒绝都将导致其拒绝。</p>\n<p>下面的代码实现了一个 <code>all</code> 方法：</p>\n<pre><code class=\"js\">MyPromise.all = function (promises) {\n  return new MyPromise(function (fulfill, reject) {\n    var index = 0\n    function next () {\n      promises[index].then(function () {\n        index++\n        if (index &lt; promises.length) next()\n        else fulfill()\n      }).catch(function (reason) {\n        reject(reason)\n      })\n    }\n    next()\n  })\n}</code></pre>\n<p><a href=\"https://github.com/ymcn/promise\" target=\"_blank\" rel=\"noopener\">点此</a> 查看完整代码示例。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h2><p>起初，人们使用回调函数进行异步编程。回调函数是指一个可被另一个函数访问，并在后者执行后调用的函数。过多的回调函数嵌套形成难以阅读和维护的回调地狱（Callback Hell / Pyramid of Doom）。</p>","more":"<pre><code class=\"js\">login(function () {\n  getUserInfo(function () {\n    getProductList(function () {\n      ...\n    })\n  })\n})</code></pre>\n<p>这时候人们开始思考更佳的异步解决方案，Promise 应运而生。</p>\n<p><code>promise</code> 这个词的原意是约定。在现实生活中，约定往往不是立即做一件事，而是在满足一定条件下做或不做某事。</p>\n<p>电影《泰坦尼克号》中杰克对罗斯说“你跳，我也跳（You jump, I jump）”。由于杰克不知道罗斯跳不跳，何时跳，后者的行为可以视为一个需要等待的异步操作。罗斯的行为可能从犹豫到跳，或者从犹豫到不跳。杰克准备好了两种情况的应对方案。所以杰克说的话实际上声明了一个 Promise。</p>\n<p>Promise 是一个表示异步操作的最终结果的对象。它帮助我们跟进异步操作的状态，并根据结果执行不同的代码。</p>\n<p>在 ES6 中我们通常会这样使用 Promise ：</p>\n<pre><code class=\"js\">const promise = new Promise((resolve, reject) =&gt; {\n  // 异步操作 ...\n  // 如果操作完成\n  resolve(value)\n  // 否则\n  reject(error)\n})\npromise.then(value =&gt; {\n  // 完成\n}).catch(error =&gt; {\n  // 拒绝或抛出异常\n})</code></pre>\n<p>Promise 的构造函数接收一个立即执行的函数 <code>executor</code>，这个函数通常包含异步操作。<code>executor</code> 的两个参数 <code>resolve</code> 和 <code>reject</code> 函数用于更新 Promise 的状态。</p>\n<p><code>then</code> 方法注册完成时的回调，该回调函数能够访问终值 <code>value</code>（如果有）。<code>catch</code> 方法注册拒绝时的回调，该回调函数能够访问拒绝的原因 <code>error</code>（如果有）。Promise 的状态更新后，相应的回调函数将被执行。</p>\n<h2 id=\"Promise-A-规范\"><a href=\"#Promise-A-规范\" class=\"headerlink\" title=\"Promise/A+ 规范\"></a>Promise/A+ 规范</h2><p>Promise 最早由社区提出，后来逐渐形成了几种规范。目前较权威的规范是 <a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">Promise/A+</a> ，ES6 正是遵循此规范实现，使 Promise 正式成为了 JavaScript 标准的一部分。</p>\n<p>简单的说一个 Promise：</p>\n<ol>\n<li>存在三种状态：pending 表示异步操作尚未结束，fulfilled 表示完成（成功），rejected 表示拒绝（失败）。</li>\n<li>状态的改变只能从 pending 到 fulfilled / rejected 。人生无法重来，Promise 也一样。</li>\n<li>必须提供一个 <code>then</code> 方法用于注册回调函数。</li>\n<li>完成时有一个终值（eventual value），拒绝时有一个不能完成的原因（reason）。</li>\n</ol>\n<p>经常使用 ES6 Promise 的同学应该会注意到，ES6 使用 resolved 状态替代了标准中的 fulfilled ，并且实现了标准中没有要求的 <code>catch</code>、<code>all</code> 等实用特性。</p>\n<p>此外，规范并没有说明 Promise 对象如何产生。ES6 使用构造函数创建 Promise 对象。</p>\n<h2 id=\"实现基础的-Promise\"><a href=\"#实现基础的-Promise\" class=\"headerlink\" title=\"实现基础的 Promise\"></a>实现基础的 Promise</h2><p>根据前述规范实现一个基础的 Promise 构造函数：</p>\n<pre><code class=\"JS\">function MyPromise (executor) {\n\n  var that = this\n\n  // 初始状态为 pending\n  this.status = &#39;pending&#39;\n\n  this.onFulfilled = null\n  this.onRejected = null\n\n  // 用于注册完成和拒绝回调的实例方法 then\n  this.then = function (onFulfilled, onRejected) {\n    this.onFulfilled = onFulfilled\n    this.onRejected = onRejected\n  }\n\n  // 完成时执行的局部函数 fulfill\n  function fulfill (eventualValue) {\n    if (that.status === &#39;pending&#39;) {\n      that.status = &#39;fulfiled&#39;\n      typeof that.onFulfilled === &#39;function&#39; &amp;&amp; that.onFulfilled(eventualValue)\n    }\n  }\n\n  // 拒绝时执行的局部函数 reject\n  function reject (reason) {\n    if (that.status === &#39;pending&#39;) {\n      that.status = &#39;rejected&#39;\n      typeof that.onRejected === &#39;function&#39; &amp;&amp; that.onRejected(reason)\n    }\n  }\n\n  // 实例化时立即执行的函数 executor\n  executor(fulfill, reject)\n\n}</code></pre>\n<p>然后可以这样使用 MyPromise：</p>\n<pre><code class=\"js\">const promise = new MyPromise((fulfill, reject) =&gt; {\n  // 异步操作 ...\n  // 如果操作完成\n  fulfill(200)\n  // 否则\n  reject(&#39;Some reasons&#39;)\n})\n\npromise.then(value =&gt; {\n  console.log(&#39;Eventual Value: &#39;, value)\n}, reason =&gt; {\n  console.log(reason)\n})</code></pre>\n<h2 id=\"增加链式调用\"><a href=\"#增加链式调用\" class=\"headerlink\" title=\"增加链式调用\"></a>增加链式调用</h2><p>你可能注意到，通过上面的构造函数创建的 Promise 只能注册一个完成回调，并不支持这样的链式调用：</p>\n<pre><code class=\"js\">promise.then(value =&gt; {\n  // 第一个回调\n}).then(value =&gt; {\n  // 第二个回调\n})</code></pre>\n<p>因此需要稍作改进：</p>\n<ol>\n<li>为了存储多个回调函数，<code>onFulfilled</code> 属性应该是一个数组，每次调用 <code>then</code> 方法都追加一个回调函数。</li>\n<li><code>then</code> 方法返回当前 promise 实例，以实现链式调用。（事实上也是规范的要求）</li>\n<li>完成时执行 <code>onFulfilled</code> 数组中的所有函数。</li>\n</ol>\n<pre><code class=\"js\">this.onFulfilled = []\n\nthis.then = function (onFulfilled, onRejected) {\n  this.onFulfilled.push(onFulfilled)\n  this.onRejected = onRejected\n  return this\n}\n\nfunction fulfill (eventualValue) {\n  if (that.status === &#39;pending&#39;) {\n    that.status = &#39;fulfiled&#39;\n    for (var i = 0; i &lt; that.onFulfilled.length; i++) {\n      typeof that.onFulfilled[i] === &#39;function&#39; &amp;&amp; that.onFulfilled[i](eventualValue)\n    }\n  }\n}</code></pre>\n<h2 id=\"增加-catch-方法\"><a href=\"#增加-catch-方法\" class=\"headerlink\" title=\"增加 catch 方法\"></a>增加 catch 方法</h2><p>接下来实现一个类似 ES6 Promise 的 <code>catch</code> 方法。</p>\n<p><code>catch</code> 方法可以注册拒绝回调，行为类似 <code>then(null, onRejected)</code> ，同时可以处理 <code>executor</code> 抛出的错误。</p>\n<p>首先增加一个 <code>catch</code> 方法：</p>\n<pre><code class=\"js\">this.catch = function (onRejected) {\n  this.onRejected = onRejected\n}</code></pre>\n<p>然后修改执行 <code>executor</code> 的语句。使用 <code>try...catch</code> 语句捕获错误，并在出错时执行 <code>onRejected</code> 方法。</p>\n<pre><code class=\"js\">setTimeout(function () {\n  try {\n    executor(fulfill, reject)\n  } catch (e) {\n    if (typeof that.onRejected === &#39;function&#39;) that.onRejected(e)\n    else throw e\n  }\n})</code></pre>\n<p>包裹 <code>setTimeout</code> 的目的是延迟执行，确保执行 <code>executor</code> 时失败回调已经注册完毕。</p>\n<h2 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h2><p>前面实现的 Promise 已经可以胜任“等一件事完成再做另一件事”的工作。那如果我们要等两件甚至更多件事完成，最后再做某事呢？比如做菜时等菜切好、油烧热再下锅。</p>\n<p>ES6 中实现的 <code>Promise.all</code> 接收一个数组，返回一个 Promise 实例。这个实例在数组内所有 <code>promise</code> 完成时才会完成，任何一个 <code>promise</code> 拒绝都将导致其拒绝。</p>\n<p>下面的代码实现了一个 <code>all</code> 方法：</p>\n<pre><code class=\"js\">MyPromise.all = function (promises) {\n  return new MyPromise(function (fulfill, reject) {\n    var index = 0\n    function next () {\n      promises[index].then(function () {\n        index++\n        if (index &lt; promises.length) next()\n        else fulfill()\n      }).catch(function (reason) {\n        reject(reason)\n      })\n    }\n    next()\n  })\n}</code></pre>\n<p><a href=\"https://github.com/ymcn/promise\" target=\"_blank\" rel=\"noopener\">点此</a> 查看完整代码示例。</p>"},{"title":"混合开发：Android 与 JavaScript 的相互通信","date":"2019-05-26T16:37:22.000Z","_content":"\n\n现代移动应用开发已经广泛运用了 Hybrid 模式，催生了 Hybrid App（混合模式移动应用），即在原生壳中内嵌网页，部分功能由 HTML5 实现的移动应用。\n\n这种方案能大幅减少开发时间和成本，易于更新维护。因此以淘宝、京东为代表的电商 app，经常使用网页实现需灵活更新的页面。\n\n<!-- more -->\n\nHybrid 的基础是原生与网页的相互通信。在 Android 平台可以认为是 Java 和 JavaScript 的相互调用。\n\n\n\n## Android 调用 JavaScript\n\n### loadUrl\n\n在 Android 中调用 JavaScript 最简单的方式是使用 `WebView.loadUrl` 方法。\n\n`loadUrl` 用于加载给定的链接。在链接中使用 `javascript` 伪协议，浏览器将执行 `:` 后面的 JavaScript 代码。\n\n下面这行代码执行了 JS 中的 `showMessage` 函数：\n\n``` java\nmWebView.loadUrl(\"javascript:showMessage('Hello, Web!')\");\n```\n\n这种方式的缺点是无法取得返回值，适合不需要返回值的场景。\n\n### evaluateJavascript\n\nAndroid 4.4 以后提供了 `WebView.evaluateJavascript` 方法。它用于异步执行 JavaScript，当返回值非空时执行回调，据说有着比 `loadUrl` 更高的执行效率。\n\n下面这段代码同样执行了 JS 中的 `showMessage` 函数，并且能够在 `onReceiveValue` 方法中拿到返回值。\n\n```java\nmWebView.evaluateJavascript(\"javascript:showMessage('Hello, Web!')\", new ValueCallback<String>() {\n  @Override\n  public void onReceiveValue(String value) {\n    // 打印返回值\n    log.d(value);\n  }\n});\n```\n\n\n\n## JavaScript 调用 Android\n\n### shouldOverrideUrlLoading\n\n`WebViewClient.shouldOverrideUrlLoading` 用于拦截即将加载的链接，重写默认行为。\n\n因此，我们可以事先约定一系列伪协议链接：\n\n```\nmyapp://showToast?text=Hello\n```\n\n然后在 Android 中拦截 WebView 加载的链接。对于符合约定格式的链接，执行相应的操作。对于其他链接，保持默认的加载行为。\n\n```java\nprivate static final String APP_SCHEME = \"myapp:\";\n...\n\nmWebView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (url.startsWith(APP_SCHEME)) {\n            // 解析链接\n            urlData = URLDecoder.decode(url.substring(APP_SCHEME.length()), \"UTF-8\");\n            // 执行相应操作...\n            return true;\n        }\n        return false;\n    }\n});\n```\n\n在网页中调用时只需要当作一个重定向就够了。\n\n```javascript\nwindow.location.href = 'myapp://showToast?text=Hello'\n```\n\n### addJavascriptInterface\n\n`WebView.addJavascriptInterface` 用于绑定接口，使 JavaScript 能够调用 Android 代码。\n\n简单地说，我们在 Android 里声明接口。接口包含我们想要暴露给网页调用的方法，它以对象的形式注入到 JavaScript 的 `Window` 对象下。最后，JavaScript 调用接口对象的方法，执行接口中的原生代码。\n\n首先创建一个接口类：\n\n``` java\npublic class WebAppInterface {\n\n  Context mContext;\n\n  // 初始化接口并设置上下文\n  WebAppInterface(Context c) {\n    mContext = c;\n  }\n\n  // 显示短消息的接口\n  @JavascriptInterface\n  public void showToast(String text) {\n    Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n  }\n\n}\n```\n\n注意，Android 4.2 以上使用 `@JavascriptInterface` 注解的方法才会暴露给 JavaScript。\n\n然后向 WebView 添加这个接口，并将其命名为 `Android`。\n\n``` java\nmWebView.addJavascriptInterface(new WebAppInterface(this), \"Android\");\n```\n\n当网页加载完成时，WebView 也将注入一个 `Window.Android` 对象。\n\n通过这个对象就可以调用接口中的原生方法了：\n\n```javascript\nAndroid.showToast('Hello, Android!')\n```\n\n\n\n## 使用 JsBridge\n\nJsBridge 是一个成熟的，用于原生和网页双向通信的开源库。它封装了上文提到的通信方式，并且提供包含传参、返回值和回调的完整方案。JsBridge 会向网页注入一个 `Window.WebViewJavascriptBridge`  对象。\n\nJsBridge 的使用方法非常简单。\n\n在布局文件中使用 `com.github.lzyzsd.jsbridge.BridgeWebView` 替代默认的 `WebView` 控件。\n\n接着注册一个 Java 处理器：\n\n``` java\nwebView.registerHandler(\"showToast\", new BridgeHandler() {\n  @Override\n  public void handler(String data, CallBackFunction function) {\n    // 执行原生代码...\n    function.onCallBack(\"return value\");\n  }\n});\n```\n\n在 JavaScript 中调用 Java 处理器：\n\n``` javascript\nWebViewJavascriptBridge.callHandler('showToast', 'Hello, Android!', responseData => {\n  // 打印返回值\n  console.log(responseData)\n})\n```\n\n类似的，我们也可以注册 JavaScript 处理器：\n\n``` javascript\nWebViewJavascriptBridge.registerHandler('showMessage', (data, responseCallback) => {\n  // 执行网页脚本...\n  responseCallback('return value')\n})\n```\n\n然后在 Java 中调用 JavaScript 处理器：\n\n``` java\nwebView.callHandler(\"showMessage\", \"Hello, JavaScript!\", new CallBackFunction() {\n  @Override\n  public void onCallBack(String data) {\n    // 打印返回值\n    log.d(data);\n  }\n});\n```\n\n访问 [GitHub](https://github.com/lzyzsd/JsBridge) 了解更多 JsBridge 的使用说明。\n\n\n\n相关环境：macOS 10.14 / Android Studio 3.3 / JsBridge 1.0","source":"_posts/2019-05-27@混合开发：Android 与 JavaScript 的相互通信.md","raw":"---\ntitle: 混合开发：Android 与 JavaScript 的相互通信\ntags:\n  - Hybrid App\n  - WebView\n  - JsBridge\n  - Java\n  - JavaScript\ncategories:\n  - Android\ndate: 2019-05-27 00:37:22\n---\n\n\n现代移动应用开发已经广泛运用了 Hybrid 模式，催生了 Hybrid App（混合模式移动应用），即在原生壳中内嵌网页，部分功能由 HTML5 实现的移动应用。\n\n这种方案能大幅减少开发时间和成本，易于更新维护。因此以淘宝、京东为代表的电商 app，经常使用网页实现需灵活更新的页面。\n\n<!-- more -->\n\nHybrid 的基础是原生与网页的相互通信。在 Android 平台可以认为是 Java 和 JavaScript 的相互调用。\n\n\n\n## Android 调用 JavaScript\n\n### loadUrl\n\n在 Android 中调用 JavaScript 最简单的方式是使用 `WebView.loadUrl` 方法。\n\n`loadUrl` 用于加载给定的链接。在链接中使用 `javascript` 伪协议，浏览器将执行 `:` 后面的 JavaScript 代码。\n\n下面这行代码执行了 JS 中的 `showMessage` 函数：\n\n``` java\nmWebView.loadUrl(\"javascript:showMessage('Hello, Web!')\");\n```\n\n这种方式的缺点是无法取得返回值，适合不需要返回值的场景。\n\n### evaluateJavascript\n\nAndroid 4.4 以后提供了 `WebView.evaluateJavascript` 方法。它用于异步执行 JavaScript，当返回值非空时执行回调，据说有着比 `loadUrl` 更高的执行效率。\n\n下面这段代码同样执行了 JS 中的 `showMessage` 函数，并且能够在 `onReceiveValue` 方法中拿到返回值。\n\n```java\nmWebView.evaluateJavascript(\"javascript:showMessage('Hello, Web!')\", new ValueCallback<String>() {\n  @Override\n  public void onReceiveValue(String value) {\n    // 打印返回值\n    log.d(value);\n  }\n});\n```\n\n\n\n## JavaScript 调用 Android\n\n### shouldOverrideUrlLoading\n\n`WebViewClient.shouldOverrideUrlLoading` 用于拦截即将加载的链接，重写默认行为。\n\n因此，我们可以事先约定一系列伪协议链接：\n\n```\nmyapp://showToast?text=Hello\n```\n\n然后在 Android 中拦截 WebView 加载的链接。对于符合约定格式的链接，执行相应的操作。对于其他链接，保持默认的加载行为。\n\n```java\nprivate static final String APP_SCHEME = \"myapp:\";\n...\n\nmWebView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (url.startsWith(APP_SCHEME)) {\n            // 解析链接\n            urlData = URLDecoder.decode(url.substring(APP_SCHEME.length()), \"UTF-8\");\n            // 执行相应操作...\n            return true;\n        }\n        return false;\n    }\n});\n```\n\n在网页中调用时只需要当作一个重定向就够了。\n\n```javascript\nwindow.location.href = 'myapp://showToast?text=Hello'\n```\n\n### addJavascriptInterface\n\n`WebView.addJavascriptInterface` 用于绑定接口，使 JavaScript 能够调用 Android 代码。\n\n简单地说，我们在 Android 里声明接口。接口包含我们想要暴露给网页调用的方法，它以对象的形式注入到 JavaScript 的 `Window` 对象下。最后，JavaScript 调用接口对象的方法，执行接口中的原生代码。\n\n首先创建一个接口类：\n\n``` java\npublic class WebAppInterface {\n\n  Context mContext;\n\n  // 初始化接口并设置上下文\n  WebAppInterface(Context c) {\n    mContext = c;\n  }\n\n  // 显示短消息的接口\n  @JavascriptInterface\n  public void showToast(String text) {\n    Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n  }\n\n}\n```\n\n注意，Android 4.2 以上使用 `@JavascriptInterface` 注解的方法才会暴露给 JavaScript。\n\n然后向 WebView 添加这个接口，并将其命名为 `Android`。\n\n``` java\nmWebView.addJavascriptInterface(new WebAppInterface(this), \"Android\");\n```\n\n当网页加载完成时，WebView 也将注入一个 `Window.Android` 对象。\n\n通过这个对象就可以调用接口中的原生方法了：\n\n```javascript\nAndroid.showToast('Hello, Android!')\n```\n\n\n\n## 使用 JsBridge\n\nJsBridge 是一个成熟的，用于原生和网页双向通信的开源库。它封装了上文提到的通信方式，并且提供包含传参、返回值和回调的完整方案。JsBridge 会向网页注入一个 `Window.WebViewJavascriptBridge`  对象。\n\nJsBridge 的使用方法非常简单。\n\n在布局文件中使用 `com.github.lzyzsd.jsbridge.BridgeWebView` 替代默认的 `WebView` 控件。\n\n接着注册一个 Java 处理器：\n\n``` java\nwebView.registerHandler(\"showToast\", new BridgeHandler() {\n  @Override\n  public void handler(String data, CallBackFunction function) {\n    // 执行原生代码...\n    function.onCallBack(\"return value\");\n  }\n});\n```\n\n在 JavaScript 中调用 Java 处理器：\n\n``` javascript\nWebViewJavascriptBridge.callHandler('showToast', 'Hello, Android!', responseData => {\n  // 打印返回值\n  console.log(responseData)\n})\n```\n\n类似的，我们也可以注册 JavaScript 处理器：\n\n``` javascript\nWebViewJavascriptBridge.registerHandler('showMessage', (data, responseCallback) => {\n  // 执行网页脚本...\n  responseCallback('return value')\n})\n```\n\n然后在 Java 中调用 JavaScript 处理器：\n\n``` java\nwebView.callHandler(\"showMessage\", \"Hello, JavaScript!\", new CallBackFunction() {\n  @Override\n  public void onCallBack(String data) {\n    // 打印返回值\n    log.d(data);\n  }\n});\n```\n\n访问 [GitHub](https://github.com/lzyzsd/JsBridge) 了解更多 JsBridge 的使用说明。\n\n\n\n相关环境：macOS 10.14 / Android Studio 3.3 / JsBridge 1.0","slug":"2019-05-27@混合开发：Android 与 JavaScript 的相互通信","published":1,"updated":"2020-06-29T03:32:42.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4ac00aerqgjd4zd9tqr","content":"<p>现代移动应用开发已经广泛运用了 Hybrid 模式，催生了 Hybrid App（混合模式移动应用），即在原生壳中内嵌网页，部分功能由 HTML5 实现的移动应用。</p>\n<p>这种方案能大幅减少开发时间和成本，易于更新维护。因此以淘宝、京东为代表的电商 app，经常使用网页实现需灵活更新的页面。</p>\n<a id=\"more\"></a>\n\n<p>Hybrid 的基础是原生与网页的相互通信。在 Android 平台可以认为是 Java 和 JavaScript 的相互调用。</p>\n<h2 id=\"Android-调用-JavaScript\"><a href=\"#Android-调用-JavaScript\" class=\"headerlink\" title=\"Android 调用 JavaScript\"></a>Android 调用 JavaScript</h2><h3 id=\"loadUrl\"><a href=\"#loadUrl\" class=\"headerlink\" title=\"loadUrl\"></a>loadUrl</h3><p>在 Android 中调用 JavaScript 最简单的方式是使用 <code>WebView.loadUrl</code> 方法。</p>\n<p><code>loadUrl</code> 用于加载给定的链接。在链接中使用 <code>javascript</code> 伪协议，浏览器将执行 <code>:</code> 后面的 JavaScript 代码。</p>\n<p>下面这行代码执行了 JS 中的 <code>showMessage</code> 函数：</p>\n<pre><code class=\"java\">mWebView.loadUrl(&quot;javascript:showMessage(&#39;Hello, Web!&#39;)&quot;);</code></pre>\n<p>这种方式的缺点是无法取得返回值，适合不需要返回值的场景。</p>\n<h3 id=\"evaluateJavascript\"><a href=\"#evaluateJavascript\" class=\"headerlink\" title=\"evaluateJavascript\"></a>evaluateJavascript</h3><p>Android 4.4 以后提供了 <code>WebView.evaluateJavascript</code> 方法。它用于异步执行 JavaScript，当返回值非空时执行回调，据说有着比 <code>loadUrl</code> 更高的执行效率。</p>\n<p>下面这段代码同样执行了 JS 中的 <code>showMessage</code> 函数，并且能够在 <code>onReceiveValue</code> 方法中拿到返回值。</p>\n<pre><code class=\"java\">mWebView.evaluateJavascript(&quot;javascript:showMessage(&#39;Hello, Web!&#39;)&quot;, new ValueCallback&lt;String&gt;() {\n  @Override\n  public void onReceiveValue(String value) {\n    // 打印返回值\n    log.d(value);\n  }\n});</code></pre>\n<h2 id=\"JavaScript-调用-Android\"><a href=\"#JavaScript-调用-Android\" class=\"headerlink\" title=\"JavaScript 调用 Android\"></a>JavaScript 调用 Android</h2><h3 id=\"shouldOverrideUrlLoading\"><a href=\"#shouldOverrideUrlLoading\" class=\"headerlink\" title=\"shouldOverrideUrlLoading\"></a>shouldOverrideUrlLoading</h3><p><code>WebViewClient.shouldOverrideUrlLoading</code> 用于拦截即将加载的链接，重写默认行为。</p>\n<p>因此，我们可以事先约定一系列伪协议链接：</p>\n<pre><code>myapp://showToast?text=Hello</code></pre><p>然后在 Android 中拦截 WebView 加载的链接。对于符合约定格式的链接，执行相应的操作。对于其他链接，保持默认的加载行为。</p>\n<pre><code class=\"java\">private static final String APP_SCHEME = &quot;myapp:&quot;;\n...\n\nmWebView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (url.startsWith(APP_SCHEME)) {\n            // 解析链接\n            urlData = URLDecoder.decode(url.substring(APP_SCHEME.length()), &quot;UTF-8&quot;);\n            // 执行相应操作...\n            return true;\n        }\n        return false;\n    }\n});</code></pre>\n<p>在网页中调用时只需要当作一个重定向就够了。</p>\n<pre><code class=\"javascript\">window.location.href = &#39;myapp://showToast?text=Hello&#39;</code></pre>\n<h3 id=\"addJavascriptInterface\"><a href=\"#addJavascriptInterface\" class=\"headerlink\" title=\"addJavascriptInterface\"></a>addJavascriptInterface</h3><p><code>WebView.addJavascriptInterface</code> 用于绑定接口，使 JavaScript 能够调用 Android 代码。</p>\n<p>简单地说，我们在 Android 里声明接口。接口包含我们想要暴露给网页调用的方法，它以对象的形式注入到 JavaScript 的 <code>Window</code> 对象下。最后，JavaScript 调用接口对象的方法，执行接口中的原生代码。</p>\n<p>首先创建一个接口类：</p>\n<pre><code class=\"java\">public class WebAppInterface {\n\n  Context mContext;\n\n  // 初始化接口并设置上下文\n  WebAppInterface(Context c) {\n    mContext = c;\n  }\n\n  // 显示短消息的接口\n  @JavascriptInterface\n  public void showToast(String text) {\n    Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n  }\n\n}</code></pre>\n<p>注意，Android 4.2 以上使用 <code>@JavascriptInterface</code> 注解的方法才会暴露给 JavaScript。</p>\n<p>然后向 WebView 添加这个接口，并将其命名为 <code>Android</code>。</p>\n<pre><code class=\"java\">mWebView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</code></pre>\n<p>当网页加载完成时，WebView 也将注入一个 <code>Window.Android</code> 对象。</p>\n<p>通过这个对象就可以调用接口中的原生方法了：</p>\n<pre><code class=\"javascript\">Android.showToast(&#39;Hello, Android!&#39;)</code></pre>\n<h2 id=\"使用-JsBridge\"><a href=\"#使用-JsBridge\" class=\"headerlink\" title=\"使用 JsBridge\"></a>使用 JsBridge</h2><p>JsBridge 是一个成熟的，用于原生和网页双向通信的开源库。它封装了上文提到的通信方式，并且提供包含传参、返回值和回调的完整方案。JsBridge 会向网页注入一个 <code>Window.WebViewJavascriptBridge</code>  对象。</p>\n<p>JsBridge 的使用方法非常简单。</p>\n<p>在布局文件中使用 <code>com.github.lzyzsd.jsbridge.BridgeWebView</code> 替代默认的 <code>WebView</code> 控件。</p>\n<p>接着注册一个 Java 处理器：</p>\n<pre><code class=\"java\">webView.registerHandler(&quot;showToast&quot;, new BridgeHandler() {\n  @Override\n  public void handler(String data, CallBackFunction function) {\n    // 执行原生代码...\n    function.onCallBack(&quot;return value&quot;);\n  }\n});</code></pre>\n<p>在 JavaScript 中调用 Java 处理器：</p>\n<pre><code class=\"javascript\">WebViewJavascriptBridge.callHandler(&#39;showToast&#39;, &#39;Hello, Android!&#39;, responseData =&gt; {\n  // 打印返回值\n  console.log(responseData)\n})</code></pre>\n<p>类似的，我们也可以注册 JavaScript 处理器：</p>\n<pre><code class=\"javascript\">WebViewJavascriptBridge.registerHandler(&#39;showMessage&#39;, (data, responseCallback) =&gt; {\n  // 执行网页脚本...\n  responseCallback(&#39;return value&#39;)\n})</code></pre>\n<p>然后在 Java 中调用 JavaScript 处理器：</p>\n<pre><code class=\"java\">webView.callHandler(&quot;showMessage&quot;, &quot;Hello, JavaScript!&quot;, new CallBackFunction() {\n  @Override\n  public void onCallBack(String data) {\n    // 打印返回值\n    log.d(data);\n  }\n});</code></pre>\n<p>访问 <a href=\"https://github.com/lzyzsd/JsBridge\" target=\"_blank\" rel=\"noopener\">GitHub</a> 了解更多 JsBridge 的使用说明。</p>\n<p>相关环境：macOS 10.14 / Android Studio 3.3 / JsBridge 1.0</p>\n","site":{"data":{}},"excerpt":"<p>现代移动应用开发已经广泛运用了 Hybrid 模式，催生了 Hybrid App（混合模式移动应用），即在原生壳中内嵌网页，部分功能由 HTML5 实现的移动应用。</p>\n<p>这种方案能大幅减少开发时间和成本，易于更新维护。因此以淘宝、京东为代表的电商 app，经常使用网页实现需灵活更新的页面。</p>","more":"<p>Hybrid 的基础是原生与网页的相互通信。在 Android 平台可以认为是 Java 和 JavaScript 的相互调用。</p>\n<h2 id=\"Android-调用-JavaScript\"><a href=\"#Android-调用-JavaScript\" class=\"headerlink\" title=\"Android 调用 JavaScript\"></a>Android 调用 JavaScript</h2><h3 id=\"loadUrl\"><a href=\"#loadUrl\" class=\"headerlink\" title=\"loadUrl\"></a>loadUrl</h3><p>在 Android 中调用 JavaScript 最简单的方式是使用 <code>WebView.loadUrl</code> 方法。</p>\n<p><code>loadUrl</code> 用于加载给定的链接。在链接中使用 <code>javascript</code> 伪协议，浏览器将执行 <code>:</code> 后面的 JavaScript 代码。</p>\n<p>下面这行代码执行了 JS 中的 <code>showMessage</code> 函数：</p>\n<pre><code class=\"java\">mWebView.loadUrl(&quot;javascript:showMessage(&#39;Hello, Web!&#39;)&quot;);</code></pre>\n<p>这种方式的缺点是无法取得返回值，适合不需要返回值的场景。</p>\n<h3 id=\"evaluateJavascript\"><a href=\"#evaluateJavascript\" class=\"headerlink\" title=\"evaluateJavascript\"></a>evaluateJavascript</h3><p>Android 4.4 以后提供了 <code>WebView.evaluateJavascript</code> 方法。它用于异步执行 JavaScript，当返回值非空时执行回调，据说有着比 <code>loadUrl</code> 更高的执行效率。</p>\n<p>下面这段代码同样执行了 JS 中的 <code>showMessage</code> 函数，并且能够在 <code>onReceiveValue</code> 方法中拿到返回值。</p>\n<pre><code class=\"java\">mWebView.evaluateJavascript(&quot;javascript:showMessage(&#39;Hello, Web!&#39;)&quot;, new ValueCallback&lt;String&gt;() {\n  @Override\n  public void onReceiveValue(String value) {\n    // 打印返回值\n    log.d(value);\n  }\n});</code></pre>\n<h2 id=\"JavaScript-调用-Android\"><a href=\"#JavaScript-调用-Android\" class=\"headerlink\" title=\"JavaScript 调用 Android\"></a>JavaScript 调用 Android</h2><h3 id=\"shouldOverrideUrlLoading\"><a href=\"#shouldOverrideUrlLoading\" class=\"headerlink\" title=\"shouldOverrideUrlLoading\"></a>shouldOverrideUrlLoading</h3><p><code>WebViewClient.shouldOverrideUrlLoading</code> 用于拦截即将加载的链接，重写默认行为。</p>\n<p>因此，我们可以事先约定一系列伪协议链接：</p>\n<pre><code>myapp://showToast?text=Hello</code></pre><p>然后在 Android 中拦截 WebView 加载的链接。对于符合约定格式的链接，执行相应的操作。对于其他链接，保持默认的加载行为。</p>\n<pre><code class=\"java\">private static final String APP_SCHEME = &quot;myapp:&quot;;\n...\n\nmWebView.setWebViewClient(new WebViewClient() {\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        if (url.startsWith(APP_SCHEME)) {\n            // 解析链接\n            urlData = URLDecoder.decode(url.substring(APP_SCHEME.length()), &quot;UTF-8&quot;);\n            // 执行相应操作...\n            return true;\n        }\n        return false;\n    }\n});</code></pre>\n<p>在网页中调用时只需要当作一个重定向就够了。</p>\n<pre><code class=\"javascript\">window.location.href = &#39;myapp://showToast?text=Hello&#39;</code></pre>\n<h3 id=\"addJavascriptInterface\"><a href=\"#addJavascriptInterface\" class=\"headerlink\" title=\"addJavascriptInterface\"></a>addJavascriptInterface</h3><p><code>WebView.addJavascriptInterface</code> 用于绑定接口，使 JavaScript 能够调用 Android 代码。</p>\n<p>简单地说，我们在 Android 里声明接口。接口包含我们想要暴露给网页调用的方法，它以对象的形式注入到 JavaScript 的 <code>Window</code> 对象下。最后，JavaScript 调用接口对象的方法，执行接口中的原生代码。</p>\n<p>首先创建一个接口类：</p>\n<pre><code class=\"java\">public class WebAppInterface {\n\n  Context mContext;\n\n  // 初始化接口并设置上下文\n  WebAppInterface(Context c) {\n    mContext = c;\n  }\n\n  // 显示短消息的接口\n  @JavascriptInterface\n  public void showToast(String text) {\n    Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();\n  }\n\n}</code></pre>\n<p>注意，Android 4.2 以上使用 <code>@JavascriptInterface</code> 注解的方法才会暴露给 JavaScript。</p>\n<p>然后向 WebView 添加这个接口，并将其命名为 <code>Android</code>。</p>\n<pre><code class=\"java\">mWebView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</code></pre>\n<p>当网页加载完成时，WebView 也将注入一个 <code>Window.Android</code> 对象。</p>\n<p>通过这个对象就可以调用接口中的原生方法了：</p>\n<pre><code class=\"javascript\">Android.showToast(&#39;Hello, Android!&#39;)</code></pre>\n<h2 id=\"使用-JsBridge\"><a href=\"#使用-JsBridge\" class=\"headerlink\" title=\"使用 JsBridge\"></a>使用 JsBridge</h2><p>JsBridge 是一个成熟的，用于原生和网页双向通信的开源库。它封装了上文提到的通信方式，并且提供包含传参、返回值和回调的完整方案。JsBridge 会向网页注入一个 <code>Window.WebViewJavascriptBridge</code>  对象。</p>\n<p>JsBridge 的使用方法非常简单。</p>\n<p>在布局文件中使用 <code>com.github.lzyzsd.jsbridge.BridgeWebView</code> 替代默认的 <code>WebView</code> 控件。</p>\n<p>接着注册一个 Java 处理器：</p>\n<pre><code class=\"java\">webView.registerHandler(&quot;showToast&quot;, new BridgeHandler() {\n  @Override\n  public void handler(String data, CallBackFunction function) {\n    // 执行原生代码...\n    function.onCallBack(&quot;return value&quot;);\n  }\n});</code></pre>\n<p>在 JavaScript 中调用 Java 处理器：</p>\n<pre><code class=\"javascript\">WebViewJavascriptBridge.callHandler(&#39;showToast&#39;, &#39;Hello, Android!&#39;, responseData =&gt; {\n  // 打印返回值\n  console.log(responseData)\n})</code></pre>\n<p>类似的，我们也可以注册 JavaScript 处理器：</p>\n<pre><code class=\"javascript\">WebViewJavascriptBridge.registerHandler(&#39;showMessage&#39;, (data, responseCallback) =&gt; {\n  // 执行网页脚本...\n  responseCallback(&#39;return value&#39;)\n})</code></pre>\n<p>然后在 Java 中调用 JavaScript 处理器：</p>\n<pre><code class=\"java\">webView.callHandler(&quot;showMessage&quot;, &quot;Hello, JavaScript!&quot;, new CallBackFunction() {\n  @Override\n  public void onCallBack(String data) {\n    // 打印返回值\n    log.d(data);\n  }\n});</code></pre>\n<p>访问 <a href=\"https://github.com/lzyzsd/JsBridge\" target=\"_blank\" rel=\"noopener\">GitHub</a> 了解更多 JsBridge 的使用说明。</p>\n<p>相关环境：macOS 10.14 / Android Studio 3.3 / JsBridge 1.0</p>"},{"title":"手把手教你开发一个微信小程序","date":"2017-03-28T03:44:53.000Z","_content":"\n由于工作需要，我最近开始学习微信小程序，看过几天文档后决定写一个简单的小程序练手，就做一个 To-do List 工具。为了日后温故，也为让有需要的朋友参考，我把开发的过程记录了下来。\n\n<!-- more -->\n\n先看一下完成后的效果：\n\n{% img /images/posts/2017/03/mini_program_practice.gif 240 功能预览 %}\n\n### 准备工作\n\n你应该具备一些基础的 Web 知识储备（HTML、CSS、JavaScript），用过 React、Vue 等前端框架更佳。访问 [官网](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html) 下载微信 Web 开发者工具，接下来的开发只需要在这一个工具上进行。\n\n### 创建应用\n\n使用你的微信号登录微信 Web 开发者工具，选择“本地小程序项目”，然后添加一个新项目。虽然不填写 AppID 也可以继续，但功能受到限制，建议开发者先注册小程序并获取 AppID 。\n\n勾选“在当前目录中创建 quick start 项目”的情况下，微信默认将创建一个 demo 程序。通过这些自动创建的文件，可以一窥小程序的目录结构：\n\n```\nTo-do List\n│  app.js          # 全局脚本\n│  app.json        # 全局配置\n│  app.wxss        # 全局样式\n│  \n├─pages\n│  ├─index         # 页面\n│  │   index.js    # 页面脚本\n│  │   index.wxml  # 页面结构\n│  │   index.wxss  # 页面样式\n│  │      \n│  └─logs\n│      logs.js\n│      logs.json\n│      logs.wxml\n│      logs.wxss\n│          \n└─utils\n   util.js\n```\n\n一个小程序主要由 wxml 结构文件、wxss 样式文件、js 脚本文件构成，和网页的构成非常相似。页面存放在 pages 目录下，该目录下的每一个目录等价于一个页面。注意，一个小程序至少应该有一个页面。\n\n本例的小程序保留全局文件和一个页面就够了，多余的目录和文件可以删除。\n\n得到如下目录结构：\n\n```\nTo-do List\n│  app.js\n│  app.json\n│  app.wxss\n│  \n└─pages\n   └─index\n       index.js\n       index.wxml\n       index.wxss\n```\n\n### 全局配置\n\n`app.json` 是小程序的全局配置文件，用于声明小程序包含的页面、修改导航栏样式等。\n\n我们要开发的小程序包含一个 index 页面，所以应该在 `pages` 中注册该页面的路径。然后在 `window` 中设置导航栏的背景色为紫色，标题就叫 `To-do List` 吧，标题的颜色设为白色。（更多配置项参考 [配置](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html) ）\n\n``` js\n\"pages\": [\n  \"pages/index/index\"\n],\n\"window\": {\n  \"navigationBarBackgroundColor\": \"#512da8\",\n  \"navigationBarTitleText\": \"To-do List\",\n  \"navigationBarTextStyle\": \"white\"\n}\n```\n\n### 框架语法\n\n在继续开发之前，你需要了解小程序框架的一些基础用法。\n\n在 wxml 文档中可以用双大括号引用 js 文档中的变量。（参考 [数据绑定](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html) ）\n\n```xhtml\n<!-- wxml -->\n<view> {{ message }} </view>\n```\n\n``` js\n// js\nPage({\n  data: {\n    message: 'Hello World!'\n  }\n})\n```\n``` xhtml\n<!-- 结果 -->\n<view> Hello World! </view>\n```\n\n在 wxml 文档中可以用 `wx:if` 判断是否要渲染该代码块 。以下面这段代码为例，当 `condition` 的值为 false、0 或空时，该代码块不会被渲染，页面中不会出现“Hello World!”。（参考 [条件渲染](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html)）\n\n``` xhtml\n<!-- wxml -->\n<view wx:if=\"{{ condition }}\"> Hello World! </view>\n```\n\n在 wxml 文档中可以用 `wx:for` 使用数组中的各项重复渲染，一般用于渲染列表。（参考 [列表渲染](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html) ）\n\n``` xhtml\n<!-- wxml -->\n<view wx:for=\"{{ array }}\"> {{ index }} - {{ item }} </view>\n```\n\n``` js\n// js\nPage({\n  data: {\n    array: [ 'Hello', 'World' ]\n  }\n})\n```\n``` xhtml\n<!-- 结果 -->\n<view> 0 - Hello </view>\n<view> 1 - World </view>\n```\n\n### 页面结构\n\n我用视图组件将页面分成了 `head`、`body`、`foot` 三个部分。`head` 提供一个输入框，用于添加新任务。`body` 用于显示待处理项目列表。`foot` 用于显示已完成项目列表。\n\n``` xhtml\n<!-- index.wxml -->\n<view class=\"head\"> ... </view>\n<view class=\"body\"> ... </view>\n<view class=\"foot\"> ... </view>\n```\n\n在 `head` 中添加一个 `input` 组件。类名 `class` 和输入框的值 `value` 分别与变量绑定。`placeholder` 和 `placeholder-style` 属性设置了提示文本的内容和样式。`bindfocus` 、`bindblur`、`bindconfirm` 分别是输入框的聚焦、失焦和提交事件。\n``` xhtml\n<view class=\"head\">\n  <input\n    class=\"{{ input.class }}\"\n    value=\"{{ input.value }}\"\n    placeholder=\"需要做什么？\"\n    placeholder-style=\"color:#fff\"\n    bindfocus=\"focus\"\n    bindblur=\"blur\"\n    bindconfirm=\"confirm\"/>\n</view>\n```\n\n`body` 视图添加一个复选框 `checkbox-group` 组件并渲染一个待处理项目列表。`bindchange` 事件用于监听子组件 `checkbox` 的变化，当用户勾选 `checkbox` 时做一些事。\n\n``` xhtml\n<view class=\"body\">\n  <!-- 项目被勾选时调用 check 方法。 -->\n  <checkbox-group bindchange=\"check\">\n    <!-- 渲染未完成项目列表。 -->\n    <view class=\"item\" wx:for=\"{{ items }}\" wx:key=\"{{ index }}\" wx:if=\"{{ !item.status }}\">\n      <!-- 复选框的值为项目的索引（以便知道哪个复选框的状态发生改变），默认不选中。 -->\n      <checkbox value=\"{{ index }}\" checked=\"{{ false }}\"/>\n      <!-- 输出项目名称 -->\n      <text>{{ item.name }}</text>\n      <!-- 删除图标，点击时调用 remove 方法，参数 index 为项目索引。 -->\n      <icon type=\"cancel\" size=\"30\" color=\"#EF5350\" bindtap=\"remove\" data-index=\"{{ index }}\"/>\n    </view>\n  </checkbox-group>\n  <!-- 当 items 中没有元素时的提示。 -->\n  <view class=\"empty\" wx:if=\"{{ items.length == 0 }}\">\n    <icon type=\"success\" size=\"20\" color=\"{{ item }}\"/>\n    <text>无待办事项</text>\n  </view>\n</view>\n```\n\n`foot` 视图的结构和 `body` 视图基本一致，渲染一个已完成项目列表。已完成项目一定是打了钩的，所以其中的 `checkbox` 默认选中。`checkbox-group` 组件的 `bindchange` 事件用于监听用户取消勾选。\n\n``` xhtml\n<view class=\"foot\">\n  <!-- 项目被取消勾选时调用 uncheck 方法。 -->\n  <checkbox-group bindchange=\"uncheck\">\n    <!-- 渲染已完成项目列表。 -->\n    <view class=\"item\" wx:for=\"{{ items }}\" wx:key=\"{{ index }}\" wx:if=\"{{ item.status }}\">\n      <!-- 复选框默认选中。 -->\n      <checkbox value=\"{{ index }}\" checked=\"{{ true }}\"/>\n      <text>{{ item.name }}</text>\n      <icon type=\"cancel\" size=\"30\" color=\"#EF5350\" bindtap=\"remove\" data-index=\"{{ index }}\"/>\n    </view>\n  </checkbox-group>\n</view>\n```\n\n### 页面脚本\n\n首先是数据部分。渲染页面使用的数据来自 `data` ，换言之在 `data` 中声明的变量可以在 wxml 中使用（打印出来）。本例声明的数据包括输入框类名 `input.class` ，用于动态修改输入框的样式，输入框的值 `input.value` 以及存储待办事项的数组 `items` 。\n\n``` js\nPage({\n  data: {\n    input: {\n      class: '',\n      value: ''\n    },\n    items: []\n  }\n}\n```\n\n`items` 中的待办事项以对象形式存在。`name` 属性是待办事项的名称，`status` 属性是待办事项的状态（0=待处理 1=已完成）。页面中通过 `status` 的值控制待处理项目列表、已完成项目列表的内容。\n\n``` js\nitems: [\n  { name: '阅读官方文档', status: 1 },\n  { name: '写一个小程序', status: 0 }\n]\n```\n\n`focus` 方法和 `blur` 方法分别在输入框获取和失去焦点时调用，通过改变 `input.class` 的值修改输入框的样式。\n\n注：在小程序中，修改数据必须使用 `setData` 方法才能使变化应用到页面上。\n\n``` js\n// 输入框获取焦点事件\nfocus: function () {\n  this.setData({ 'input.class': 'focused' })\n},\n\n// 输入框失去焦点事件\nblur: function () {\n  this.setData({ 'input.class': '' })\n},\n```\n\n`confirm` 方法在用户提交内容时调用，新增一个待办事项并清空输入框。通过参数中的 `event.detail.value` 可以取到输入框的值。\n\n``` js\n// 输入框内容提交事件\nconfirm: function (event) {\n  // 判断是否有值\n  if (event.detail.value) {\n    // 新增一个待处理项目\n    this.data.items.push({ name: event.detail.value, status: 0 })\n    // 更新页面\n    this.setData({ 'items' : this.data.items })\n    // 清空输入框\n    this.setData({ 'input.value' : '' })\n  }\n},\n\n```\n\n`check` 方法和 `uncheck` 方法分别在用户勾选待处理项目、取消勾选已完成项目时调用，用于修改数据并更新页面。通过参数中的 `event.detail.value` 获取到的是 `checkbox-group` 中所有已选 `checkbox` 的索引组成的数组。\n\n``` js\n// 复选框选中事件\ncheck: function (event) {\n  // 获得已勾选项目索引\n  let index = event.detail.value[0]\n  // 将被勾选项目的状态设为 1\n  this.data.items[index].status = 1\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n},\n// 复选框取消选中事件\nuncheck: function (event) {\n  // 将所有项目的状态设为 0\n  for (let i = 0; i < this.data.items.length; i++) {\n    this.data.items[i].status = 0\n  }\n  // 将被勾选项目的状态设为 1\n  for (let i = 0; i < event.detail.value.length; i++) {\n    let index = event.detail.value[i]\n    this.data.items[index].status = 1\n  }\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n},\n```\n\n`remove` 方法在用户点击项目的“删除”图标时调用，它将移除相应的元素并更新页面。\n\n可能有人会问：为什么 `event.target.dataset.index` 是项目索引呢？这是因为事先在 `icon` 组件上使用了自定义属性 `data-index` 向事件传参。\n\n``` js\n// 删除按钮点击事件\nremove: function (event) {\n  // 获得待删除项目索引\n  let index = event.target.dataset.index\n  // 移除元素\n  this.data.items.splice(index, 1)\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n}\n```\n\n### 页面样式\n\n小程序的样式表与 CSS 并无二致。扩展了根据屏幕宽度进行自适应的 `rpx` 单位。（参考 [WXSS](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html) ）\n\n``` css\ntext {\n  margin-left: 20rpx;\n}\ncheckbox, text, icon {\n  vertical-align:middle;\n}\nicon {\n  float: right;\n}\nview.head {\n  background: #3F51B5;\n  padding: 120rpx 50rpx;\n}\nview.head input {\n  color: #fff;\n  height: 30pt;\n  font-size: 20pt;\n  -webkit-transition: all 0.5s;\n  transition: all 0.5s;\n}\nview.head input.focused {\n  font-size: 28pt;\n}\nview.body .item, .foot .item {\n  font-size: 14pt;\n  color: #333;\n  padding: 40rpx 50rpx;\n  border-bottom: 1px solid #eeeeee;\n}\nview.foot .item text {\n  color: #bbbbbb;\n}\nview.empty {\n  font-size: 12pt;\n  padding: 50rpx;\n  text-align: center;\n}\nview.empty text {\n  margin-left: 10rpx;\n}\nview.empty icon {\n  float: none;\n}\n```\n\n现在你可以在开发者工具的“项目”选项卡中预览或上传这个小程序了。如果想体验一下这个小程序的运行效果，可以在微信中搜索已上线的版本“小待办”。\n\n相关环境：Windows 10 x64 / WeChat Web DevTools 0.15 / WeChat 6.5.6","source":"_posts/2017-03-28@手把手教你开发一个微信小程序.md","raw":"---\ntitle: 手把手教你开发一个微信小程序\ncategories:\n  - Web Front-end\ndate: 2017-03-28 11:44:53\ntags:\n  - 小程序\n  - 微信\n---\n\n由于工作需要，我最近开始学习微信小程序，看过几天文档后决定写一个简单的小程序练手，就做一个 To-do List 工具。为了日后温故，也为让有需要的朋友参考，我把开发的过程记录了下来。\n\n<!-- more -->\n\n先看一下完成后的效果：\n\n{% img /images/posts/2017/03/mini_program_practice.gif 240 功能预览 %}\n\n### 准备工作\n\n你应该具备一些基础的 Web 知识储备（HTML、CSS、JavaScript），用过 React、Vue 等前端框架更佳。访问 [官网](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html) 下载微信 Web 开发者工具，接下来的开发只需要在这一个工具上进行。\n\n### 创建应用\n\n使用你的微信号登录微信 Web 开发者工具，选择“本地小程序项目”，然后添加一个新项目。虽然不填写 AppID 也可以继续，但功能受到限制，建议开发者先注册小程序并获取 AppID 。\n\n勾选“在当前目录中创建 quick start 项目”的情况下，微信默认将创建一个 demo 程序。通过这些自动创建的文件，可以一窥小程序的目录结构：\n\n```\nTo-do List\n│  app.js          # 全局脚本\n│  app.json        # 全局配置\n│  app.wxss        # 全局样式\n│  \n├─pages\n│  ├─index         # 页面\n│  │   index.js    # 页面脚本\n│  │   index.wxml  # 页面结构\n│  │   index.wxss  # 页面样式\n│  │      \n│  └─logs\n│      logs.js\n│      logs.json\n│      logs.wxml\n│      logs.wxss\n│          \n└─utils\n   util.js\n```\n\n一个小程序主要由 wxml 结构文件、wxss 样式文件、js 脚本文件构成，和网页的构成非常相似。页面存放在 pages 目录下，该目录下的每一个目录等价于一个页面。注意，一个小程序至少应该有一个页面。\n\n本例的小程序保留全局文件和一个页面就够了，多余的目录和文件可以删除。\n\n得到如下目录结构：\n\n```\nTo-do List\n│  app.js\n│  app.json\n│  app.wxss\n│  \n└─pages\n   └─index\n       index.js\n       index.wxml\n       index.wxss\n```\n\n### 全局配置\n\n`app.json` 是小程序的全局配置文件，用于声明小程序包含的页面、修改导航栏样式等。\n\n我们要开发的小程序包含一个 index 页面，所以应该在 `pages` 中注册该页面的路径。然后在 `window` 中设置导航栏的背景色为紫色，标题就叫 `To-do List` 吧，标题的颜色设为白色。（更多配置项参考 [配置](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html) ）\n\n``` js\n\"pages\": [\n  \"pages/index/index\"\n],\n\"window\": {\n  \"navigationBarBackgroundColor\": \"#512da8\",\n  \"navigationBarTitleText\": \"To-do List\",\n  \"navigationBarTextStyle\": \"white\"\n}\n```\n\n### 框架语法\n\n在继续开发之前，你需要了解小程序框架的一些基础用法。\n\n在 wxml 文档中可以用双大括号引用 js 文档中的变量。（参考 [数据绑定](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html) ）\n\n```xhtml\n<!-- wxml -->\n<view> {{ message }} </view>\n```\n\n``` js\n// js\nPage({\n  data: {\n    message: 'Hello World!'\n  }\n})\n```\n``` xhtml\n<!-- 结果 -->\n<view> Hello World! </view>\n```\n\n在 wxml 文档中可以用 `wx:if` 判断是否要渲染该代码块 。以下面这段代码为例，当 `condition` 的值为 false、0 或空时，该代码块不会被渲染，页面中不会出现“Hello World!”。（参考 [条件渲染](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html)）\n\n``` xhtml\n<!-- wxml -->\n<view wx:if=\"{{ condition }}\"> Hello World! </view>\n```\n\n在 wxml 文档中可以用 `wx:for` 使用数组中的各项重复渲染，一般用于渲染列表。（参考 [列表渲染](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html) ）\n\n``` xhtml\n<!-- wxml -->\n<view wx:for=\"{{ array }}\"> {{ index }} - {{ item }} </view>\n```\n\n``` js\n// js\nPage({\n  data: {\n    array: [ 'Hello', 'World' ]\n  }\n})\n```\n``` xhtml\n<!-- 结果 -->\n<view> 0 - Hello </view>\n<view> 1 - World </view>\n```\n\n### 页面结构\n\n我用视图组件将页面分成了 `head`、`body`、`foot` 三个部分。`head` 提供一个输入框，用于添加新任务。`body` 用于显示待处理项目列表。`foot` 用于显示已完成项目列表。\n\n``` xhtml\n<!-- index.wxml -->\n<view class=\"head\"> ... </view>\n<view class=\"body\"> ... </view>\n<view class=\"foot\"> ... </view>\n```\n\n在 `head` 中添加一个 `input` 组件。类名 `class` 和输入框的值 `value` 分别与变量绑定。`placeholder` 和 `placeholder-style` 属性设置了提示文本的内容和样式。`bindfocus` 、`bindblur`、`bindconfirm` 分别是输入框的聚焦、失焦和提交事件。\n``` xhtml\n<view class=\"head\">\n  <input\n    class=\"{{ input.class }}\"\n    value=\"{{ input.value }}\"\n    placeholder=\"需要做什么？\"\n    placeholder-style=\"color:#fff\"\n    bindfocus=\"focus\"\n    bindblur=\"blur\"\n    bindconfirm=\"confirm\"/>\n</view>\n```\n\n`body` 视图添加一个复选框 `checkbox-group` 组件并渲染一个待处理项目列表。`bindchange` 事件用于监听子组件 `checkbox` 的变化，当用户勾选 `checkbox` 时做一些事。\n\n``` xhtml\n<view class=\"body\">\n  <!-- 项目被勾选时调用 check 方法。 -->\n  <checkbox-group bindchange=\"check\">\n    <!-- 渲染未完成项目列表。 -->\n    <view class=\"item\" wx:for=\"{{ items }}\" wx:key=\"{{ index }}\" wx:if=\"{{ !item.status }}\">\n      <!-- 复选框的值为项目的索引（以便知道哪个复选框的状态发生改变），默认不选中。 -->\n      <checkbox value=\"{{ index }}\" checked=\"{{ false }}\"/>\n      <!-- 输出项目名称 -->\n      <text>{{ item.name }}</text>\n      <!-- 删除图标，点击时调用 remove 方法，参数 index 为项目索引。 -->\n      <icon type=\"cancel\" size=\"30\" color=\"#EF5350\" bindtap=\"remove\" data-index=\"{{ index }}\"/>\n    </view>\n  </checkbox-group>\n  <!-- 当 items 中没有元素时的提示。 -->\n  <view class=\"empty\" wx:if=\"{{ items.length == 0 }}\">\n    <icon type=\"success\" size=\"20\" color=\"{{ item }}\"/>\n    <text>无待办事项</text>\n  </view>\n</view>\n```\n\n`foot` 视图的结构和 `body` 视图基本一致，渲染一个已完成项目列表。已完成项目一定是打了钩的，所以其中的 `checkbox` 默认选中。`checkbox-group` 组件的 `bindchange` 事件用于监听用户取消勾选。\n\n``` xhtml\n<view class=\"foot\">\n  <!-- 项目被取消勾选时调用 uncheck 方法。 -->\n  <checkbox-group bindchange=\"uncheck\">\n    <!-- 渲染已完成项目列表。 -->\n    <view class=\"item\" wx:for=\"{{ items }}\" wx:key=\"{{ index }}\" wx:if=\"{{ item.status }}\">\n      <!-- 复选框默认选中。 -->\n      <checkbox value=\"{{ index }}\" checked=\"{{ true }}\"/>\n      <text>{{ item.name }}</text>\n      <icon type=\"cancel\" size=\"30\" color=\"#EF5350\" bindtap=\"remove\" data-index=\"{{ index }}\"/>\n    </view>\n  </checkbox-group>\n</view>\n```\n\n### 页面脚本\n\n首先是数据部分。渲染页面使用的数据来自 `data` ，换言之在 `data` 中声明的变量可以在 wxml 中使用（打印出来）。本例声明的数据包括输入框类名 `input.class` ，用于动态修改输入框的样式，输入框的值 `input.value` 以及存储待办事项的数组 `items` 。\n\n``` js\nPage({\n  data: {\n    input: {\n      class: '',\n      value: ''\n    },\n    items: []\n  }\n}\n```\n\n`items` 中的待办事项以对象形式存在。`name` 属性是待办事项的名称，`status` 属性是待办事项的状态（0=待处理 1=已完成）。页面中通过 `status` 的值控制待处理项目列表、已完成项目列表的内容。\n\n``` js\nitems: [\n  { name: '阅读官方文档', status: 1 },\n  { name: '写一个小程序', status: 0 }\n]\n```\n\n`focus` 方法和 `blur` 方法分别在输入框获取和失去焦点时调用，通过改变 `input.class` 的值修改输入框的样式。\n\n注：在小程序中，修改数据必须使用 `setData` 方法才能使变化应用到页面上。\n\n``` js\n// 输入框获取焦点事件\nfocus: function () {\n  this.setData({ 'input.class': 'focused' })\n},\n\n// 输入框失去焦点事件\nblur: function () {\n  this.setData({ 'input.class': '' })\n},\n```\n\n`confirm` 方法在用户提交内容时调用，新增一个待办事项并清空输入框。通过参数中的 `event.detail.value` 可以取到输入框的值。\n\n``` js\n// 输入框内容提交事件\nconfirm: function (event) {\n  // 判断是否有值\n  if (event.detail.value) {\n    // 新增一个待处理项目\n    this.data.items.push({ name: event.detail.value, status: 0 })\n    // 更新页面\n    this.setData({ 'items' : this.data.items })\n    // 清空输入框\n    this.setData({ 'input.value' : '' })\n  }\n},\n\n```\n\n`check` 方法和 `uncheck` 方法分别在用户勾选待处理项目、取消勾选已完成项目时调用，用于修改数据并更新页面。通过参数中的 `event.detail.value` 获取到的是 `checkbox-group` 中所有已选 `checkbox` 的索引组成的数组。\n\n``` js\n// 复选框选中事件\ncheck: function (event) {\n  // 获得已勾选项目索引\n  let index = event.detail.value[0]\n  // 将被勾选项目的状态设为 1\n  this.data.items[index].status = 1\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n},\n// 复选框取消选中事件\nuncheck: function (event) {\n  // 将所有项目的状态设为 0\n  for (let i = 0; i < this.data.items.length; i++) {\n    this.data.items[i].status = 0\n  }\n  // 将被勾选项目的状态设为 1\n  for (let i = 0; i < event.detail.value.length; i++) {\n    let index = event.detail.value[i]\n    this.data.items[index].status = 1\n  }\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n},\n```\n\n`remove` 方法在用户点击项目的“删除”图标时调用，它将移除相应的元素并更新页面。\n\n可能有人会问：为什么 `event.target.dataset.index` 是项目索引呢？这是因为事先在 `icon` 组件上使用了自定义属性 `data-index` 向事件传参。\n\n``` js\n// 删除按钮点击事件\nremove: function (event) {\n  // 获得待删除项目索引\n  let index = event.target.dataset.index\n  // 移除元素\n  this.data.items.splice(index, 1)\n  // 更新页面\n  this.setData({ 'items' : this.data.items })\n}\n```\n\n### 页面样式\n\n小程序的样式表与 CSS 并无二致。扩展了根据屏幕宽度进行自适应的 `rpx` 单位。（参考 [WXSS](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html) ）\n\n``` css\ntext {\n  margin-left: 20rpx;\n}\ncheckbox, text, icon {\n  vertical-align:middle;\n}\nicon {\n  float: right;\n}\nview.head {\n  background: #3F51B5;\n  padding: 120rpx 50rpx;\n}\nview.head input {\n  color: #fff;\n  height: 30pt;\n  font-size: 20pt;\n  -webkit-transition: all 0.5s;\n  transition: all 0.5s;\n}\nview.head input.focused {\n  font-size: 28pt;\n}\nview.body .item, .foot .item {\n  font-size: 14pt;\n  color: #333;\n  padding: 40rpx 50rpx;\n  border-bottom: 1px solid #eeeeee;\n}\nview.foot .item text {\n  color: #bbbbbb;\n}\nview.empty {\n  font-size: 12pt;\n  padding: 50rpx;\n  text-align: center;\n}\nview.empty text {\n  margin-left: 10rpx;\n}\nview.empty icon {\n  float: none;\n}\n```\n\n现在你可以在开发者工具的“项目”选项卡中预览或上传这个小程序了。如果想体验一下这个小程序的运行效果，可以在微信中搜索已上线的版本“小待办”。\n\n相关环境：Windows 10 x64 / WeChat Web DevTools 0.15 / WeChat 6.5.6","slug":"2017-03-28@手把手教你开发一个微信小程序","published":1,"updated":"2020-06-29T03:32:42.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4br00ezrqgj4vw8epuk","content":"<p>由于工作需要，我最近开始学习微信小程序，看过几天文档后决定写一个简单的小程序练手，就做一个 To-do List 工具。为了日后温故，也为让有需要的朋友参考，我把开发的过程记录了下来。</p>\n<a id=\"more\"></a>\n\n<p>先看一下完成后的效果：</p>\n<img src=\"/images/posts/2017/03/mini_program_practice.gif\" class=\"\" width=\"240\" title=\"功能预览\">\n\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>你应该具备一些基础的 Web 知识储备（HTML、CSS、JavaScript），用过 React、Vue 等前端框架更佳。访问 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html\" target=\"_blank\" rel=\"noopener\">官网</a> 下载微信 Web 开发者工具，接下来的开发只需要在这一个工具上进行。</p>\n<h3 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h3><p>使用你的微信号登录微信 Web 开发者工具，选择“本地小程序项目”，然后添加一个新项目。虽然不填写 AppID 也可以继续，但功能受到限制，建议开发者先注册小程序并获取 AppID 。</p>\n<p>勾选“在当前目录中创建 quick start 项目”的情况下，微信默认将创建一个 demo 程序。通过这些自动创建的文件，可以一窥小程序的目录结构：</p>\n<pre><code>To-do List\n│  app.js          # 全局脚本\n│  app.json        # 全局配置\n│  app.wxss        # 全局样式\n│  \n├─pages\n│  ├─index         # 页面\n│  │   index.js    # 页面脚本\n│  │   index.wxml  # 页面结构\n│  │   index.wxss  # 页面样式\n│  │      \n│  └─logs\n│      logs.js\n│      logs.json\n│      logs.wxml\n│      logs.wxss\n│          \n└─utils\n   util.js</code></pre><p>一个小程序主要由 wxml 结构文件、wxss 样式文件、js 脚本文件构成，和网页的构成非常相似。页面存放在 pages 目录下，该目录下的每一个目录等价于一个页面。注意，一个小程序至少应该有一个页面。</p>\n<p>本例的小程序保留全局文件和一个页面就够了，多余的目录和文件可以删除。</p>\n<p>得到如下目录结构：</p>\n<pre><code>To-do List\n│  app.js\n│  app.json\n│  app.wxss\n│  \n└─pages\n   └─index\n       index.js\n       index.wxml\n       index.wxss</code></pre><h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p><code>app.json</code> 是小程序的全局配置文件，用于声明小程序包含的页面、修改导航栏样式等。</p>\n<p>我们要开发的小程序包含一个 index 页面，所以应该在 <code>pages</code> 中注册该页面的路径。然后在 <code>window</code> 中设置导航栏的背景色为紫色，标题就叫 <code>To-do List</code> 吧，标题的颜色设为白色。（更多配置项参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">配置</a> ）</p>\n<pre><code class=\"js\">&quot;pages&quot;: [\n  &quot;pages/index/index&quot;\n],\n&quot;window&quot;: {\n  &quot;navigationBarBackgroundColor&quot;: &quot;#512da8&quot;,\n  &quot;navigationBarTitleText&quot;: &quot;To-do List&quot;,\n  &quot;navigationBarTextStyle&quot;: &quot;white&quot;\n}</code></pre>\n<h3 id=\"框架语法\"><a href=\"#框架语法\" class=\"headerlink\" title=\"框架语法\"></a>框架语法</h3><p>在继续开发之前，你需要了解小程序框架的一些基础用法。</p>\n<p>在 wxml 文档中可以用双大括号引用 js 文档中的变量。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html\" target=\"_blank\" rel=\"noopener\">数据绑定</a> ）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view&gt; {{ message }} &lt;/view&gt;</code></pre>\n<pre><code class=\"js\">// js\nPage({\n  data: {\n    message: &#39;Hello World!&#39;\n  }\n})</code></pre>\n<pre><code class=\"xhtml\">&lt;!-- 结果 --&gt;\n&lt;view&gt; Hello World! &lt;/view&gt;</code></pre>\n<p>在 wxml 文档中可以用 <code>wx:if</code> 判断是否要渲染该代码块 。以下面这段代码为例，当 <code>condition</code> 的值为 false、0 或空时，该代码块不会被渲染，页面中不会出现“Hello World!”。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html\" target=\"_blank\" rel=\"noopener\">条件渲染</a>）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view wx:if=&quot;{{ condition }}&quot;&gt; Hello World! &lt;/view&gt;</code></pre>\n<p>在 wxml 文档中可以用 <code>wx:for</code> 使用数组中的各项重复渲染，一般用于渲染列表。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html\" target=\"_blank\" rel=\"noopener\">列表渲染</a> ）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view wx:for=&quot;{{ array }}&quot;&gt; {{ index }} - {{ item }} &lt;/view&gt;</code></pre>\n<pre><code class=\"js\">// js\nPage({\n  data: {\n    array: [ &#39;Hello&#39;, &#39;World&#39; ]\n  }\n})</code></pre>\n<pre><code class=\"xhtml\">&lt;!-- 结果 --&gt;\n&lt;view&gt; 0 - Hello &lt;/view&gt;\n&lt;view&gt; 1 - World &lt;/view&gt;</code></pre>\n<h3 id=\"页面结构\"><a href=\"#页面结构\" class=\"headerlink\" title=\"页面结构\"></a>页面结构</h3><p>我用视图组件将页面分成了 <code>head</code>、<code>body</code>、<code>foot</code> 三个部分。<code>head</code> 提供一个输入框，用于添加新任务。<code>body</code> 用于显示待处理项目列表。<code>foot</code> 用于显示已完成项目列表。</p>\n<pre><code class=\"xhtml\">&lt;!-- index.wxml --&gt;\n&lt;view class=&quot;head&quot;&gt; ... &lt;/view&gt;\n&lt;view class=&quot;body&quot;&gt; ... &lt;/view&gt;\n&lt;view class=&quot;foot&quot;&gt; ... &lt;/view&gt;</code></pre>\n<p>在 <code>head</code> 中添加一个 <code>input</code> 组件。类名 <code>class</code> 和输入框的值 <code>value</code> 分别与变量绑定。<code>placeholder</code> 和 <code>placeholder-style</code> 属性设置了提示文本的内容和样式。<code>bindfocus</code> 、<code>bindblur</code>、<code>bindconfirm</code> 分别是输入框的聚焦、失焦和提交事件。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;head&quot;&gt;\n  &lt;input\n    class=&quot;{{ input.class }}&quot;\n    value=&quot;{{ input.value }}&quot;\n    placeholder=&quot;需要做什么？&quot;\n    placeholder-style=&quot;color:#fff&quot;\n    bindfocus=&quot;focus&quot;\n    bindblur=&quot;blur&quot;\n    bindconfirm=&quot;confirm&quot;/&gt;\n&lt;/view&gt;</code></pre>\n<p><code>body</code> 视图添加一个复选框 <code>checkbox-group</code> 组件并渲染一个待处理项目列表。<code>bindchange</code> 事件用于监听子组件 <code>checkbox</code> 的变化，当用户勾选 <code>checkbox</code> 时做一些事。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;body&quot;&gt;\n  &lt;!-- 项目被勾选时调用 check 方法。 --&gt;\n  &lt;checkbox-group bindchange=&quot;check&quot;&gt;\n    &lt;!-- 渲染未完成项目列表。 --&gt;\n    &lt;view class=&quot;item&quot; wx:for=&quot;{{ items }}&quot; wx:key=&quot;{{ index }}&quot; wx:if=&quot;{{ !item.status }}&quot;&gt;\n      &lt;!-- 复选框的值为项目的索引（以便知道哪个复选框的状态发生改变），默认不选中。 --&gt;\n      &lt;checkbox value=&quot;{{ index }}&quot; checked=&quot;{{ false }}&quot;/&gt;\n      &lt;!-- 输出项目名称 --&gt;\n      &lt;text&gt;{{ item.name }}&lt;/text&gt;\n      &lt;!-- 删除图标，点击时调用 remove 方法，参数 index 为项目索引。 --&gt;\n      &lt;icon type=&quot;cancel&quot; size=&quot;30&quot; color=&quot;#EF5350&quot; bindtap=&quot;remove&quot; data-index=&quot;{{ index }}&quot;/&gt;\n    &lt;/view&gt;\n  &lt;/checkbox-group&gt;\n  &lt;!-- 当 items 中没有元素时的提示。 --&gt;\n  &lt;view class=&quot;empty&quot; wx:if=&quot;{{ items.length == 0 }}&quot;&gt;\n    &lt;icon type=&quot;success&quot; size=&quot;20&quot; color=&quot;{{ item }}&quot;/&gt;\n    &lt;text&gt;无待办事项&lt;/text&gt;\n  &lt;/view&gt;\n&lt;/view&gt;</code></pre>\n<p><code>foot</code> 视图的结构和 <code>body</code> 视图基本一致，渲染一个已完成项目列表。已完成项目一定是打了钩的，所以其中的 <code>checkbox</code> 默认选中。<code>checkbox-group</code> 组件的 <code>bindchange</code> 事件用于监听用户取消勾选。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;foot&quot;&gt;\n  &lt;!-- 项目被取消勾选时调用 uncheck 方法。 --&gt;\n  &lt;checkbox-group bindchange=&quot;uncheck&quot;&gt;\n    &lt;!-- 渲染已完成项目列表。 --&gt;\n    &lt;view class=&quot;item&quot; wx:for=&quot;{{ items }}&quot; wx:key=&quot;{{ index }}&quot; wx:if=&quot;{{ item.status }}&quot;&gt;\n      &lt;!-- 复选框默认选中。 --&gt;\n      &lt;checkbox value=&quot;{{ index }}&quot; checked=&quot;{{ true }}&quot;/&gt;\n      &lt;text&gt;{{ item.name }}&lt;/text&gt;\n      &lt;icon type=&quot;cancel&quot; size=&quot;30&quot; color=&quot;#EF5350&quot; bindtap=&quot;remove&quot; data-index=&quot;{{ index }}&quot;/&gt;\n    &lt;/view&gt;\n  &lt;/checkbox-group&gt;\n&lt;/view&gt;</code></pre>\n<h3 id=\"页面脚本\"><a href=\"#页面脚本\" class=\"headerlink\" title=\"页面脚本\"></a>页面脚本</h3><p>首先是数据部分。渲染页面使用的数据来自 <code>data</code> ，换言之在 <code>data</code> 中声明的变量可以在 wxml 中使用（打印出来）。本例声明的数据包括输入框类名 <code>input.class</code> ，用于动态修改输入框的样式，输入框的值 <code>input.value</code> 以及存储待办事项的数组 <code>items</code> 。</p>\n<pre><code class=\"js\">Page({\n  data: {\n    input: {\n      class: &#39;&#39;,\n      value: &#39;&#39;\n    },\n    items: []\n  }\n}</code></pre>\n<p><code>items</code> 中的待办事项以对象形式存在。<code>name</code> 属性是待办事项的名称，<code>status</code> 属性是待办事项的状态（0=待处理 1=已完成）。页面中通过 <code>status</code> 的值控制待处理项目列表、已完成项目列表的内容。</p>\n<pre><code class=\"js\">items: [\n  { name: &#39;阅读官方文档&#39;, status: 1 },\n  { name: &#39;写一个小程序&#39;, status: 0 }\n]</code></pre>\n<p><code>focus</code> 方法和 <code>blur</code> 方法分别在输入框获取和失去焦点时调用，通过改变 <code>input.class</code> 的值修改输入框的样式。</p>\n<p>注：在小程序中，修改数据必须使用 <code>setData</code> 方法才能使变化应用到页面上。</p>\n<pre><code class=\"js\">// 输入框获取焦点事件\nfocus: function () {\n  this.setData({ &#39;input.class&#39;: &#39;focused&#39; })\n},\n\n// 输入框失去焦点事件\nblur: function () {\n  this.setData({ &#39;input.class&#39;: &#39;&#39; })\n},</code></pre>\n<p><code>confirm</code> 方法在用户提交内容时调用，新增一个待办事项并清空输入框。通过参数中的 <code>event.detail.value</code> 可以取到输入框的值。</p>\n<pre><code class=\"js\">// 输入框内容提交事件\nconfirm: function (event) {\n  // 判断是否有值\n  if (event.detail.value) {\n    // 新增一个待处理项目\n    this.data.items.push({ name: event.detail.value, status: 0 })\n    // 更新页面\n    this.setData({ &#39;items&#39; : this.data.items })\n    // 清空输入框\n    this.setData({ &#39;input.value&#39; : &#39;&#39; })\n  }\n},\n</code></pre>\n<p><code>check</code> 方法和 <code>uncheck</code> 方法分别在用户勾选待处理项目、取消勾选已完成项目时调用，用于修改数据并更新页面。通过参数中的 <code>event.detail.value</code> 获取到的是 <code>checkbox-group</code> 中所有已选 <code>checkbox</code> 的索引组成的数组。</p>\n<pre><code class=\"js\">// 复选框选中事件\ncheck: function (event) {\n  // 获得已勾选项目索引\n  let index = event.detail.value[0]\n  // 将被勾选项目的状态设为 1\n  this.data.items[index].status = 1\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n},\n// 复选框取消选中事件\nuncheck: function (event) {\n  // 将所有项目的状态设为 0\n  for (let i = 0; i &lt; this.data.items.length; i++) {\n    this.data.items[i].status = 0\n  }\n  // 将被勾选项目的状态设为 1\n  for (let i = 0; i &lt; event.detail.value.length; i++) {\n    let index = event.detail.value[i]\n    this.data.items[index].status = 1\n  }\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n},</code></pre>\n<p><code>remove</code> 方法在用户点击项目的“删除”图标时调用，它将移除相应的元素并更新页面。</p>\n<p>可能有人会问：为什么 <code>event.target.dataset.index</code> 是项目索引呢？这是因为事先在 <code>icon</code> 组件上使用了自定义属性 <code>data-index</code> 向事件传参。</p>\n<pre><code class=\"js\">// 删除按钮点击事件\nremove: function (event) {\n  // 获得待删除项目索引\n  let index = event.target.dataset.index\n  // 移除元素\n  this.data.items.splice(index, 1)\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n}</code></pre>\n<h3 id=\"页面样式\"><a href=\"#页面样式\" class=\"headerlink\" title=\"页面样式\"></a>页面样式</h3><p>小程序的样式表与 CSS 并无二致。扩展了根据屏幕宽度进行自适应的 <code>rpx</code> 单位。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html\" target=\"_blank\" rel=\"noopener\">WXSS</a> ）</p>\n<pre><code class=\"css\">text {\n  margin-left: 20rpx;\n}\ncheckbox, text, icon {\n  vertical-align:middle;\n}\nicon {\n  float: right;\n}\nview.head {\n  background: #3F51B5;\n  padding: 120rpx 50rpx;\n}\nview.head input {\n  color: #fff;\n  height: 30pt;\n  font-size: 20pt;\n  -webkit-transition: all 0.5s;\n  transition: all 0.5s;\n}\nview.head input.focused {\n  font-size: 28pt;\n}\nview.body .item, .foot .item {\n  font-size: 14pt;\n  color: #333;\n  padding: 40rpx 50rpx;\n  border-bottom: 1px solid #eeeeee;\n}\nview.foot .item text {\n  color: #bbbbbb;\n}\nview.empty {\n  font-size: 12pt;\n  padding: 50rpx;\n  text-align: center;\n}\nview.empty text {\n  margin-left: 10rpx;\n}\nview.empty icon {\n  float: none;\n}</code></pre>\n<p>现在你可以在开发者工具的“项目”选项卡中预览或上传这个小程序了。如果想体验一下这个小程序的运行效果，可以在微信中搜索已上线的版本“小待办”。</p>\n<p>相关环境：Windows 10 x64 / WeChat Web DevTools 0.15 / WeChat 6.5.6</p>\n","site":{"data":{}},"excerpt":"<p>由于工作需要，我最近开始学习微信小程序，看过几天文档后决定写一个简单的小程序练手，就做一个 To-do List 工具。为了日后温故，也为让有需要的朋友参考，我把开发的过程记录了下来。</p>","more":"<p>先看一下完成后的效果：</p>\n<img src=\"/images/posts/2017/03/mini_program_practice.gif\" class=\"\" width=\"240\" title=\"功能预览\">\n\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>你应该具备一些基础的 Web 知识储备（HTML、CSS、JavaScript），用过 React、Vue 等前端框架更佳。访问 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html\" target=\"_blank\" rel=\"noopener\">官网</a> 下载微信 Web 开发者工具，接下来的开发只需要在这一个工具上进行。</p>\n<h3 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h3><p>使用你的微信号登录微信 Web 开发者工具，选择“本地小程序项目”，然后添加一个新项目。虽然不填写 AppID 也可以继续，但功能受到限制，建议开发者先注册小程序并获取 AppID 。</p>\n<p>勾选“在当前目录中创建 quick start 项目”的情况下，微信默认将创建一个 demo 程序。通过这些自动创建的文件，可以一窥小程序的目录结构：</p>\n<pre><code>To-do List\n│  app.js          # 全局脚本\n│  app.json        # 全局配置\n│  app.wxss        # 全局样式\n│  \n├─pages\n│  ├─index         # 页面\n│  │   index.js    # 页面脚本\n│  │   index.wxml  # 页面结构\n│  │   index.wxss  # 页面样式\n│  │      \n│  └─logs\n│      logs.js\n│      logs.json\n│      logs.wxml\n│      logs.wxss\n│          \n└─utils\n   util.js</code></pre><p>一个小程序主要由 wxml 结构文件、wxss 样式文件、js 脚本文件构成，和网页的构成非常相似。页面存放在 pages 目录下，该目录下的每一个目录等价于一个页面。注意，一个小程序至少应该有一个页面。</p>\n<p>本例的小程序保留全局文件和一个页面就够了，多余的目录和文件可以删除。</p>\n<p>得到如下目录结构：</p>\n<pre><code>To-do List\n│  app.js\n│  app.json\n│  app.wxss\n│  \n└─pages\n   └─index\n       index.js\n       index.wxml\n       index.wxss</code></pre><h3 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h3><p><code>app.json</code> 是小程序的全局配置文件，用于声明小程序包含的页面、修改导航栏样式等。</p>\n<p>我们要开发的小程序包含一个 index 页面，所以应该在 <code>pages</code> 中注册该页面的路径。然后在 <code>window</code> 中设置导航栏的背景色为紫色，标题就叫 <code>To-do List</code> 吧，标题的颜色设为白色。（更多配置项参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">配置</a> ）</p>\n<pre><code class=\"js\">&quot;pages&quot;: [\n  &quot;pages/index/index&quot;\n],\n&quot;window&quot;: {\n  &quot;navigationBarBackgroundColor&quot;: &quot;#512da8&quot;,\n  &quot;navigationBarTitleText&quot;: &quot;To-do List&quot;,\n  &quot;navigationBarTextStyle&quot;: &quot;white&quot;\n}</code></pre>\n<h3 id=\"框架语法\"><a href=\"#框架语法\" class=\"headerlink\" title=\"框架语法\"></a>框架语法</h3><p>在继续开发之前，你需要了解小程序框架的一些基础用法。</p>\n<p>在 wxml 文档中可以用双大括号引用 js 文档中的变量。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html\" target=\"_blank\" rel=\"noopener\">数据绑定</a> ）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view&gt; {{ message }} &lt;/view&gt;</code></pre>\n<pre><code class=\"js\">// js\nPage({\n  data: {\n    message: &#39;Hello World!&#39;\n  }\n})</code></pre>\n<pre><code class=\"xhtml\">&lt;!-- 结果 --&gt;\n&lt;view&gt; Hello World! &lt;/view&gt;</code></pre>\n<p>在 wxml 文档中可以用 <code>wx:if</code> 判断是否要渲染该代码块 。以下面这段代码为例，当 <code>condition</code> 的值为 false、0 或空时，该代码块不会被渲染，页面中不会出现“Hello World!”。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html\" target=\"_blank\" rel=\"noopener\">条件渲染</a>）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view wx:if=&quot;{{ condition }}&quot;&gt; Hello World! &lt;/view&gt;</code></pre>\n<p>在 wxml 文档中可以用 <code>wx:for</code> 使用数组中的各项重复渲染，一般用于渲染列表。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html\" target=\"_blank\" rel=\"noopener\">列表渲染</a> ）</p>\n<pre><code class=\"xhtml\">&lt;!-- wxml --&gt;\n&lt;view wx:for=&quot;{{ array }}&quot;&gt; {{ index }} - {{ item }} &lt;/view&gt;</code></pre>\n<pre><code class=\"js\">// js\nPage({\n  data: {\n    array: [ &#39;Hello&#39;, &#39;World&#39; ]\n  }\n})</code></pre>\n<pre><code class=\"xhtml\">&lt;!-- 结果 --&gt;\n&lt;view&gt; 0 - Hello &lt;/view&gt;\n&lt;view&gt; 1 - World &lt;/view&gt;</code></pre>\n<h3 id=\"页面结构\"><a href=\"#页面结构\" class=\"headerlink\" title=\"页面结构\"></a>页面结构</h3><p>我用视图组件将页面分成了 <code>head</code>、<code>body</code>、<code>foot</code> 三个部分。<code>head</code> 提供一个输入框，用于添加新任务。<code>body</code> 用于显示待处理项目列表。<code>foot</code> 用于显示已完成项目列表。</p>\n<pre><code class=\"xhtml\">&lt;!-- index.wxml --&gt;\n&lt;view class=&quot;head&quot;&gt; ... &lt;/view&gt;\n&lt;view class=&quot;body&quot;&gt; ... &lt;/view&gt;\n&lt;view class=&quot;foot&quot;&gt; ... &lt;/view&gt;</code></pre>\n<p>在 <code>head</code> 中添加一个 <code>input</code> 组件。类名 <code>class</code> 和输入框的值 <code>value</code> 分别与变量绑定。<code>placeholder</code> 和 <code>placeholder-style</code> 属性设置了提示文本的内容和样式。<code>bindfocus</code> 、<code>bindblur</code>、<code>bindconfirm</code> 分别是输入框的聚焦、失焦和提交事件。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;head&quot;&gt;\n  &lt;input\n    class=&quot;{{ input.class }}&quot;\n    value=&quot;{{ input.value }}&quot;\n    placeholder=&quot;需要做什么？&quot;\n    placeholder-style=&quot;color:#fff&quot;\n    bindfocus=&quot;focus&quot;\n    bindblur=&quot;blur&quot;\n    bindconfirm=&quot;confirm&quot;/&gt;\n&lt;/view&gt;</code></pre>\n<p><code>body</code> 视图添加一个复选框 <code>checkbox-group</code> 组件并渲染一个待处理项目列表。<code>bindchange</code> 事件用于监听子组件 <code>checkbox</code> 的变化，当用户勾选 <code>checkbox</code> 时做一些事。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;body&quot;&gt;\n  &lt;!-- 项目被勾选时调用 check 方法。 --&gt;\n  &lt;checkbox-group bindchange=&quot;check&quot;&gt;\n    &lt;!-- 渲染未完成项目列表。 --&gt;\n    &lt;view class=&quot;item&quot; wx:for=&quot;{{ items }}&quot; wx:key=&quot;{{ index }}&quot; wx:if=&quot;{{ !item.status }}&quot;&gt;\n      &lt;!-- 复选框的值为项目的索引（以便知道哪个复选框的状态发生改变），默认不选中。 --&gt;\n      &lt;checkbox value=&quot;{{ index }}&quot; checked=&quot;{{ false }}&quot;/&gt;\n      &lt;!-- 输出项目名称 --&gt;\n      &lt;text&gt;{{ item.name }}&lt;/text&gt;\n      &lt;!-- 删除图标，点击时调用 remove 方法，参数 index 为项目索引。 --&gt;\n      &lt;icon type=&quot;cancel&quot; size=&quot;30&quot; color=&quot;#EF5350&quot; bindtap=&quot;remove&quot; data-index=&quot;{{ index }}&quot;/&gt;\n    &lt;/view&gt;\n  &lt;/checkbox-group&gt;\n  &lt;!-- 当 items 中没有元素时的提示。 --&gt;\n  &lt;view class=&quot;empty&quot; wx:if=&quot;{{ items.length == 0 }}&quot;&gt;\n    &lt;icon type=&quot;success&quot; size=&quot;20&quot; color=&quot;{{ item }}&quot;/&gt;\n    &lt;text&gt;无待办事项&lt;/text&gt;\n  &lt;/view&gt;\n&lt;/view&gt;</code></pre>\n<p><code>foot</code> 视图的结构和 <code>body</code> 视图基本一致，渲染一个已完成项目列表。已完成项目一定是打了钩的，所以其中的 <code>checkbox</code> 默认选中。<code>checkbox-group</code> 组件的 <code>bindchange</code> 事件用于监听用户取消勾选。</p>\n<pre><code class=\"xhtml\">&lt;view class=&quot;foot&quot;&gt;\n  &lt;!-- 项目被取消勾选时调用 uncheck 方法。 --&gt;\n  &lt;checkbox-group bindchange=&quot;uncheck&quot;&gt;\n    &lt;!-- 渲染已完成项目列表。 --&gt;\n    &lt;view class=&quot;item&quot; wx:for=&quot;{{ items }}&quot; wx:key=&quot;{{ index }}&quot; wx:if=&quot;{{ item.status }}&quot;&gt;\n      &lt;!-- 复选框默认选中。 --&gt;\n      &lt;checkbox value=&quot;{{ index }}&quot; checked=&quot;{{ true }}&quot;/&gt;\n      &lt;text&gt;{{ item.name }}&lt;/text&gt;\n      &lt;icon type=&quot;cancel&quot; size=&quot;30&quot; color=&quot;#EF5350&quot; bindtap=&quot;remove&quot; data-index=&quot;{{ index }}&quot;/&gt;\n    &lt;/view&gt;\n  &lt;/checkbox-group&gt;\n&lt;/view&gt;</code></pre>\n<h3 id=\"页面脚本\"><a href=\"#页面脚本\" class=\"headerlink\" title=\"页面脚本\"></a>页面脚本</h3><p>首先是数据部分。渲染页面使用的数据来自 <code>data</code> ，换言之在 <code>data</code> 中声明的变量可以在 wxml 中使用（打印出来）。本例声明的数据包括输入框类名 <code>input.class</code> ，用于动态修改输入框的样式，输入框的值 <code>input.value</code> 以及存储待办事项的数组 <code>items</code> 。</p>\n<pre><code class=\"js\">Page({\n  data: {\n    input: {\n      class: &#39;&#39;,\n      value: &#39;&#39;\n    },\n    items: []\n  }\n}</code></pre>\n<p><code>items</code> 中的待办事项以对象形式存在。<code>name</code> 属性是待办事项的名称，<code>status</code> 属性是待办事项的状态（0=待处理 1=已完成）。页面中通过 <code>status</code> 的值控制待处理项目列表、已完成项目列表的内容。</p>\n<pre><code class=\"js\">items: [\n  { name: &#39;阅读官方文档&#39;, status: 1 },\n  { name: &#39;写一个小程序&#39;, status: 0 }\n]</code></pre>\n<p><code>focus</code> 方法和 <code>blur</code> 方法分别在输入框获取和失去焦点时调用，通过改变 <code>input.class</code> 的值修改输入框的样式。</p>\n<p>注：在小程序中，修改数据必须使用 <code>setData</code> 方法才能使变化应用到页面上。</p>\n<pre><code class=\"js\">// 输入框获取焦点事件\nfocus: function () {\n  this.setData({ &#39;input.class&#39;: &#39;focused&#39; })\n},\n\n// 输入框失去焦点事件\nblur: function () {\n  this.setData({ &#39;input.class&#39;: &#39;&#39; })\n},</code></pre>\n<p><code>confirm</code> 方法在用户提交内容时调用，新增一个待办事项并清空输入框。通过参数中的 <code>event.detail.value</code> 可以取到输入框的值。</p>\n<pre><code class=\"js\">// 输入框内容提交事件\nconfirm: function (event) {\n  // 判断是否有值\n  if (event.detail.value) {\n    // 新增一个待处理项目\n    this.data.items.push({ name: event.detail.value, status: 0 })\n    // 更新页面\n    this.setData({ &#39;items&#39; : this.data.items })\n    // 清空输入框\n    this.setData({ &#39;input.value&#39; : &#39;&#39; })\n  }\n},\n</code></pre>\n<p><code>check</code> 方法和 <code>uncheck</code> 方法分别在用户勾选待处理项目、取消勾选已完成项目时调用，用于修改数据并更新页面。通过参数中的 <code>event.detail.value</code> 获取到的是 <code>checkbox-group</code> 中所有已选 <code>checkbox</code> 的索引组成的数组。</p>\n<pre><code class=\"js\">// 复选框选中事件\ncheck: function (event) {\n  // 获得已勾选项目索引\n  let index = event.detail.value[0]\n  // 将被勾选项目的状态设为 1\n  this.data.items[index].status = 1\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n},\n// 复选框取消选中事件\nuncheck: function (event) {\n  // 将所有项目的状态设为 0\n  for (let i = 0; i &lt; this.data.items.length; i++) {\n    this.data.items[i].status = 0\n  }\n  // 将被勾选项目的状态设为 1\n  for (let i = 0; i &lt; event.detail.value.length; i++) {\n    let index = event.detail.value[i]\n    this.data.items[index].status = 1\n  }\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n},</code></pre>\n<p><code>remove</code> 方法在用户点击项目的“删除”图标时调用，它将移除相应的元素并更新页面。</p>\n<p>可能有人会问：为什么 <code>event.target.dataset.index</code> 是项目索引呢？这是因为事先在 <code>icon</code> 组件上使用了自定义属性 <code>data-index</code> 向事件传参。</p>\n<pre><code class=\"js\">// 删除按钮点击事件\nremove: function (event) {\n  // 获得待删除项目索引\n  let index = event.target.dataset.index\n  // 移除元素\n  this.data.items.splice(index, 1)\n  // 更新页面\n  this.setData({ &#39;items&#39; : this.data.items })\n}</code></pre>\n<h3 id=\"页面样式\"><a href=\"#页面样式\" class=\"headerlink\" title=\"页面样式\"></a>页面样式</h3><p>小程序的样式表与 CSS 并无二致。扩展了根据屏幕宽度进行自适应的 <code>rpx</code> 单位。（参考 <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html\" target=\"_blank\" rel=\"noopener\">WXSS</a> ）</p>\n<pre><code class=\"css\">text {\n  margin-left: 20rpx;\n}\ncheckbox, text, icon {\n  vertical-align:middle;\n}\nicon {\n  float: right;\n}\nview.head {\n  background: #3F51B5;\n  padding: 120rpx 50rpx;\n}\nview.head input {\n  color: #fff;\n  height: 30pt;\n  font-size: 20pt;\n  -webkit-transition: all 0.5s;\n  transition: all 0.5s;\n}\nview.head input.focused {\n  font-size: 28pt;\n}\nview.body .item, .foot .item {\n  font-size: 14pt;\n  color: #333;\n  padding: 40rpx 50rpx;\n  border-bottom: 1px solid #eeeeee;\n}\nview.foot .item text {\n  color: #bbbbbb;\n}\nview.empty {\n  font-size: 12pt;\n  padding: 50rpx;\n  text-align: center;\n}\nview.empty text {\n  margin-left: 10rpx;\n}\nview.empty icon {\n  float: none;\n}</code></pre>\n<p>现在你可以在开发者工具的“项目”选项卡中预览或上传这个小程序了。如果想体验一下这个小程序的运行效果，可以在微信中搜索已上线的版本“小待办”。</p>\n<p>相关环境：Windows 10 x64 / WeChat Web DevTools 0.15 / WeChat 6.5.6</p>"},{"title":"Laravel 快速入门","date":"2018-09-02T15:00:53.000Z","_content":"\n上周我在团队内做了 Laravel 入门分享，希望能够帮助对这款框架不熟悉的同学快速上手，最好听完就能撸个接口。作为前端小哥的我自知对后端了解有限，于是我事先写了个 demo，围绕一个假定的需求 —— 学生信息的增删改查来讲这堂课。\n\n<!-- more -->\n\n这篇文章假设读者已经掌握 Laravel 的安装，若不了解请先移步 [文档](https://laravel.com/docs/5.6#installation) 。\n\n## 数据库\n\n### 迁移\n\n首先我们要建一个班级表和一个学生表。Laravel 提供了迁移（migration）功能用于创建和更新数据表。\n\n简单地说，我们把表结构用编程的方式写在文件中，然后执行这些文件，达到建表和更新表结构的目的。每个迁移文件都包含一个 `up` 方法和一个 `down` 方法，分别用于执行和回滚迁移。\n\n在 CLI 执行以下命令创建两张表的迁移文件：\n\n```\nphp artisan make:migration create_classes_table\nphp artisan make:migration create_students_table\n```\n\n此时可在 `database/migrations` 目录下找到新增的 2 个迁移文件。\n\n我们先来看看 `classes` 表的迁移文件，Laravel 已经帮我们写了一些代码。\n\n```php\nSchema::create('classes', function (Blueprint $table) {\n    $table->increments('id');  // 创建一个自增的 id 字段\n    $table->timestamps();      // 创建 created_at 和 updated_at 字段\n});\n```\n\n我增加了一个 ` name` 字段，用来保存班级名称。实际上，这句代码在数据库中创建的是一个 varchar 类型，最大长度 16 个字符的字段。\n\n```php\n$table->string('name', 16);\n```\n\n接下来编辑 students 表的迁移文件：\n\n```php\nSchema::create('students', function (Blueprint $table) {\n    $table->increments('id');\n    $table->string('number', 16);     // 学生编号\n    $table->string('name', 16);       // 学生姓名\n    $table->tinyInteger('class_id');  // 班级 ID\n    $table->timestamps();\n    $table->softDeletes();            // 创建 deleted_at 字段\n});\n```\n\n然后在 CLI 中执行 `php artisan migrate` 运行迁移，数据库中便创建了 `classes`、`students`、`migrations` 等表。\n\n`migrations` 表用于记录执行过哪些迁移。\n\n`created_at` 和 `updated_at` 字段分别用于存储创建时间和更新时间。当使用 Eloquent ORM 方式修改数据时，它们将自动更新。\n\n`deleted_at` 字段用于软删除数据，即记录不会真的从数据库中删除，而是存储一个删除时间，这些数据便不会再被查询出来。\n\n### 填充\n\n有时候我们希望给数据表批量写入一些数据。例如，在建完 `classes` 表后将已知的所有班级信息插入到表中。Laravel 提供了填充（seed）功能用于填充测试数据。\n\n在 CLI 执行以下命令创建一个填充器。\n\n```\nphp artisan make:seeder ClassesTableSeeder\n```\n\n编辑 `database/seeds` 目录下新增的 `ClassesTableSeeder.php` ，在 `run` 方法中插入代码：\n\n```php\nDB::table('classes')->insert(['name' => '三年一班']);\nDB::table('classes')->insert(['name' => '三年二班']);\nDB::table('classes')->insert(['name' => '三年三班']);\n```\n\n执行以下命令运行填充器：\n\n```\nphp artisan db:seed --class=ClassesTableSeeder\n```\n\n然后便可以在 classes 表中看见刚刚填充进去的 3 个班级。\n\n## 路由\n\nAPI 路由应该在 `route/api.php` 中声明，Route 类提供了 `get/post/patch/delete` 等路由方法用于定义不同类型的路由。\n\n我们先定义一个简单的路由：\n\n```php\nRoute::get('hello', function (Request $request) {\n    $name = $request->input('name');         // 获取请求参数\n    return \"Hello Laravel, I am {$name} !\";  // 响应字符串内容\n});\n```\n\n然后我们访问 `http://{你的域名}/api/hello?name=YIMING`，浏览器将显示：\n\n```\nHello Laravel, I am YIMING !\n```\n\n通过这个 Hello World 路由可以知道，路由方法的第一个参数是 URI ，第二个参数是一个 callback 。\n\nURI 中可以使用 `{}` 声明路由参数，并在回调函数中使用：\n\n```\nRoute::get('hello/{name}', function ($name) {\n    return \"Hello Laravel, I am {$name} !\";\n});\n```\n\n路由也可以指向某个控制器动作（方法）：\n\n```php\nRoute::get('students', 'StudentController@index');\nRoute::post('students', 'StudentController@store');\nRoute::get('students/{student}', 'StudentController@show');\nRoute::patch('students/{student}', 'StudentController@update');\nRoute::delete('students/{student}', 'StudentController@destory');\n```\n\n如果控制器是一个符合要求的 RESTful 资源控制器（见下文），上面这些路由等价于。\n\n```php\nRoute::resource('students', 'StudentController');\n```\n\n## 模型\n\nLaravel 提供了 Eloquent ORM（对象关系映射），一个模型对应一张数据表，通过模型类操作数据表。模型文件默认放在 `app` 目录下。 \n\n举个例子，假设存在 `User` 模型，那么它将默认对应数据库中的 `users` 表，我们可以这样查询数据：\n\n```php\nUser::where('id', 1)->get(); // 查询 id 等于1的用户\n```\n\n执行以下命令分别为班级表、学生表创建模型：\n\n```\nphp artisan make:model StudentClass\nphp artisan make:model Student\n```\n\n`Student` 模型默认对应 `students` 表。\n\n对于  `StudentClass` 模型，我们可以显式地声明它的关联表为 `classes` ：\n\n```php\nclass StudentClass extends Model\n{\n    protected $table = 'classes';\n}\n```\n\n然后编辑 `Student` 模型：\n\n```php\nnamespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Student extends Model\n{\n    // 启用软删除\n    use SoftDeletes;\n    // 可被批量赋值的字段\n    protected $fillable = [\n        'number',\n        'name',\n        'class_id'\n    ];\n    // 与班级表的关联关系\n    public function studentClass ()\n    {\n        return $this->hasOne('App\\StudentClass', 'id', 'class_id');\n    }\n}\n```\n\n## 控制器\n\n### 基础\n\n在路由小节中，我们注册了一个指向 `StudentController` 控制器的资源路由。\n\n```php\nRoute::resource('students', 'StudentController');\n```\n\n执行以下命令创建 `StudentController` 控制器：\n\n```\nphp artisan make:controller StudentController \n```\n\n由于 `StudentController` 是一个资源控制器，下列请求将自动指向相应控制器方法。\n\n| 请求方式 | URI                     | 控制器方法 | 操作     |\n| -------- | ----------------------- | ---------- | -------- |\n| GET      | /api/students           | index      | 查询全部 |\n| GET      | /api/students/{student} | show       | 查询单条 |\n| POST     | /api/students           | store      | 创建     |\n| PATCH    | /api/students/{student} | update     | 修改     |\n| DELETE   | /api/students/{student} | destroy    | 删除     |\n\n首先，在控制器中导入 Request、Validator 和 Student 模型：\n\n```\nuse Illuminate\\Http\\Request;\nuse Validator;\nuse App\\Student;\n```\n\n请求类（Request）用于获取参数，验证类（Validator）用于验证参数的合法性，Student 模型用于 `students` 表的增删改查操作。\n\n### 查询\n\n`index` 方法使用模型查询数据表，然后返回学生列表：\n\n```php\npublic function index ()\n{\n    // 查询全部记录\n    return Student::all();\n    // 查询三年一班的学生\n    return Student::where('class_id', '1')->get();\n    // 查询前两个班的学生\n    return Student::where('class_id', '<=', '2')->get();\n    // 包含软删除的记录\n    return Student::withTrashed()->get();\n    // 分页 每页15条记录\n    return Student::paginate(15);\n    // 同时查询关联数据\n    return Student::with('studentClass')->get();\n}\n```\n\n启用分页时，返回的结果中会包含页码、总页数等数据。\n\n在请求时传递  `page`  可以查询指定页码的数据，否则默认返回第一页。\n\n```\n/api/students?page=2\n```\n\n由于在 Student 模型中声明了和 StudentClass 模型（即班级表）的关联关系，我们可以使用 `with` 同时查出学生的班级信息。\n\n```js\n[{\n    number: '2018090201'\n    name: '张三'，\n    ...\n    studentClass: {\n        name: '三年一班',\n        ...\n    }\n}]\n```\n\n`show` 方法接收一个路由参数，返回指定 id 的学生：\n\n```php\npublic function show ($id)\n{\n    return Student::find($id);\n}\n```\n\n### 新增\n\n`store` 方法接收用户输入，验证参数的合法性，然后创建一名学生。这里不再赘述验证（Validation）功能的用法，感兴趣的同学可以移步官方文档了解。\n\n```php\npublic function store (Request $request)\n{\n    // 验证器\n    $validator = Validator::make($request->all(), [\n        // 必填，在 students 表中唯一，不多于10个字符。\n        'number' => 'required|unique:students|max:10',\n        // 必填，不多于8个字符。\n        'name' => 'required|max:8',\n        // 必填，只能是1、2或3。\n        'class_id' => 'required|in:1,2,3'\n    ]);\n\t// 当验证失败时响应 422 错误\n    if ($validator->fails()) {\n        return response($validator->errors(), 422);\n    }\n    return Student::create($request->all());\n}\n```\n\n### 修改\n\n`update` 方法接收用户输入和路由参数（学生 id），然后更新相应学生的信息。\n\n```php\npublic function update (Request $request, $id)\n{\n    Student::where('id', $id)->update($request->all());\n}\n```\n\n### 删除\n\n`destroy` 方法接收一个路由参数（学生 id），然后删除相应的学生。由于模型中启用了软删除，不会真的从数据表中删除记录，而是更新其 `deleted_at` 字段。\n\n```php\npublic function destory ($id)\n{\n    Student::destroy($id);\n}\n```\n\n## 最后\n\n你可以在 Postman 中调试一下这几个接口了，happy hacking ！\n\n相关链接：\n\n[Laravel 5.6 官方文档](https://laravel.com/docs/5.6)\n\n[Laravel 5.6 中文文档](https://laravelacademy.org/laravel-docs-5_6)\n\n[本文中的 demo 代码](https://github.com/ymcn/laravel-demo)\n\n\n\n相关环境：macOS 10.13 / Laravel Homestead / Laravel 5.6\n","source":"_posts/2018-09-02@Laravel 快速入门.md","raw":"---\ntitle: Laravel 快速入门\ndate: 2018-09-02 23:00:53\ncategories:\n  - Web Back-end\ntags:\n  - PHP\n  - Laravel\n---\n\n上周我在团队内做了 Laravel 入门分享，希望能够帮助对这款框架不熟悉的同学快速上手，最好听完就能撸个接口。作为前端小哥的我自知对后端了解有限，于是我事先写了个 demo，围绕一个假定的需求 —— 学生信息的增删改查来讲这堂课。\n\n<!-- more -->\n\n这篇文章假设读者已经掌握 Laravel 的安装，若不了解请先移步 [文档](https://laravel.com/docs/5.6#installation) 。\n\n## 数据库\n\n### 迁移\n\n首先我们要建一个班级表和一个学生表。Laravel 提供了迁移（migration）功能用于创建和更新数据表。\n\n简单地说，我们把表结构用编程的方式写在文件中，然后执行这些文件，达到建表和更新表结构的目的。每个迁移文件都包含一个 `up` 方法和一个 `down` 方法，分别用于执行和回滚迁移。\n\n在 CLI 执行以下命令创建两张表的迁移文件：\n\n```\nphp artisan make:migration create_classes_table\nphp artisan make:migration create_students_table\n```\n\n此时可在 `database/migrations` 目录下找到新增的 2 个迁移文件。\n\n我们先来看看 `classes` 表的迁移文件，Laravel 已经帮我们写了一些代码。\n\n```php\nSchema::create('classes', function (Blueprint $table) {\n    $table->increments('id');  // 创建一个自增的 id 字段\n    $table->timestamps();      // 创建 created_at 和 updated_at 字段\n});\n```\n\n我增加了一个 ` name` 字段，用来保存班级名称。实际上，这句代码在数据库中创建的是一个 varchar 类型，最大长度 16 个字符的字段。\n\n```php\n$table->string('name', 16);\n```\n\n接下来编辑 students 表的迁移文件：\n\n```php\nSchema::create('students', function (Blueprint $table) {\n    $table->increments('id');\n    $table->string('number', 16);     // 学生编号\n    $table->string('name', 16);       // 学生姓名\n    $table->tinyInteger('class_id');  // 班级 ID\n    $table->timestamps();\n    $table->softDeletes();            // 创建 deleted_at 字段\n});\n```\n\n然后在 CLI 中执行 `php artisan migrate` 运行迁移，数据库中便创建了 `classes`、`students`、`migrations` 等表。\n\n`migrations` 表用于记录执行过哪些迁移。\n\n`created_at` 和 `updated_at` 字段分别用于存储创建时间和更新时间。当使用 Eloquent ORM 方式修改数据时，它们将自动更新。\n\n`deleted_at` 字段用于软删除数据，即记录不会真的从数据库中删除，而是存储一个删除时间，这些数据便不会再被查询出来。\n\n### 填充\n\n有时候我们希望给数据表批量写入一些数据。例如，在建完 `classes` 表后将已知的所有班级信息插入到表中。Laravel 提供了填充（seed）功能用于填充测试数据。\n\n在 CLI 执行以下命令创建一个填充器。\n\n```\nphp artisan make:seeder ClassesTableSeeder\n```\n\n编辑 `database/seeds` 目录下新增的 `ClassesTableSeeder.php` ，在 `run` 方法中插入代码：\n\n```php\nDB::table('classes')->insert(['name' => '三年一班']);\nDB::table('classes')->insert(['name' => '三年二班']);\nDB::table('classes')->insert(['name' => '三年三班']);\n```\n\n执行以下命令运行填充器：\n\n```\nphp artisan db:seed --class=ClassesTableSeeder\n```\n\n然后便可以在 classes 表中看见刚刚填充进去的 3 个班级。\n\n## 路由\n\nAPI 路由应该在 `route/api.php` 中声明，Route 类提供了 `get/post/patch/delete` 等路由方法用于定义不同类型的路由。\n\n我们先定义一个简单的路由：\n\n```php\nRoute::get('hello', function (Request $request) {\n    $name = $request->input('name');         // 获取请求参数\n    return \"Hello Laravel, I am {$name} !\";  // 响应字符串内容\n});\n```\n\n然后我们访问 `http://{你的域名}/api/hello?name=YIMING`，浏览器将显示：\n\n```\nHello Laravel, I am YIMING !\n```\n\n通过这个 Hello World 路由可以知道，路由方法的第一个参数是 URI ，第二个参数是一个 callback 。\n\nURI 中可以使用 `{}` 声明路由参数，并在回调函数中使用：\n\n```\nRoute::get('hello/{name}', function ($name) {\n    return \"Hello Laravel, I am {$name} !\";\n});\n```\n\n路由也可以指向某个控制器动作（方法）：\n\n```php\nRoute::get('students', 'StudentController@index');\nRoute::post('students', 'StudentController@store');\nRoute::get('students/{student}', 'StudentController@show');\nRoute::patch('students/{student}', 'StudentController@update');\nRoute::delete('students/{student}', 'StudentController@destory');\n```\n\n如果控制器是一个符合要求的 RESTful 资源控制器（见下文），上面这些路由等价于。\n\n```php\nRoute::resource('students', 'StudentController');\n```\n\n## 模型\n\nLaravel 提供了 Eloquent ORM（对象关系映射），一个模型对应一张数据表，通过模型类操作数据表。模型文件默认放在 `app` 目录下。 \n\n举个例子，假设存在 `User` 模型，那么它将默认对应数据库中的 `users` 表，我们可以这样查询数据：\n\n```php\nUser::where('id', 1)->get(); // 查询 id 等于1的用户\n```\n\n执行以下命令分别为班级表、学生表创建模型：\n\n```\nphp artisan make:model StudentClass\nphp artisan make:model Student\n```\n\n`Student` 模型默认对应 `students` 表。\n\n对于  `StudentClass` 模型，我们可以显式地声明它的关联表为 `classes` ：\n\n```php\nclass StudentClass extends Model\n{\n    protected $table = 'classes';\n}\n```\n\n然后编辑 `Student` 模型：\n\n```php\nnamespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Student extends Model\n{\n    // 启用软删除\n    use SoftDeletes;\n    // 可被批量赋值的字段\n    protected $fillable = [\n        'number',\n        'name',\n        'class_id'\n    ];\n    // 与班级表的关联关系\n    public function studentClass ()\n    {\n        return $this->hasOne('App\\StudentClass', 'id', 'class_id');\n    }\n}\n```\n\n## 控制器\n\n### 基础\n\n在路由小节中，我们注册了一个指向 `StudentController` 控制器的资源路由。\n\n```php\nRoute::resource('students', 'StudentController');\n```\n\n执行以下命令创建 `StudentController` 控制器：\n\n```\nphp artisan make:controller StudentController \n```\n\n由于 `StudentController` 是一个资源控制器，下列请求将自动指向相应控制器方法。\n\n| 请求方式 | URI                     | 控制器方法 | 操作     |\n| -------- | ----------------------- | ---------- | -------- |\n| GET      | /api/students           | index      | 查询全部 |\n| GET      | /api/students/{student} | show       | 查询单条 |\n| POST     | /api/students           | store      | 创建     |\n| PATCH    | /api/students/{student} | update     | 修改     |\n| DELETE   | /api/students/{student} | destroy    | 删除     |\n\n首先，在控制器中导入 Request、Validator 和 Student 模型：\n\n```\nuse Illuminate\\Http\\Request;\nuse Validator;\nuse App\\Student;\n```\n\n请求类（Request）用于获取参数，验证类（Validator）用于验证参数的合法性，Student 模型用于 `students` 表的增删改查操作。\n\n### 查询\n\n`index` 方法使用模型查询数据表，然后返回学生列表：\n\n```php\npublic function index ()\n{\n    // 查询全部记录\n    return Student::all();\n    // 查询三年一班的学生\n    return Student::where('class_id', '1')->get();\n    // 查询前两个班的学生\n    return Student::where('class_id', '<=', '2')->get();\n    // 包含软删除的记录\n    return Student::withTrashed()->get();\n    // 分页 每页15条记录\n    return Student::paginate(15);\n    // 同时查询关联数据\n    return Student::with('studentClass')->get();\n}\n```\n\n启用分页时，返回的结果中会包含页码、总页数等数据。\n\n在请求时传递  `page`  可以查询指定页码的数据，否则默认返回第一页。\n\n```\n/api/students?page=2\n```\n\n由于在 Student 模型中声明了和 StudentClass 模型（即班级表）的关联关系，我们可以使用 `with` 同时查出学生的班级信息。\n\n```js\n[{\n    number: '2018090201'\n    name: '张三'，\n    ...\n    studentClass: {\n        name: '三年一班',\n        ...\n    }\n}]\n```\n\n`show` 方法接收一个路由参数，返回指定 id 的学生：\n\n```php\npublic function show ($id)\n{\n    return Student::find($id);\n}\n```\n\n### 新增\n\n`store` 方法接收用户输入，验证参数的合法性，然后创建一名学生。这里不再赘述验证（Validation）功能的用法，感兴趣的同学可以移步官方文档了解。\n\n```php\npublic function store (Request $request)\n{\n    // 验证器\n    $validator = Validator::make($request->all(), [\n        // 必填，在 students 表中唯一，不多于10个字符。\n        'number' => 'required|unique:students|max:10',\n        // 必填，不多于8个字符。\n        'name' => 'required|max:8',\n        // 必填，只能是1、2或3。\n        'class_id' => 'required|in:1,2,3'\n    ]);\n\t// 当验证失败时响应 422 错误\n    if ($validator->fails()) {\n        return response($validator->errors(), 422);\n    }\n    return Student::create($request->all());\n}\n```\n\n### 修改\n\n`update` 方法接收用户输入和路由参数（学生 id），然后更新相应学生的信息。\n\n```php\npublic function update (Request $request, $id)\n{\n    Student::where('id', $id)->update($request->all());\n}\n```\n\n### 删除\n\n`destroy` 方法接收一个路由参数（学生 id），然后删除相应的学生。由于模型中启用了软删除，不会真的从数据表中删除记录，而是更新其 `deleted_at` 字段。\n\n```php\npublic function destory ($id)\n{\n    Student::destroy($id);\n}\n```\n\n## 最后\n\n你可以在 Postman 中调试一下这几个接口了，happy hacking ！\n\n相关链接：\n\n[Laravel 5.6 官方文档](https://laravel.com/docs/5.6)\n\n[Laravel 5.6 中文文档](https://laravelacademy.org/laravel-docs-5_6)\n\n[本文中的 demo 代码](https://github.com/ymcn/laravel-demo)\n\n\n\n相关环境：macOS 10.13 / Laravel Homestead / Laravel 5.6\n","slug":"2018-09-02@Laravel 快速入门","published":1,"updated":"2020-06-29T03:32:42.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4bs00f0rqgjhh2bhede","content":"<p>上周我在团队内做了 Laravel 入门分享，希望能够帮助对这款框架不熟悉的同学快速上手，最好听完就能撸个接口。作为前端小哥的我自知对后端了解有限，于是我事先写了个 demo，围绕一个假定的需求 —— 学生信息的增删改查来讲这堂课。</p>\n<a id=\"more\"></a>\n\n<p>这篇文章假设读者已经掌握 Laravel 的安装，若不了解请先移步 <a href=\"https://laravel.com/docs/5.6#installation\" target=\"_blank\" rel=\"noopener\">文档</a> 。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"迁移\"><a href=\"#迁移\" class=\"headerlink\" title=\"迁移\"></a>迁移</h3><p>首先我们要建一个班级表和一个学生表。Laravel 提供了迁移（migration）功能用于创建和更新数据表。</p>\n<p>简单地说，我们把表结构用编程的方式写在文件中，然后执行这些文件，达到建表和更新表结构的目的。每个迁移文件都包含一个 <code>up</code> 方法和一个 <code>down</code> 方法，分别用于执行和回滚迁移。</p>\n<p>在 CLI 执行以下命令创建两张表的迁移文件：</p>\n<pre><code>php artisan make:migration create_classes_table\nphp artisan make:migration create_students_table</code></pre><p>此时可在 <code>database/migrations</code> 目录下找到新增的 2 个迁移文件。</p>\n<p>我们先来看看 <code>classes</code> 表的迁移文件，Laravel 已经帮我们写了一些代码。</p>\n<pre><code class=\"php\">Schema::create(&#39;classes&#39;, function (Blueprint $table) {\n    $table-&gt;increments(&#39;id&#39;);  // 创建一个自增的 id 字段\n    $table-&gt;timestamps();      // 创建 created_at 和 updated_at 字段\n});</code></pre>\n<p>我增加了一个 <code>name</code> 字段，用来保存班级名称。实际上，这句代码在数据库中创建的是一个 varchar 类型，最大长度 16 个字符的字段。</p>\n<pre><code class=\"php\">$table-&gt;string(&#39;name&#39;, 16);</code></pre>\n<p>接下来编辑 students 表的迁移文件：</p>\n<pre><code class=\"php\">Schema::create(&#39;students&#39;, function (Blueprint $table) {\n    $table-&gt;increments(&#39;id&#39;);\n    $table-&gt;string(&#39;number&#39;, 16);     // 学生编号\n    $table-&gt;string(&#39;name&#39;, 16);       // 学生姓名\n    $table-&gt;tinyInteger(&#39;class_id&#39;);  // 班级 ID\n    $table-&gt;timestamps();\n    $table-&gt;softDeletes();            // 创建 deleted_at 字段\n});</code></pre>\n<p>然后在 CLI 中执行 <code>php artisan migrate</code> 运行迁移，数据库中便创建了 <code>classes</code>、<code>students</code>、<code>migrations</code> 等表。</p>\n<p><code>migrations</code> 表用于记录执行过哪些迁移。</p>\n<p><code>created_at</code> 和 <code>updated_at</code> 字段分别用于存储创建时间和更新时间。当使用 Eloquent ORM 方式修改数据时，它们将自动更新。</p>\n<p><code>deleted_at</code> 字段用于软删除数据，即记录不会真的从数据库中删除，而是存储一个删除时间，这些数据便不会再被查询出来。</p>\n<h3 id=\"填充\"><a href=\"#填充\" class=\"headerlink\" title=\"填充\"></a>填充</h3><p>有时候我们希望给数据表批量写入一些数据。例如，在建完 <code>classes</code> 表后将已知的所有班级信息插入到表中。Laravel 提供了填充（seed）功能用于填充测试数据。</p>\n<p>在 CLI 执行以下命令创建一个填充器。</p>\n<pre><code>php artisan make:seeder ClassesTableSeeder</code></pre><p>编辑 <code>database/seeds</code> 目录下新增的 <code>ClassesTableSeeder.php</code> ，在 <code>run</code> 方法中插入代码：</p>\n<pre><code class=\"php\">DB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年一班&#39;]);\nDB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年二班&#39;]);\nDB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年三班&#39;]);</code></pre>\n<p>执行以下命令运行填充器：</p>\n<pre><code>php artisan db:seed --class=ClassesTableSeeder</code></pre><p>然后便可以在 classes 表中看见刚刚填充进去的 3 个班级。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>API 路由应该在 <code>route/api.php</code> 中声明，Route 类提供了 <code>get/post/patch/delete</code> 等路由方法用于定义不同类型的路由。</p>\n<p>我们先定义一个简单的路由：</p>\n<pre><code class=\"php\">Route::get(&#39;hello&#39;, function (Request $request) {\n    $name = $request-&gt;input(&#39;name&#39;);         // 获取请求参数\n    return &quot;Hello Laravel, I am {$name} !&quot;;  // 响应字符串内容\n});</code></pre>\n<p>然后我们访问 <code>http://{你的域名}/api/hello?name=YIMING</code>，浏览器将显示：</p>\n<pre><code>Hello Laravel, I am YIMING !</code></pre><p>通过这个 Hello World 路由可以知道，路由方法的第一个参数是 URI ，第二个参数是一个 callback 。</p>\n<p>URI 中可以使用 <code>{}</code> 声明路由参数，并在回调函数中使用：</p>\n<pre><code>Route::get(&#39;hello/{name}&#39;, function ($name) {\n    return &quot;Hello Laravel, I am {$name} !&quot;;\n});</code></pre><p>路由也可以指向某个控制器动作（方法）：</p>\n<pre><code class=\"php\">Route::get(&#39;students&#39;, &#39;StudentController@index&#39;);\nRoute::post(&#39;students&#39;, &#39;StudentController@store&#39;);\nRoute::get(&#39;students/{student}&#39;, &#39;StudentController@show&#39;);\nRoute::patch(&#39;students/{student}&#39;, &#39;StudentController@update&#39;);\nRoute::delete(&#39;students/{student}&#39;, &#39;StudentController@destory&#39;);</code></pre>\n<p>如果控制器是一个符合要求的 RESTful 资源控制器（见下文），上面这些路由等价于。</p>\n<pre><code class=\"php\">Route::resource(&#39;students&#39;, &#39;StudentController&#39;);</code></pre>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>Laravel 提供了 Eloquent ORM（对象关系映射），一个模型对应一张数据表，通过模型类操作数据表。模型文件默认放在 <code>app</code> 目录下。 </p>\n<p>举个例子，假设存在 <code>User</code> 模型，那么它将默认对应数据库中的 <code>users</code> 表，我们可以这样查询数据：</p>\n<pre><code class=\"php\">User::where(&#39;id&#39;, 1)-&gt;get(); // 查询 id 等于1的用户</code></pre>\n<p>执行以下命令分别为班级表、学生表创建模型：</p>\n<pre><code>php artisan make:model StudentClass\nphp artisan make:model Student</code></pre><p><code>Student</code> 模型默认对应 <code>students</code> 表。</p>\n<p>对于  <code>StudentClass</code> 模型，我们可以显式地声明它的关联表为 <code>classes</code> ：</p>\n<pre><code class=\"php\">class StudentClass extends Model\n{\n    protected $table = &#39;classes&#39;;\n}</code></pre>\n<p>然后编辑 <code>Student</code> 模型：</p>\n<pre><code class=\"php\">namespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Student extends Model\n{\n    // 启用软删除\n    use SoftDeletes;\n    // 可被批量赋值的字段\n    protected $fillable = [\n        &#39;number&#39;,\n        &#39;name&#39;,\n        &#39;class_id&#39;\n    ];\n    // 与班级表的关联关系\n    public function studentClass ()\n    {\n        return $this-&gt;hasOne(&#39;App\\StudentClass&#39;, &#39;id&#39;, &#39;class_id&#39;);\n    }\n}</code></pre>\n<h2 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>在路由小节中，我们注册了一个指向 <code>StudentController</code> 控制器的资源路由。</p>\n<pre><code class=\"php\">Route::resource(&#39;students&#39;, &#39;StudentController&#39;);</code></pre>\n<p>执行以下命令创建 <code>StudentController</code> 控制器：</p>\n<pre><code>php artisan make:controller StudentController </code></pre><p>由于 <code>StudentController</code> 是一个资源控制器，下列请求将自动指向相应控制器方法。</p>\n<table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>URI</th>\n<th>控制器方法</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>/api/students</td>\n<td>index</td>\n<td>查询全部</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>/api/students/{student}</td>\n<td>show</td>\n<td>查询单条</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>/api/students</td>\n<td>store</td>\n<td>创建</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>/api/students/{student}</td>\n<td>update</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>/api/students/{student}</td>\n<td>destroy</td>\n<td>删除</td>\n</tr>\n</tbody></table>\n<p>首先，在控制器中导入 Request、Validator 和 Student 模型：</p>\n<pre><code>use Illuminate\\Http\\Request;\nuse Validator;\nuse App\\Student;</code></pre><p>请求类（Request）用于获取参数，验证类（Validator）用于验证参数的合法性，Student 模型用于 <code>students</code> 表的增删改查操作。</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p><code>index</code> 方法使用模型查询数据表，然后返回学生列表：</p>\n<pre><code class=\"php\">public function index ()\n{\n    // 查询全部记录\n    return Student::all();\n    // 查询三年一班的学生\n    return Student::where(&#39;class_id&#39;, &#39;1&#39;)-&gt;get();\n    // 查询前两个班的学生\n    return Student::where(&#39;class_id&#39;, &#39;&lt;=&#39;, &#39;2&#39;)-&gt;get();\n    // 包含软删除的记录\n    return Student::withTrashed()-&gt;get();\n    // 分页 每页15条记录\n    return Student::paginate(15);\n    // 同时查询关联数据\n    return Student::with(&#39;studentClass&#39;)-&gt;get();\n}</code></pre>\n<p>启用分页时，返回的结果中会包含页码、总页数等数据。</p>\n<p>在请求时传递  <code>page</code>  可以查询指定页码的数据，否则默认返回第一页。</p>\n<pre><code>/api/students?page=2</code></pre><p>由于在 Student 模型中声明了和 StudentClass 模型（即班级表）的关联关系，我们可以使用 <code>with</code> 同时查出学生的班级信息。</p>\n<pre><code class=\"js\">[{\n    number: &#39;2018090201&#39;\n    name: &#39;张三&#39;，\n    ...\n    studentClass: {\n        name: &#39;三年一班&#39;,\n        ...\n    }\n}]</code></pre>\n<p><code>show</code> 方法接收一个路由参数，返回指定 id 的学生：</p>\n<pre><code class=\"php\">public function show ($id)\n{\n    return Student::find($id);\n}</code></pre>\n<h3 id=\"新增\"><a href=\"#新增\" class=\"headerlink\" title=\"新增\"></a>新增</h3><p><code>store</code> 方法接收用户输入，验证参数的合法性，然后创建一名学生。这里不再赘述验证（Validation）功能的用法，感兴趣的同学可以移步官方文档了解。</p>\n<pre><code class=\"php\">public function store (Request $request)\n{\n    // 验证器\n    $validator = Validator::make($request-&gt;all(), [\n        // 必填，在 students 表中唯一，不多于10个字符。\n        &#39;number&#39; =&gt; &#39;required|unique:students|max:10&#39;,\n        // 必填，不多于8个字符。\n        &#39;name&#39; =&gt; &#39;required|max:8&#39;,\n        // 必填，只能是1、2或3。\n        &#39;class_id&#39; =&gt; &#39;required|in:1,2,3&#39;\n    ]);\n    // 当验证失败时响应 422 错误\n    if ($validator-&gt;fails()) {\n        return response($validator-&gt;errors(), 422);\n    }\n    return Student::create($request-&gt;all());\n}</code></pre>\n<h3 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h3><p><code>update</code> 方法接收用户输入和路由参数（学生 id），然后更新相应学生的信息。</p>\n<pre><code class=\"php\">public function update (Request $request, $id)\n{\n    Student::where(&#39;id&#39;, $id)-&gt;update($request-&gt;all());\n}</code></pre>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p><code>destroy</code> 方法接收一个路由参数（学生 id），然后删除相应的学生。由于模型中启用了软删除，不会真的从数据表中删除记录，而是更新其 <code>deleted_at</code> 字段。</p>\n<pre><code class=\"php\">public function destory ($id)\n{\n    Student::destroy($id);\n}</code></pre>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>你可以在 Postman 中调试一下这几个接口了，happy hacking ！</p>\n<p>相关链接：</p>\n<p><a href=\"https://laravel.com/docs/5.6\" target=\"_blank\" rel=\"noopener\">Laravel 5.6 官方文档</a></p>\n<p><a href=\"https://laravelacademy.org/laravel-docs-5_6\" target=\"_blank\" rel=\"noopener\">Laravel 5.6 中文文档</a></p>\n<p><a href=\"https://github.com/ymcn/laravel-demo\" target=\"_blank\" rel=\"noopener\">本文中的 demo 代码</a></p>\n<p>相关环境：macOS 10.13 / Laravel Homestead / Laravel 5.6</p>\n","site":{"data":{}},"excerpt":"<p>上周我在团队内做了 Laravel 入门分享，希望能够帮助对这款框架不熟悉的同学快速上手，最好听完就能撸个接口。作为前端小哥的我自知对后端了解有限，于是我事先写了个 demo，围绕一个假定的需求 —— 学生信息的增删改查来讲这堂课。</p>","more":"<p>这篇文章假设读者已经掌握 Laravel 的安装，若不了解请先移步 <a href=\"https://laravel.com/docs/5.6#installation\" target=\"_blank\" rel=\"noopener\">文档</a> 。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"迁移\"><a href=\"#迁移\" class=\"headerlink\" title=\"迁移\"></a>迁移</h3><p>首先我们要建一个班级表和一个学生表。Laravel 提供了迁移（migration）功能用于创建和更新数据表。</p>\n<p>简单地说，我们把表结构用编程的方式写在文件中，然后执行这些文件，达到建表和更新表结构的目的。每个迁移文件都包含一个 <code>up</code> 方法和一个 <code>down</code> 方法，分别用于执行和回滚迁移。</p>\n<p>在 CLI 执行以下命令创建两张表的迁移文件：</p>\n<pre><code>php artisan make:migration create_classes_table\nphp artisan make:migration create_students_table</code></pre><p>此时可在 <code>database/migrations</code> 目录下找到新增的 2 个迁移文件。</p>\n<p>我们先来看看 <code>classes</code> 表的迁移文件，Laravel 已经帮我们写了一些代码。</p>\n<pre><code class=\"php\">Schema::create(&#39;classes&#39;, function (Blueprint $table) {\n    $table-&gt;increments(&#39;id&#39;);  // 创建一个自增的 id 字段\n    $table-&gt;timestamps();      // 创建 created_at 和 updated_at 字段\n});</code></pre>\n<p>我增加了一个 <code>name</code> 字段，用来保存班级名称。实际上，这句代码在数据库中创建的是一个 varchar 类型，最大长度 16 个字符的字段。</p>\n<pre><code class=\"php\">$table-&gt;string(&#39;name&#39;, 16);</code></pre>\n<p>接下来编辑 students 表的迁移文件：</p>\n<pre><code class=\"php\">Schema::create(&#39;students&#39;, function (Blueprint $table) {\n    $table-&gt;increments(&#39;id&#39;);\n    $table-&gt;string(&#39;number&#39;, 16);     // 学生编号\n    $table-&gt;string(&#39;name&#39;, 16);       // 学生姓名\n    $table-&gt;tinyInteger(&#39;class_id&#39;);  // 班级 ID\n    $table-&gt;timestamps();\n    $table-&gt;softDeletes();            // 创建 deleted_at 字段\n});</code></pre>\n<p>然后在 CLI 中执行 <code>php artisan migrate</code> 运行迁移，数据库中便创建了 <code>classes</code>、<code>students</code>、<code>migrations</code> 等表。</p>\n<p><code>migrations</code> 表用于记录执行过哪些迁移。</p>\n<p><code>created_at</code> 和 <code>updated_at</code> 字段分别用于存储创建时间和更新时间。当使用 Eloquent ORM 方式修改数据时，它们将自动更新。</p>\n<p><code>deleted_at</code> 字段用于软删除数据，即记录不会真的从数据库中删除，而是存储一个删除时间，这些数据便不会再被查询出来。</p>\n<h3 id=\"填充\"><a href=\"#填充\" class=\"headerlink\" title=\"填充\"></a>填充</h3><p>有时候我们希望给数据表批量写入一些数据。例如，在建完 <code>classes</code> 表后将已知的所有班级信息插入到表中。Laravel 提供了填充（seed）功能用于填充测试数据。</p>\n<p>在 CLI 执行以下命令创建一个填充器。</p>\n<pre><code>php artisan make:seeder ClassesTableSeeder</code></pre><p>编辑 <code>database/seeds</code> 目录下新增的 <code>ClassesTableSeeder.php</code> ，在 <code>run</code> 方法中插入代码：</p>\n<pre><code class=\"php\">DB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年一班&#39;]);\nDB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年二班&#39;]);\nDB::table(&#39;classes&#39;)-&gt;insert([&#39;name&#39; =&gt; &#39;三年三班&#39;]);</code></pre>\n<p>执行以下命令运行填充器：</p>\n<pre><code>php artisan db:seed --class=ClassesTableSeeder</code></pre><p>然后便可以在 classes 表中看见刚刚填充进去的 3 个班级。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>API 路由应该在 <code>route/api.php</code> 中声明，Route 类提供了 <code>get/post/patch/delete</code> 等路由方法用于定义不同类型的路由。</p>\n<p>我们先定义一个简单的路由：</p>\n<pre><code class=\"php\">Route::get(&#39;hello&#39;, function (Request $request) {\n    $name = $request-&gt;input(&#39;name&#39;);         // 获取请求参数\n    return &quot;Hello Laravel, I am {$name} !&quot;;  // 响应字符串内容\n});</code></pre>\n<p>然后我们访问 <code>http://{你的域名}/api/hello?name=YIMING</code>，浏览器将显示：</p>\n<pre><code>Hello Laravel, I am YIMING !</code></pre><p>通过这个 Hello World 路由可以知道，路由方法的第一个参数是 URI ，第二个参数是一个 callback 。</p>\n<p>URI 中可以使用 <code>{}</code> 声明路由参数，并在回调函数中使用：</p>\n<pre><code>Route::get(&#39;hello/{name}&#39;, function ($name) {\n    return &quot;Hello Laravel, I am {$name} !&quot;;\n});</code></pre><p>路由也可以指向某个控制器动作（方法）：</p>\n<pre><code class=\"php\">Route::get(&#39;students&#39;, &#39;StudentController@index&#39;);\nRoute::post(&#39;students&#39;, &#39;StudentController@store&#39;);\nRoute::get(&#39;students/{student}&#39;, &#39;StudentController@show&#39;);\nRoute::patch(&#39;students/{student}&#39;, &#39;StudentController@update&#39;);\nRoute::delete(&#39;students/{student}&#39;, &#39;StudentController@destory&#39;);</code></pre>\n<p>如果控制器是一个符合要求的 RESTful 资源控制器（见下文），上面这些路由等价于。</p>\n<pre><code class=\"php\">Route::resource(&#39;students&#39;, &#39;StudentController&#39;);</code></pre>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>Laravel 提供了 Eloquent ORM（对象关系映射），一个模型对应一张数据表，通过模型类操作数据表。模型文件默认放在 <code>app</code> 目录下。 </p>\n<p>举个例子，假设存在 <code>User</code> 模型，那么它将默认对应数据库中的 <code>users</code> 表，我们可以这样查询数据：</p>\n<pre><code class=\"php\">User::where(&#39;id&#39;, 1)-&gt;get(); // 查询 id 等于1的用户</code></pre>\n<p>执行以下命令分别为班级表、学生表创建模型：</p>\n<pre><code>php artisan make:model StudentClass\nphp artisan make:model Student</code></pre><p><code>Student</code> 模型默认对应 <code>students</code> 表。</p>\n<p>对于  <code>StudentClass</code> 模型，我们可以显式地声明它的关联表为 <code>classes</code> ：</p>\n<pre><code class=\"php\">class StudentClass extends Model\n{\n    protected $table = &#39;classes&#39;;\n}</code></pre>\n<p>然后编辑 <code>Student</code> 模型：</p>\n<pre><code class=\"php\">namespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Student extends Model\n{\n    // 启用软删除\n    use SoftDeletes;\n    // 可被批量赋值的字段\n    protected $fillable = [\n        &#39;number&#39;,\n        &#39;name&#39;,\n        &#39;class_id&#39;\n    ];\n    // 与班级表的关联关系\n    public function studentClass ()\n    {\n        return $this-&gt;hasOne(&#39;App\\StudentClass&#39;, &#39;id&#39;, &#39;class_id&#39;);\n    }\n}</code></pre>\n<h2 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>在路由小节中，我们注册了一个指向 <code>StudentController</code> 控制器的资源路由。</p>\n<pre><code class=\"php\">Route::resource(&#39;students&#39;, &#39;StudentController&#39;);</code></pre>\n<p>执行以下命令创建 <code>StudentController</code> 控制器：</p>\n<pre><code>php artisan make:controller StudentController </code></pre><p>由于 <code>StudentController</code> 是一个资源控制器，下列请求将自动指向相应控制器方法。</p>\n<table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>URI</th>\n<th>控制器方法</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>/api/students</td>\n<td>index</td>\n<td>查询全部</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>/api/students/{student}</td>\n<td>show</td>\n<td>查询单条</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>/api/students</td>\n<td>store</td>\n<td>创建</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>/api/students/{student}</td>\n<td>update</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>/api/students/{student}</td>\n<td>destroy</td>\n<td>删除</td>\n</tr>\n</tbody></table>\n<p>首先，在控制器中导入 Request、Validator 和 Student 模型：</p>\n<pre><code>use Illuminate\\Http\\Request;\nuse Validator;\nuse App\\Student;</code></pre><p>请求类（Request）用于获取参数，验证类（Validator）用于验证参数的合法性，Student 模型用于 <code>students</code> 表的增删改查操作。</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p><code>index</code> 方法使用模型查询数据表，然后返回学生列表：</p>\n<pre><code class=\"php\">public function index ()\n{\n    // 查询全部记录\n    return Student::all();\n    // 查询三年一班的学生\n    return Student::where(&#39;class_id&#39;, &#39;1&#39;)-&gt;get();\n    // 查询前两个班的学生\n    return Student::where(&#39;class_id&#39;, &#39;&lt;=&#39;, &#39;2&#39;)-&gt;get();\n    // 包含软删除的记录\n    return Student::withTrashed()-&gt;get();\n    // 分页 每页15条记录\n    return Student::paginate(15);\n    // 同时查询关联数据\n    return Student::with(&#39;studentClass&#39;)-&gt;get();\n}</code></pre>\n<p>启用分页时，返回的结果中会包含页码、总页数等数据。</p>\n<p>在请求时传递  <code>page</code>  可以查询指定页码的数据，否则默认返回第一页。</p>\n<pre><code>/api/students?page=2</code></pre><p>由于在 Student 模型中声明了和 StudentClass 模型（即班级表）的关联关系，我们可以使用 <code>with</code> 同时查出学生的班级信息。</p>\n<pre><code class=\"js\">[{\n    number: &#39;2018090201&#39;\n    name: &#39;张三&#39;，\n    ...\n    studentClass: {\n        name: &#39;三年一班&#39;,\n        ...\n    }\n}]</code></pre>\n<p><code>show</code> 方法接收一个路由参数，返回指定 id 的学生：</p>\n<pre><code class=\"php\">public function show ($id)\n{\n    return Student::find($id);\n}</code></pre>\n<h3 id=\"新增\"><a href=\"#新增\" class=\"headerlink\" title=\"新增\"></a>新增</h3><p><code>store</code> 方法接收用户输入，验证参数的合法性，然后创建一名学生。这里不再赘述验证（Validation）功能的用法，感兴趣的同学可以移步官方文档了解。</p>\n<pre><code class=\"php\">public function store (Request $request)\n{\n    // 验证器\n    $validator = Validator::make($request-&gt;all(), [\n        // 必填，在 students 表中唯一，不多于10个字符。\n        &#39;number&#39; =&gt; &#39;required|unique:students|max:10&#39;,\n        // 必填，不多于8个字符。\n        &#39;name&#39; =&gt; &#39;required|max:8&#39;,\n        // 必填，只能是1、2或3。\n        &#39;class_id&#39; =&gt; &#39;required|in:1,2,3&#39;\n    ]);\n    // 当验证失败时响应 422 错误\n    if ($validator-&gt;fails()) {\n        return response($validator-&gt;errors(), 422);\n    }\n    return Student::create($request-&gt;all());\n}</code></pre>\n<h3 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h3><p><code>update</code> 方法接收用户输入和路由参数（学生 id），然后更新相应学生的信息。</p>\n<pre><code class=\"php\">public function update (Request $request, $id)\n{\n    Student::where(&#39;id&#39;, $id)-&gt;update($request-&gt;all());\n}</code></pre>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p><code>destroy</code> 方法接收一个路由参数（学生 id），然后删除相应的学生。由于模型中启用了软删除，不会真的从数据表中删除记录，而是更新其 <code>deleted_at</code> 字段。</p>\n<pre><code class=\"php\">public function destory ($id)\n{\n    Student::destroy($id);\n}</code></pre>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>你可以在 Postman 中调试一下这几个接口了，happy hacking ！</p>\n<p>相关链接：</p>\n<p><a href=\"https://laravel.com/docs/5.6\" target=\"_blank\" rel=\"noopener\">Laravel 5.6 官方文档</a></p>\n<p><a href=\"https://laravelacademy.org/laravel-docs-5_6\" target=\"_blank\" rel=\"noopener\">Laravel 5.6 中文文档</a></p>\n<p><a href=\"https://github.com/ymcn/laravel-demo\" target=\"_blank\" rel=\"noopener\">本文中的 demo 代码</a></p>\n<p>相关环境：macOS 10.13 / Laravel Homestead / Laravel 5.6</p>"},{"title":"PixiJS 实战万圣节主题横版 H5","date":"2018-11-11T13:50:00.000Z","_content":"\n上个月初我们准备了一期万圣节主题 H5 用于推广 APP 的拍照效果，10月24日上线，截止万圣节当天共 560 万 PV。对我个人比较有纪念意义的是，它算是我的第一个真正意义上的百万级 PV H5，也是我第一次用 2D 渲染引擎。虽然开发的时候遇到不少问题，但解锁挑战的过程非常有趣。\n\n<!-- more -->\n\n{% img round /images/posts/2018/11/pixi_practice_preview.gif 650 前端实现（有损压缩） %}\n\n## 准备工作\n\n在动手之前，我先了解了几款 HTML5 2D 动画引擎，包括 PixiJS、Fabric.js、Paper.js、EaselJS、Collie 。我需要一款易上手、可靠、高性能的渲染引擎，最终选择了 PixiJS 。\n\n因为它：\n\n- GitHub 20k+ Star，广泛的用户基础意味着问题更容易找到答案。\n- 仍在不断更新，示例代码使用了 ES6 语法。\n- 文档及示例友好，还有一篇质量不错的 [官方教程中文版](https://github.com/Zainking/learningPixi) 可供入门。\n- 追求性能，官网称它在 2D 渲染上无人望其项背。\n\n由于笔者的项目面向海外市场，需要照顾可能在一些发展中国家占主流的中低端机用户，加上之前的 H5 已经有在中低端机上表现欠佳的经历，所以性能因素非常影响我的选择。\n\n在着手实现之前，先来了解一下设计输出的视觉稿：\n\n{% img round /images/posts/2018/11/pixi_practice_design.jpg 650 视觉稿 %}\n\n视觉稿中的图2至图6就是我们要用 PixiJS 实现的场景。设计师希望以类似“一键到底”的效果呈现，用户左右滑动屏幕在“主题馆”之间切换，然后点击入口点按钮进入其他页面浏览更多内容。\n\n动画部分需要实现：招牌霓虹闪烁，浏览到图5位置时月亮缓慢升起，图5和图6建筑后方烟雾扩散，蝙蝠和女巫上下漂浮等。\n\n## 切图与布局\n\n在开始切图之前，必须先结合动画需求把内容分层。在这个案例中，动画需求直接影响了内容是否能够合并成一张图片呈现，也影响了切图阶段的工作量。一张静态背景图显然是无法让月亮动起来的。\n\n于是我把内容拆分成了8层：\n\n{% img /images/posts/2018/11/pixi_practice_layers.jpg 650 内容分层 %}\n\nL6-8 组成背景部分：纯色矩形叠加星星素材组成“星空”，然后是月亮，最上面是背景建筑群。L3-5 组成中景部分：主题馆建筑后面有两片正在扩散的烟雾，前面是不断闪烁的霓虹招牌。L1-2 组成前景部分：贯穿整个场景的马路旁立着路灯，左侧近处有一栋建筑，蝙蝠和女巫上下漂浮。\n\n用切图工具把每一层中相对独立的内容切成图片。我用的是 [Cutterman](http://www.cutterman.cn/zh/cutterman)，使用 @2X 分辨率 。霓虹招牌比较特殊，需要按照动画的关键帧切图。加上要做5种语言版本，每个招牌最终切出了 10-30 张图片。由于招牌的关键帧内容有所不同，切图工具自动选择的区域可能存在误差，导致动画效果不协调，所以切图时必须手动选择区域。\n\n倒序地把每一层内容绘制到画布上就得到了完整的静态场景。为了适配不同屏幕尺寸，我用浏览器可视区域的高度作为参考来设置内容的尺寸和位置。\n\n下一步便是实现动画。\n\n## 关键帧动画\n\n关键帧动画适用于精灵需要有规律地改变外观的场景。以用户看到的第一个霓虹招牌为例，每个语言切出6张关键帧图片，然后以预先编排好的顺序播放就能实现闪烁效果。其他招牌同理。\n\n{% img /images/posts/2018/11/pixi_practice_animated_sprite.jpg 540 主标题招牌关键帧 %}\n\n\n\n在 PixiJS 中使用 `AnimatedSprite` 创建关键帧动画：\n\n``` js\nconst sprite = new PIXI.extras.AnimatedSprite([\n  PIXI.loader.resources[require('@img/frame_1.png')].texture,\n  PIXI.loader.resources[require('@img/frame_2.png')].texture,\n  ...\n])\nsprite.animationSpeed = 0.2\nsprite.play()\n```\n`AnimatedSprite` 类的构造方法接收一个由关键帧图片转化成的纹理组成的数组。纹理是指可以被 GPU 处理的图片。PixiJS 默认使用 WebGL 和 GPU 渲染，所以图片都需要转换成纹理。`animationSpeed` 用于控制动画的播放速度。\n\n## 游戏循环动画\n\n游戏循环动画适用于精灵需要匀速改变尺寸、位置或角度的场景。PixiJS 提供了 `ticker` 用于添加游戏循环动画，游戏循环中的代码每秒将被执行60次。\n\n{% img round /images/posts/2018/11/pixi_practice_candy_house_sign.gif 280 糖果屋招牌 %}\n\n以“糖果屋”招牌上旋转的蛋糕和糖果为例，添加每次转动 0.02 弧度的游戏循环动画：\n\n``` js\napp.ticker.add(delta => {\n  cake.rotation -= 0.02 * delta   // 逆时针旋转\n  candy.rotation += 0.02 * delta  // 顺时针旋转\n})\n```\n\n然后，蛋糕和糖果将每 1/60 秒转动 0.02 弧度。 `delta` 表示帧延迟率，根据延迟率改变转动的弧度数，能够缓解老旧设备上的卡顿感。`ticker` 适合用来实现循环的匀速的动画。\n\n## 辅助动画库\n\n游戏循环动画已经足够处理一些简单的动画逻辑，但是如果我们想要给动画加上条件判断或者是舒适的过渡效果，它就显得不那么顺手了。于是我在项目中同时引入了 [Anime](http://animejs.com/) 动画库，辅助实现一部分动画。其中就包括月亮升起的动画：\n\n``` js\nanime({\n  targets: sprite,\n  y: 0,                  // 垂直位置变为0\n  round: 1,              // 平滑移动\n  duration: 1000,        // 过渡持续1秒\n  easing: 'easeOutQuad'  // 以慢速结束的过渡效果\n})\n```\n\n烟雾扩散动画同样使用 Anime 实现，实际上是逐渐放大、透明。在应用了 Anime 的过渡效果后，用户滑动屏幕时画面的滚动也变得更加平滑。它的加入不仅使动画更易实现，而且提高了动画质量。\n\n## 交互\n\n场景的触摸滑动是通过舞台的触摸事件： `touchstart` 、`touchmove` 和 `touchend` 实现的。如果说用户的视角是一台摄像机，那么我要做的不是转动它，而是移动整幅画面。\n\n首先，计算出 5 个焦点区域的舞台位置：\n\n{% img round /images/posts/2018/11/pixi_practice_camera.jpg 650 舞台位置的变化 %}\n\n`x` 表示舞台的水平位置 `stage.x` ，`w` 和 `h` 分别表示浏览器可视区域的宽和高。\n\n在用户向左滑动屏幕的过程中，不断让舞台的水平位置向左移动（用户手指移动的距离），就可以产生滑动跟手的效果。在用户结束触摸后，根据滑动方向继续移动舞台，使下一个焦点区域显示在屏幕上。\n\n``` js\n// 启用舞台交互\nthis.app.stage.interactive = true\nthis.app.stage.on('touchstart', event => {\n  // 监听触摸开始，在这里保存起始点坐标。\n})\nthis.app.stage.on('touchmove', event => {\n  // 监听手指移动，在这里判断滑动方向，制造跟手效果。\n})\nthis.app.stage.on('touchend', event => {\n  // 监听触摸结束，在这里判断滑动方向，平滑移动舞台到下一个焦点。\n})\n```\n\n主题馆入口点按钮的点击是通过 `tap` 事件实现的：\n\n``` js\n// 启用精灵交互\nentrance.interactive = true\nentrance.on('tap', () => {\n  // 在这里路由到下一个页面\n})\n```\n\n## 加载\n\n由于使用的图片资源很多，必须在渲染之前确保所有图片加载完毕，避免用户看到的不完整的场景。\n\nPixiJS 提供了 `loader` 用于加载资源：\n\n``` js\nPIXI.loader.add([\n  require('@img/image_1.png'),\n  ...\n]).on('progress', (loader) => {\n  // 更新加载进度\n  this.progress = parseInt(loader.progress)\n}).load(() => {\n  // 加载完毕\n  // 在这里结束 Loading\n})\n```\n\n## 优化\n\n1\\. 图片当然都是经过压缩的。权衡了设计师对画质的追求，最后我把首屏加载的图片量控制在 1.4mb 。\n\n2\\. PixiJS 默认使用的 WebGL 渲染能够提供更好的性能，但是一些老旧设备并不支持。比如在一台 Android 4.4 测试机上，我们发现了画面持续闪烁的现象。这个问题在强制使用 Canvas 渲染模式后得到解决，并且动画性能也没有明显下降。\n\n``` js\nnew PIXI.Application({ forceCanvas: true })\n```\n\n3\\. PixiJS 支持使用图片中的一块区域作为精灵的材质。为了减少请求数，同时避免小概率的图片加载失败，我曾尝试将图片素材合成一两张大的雪碧图。测试后发现性能明显下降，最终放弃。\n\n4\\. 为了提高清晰度和消除锯齿，我是用浏览器可视区域两倍的尺寸渲染，然后把 Canvas 缩放到 1/2 。\n","source":"_posts/2018-10-10@PixiJS 实战万圣节主题横版 H5.md","raw":"---\ntitle: PixiJS 实战万圣节主题横版 H5\ndate: 2018-11-11 21:50:00\ncategories:\n  - Web Front-end\ntags:\n  - PixiJS\n  - WebGL\n  - Canvas\n  - 2D\n  - anime.js\n  - H5\n---\n\n上个月初我们准备了一期万圣节主题 H5 用于推广 APP 的拍照效果，10月24日上线，截止万圣节当天共 560 万 PV。对我个人比较有纪念意义的是，它算是我的第一个真正意义上的百万级 PV H5，也是我第一次用 2D 渲染引擎。虽然开发的时候遇到不少问题，但解锁挑战的过程非常有趣。\n\n<!-- more -->\n\n{% img round /images/posts/2018/11/pixi_practice_preview.gif 650 前端实现（有损压缩） %}\n\n## 准备工作\n\n在动手之前，我先了解了几款 HTML5 2D 动画引擎，包括 PixiJS、Fabric.js、Paper.js、EaselJS、Collie 。我需要一款易上手、可靠、高性能的渲染引擎，最终选择了 PixiJS 。\n\n因为它：\n\n- GitHub 20k+ Star，广泛的用户基础意味着问题更容易找到答案。\n- 仍在不断更新，示例代码使用了 ES6 语法。\n- 文档及示例友好，还有一篇质量不错的 [官方教程中文版](https://github.com/Zainking/learningPixi) 可供入门。\n- 追求性能，官网称它在 2D 渲染上无人望其项背。\n\n由于笔者的项目面向海外市场，需要照顾可能在一些发展中国家占主流的中低端机用户，加上之前的 H5 已经有在中低端机上表现欠佳的经历，所以性能因素非常影响我的选择。\n\n在着手实现之前，先来了解一下设计输出的视觉稿：\n\n{% img round /images/posts/2018/11/pixi_practice_design.jpg 650 视觉稿 %}\n\n视觉稿中的图2至图6就是我们要用 PixiJS 实现的场景。设计师希望以类似“一键到底”的效果呈现，用户左右滑动屏幕在“主题馆”之间切换，然后点击入口点按钮进入其他页面浏览更多内容。\n\n动画部分需要实现：招牌霓虹闪烁，浏览到图5位置时月亮缓慢升起，图5和图6建筑后方烟雾扩散，蝙蝠和女巫上下漂浮等。\n\n## 切图与布局\n\n在开始切图之前，必须先结合动画需求把内容分层。在这个案例中，动画需求直接影响了内容是否能够合并成一张图片呈现，也影响了切图阶段的工作量。一张静态背景图显然是无法让月亮动起来的。\n\n于是我把内容拆分成了8层：\n\n{% img /images/posts/2018/11/pixi_practice_layers.jpg 650 内容分层 %}\n\nL6-8 组成背景部分：纯色矩形叠加星星素材组成“星空”，然后是月亮，最上面是背景建筑群。L3-5 组成中景部分：主题馆建筑后面有两片正在扩散的烟雾，前面是不断闪烁的霓虹招牌。L1-2 组成前景部分：贯穿整个场景的马路旁立着路灯，左侧近处有一栋建筑，蝙蝠和女巫上下漂浮。\n\n用切图工具把每一层中相对独立的内容切成图片。我用的是 [Cutterman](http://www.cutterman.cn/zh/cutterman)，使用 @2X 分辨率 。霓虹招牌比较特殊，需要按照动画的关键帧切图。加上要做5种语言版本，每个招牌最终切出了 10-30 张图片。由于招牌的关键帧内容有所不同，切图工具自动选择的区域可能存在误差，导致动画效果不协调，所以切图时必须手动选择区域。\n\n倒序地把每一层内容绘制到画布上就得到了完整的静态场景。为了适配不同屏幕尺寸，我用浏览器可视区域的高度作为参考来设置内容的尺寸和位置。\n\n下一步便是实现动画。\n\n## 关键帧动画\n\n关键帧动画适用于精灵需要有规律地改变外观的场景。以用户看到的第一个霓虹招牌为例，每个语言切出6张关键帧图片，然后以预先编排好的顺序播放就能实现闪烁效果。其他招牌同理。\n\n{% img /images/posts/2018/11/pixi_practice_animated_sprite.jpg 540 主标题招牌关键帧 %}\n\n\n\n在 PixiJS 中使用 `AnimatedSprite` 创建关键帧动画：\n\n``` js\nconst sprite = new PIXI.extras.AnimatedSprite([\n  PIXI.loader.resources[require('@img/frame_1.png')].texture,\n  PIXI.loader.resources[require('@img/frame_2.png')].texture,\n  ...\n])\nsprite.animationSpeed = 0.2\nsprite.play()\n```\n`AnimatedSprite` 类的构造方法接收一个由关键帧图片转化成的纹理组成的数组。纹理是指可以被 GPU 处理的图片。PixiJS 默认使用 WebGL 和 GPU 渲染，所以图片都需要转换成纹理。`animationSpeed` 用于控制动画的播放速度。\n\n## 游戏循环动画\n\n游戏循环动画适用于精灵需要匀速改变尺寸、位置或角度的场景。PixiJS 提供了 `ticker` 用于添加游戏循环动画，游戏循环中的代码每秒将被执行60次。\n\n{% img round /images/posts/2018/11/pixi_practice_candy_house_sign.gif 280 糖果屋招牌 %}\n\n以“糖果屋”招牌上旋转的蛋糕和糖果为例，添加每次转动 0.02 弧度的游戏循环动画：\n\n``` js\napp.ticker.add(delta => {\n  cake.rotation -= 0.02 * delta   // 逆时针旋转\n  candy.rotation += 0.02 * delta  // 顺时针旋转\n})\n```\n\n然后，蛋糕和糖果将每 1/60 秒转动 0.02 弧度。 `delta` 表示帧延迟率，根据延迟率改变转动的弧度数，能够缓解老旧设备上的卡顿感。`ticker` 适合用来实现循环的匀速的动画。\n\n## 辅助动画库\n\n游戏循环动画已经足够处理一些简单的动画逻辑，但是如果我们想要给动画加上条件判断或者是舒适的过渡效果，它就显得不那么顺手了。于是我在项目中同时引入了 [Anime](http://animejs.com/) 动画库，辅助实现一部分动画。其中就包括月亮升起的动画：\n\n``` js\nanime({\n  targets: sprite,\n  y: 0,                  // 垂直位置变为0\n  round: 1,              // 平滑移动\n  duration: 1000,        // 过渡持续1秒\n  easing: 'easeOutQuad'  // 以慢速结束的过渡效果\n})\n```\n\n烟雾扩散动画同样使用 Anime 实现，实际上是逐渐放大、透明。在应用了 Anime 的过渡效果后，用户滑动屏幕时画面的滚动也变得更加平滑。它的加入不仅使动画更易实现，而且提高了动画质量。\n\n## 交互\n\n场景的触摸滑动是通过舞台的触摸事件： `touchstart` 、`touchmove` 和 `touchend` 实现的。如果说用户的视角是一台摄像机，那么我要做的不是转动它，而是移动整幅画面。\n\n首先，计算出 5 个焦点区域的舞台位置：\n\n{% img round /images/posts/2018/11/pixi_practice_camera.jpg 650 舞台位置的变化 %}\n\n`x` 表示舞台的水平位置 `stage.x` ，`w` 和 `h` 分别表示浏览器可视区域的宽和高。\n\n在用户向左滑动屏幕的过程中，不断让舞台的水平位置向左移动（用户手指移动的距离），就可以产生滑动跟手的效果。在用户结束触摸后，根据滑动方向继续移动舞台，使下一个焦点区域显示在屏幕上。\n\n``` js\n// 启用舞台交互\nthis.app.stage.interactive = true\nthis.app.stage.on('touchstart', event => {\n  // 监听触摸开始，在这里保存起始点坐标。\n})\nthis.app.stage.on('touchmove', event => {\n  // 监听手指移动，在这里判断滑动方向，制造跟手效果。\n})\nthis.app.stage.on('touchend', event => {\n  // 监听触摸结束，在这里判断滑动方向，平滑移动舞台到下一个焦点。\n})\n```\n\n主题馆入口点按钮的点击是通过 `tap` 事件实现的：\n\n``` js\n// 启用精灵交互\nentrance.interactive = true\nentrance.on('tap', () => {\n  // 在这里路由到下一个页面\n})\n```\n\n## 加载\n\n由于使用的图片资源很多，必须在渲染之前确保所有图片加载完毕，避免用户看到的不完整的场景。\n\nPixiJS 提供了 `loader` 用于加载资源：\n\n``` js\nPIXI.loader.add([\n  require('@img/image_1.png'),\n  ...\n]).on('progress', (loader) => {\n  // 更新加载进度\n  this.progress = parseInt(loader.progress)\n}).load(() => {\n  // 加载完毕\n  // 在这里结束 Loading\n})\n```\n\n## 优化\n\n1\\. 图片当然都是经过压缩的。权衡了设计师对画质的追求，最后我把首屏加载的图片量控制在 1.4mb 。\n\n2\\. PixiJS 默认使用的 WebGL 渲染能够提供更好的性能，但是一些老旧设备并不支持。比如在一台 Android 4.4 测试机上，我们发现了画面持续闪烁的现象。这个问题在强制使用 Canvas 渲染模式后得到解决，并且动画性能也没有明显下降。\n\n``` js\nnew PIXI.Application({ forceCanvas: true })\n```\n\n3\\. PixiJS 支持使用图片中的一块区域作为精灵的材质。为了减少请求数，同时避免小概率的图片加载失败，我曾尝试将图片素材合成一两张大的雪碧图。测试后发现性能明显下降，最终放弃。\n\n4\\. 为了提高清晰度和消除锯齿，我是用浏览器可视区域两倍的尺寸渲染，然后把 Canvas 缩放到 1/2 。\n","slug":"2018-10-10@PixiJS 实战万圣节主题横版 H5","published":1,"updated":"2020-06-30T02:55:09.836Z","_id":"ckc1bt4bt00f2rqgjebu05zxe","comments":1,"layout":"post","photos":[],"link":"","content":"<p>上个月初我们准备了一期万圣节主题 H5 用于推广 APP 的拍照效果，10月24日上线，截止万圣节当天共 560 万 PV。对我个人比较有纪念意义的是，它算是我的第一个真正意义上的百万级 PV H5，也是我第一次用 2D 渲染引擎。虽然开发的时候遇到不少问题，但解锁挑战的过程非常有趣。</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/posts/2018/11/pixi_practice_preview.gif\" class=\"round\" width=\"650\" title=\"前端实现（有损压缩）\">\n\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>在动手之前，我先了解了几款 HTML5 2D 动画引擎，包括 PixiJS、Fabric.js、Paper.js、EaselJS、Collie 。我需要一款易上手、可靠、高性能的渲染引擎，最终选择了 PixiJS 。</p>\n<p>因为它：</p>\n<ul>\n<li>GitHub 20k+ Star，广泛的用户基础意味着问题更容易找到答案。</li>\n<li>仍在不断更新，示例代码使用了 ES6 语法。</li>\n<li>文档及示例友好，还有一篇质量不错的 <a href=\"https://github.com/Zainking/learningPixi\" target=\"_blank\" rel=\"noopener\">官方教程中文版</a> 可供入门。</li>\n<li>追求性能，官网称它在 2D 渲染上无人望其项背。</li>\n</ul>\n<p>由于笔者的项目面向海外市场，需要照顾可能在一些发展中国家占主流的中低端机用户，加上之前的 H5 已经有在中低端机上表现欠佳的经历，所以性能因素非常影响我的选择。</p>\n<p>在着手实现之前，先来了解一下设计输出的视觉稿：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_design.jpg\" class=\"round\" width=\"650\" title=\"视觉稿\">\n\n<p>视觉稿中的图2至图6就是我们要用 PixiJS 实现的场景。设计师希望以类似“一键到底”的效果呈现，用户左右滑动屏幕在“主题馆”之间切换，然后点击入口点按钮进入其他页面浏览更多内容。</p>\n<p>动画部分需要实现：招牌霓虹闪烁，浏览到图5位置时月亮缓慢升起，图5和图6建筑后方烟雾扩散，蝙蝠和女巫上下漂浮等。</p>\n<h2 id=\"切图与布局\"><a href=\"#切图与布局\" class=\"headerlink\" title=\"切图与布局\"></a>切图与布局</h2><p>在开始切图之前，必须先结合动画需求把内容分层。在这个案例中，动画需求直接影响了内容是否能够合并成一张图片呈现，也影响了切图阶段的工作量。一张静态背景图显然是无法让月亮动起来的。</p>\n<p>于是我把内容拆分成了8层：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_layers.jpg\" class=\"\" width=\"650\" title=\"内容分层\">\n\n<p>L6-8 组成背景部分：纯色矩形叠加星星素材组成“星空”，然后是月亮，最上面是背景建筑群。L3-5 组成中景部分：主题馆建筑后面有两片正在扩散的烟雾，前面是不断闪烁的霓虹招牌。L1-2 组成前景部分：贯穿整个场景的马路旁立着路灯，左侧近处有一栋建筑，蝙蝠和女巫上下漂浮。</p>\n<p>用切图工具把每一层中相对独立的内容切成图片。我用的是 <a href=\"http://www.cutterman.cn/zh/cutterman\" target=\"_blank\" rel=\"noopener\">Cutterman</a>，使用 @2X 分辨率 。霓虹招牌比较特殊，需要按照动画的关键帧切图。加上要做5种语言版本，每个招牌最终切出了 10-30 张图片。由于招牌的关键帧内容有所不同，切图工具自动选择的区域可能存在误差，导致动画效果不协调，所以切图时必须手动选择区域。</p>\n<p>倒序地把每一层内容绘制到画布上就得到了完整的静态场景。为了适配不同屏幕尺寸，我用浏览器可视区域的高度作为参考来设置内容的尺寸和位置。</p>\n<p>下一步便是实现动画。</p>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><p>关键帧动画适用于精灵需要有规律地改变外观的场景。以用户看到的第一个霓虹招牌为例，每个语言切出6张关键帧图片，然后以预先编排好的顺序播放就能实现闪烁效果。其他招牌同理。</p>\n<img src=\"/images/posts/2018/11/pixi_practice_animated_sprite.jpg\" class=\"\" width=\"540\" title=\"主标题招牌关键帧\">\n\n\n\n<p>在 PixiJS 中使用 <code>AnimatedSprite</code> 创建关键帧动画：</p>\n<pre><code class=\"js\">const sprite = new PIXI.extras.AnimatedSprite([\n  PIXI.loader.resources[require(&#39;@img/frame_1.png&#39;)].texture,\n  PIXI.loader.resources[require(&#39;@img/frame_2.png&#39;)].texture,\n  ...\n])\nsprite.animationSpeed = 0.2\nsprite.play()</code></pre>\n<p><code>AnimatedSprite</code> 类的构造方法接收一个由关键帧图片转化成的纹理组成的数组。纹理是指可以被 GPU 处理的图片。PixiJS 默认使用 WebGL 和 GPU 渲染，所以图片都需要转换成纹理。<code>animationSpeed</code> 用于控制动画的播放速度。</p>\n<h2 id=\"游戏循环动画\"><a href=\"#游戏循环动画\" class=\"headerlink\" title=\"游戏循环动画\"></a>游戏循环动画</h2><p>游戏循环动画适用于精灵需要匀速改变尺寸、位置或角度的场景。PixiJS 提供了 <code>ticker</code> 用于添加游戏循环动画，游戏循环中的代码每秒将被执行60次。</p>\n<img src=\"/images/posts/2018/11/pixi_practice_candy_house_sign.gif\" class=\"round\" width=\"280\" title=\"糖果屋招牌\">\n\n<p>以“糖果屋”招牌上旋转的蛋糕和糖果为例，添加每次转动 0.02 弧度的游戏循环动画：</p>\n<pre><code class=\"js\">app.ticker.add(delta =&gt; {\n  cake.rotation -= 0.02 * delta   // 逆时针旋转\n  candy.rotation += 0.02 * delta  // 顺时针旋转\n})</code></pre>\n<p>然后，蛋糕和糖果将每 1/60 秒转动 0.02 弧度。 <code>delta</code> 表示帧延迟率，根据延迟率改变转动的弧度数，能够缓解老旧设备上的卡顿感。<code>ticker</code> 适合用来实现循环的匀速的动画。</p>\n<h2 id=\"辅助动画库\"><a href=\"#辅助动画库\" class=\"headerlink\" title=\"辅助动画库\"></a>辅助动画库</h2><p>游戏循环动画已经足够处理一些简单的动画逻辑，但是如果我们想要给动画加上条件判断或者是舒适的过渡效果，它就显得不那么顺手了。于是我在项目中同时引入了 <a href=\"http://animejs.com/\" target=\"_blank\" rel=\"noopener\">Anime</a> 动画库，辅助实现一部分动画。其中就包括月亮升起的动画：</p>\n<pre><code class=\"js\">anime({\n  targets: sprite,\n  y: 0,                  // 垂直位置变为0\n  round: 1,              // 平滑移动\n  duration: 1000,        // 过渡持续1秒\n  easing: &#39;easeOutQuad&#39;  // 以慢速结束的过渡效果\n})</code></pre>\n<p>烟雾扩散动画同样使用 Anime 实现，实际上是逐渐放大、透明。在应用了 Anime 的过渡效果后，用户滑动屏幕时画面的滚动也变得更加平滑。它的加入不仅使动画更易实现，而且提高了动画质量。</p>\n<h2 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h2><p>场景的触摸滑动是通过舞台的触摸事件： <code>touchstart</code> 、<code>touchmove</code> 和 <code>touchend</code> 实现的。如果说用户的视角是一台摄像机，那么我要做的不是转动它，而是移动整幅画面。</p>\n<p>首先，计算出 5 个焦点区域的舞台位置：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_camera.jpg\" class=\"round\" width=\"650\" title=\"舞台位置的变化\">\n\n<p><code>x</code> 表示舞台的水平位置 <code>stage.x</code> ，<code>w</code> 和 <code>h</code> 分别表示浏览器可视区域的宽和高。</p>\n<p>在用户向左滑动屏幕的过程中，不断让舞台的水平位置向左移动（用户手指移动的距离），就可以产生滑动跟手的效果。在用户结束触摸后，根据滑动方向继续移动舞台，使下一个焦点区域显示在屏幕上。</p>\n<pre><code class=\"js\">// 启用舞台交互\nthis.app.stage.interactive = true\nthis.app.stage.on(&#39;touchstart&#39;, event =&gt; {\n  // 监听触摸开始，在这里保存起始点坐标。\n})\nthis.app.stage.on(&#39;touchmove&#39;, event =&gt; {\n  // 监听手指移动，在这里判断滑动方向，制造跟手效果。\n})\nthis.app.stage.on(&#39;touchend&#39;, event =&gt; {\n  // 监听触摸结束，在这里判断滑动方向，平滑移动舞台到下一个焦点。\n})</code></pre>\n<p>主题馆入口点按钮的点击是通过 <code>tap</code> 事件实现的：</p>\n<pre><code class=\"js\">// 启用精灵交互\nentrance.interactive = true\nentrance.on(&#39;tap&#39;, () =&gt; {\n  // 在这里路由到下一个页面\n})</code></pre>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>由于使用的图片资源很多，必须在渲染之前确保所有图片加载完毕，避免用户看到的不完整的场景。</p>\n<p>PixiJS 提供了 <code>loader</code> 用于加载资源：</p>\n<pre><code class=\"js\">PIXI.loader.add([\n  require(&#39;@img/image_1.png&#39;),\n  ...\n]).on(&#39;progress&#39;, (loader) =&gt; {\n  // 更新加载进度\n  this.progress = parseInt(loader.progress)\n}).load(() =&gt; {\n  // 加载完毕\n  // 在这里结束 Loading\n})</code></pre>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1. 图片当然都是经过压缩的。权衡了设计师对画质的追求，最后我把首屏加载的图片量控制在 1.4mb 。</p>\n<p>2. PixiJS 默认使用的 WebGL 渲染能够提供更好的性能，但是一些老旧设备并不支持。比如在一台 Android 4.4 测试机上，我们发现了画面持续闪烁的现象。这个问题在强制使用 Canvas 渲染模式后得到解决，并且动画性能也没有明显下降。</p>\n<pre><code class=\"js\">new PIXI.Application({ forceCanvas: true })</code></pre>\n<p>3. PixiJS 支持使用图片中的一块区域作为精灵的材质。为了减少请求数，同时避免小概率的图片加载失败，我曾尝试将图片素材合成一两张大的雪碧图。测试后发现性能明显下降，最终放弃。</p>\n<p>4. 为了提高清晰度和消除锯齿，我是用浏览器可视区域两倍的尺寸渲染，然后把 Canvas 缩放到 1/2 。</p>\n","site":{"data":{}},"excerpt":"<p>上个月初我们准备了一期万圣节主题 H5 用于推广 APP 的拍照效果，10月24日上线，截止万圣节当天共 560 万 PV。对我个人比较有纪念意义的是，它算是我的第一个真正意义上的百万级 PV H5，也是我第一次用 2D 渲染引擎。虽然开发的时候遇到不少问题，但解锁挑战的过程非常有趣。</p>","more":"<img src=\"/images/posts/2018/11/pixi_practice_preview.gif\" class=\"round\" width=\"650\" title=\"前端实现（有损压缩）\">\n\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>在动手之前，我先了解了几款 HTML5 2D 动画引擎，包括 PixiJS、Fabric.js、Paper.js、EaselJS、Collie 。我需要一款易上手、可靠、高性能的渲染引擎，最终选择了 PixiJS 。</p>\n<p>因为它：</p>\n<ul>\n<li>GitHub 20k+ Star，广泛的用户基础意味着问题更容易找到答案。</li>\n<li>仍在不断更新，示例代码使用了 ES6 语法。</li>\n<li>文档及示例友好，还有一篇质量不错的 <a href=\"https://github.com/Zainking/learningPixi\" target=\"_blank\" rel=\"noopener\">官方教程中文版</a> 可供入门。</li>\n<li>追求性能，官网称它在 2D 渲染上无人望其项背。</li>\n</ul>\n<p>由于笔者的项目面向海外市场，需要照顾可能在一些发展中国家占主流的中低端机用户，加上之前的 H5 已经有在中低端机上表现欠佳的经历，所以性能因素非常影响我的选择。</p>\n<p>在着手实现之前，先来了解一下设计输出的视觉稿：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_design.jpg\" class=\"round\" width=\"650\" title=\"视觉稿\">\n\n<p>视觉稿中的图2至图6就是我们要用 PixiJS 实现的场景。设计师希望以类似“一键到底”的效果呈现，用户左右滑动屏幕在“主题馆”之间切换，然后点击入口点按钮进入其他页面浏览更多内容。</p>\n<p>动画部分需要实现：招牌霓虹闪烁，浏览到图5位置时月亮缓慢升起，图5和图6建筑后方烟雾扩散，蝙蝠和女巫上下漂浮等。</p>\n<h2 id=\"切图与布局\"><a href=\"#切图与布局\" class=\"headerlink\" title=\"切图与布局\"></a>切图与布局</h2><p>在开始切图之前，必须先结合动画需求把内容分层。在这个案例中，动画需求直接影响了内容是否能够合并成一张图片呈现，也影响了切图阶段的工作量。一张静态背景图显然是无法让月亮动起来的。</p>\n<p>于是我把内容拆分成了8层：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_layers.jpg\" class=\"\" width=\"650\" title=\"内容分层\">\n\n<p>L6-8 组成背景部分：纯色矩形叠加星星素材组成“星空”，然后是月亮，最上面是背景建筑群。L3-5 组成中景部分：主题馆建筑后面有两片正在扩散的烟雾，前面是不断闪烁的霓虹招牌。L1-2 组成前景部分：贯穿整个场景的马路旁立着路灯，左侧近处有一栋建筑，蝙蝠和女巫上下漂浮。</p>\n<p>用切图工具把每一层中相对独立的内容切成图片。我用的是 <a href=\"http://www.cutterman.cn/zh/cutterman\" target=\"_blank\" rel=\"noopener\">Cutterman</a>，使用 @2X 分辨率 。霓虹招牌比较特殊，需要按照动画的关键帧切图。加上要做5种语言版本，每个招牌最终切出了 10-30 张图片。由于招牌的关键帧内容有所不同，切图工具自动选择的区域可能存在误差，导致动画效果不协调，所以切图时必须手动选择区域。</p>\n<p>倒序地把每一层内容绘制到画布上就得到了完整的静态场景。为了适配不同屏幕尺寸，我用浏览器可视区域的高度作为参考来设置内容的尺寸和位置。</p>\n<p>下一步便是实现动画。</p>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><p>关键帧动画适用于精灵需要有规律地改变外观的场景。以用户看到的第一个霓虹招牌为例，每个语言切出6张关键帧图片，然后以预先编排好的顺序播放就能实现闪烁效果。其他招牌同理。</p>\n<img src=\"/images/posts/2018/11/pixi_practice_animated_sprite.jpg\" class=\"\" width=\"540\" title=\"主标题招牌关键帧\">\n\n\n\n<p>在 PixiJS 中使用 <code>AnimatedSprite</code> 创建关键帧动画：</p>\n<pre><code class=\"js\">const sprite = new PIXI.extras.AnimatedSprite([\n  PIXI.loader.resources[require(&#39;@img/frame_1.png&#39;)].texture,\n  PIXI.loader.resources[require(&#39;@img/frame_2.png&#39;)].texture,\n  ...\n])\nsprite.animationSpeed = 0.2\nsprite.play()</code></pre>\n<p><code>AnimatedSprite</code> 类的构造方法接收一个由关键帧图片转化成的纹理组成的数组。纹理是指可以被 GPU 处理的图片。PixiJS 默认使用 WebGL 和 GPU 渲染，所以图片都需要转换成纹理。<code>animationSpeed</code> 用于控制动画的播放速度。</p>\n<h2 id=\"游戏循环动画\"><a href=\"#游戏循环动画\" class=\"headerlink\" title=\"游戏循环动画\"></a>游戏循环动画</h2><p>游戏循环动画适用于精灵需要匀速改变尺寸、位置或角度的场景。PixiJS 提供了 <code>ticker</code> 用于添加游戏循环动画，游戏循环中的代码每秒将被执行60次。</p>\n<img src=\"/images/posts/2018/11/pixi_practice_candy_house_sign.gif\" class=\"round\" width=\"280\" title=\"糖果屋招牌\">\n\n<p>以“糖果屋”招牌上旋转的蛋糕和糖果为例，添加每次转动 0.02 弧度的游戏循环动画：</p>\n<pre><code class=\"js\">app.ticker.add(delta =&gt; {\n  cake.rotation -= 0.02 * delta   // 逆时针旋转\n  candy.rotation += 0.02 * delta  // 顺时针旋转\n})</code></pre>\n<p>然后，蛋糕和糖果将每 1/60 秒转动 0.02 弧度。 <code>delta</code> 表示帧延迟率，根据延迟率改变转动的弧度数，能够缓解老旧设备上的卡顿感。<code>ticker</code> 适合用来实现循环的匀速的动画。</p>\n<h2 id=\"辅助动画库\"><a href=\"#辅助动画库\" class=\"headerlink\" title=\"辅助动画库\"></a>辅助动画库</h2><p>游戏循环动画已经足够处理一些简单的动画逻辑，但是如果我们想要给动画加上条件判断或者是舒适的过渡效果，它就显得不那么顺手了。于是我在项目中同时引入了 <a href=\"http://animejs.com/\" target=\"_blank\" rel=\"noopener\">Anime</a> 动画库，辅助实现一部分动画。其中就包括月亮升起的动画：</p>\n<pre><code class=\"js\">anime({\n  targets: sprite,\n  y: 0,                  // 垂直位置变为0\n  round: 1,              // 平滑移动\n  duration: 1000,        // 过渡持续1秒\n  easing: &#39;easeOutQuad&#39;  // 以慢速结束的过渡效果\n})</code></pre>\n<p>烟雾扩散动画同样使用 Anime 实现，实际上是逐渐放大、透明。在应用了 Anime 的过渡效果后，用户滑动屏幕时画面的滚动也变得更加平滑。它的加入不仅使动画更易实现，而且提高了动画质量。</p>\n<h2 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h2><p>场景的触摸滑动是通过舞台的触摸事件： <code>touchstart</code> 、<code>touchmove</code> 和 <code>touchend</code> 实现的。如果说用户的视角是一台摄像机，那么我要做的不是转动它，而是移动整幅画面。</p>\n<p>首先，计算出 5 个焦点区域的舞台位置：</p>\n<img src=\"/images/posts/2018/11/pixi_practice_camera.jpg\" class=\"round\" width=\"650\" title=\"舞台位置的变化\">\n\n<p><code>x</code> 表示舞台的水平位置 <code>stage.x</code> ，<code>w</code> 和 <code>h</code> 分别表示浏览器可视区域的宽和高。</p>\n<p>在用户向左滑动屏幕的过程中，不断让舞台的水平位置向左移动（用户手指移动的距离），就可以产生滑动跟手的效果。在用户结束触摸后，根据滑动方向继续移动舞台，使下一个焦点区域显示在屏幕上。</p>\n<pre><code class=\"js\">// 启用舞台交互\nthis.app.stage.interactive = true\nthis.app.stage.on(&#39;touchstart&#39;, event =&gt; {\n  // 监听触摸开始，在这里保存起始点坐标。\n})\nthis.app.stage.on(&#39;touchmove&#39;, event =&gt; {\n  // 监听手指移动，在这里判断滑动方向，制造跟手效果。\n})\nthis.app.stage.on(&#39;touchend&#39;, event =&gt; {\n  // 监听触摸结束，在这里判断滑动方向，平滑移动舞台到下一个焦点。\n})</code></pre>\n<p>主题馆入口点按钮的点击是通过 <code>tap</code> 事件实现的：</p>\n<pre><code class=\"js\">// 启用精灵交互\nentrance.interactive = true\nentrance.on(&#39;tap&#39;, () =&gt; {\n  // 在这里路由到下一个页面\n})</code></pre>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>由于使用的图片资源很多，必须在渲染之前确保所有图片加载完毕，避免用户看到的不完整的场景。</p>\n<p>PixiJS 提供了 <code>loader</code> 用于加载资源：</p>\n<pre><code class=\"js\">PIXI.loader.add([\n  require(&#39;@img/image_1.png&#39;),\n  ...\n]).on(&#39;progress&#39;, (loader) =&gt; {\n  // 更新加载进度\n  this.progress = parseInt(loader.progress)\n}).load(() =&gt; {\n  // 加载完毕\n  // 在这里结束 Loading\n})</code></pre>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1. 图片当然都是经过压缩的。权衡了设计师对画质的追求，最后我把首屏加载的图片量控制在 1.4mb 。</p>\n<p>2. PixiJS 默认使用的 WebGL 渲染能够提供更好的性能，但是一些老旧设备并不支持。比如在一台 Android 4.4 测试机上，我们发现了画面持续闪烁的现象。这个问题在强制使用 Canvas 渲染模式后得到解决，并且动画性能也没有明显下降。</p>\n<pre><code class=\"js\">new PIXI.Application({ forceCanvas: true })</code></pre>\n<p>3. PixiJS 支持使用图片中的一块区域作为精灵的材质。为了减少请求数，同时避免小概率的图片加载失败，我曾尝试将图片素材合成一两张大的雪碧图。测试后发现性能明显下降，最终放弃。</p>\n<p>4. 为了提高清晰度和消除锯齿，我是用浏览器可视区域两倍的尺寸渲染，然后把 Canvas 缩放到 1/2 。</p>"},{"title":"Swift 语言入门学习笔记","date":"2018-12-18T13:20:11.000Z","_content":"\n## 变量与常量\n\nSwift 使用 `var` 声明变量，使用 `let` 声明常量。常量是不会被修改的量，只能被赋值一次。\n\n``` swift\nvar foo = 1\nlet bar = 1\n```\n\n<!-- more -->\n\nSwift 是强静态类型的语言，具有类型推论（Type Inference）的特性，即在编译期自动推导出值的数据类型。简单的说，当你将一个变量赋值为 `1` 时，Swift 便认为它是整数型变量，此后修改它的值为其他类型会报错。\n\n``` swift\nvar foo = 1\nfoo = 'Hello' // 错误\n```\n\n在变量声明时可以使用 `:` 显式地声明它的类型。\n\n``` swift\nlet foo: String = 'Hello World!'\n```\n\n使用 `,` 可以在一个语句中声明多个变量。\n\n``` swift\nlet foo = 1, bar = 2\nlet baz, qux: Int\n```\n\n## 数据类型\n\nSwift 中的数据类型包括整型 `Int`，浮点型 `Float` 和 `Double`，布尔型 `Bool`，字符串 `String` 以及元组 `Tuple`。\n\n### 整型\n\n声明一个整型。\n\n``` swift\nlet foo = 1 // 普通整型\nlet bar: UInt = 1 // 无符号整型\n```\n\n为了便于阅读，可以使用 `_` 任意分隔数字。下划线并无实际意义，`foo` 的值仍是 `10000000`。\n\n``` swift\nlet foo = 10_000_000\n```\n\n### 浮点型\n\nSwift 中的浮点型包括 `Float` 和 `Double` 两种类型。`Double` 的精度更高，能够容纳更多小数位数。\n\n声明一个浮点数，默认为 `Double` 类型。\n\n``` swift\nlet foo = 1.23\n```\n\n显式地声明一个浮点数为 `Float` 或 `Double` 类型。\n\n``` swift\nlet foo: Float = 1.23\nlet bar: Double = 1.23 \n```\n\n浮点数的小数部分同样支持用 `_` 分隔的表示方式。\n\n``` swift\nlet foo = 0.123_456\n```\n\n### 布尔型\n\n声明一个布尔型。\n\n``` swift\nlet foo = true\nlet bar = false\n```\n\n### 字符串\n\n在 Swift 中，字符串只能使用双引号表示。\n\n声明一个字符串。\n\n``` swift\nlet foo = \"Hello\"\n```\n\n使用 `+` 拼接字符串。\n\n``` swift\nprint(\"He\" + \"llo\") // Hello\n```\n\n使用 `\\()` 在字符串中包含变量。\n\n``` swift\nlet foo = \"Swift\"\nprint(\"Hello, \\(foo)!\") // Hello, Swift!\n```\n\n使用 `isEmpty` 属性判断一个字符是否为空。\n\n``` swift\nlet string = \"\"\nprint(string.isEmpty) // true\n```\n\n### 元组\n\n元组是由多个值组成的复合值，其元素可以是任意类型，且彼此间不必是相同类型。\n\n创建一个普通元组 `foo` 和带元素命名的 `bar`。元组 `foo` 使用从 0 开始的索引访问元素，元组 `bar` 使用元素名称访问元素。两者分别类似于 JavaScript 中的数组和对象。\n\n``` swift\nlet foo = (1, 2)\nlet bar = (a: 1, b: 2)\n```\n\n显式地指定元组中每个元素的类型。\n\n``` swift\nlet foo: (Int, Float) = (1, 1.0)\nlet bar: (a: Int, b: Float) = (a: 1, b: 1.0)\n```\n\n使用索引或名称访问元组中的元素。\n\n``` swift\nlet foo = (a: 1, b: 2)\nprint(foo.0, foo.a) // 1 1\n```\n\n将一个普通元组分解成独立的变量或常量。\n\n``` swift\nlet foo = (1, 2)\nlet (x, y) = foo\nprint(x, y) // 1 2\n```\n\n分解一个命名元组，并且使用 `_` 忽略用不到的元素。\n\n``` swift\nlet foo = (a: 1, b: 2)\nlet (a, _) = foo\nprint(a) // 1\n```\n\n### 类型转换\n\nSwift 不自动转换数据类型。两个不同数据类型计算时，需要显式地强制转换为相同的类型。举个栗子，当整数和小数相加时，使用 `Int` 函数将浮点数强制转换为整数。\n\n``` swift\nlet foo = 1\nlet bar = 1.0\nlet baz = foo + Int(bar)\n```\n\n## 运算符\n\nSwift 中的运算符和其他语言，如 Java、JavaScript 基本一致。**区间运算符** 是 Swift 特有的运算符。\n\n### 基本运算符\n\n基本运算符用于数值的计算，常用的包括加减乘除及取余运算。\n\n``` swift\nprint(1 + 2 - 3 * 4 / 5 % 6) // 1\n```\n\n由于 Swift 是一个强类型的语言 —— 整型除以整型的结果仍是整型，所以 `1` 除以 `2` 的结果是 `0`，而不是 `0.5` 。\n\n``` swift\nprint(1 / 2) // 0\nprint(1.0 / 2.0) // 0.5\n```\n\nSwift 2.2 起废弃了自增运算符 `++` 和自减运算符 `--` ，应使用 `+=` 和 `-=` 实现。\n\n``` swift\nfoo++  // 错误\nfoo += 1 // 正确 等同于 foo = foo + 1\n```\n\n### 比较运算符\n\n比较运算符比较两个值，然后返回一个布尔值。二者关系成立时返回 `true` ，关系不成立时返回 `false` 。比较运算符一般用于条件判断。与其他常见语言并无二致，Swift 中的比较运算符包括相等 `==` 和不等 `!=` ，大于 `>` 和大于等于 `>=` ，小于 `<` 和小于等于 `<=` 。\n\n``` swift\n1 == 2 // false\n1 <= 2 // true\n```\n\n### 逻辑运算符\n\n逻辑运算符包括逻辑非 `!`，逻辑与 `&&` 和逻辑或 `||` ，常用于条件判断。\n\n``` swift\nlet foo = true\nlet bar = false\n!foo       // false，foo 不为真时返回 true。\nfoo && bar // false，foo、bar 皆为真时返回 true。\nfoo || bar // false，foo、bar 中有一个为真时返回 true。\n```\n\n### 三元运算符\n\n三元运算符判断一个条件表达式，`true` 时执行 `:` 前面的表达式，否则执行 `:` 后面的表达式。\n\n``` swift\nlet raining = true\nlet wheather = raining ? \"Rainy\" : \"Sunny\" // Rainy\n```\n\n### 区间运算符\n\n区间运算符用于表示一个整数的集合。\n\n``` swift\na...b // 相当于数学上的 [a, b]\na..<b // 相当于数学上的 [a, b)\n```\n\n## 函数\n\n使用 `func` 声明函数。\n\n``` swift\nlet text = \"This is a log.\"\nfunc log(msg: String) {\n    print(msg)\n}\nlog(msg: text)\n// This is a log.\n```\n\n## 控制流\n\nSwift 4 提供了 `if`、`switch` 条件语句，以及 `for-in`、`while`、`repeat-while` 循环语句。\n\n- 使用 if / switch 制造条件。\n- 使用 for-in / while / repeat-while 制造循环。\n- Swift 3 起废弃了常见的 C 语言风格的 for 循环。\n- 同样支持使用 break 结束循环，使用 continue 结束当前循环并进入下一次循环。\n\n### if 语句\n\n`if` 语句的条件不需要用 `()` 包裹。即使只有一个语句，`{}` 也不能省略。\n\n``` swift\nlet wheather = \"rainy\"\nif wheather == \"rainy\" {\n    print(\"It will rain today.\");\n} else {\n    print(\"It won't rain today.\");\n}\n// It will rain today.\n```\n\n### guard 语句\n\n在使用其他语言的过程中，经常会遇到嵌套 `if` 语句的情况，影响代码的可读性。\n\nSwift 中的 `guard` 语句解决了这个问题。`guard` 语句判断一个条件，只有条件成立时才能执行 `guard` 语句之后的代码，否则执行 `else` 子句中的代码。我们可以优雅的把不符合继续执行的条件放在一个方法的前面处理。\n\n\n``` swift\nlet wheather = \"sunny\"\nfunc todo() {\n    guard wheather == \"sunny\" else {\n        return\n    }\n    print(\"Go sports.\")\n}\ntodo()\n// Go sports.\n```\n\n### switch 语句\n\nSwift 中的 `switch` 语句只会执行一个 `case` ，所以不需要像其他语言那样使用 `break` 手动结束循环。另外，一个 `case` 可以对应多个值，使用逗号分隔。\n\n使用 `switch` 语句判断一周中的某一天应该做什么事。\n\n``` swift\nlet day = \"Monday\"\nswitch day  {\ncase \"Friday\":\n    print(\"Go shopping.\")\n    break // 冗余\ncase \"Saturday\", \"Sunday\":\n    print(\"Go sports.\")\ndefault:\n    print(\"Go to work.\")\n}\n// Go to work.\n```\n\n使用 `fallthrough` 关键字可以在循环结束后继续执行下一个 `case` 的代码块。\n\n``` swift\nlet num = true\nswitch num  {\ncase true:\n    print(\"true\", terminator: \" \")\n    fallthrough\ncase false:\n    print(\"false\", terminator: \" \")\n}\n// true false\n```\n\n`case` 可以使用 `where` 子句进一步限定条件。例如，判断一个整数是否介于 5 到 10 之间，并且是一个偶数。\n\n``` swift\nlet num = 8\nswitch num {\ncase 5...10 where num % 2 == 0 :\n    print(true)\ndefault:\n    print(false)\n}\n// true\n```\n\n### for-in 循环\n\n遍历一个区间，计算 1-100 的累加结果。\n\n``` swift\nvar sum = 0\nfor i in 1...100 {\n    sum += i\n}\nprint(sum) // 5050\n```\n\n遍历一个数组，打印一个拼接的字符串。\n\n``` swift\nvar string = \"\"\nfor item in [\"Hello\", \"World\", \"Swift\"] {\n    string += item\n}\nprint(string) // HelloWorldSwift\n```\n\n### while 循环\n\n打印 1-10 之间的整数。\n\n``` swift\nvar i = 1\nwhile i <= 10 {\n    print(i, terminator: \" \")\n    i += 1\n}\n// 1 2 3 4 5 6 7 8 9 10\n```\n\n### repeat-while 循环\n\n`repeat-while` 类似其他语言中的 `do-while` 循环，即先执行代码，再判断是否符合条件。如果条件成立，继续循环，否则跳出循环。`repeat-while` 中的循环体至少会执行一次。\n\n使用 `repeat-while` 语句打印 1-10 之间的整数。\n\n``` swift\nvar i = 1\nrepeat {\n    print(i, terminator: \" \")\n    i += 1\n} while i <= 10\n// 1 2 3 4 5 6 7 8 9 10\n```\n","source":"_posts/2018-12-18@Swift 语言入门学习笔记.md","raw":"---\ntitle: Swift 语言入门学习笔记\ndate: 2018-12-18 21:20:11\ntags:\n  - Swift\n  - iOS\ncategories:\n  - iOS\n---\n\n## 变量与常量\n\nSwift 使用 `var` 声明变量，使用 `let` 声明常量。常量是不会被修改的量，只能被赋值一次。\n\n``` swift\nvar foo = 1\nlet bar = 1\n```\n\n<!-- more -->\n\nSwift 是强静态类型的语言，具有类型推论（Type Inference）的特性，即在编译期自动推导出值的数据类型。简单的说，当你将一个变量赋值为 `1` 时，Swift 便认为它是整数型变量，此后修改它的值为其他类型会报错。\n\n``` swift\nvar foo = 1\nfoo = 'Hello' // 错误\n```\n\n在变量声明时可以使用 `:` 显式地声明它的类型。\n\n``` swift\nlet foo: String = 'Hello World!'\n```\n\n使用 `,` 可以在一个语句中声明多个变量。\n\n``` swift\nlet foo = 1, bar = 2\nlet baz, qux: Int\n```\n\n## 数据类型\n\nSwift 中的数据类型包括整型 `Int`，浮点型 `Float` 和 `Double`，布尔型 `Bool`，字符串 `String` 以及元组 `Tuple`。\n\n### 整型\n\n声明一个整型。\n\n``` swift\nlet foo = 1 // 普通整型\nlet bar: UInt = 1 // 无符号整型\n```\n\n为了便于阅读，可以使用 `_` 任意分隔数字。下划线并无实际意义，`foo` 的值仍是 `10000000`。\n\n``` swift\nlet foo = 10_000_000\n```\n\n### 浮点型\n\nSwift 中的浮点型包括 `Float` 和 `Double` 两种类型。`Double` 的精度更高，能够容纳更多小数位数。\n\n声明一个浮点数，默认为 `Double` 类型。\n\n``` swift\nlet foo = 1.23\n```\n\n显式地声明一个浮点数为 `Float` 或 `Double` 类型。\n\n``` swift\nlet foo: Float = 1.23\nlet bar: Double = 1.23 \n```\n\n浮点数的小数部分同样支持用 `_` 分隔的表示方式。\n\n``` swift\nlet foo = 0.123_456\n```\n\n### 布尔型\n\n声明一个布尔型。\n\n``` swift\nlet foo = true\nlet bar = false\n```\n\n### 字符串\n\n在 Swift 中，字符串只能使用双引号表示。\n\n声明一个字符串。\n\n``` swift\nlet foo = \"Hello\"\n```\n\n使用 `+` 拼接字符串。\n\n``` swift\nprint(\"He\" + \"llo\") // Hello\n```\n\n使用 `\\()` 在字符串中包含变量。\n\n``` swift\nlet foo = \"Swift\"\nprint(\"Hello, \\(foo)!\") // Hello, Swift!\n```\n\n使用 `isEmpty` 属性判断一个字符是否为空。\n\n``` swift\nlet string = \"\"\nprint(string.isEmpty) // true\n```\n\n### 元组\n\n元组是由多个值组成的复合值，其元素可以是任意类型，且彼此间不必是相同类型。\n\n创建一个普通元组 `foo` 和带元素命名的 `bar`。元组 `foo` 使用从 0 开始的索引访问元素，元组 `bar` 使用元素名称访问元素。两者分别类似于 JavaScript 中的数组和对象。\n\n``` swift\nlet foo = (1, 2)\nlet bar = (a: 1, b: 2)\n```\n\n显式地指定元组中每个元素的类型。\n\n``` swift\nlet foo: (Int, Float) = (1, 1.0)\nlet bar: (a: Int, b: Float) = (a: 1, b: 1.0)\n```\n\n使用索引或名称访问元组中的元素。\n\n``` swift\nlet foo = (a: 1, b: 2)\nprint(foo.0, foo.a) // 1 1\n```\n\n将一个普通元组分解成独立的变量或常量。\n\n``` swift\nlet foo = (1, 2)\nlet (x, y) = foo\nprint(x, y) // 1 2\n```\n\n分解一个命名元组，并且使用 `_` 忽略用不到的元素。\n\n``` swift\nlet foo = (a: 1, b: 2)\nlet (a, _) = foo\nprint(a) // 1\n```\n\n### 类型转换\n\nSwift 不自动转换数据类型。两个不同数据类型计算时，需要显式地强制转换为相同的类型。举个栗子，当整数和小数相加时，使用 `Int` 函数将浮点数强制转换为整数。\n\n``` swift\nlet foo = 1\nlet bar = 1.0\nlet baz = foo + Int(bar)\n```\n\n## 运算符\n\nSwift 中的运算符和其他语言，如 Java、JavaScript 基本一致。**区间运算符** 是 Swift 特有的运算符。\n\n### 基本运算符\n\n基本运算符用于数值的计算，常用的包括加减乘除及取余运算。\n\n``` swift\nprint(1 + 2 - 3 * 4 / 5 % 6) // 1\n```\n\n由于 Swift 是一个强类型的语言 —— 整型除以整型的结果仍是整型，所以 `1` 除以 `2` 的结果是 `0`，而不是 `0.5` 。\n\n``` swift\nprint(1 / 2) // 0\nprint(1.0 / 2.0) // 0.5\n```\n\nSwift 2.2 起废弃了自增运算符 `++` 和自减运算符 `--` ，应使用 `+=` 和 `-=` 实现。\n\n``` swift\nfoo++  // 错误\nfoo += 1 // 正确 等同于 foo = foo + 1\n```\n\n### 比较运算符\n\n比较运算符比较两个值，然后返回一个布尔值。二者关系成立时返回 `true` ，关系不成立时返回 `false` 。比较运算符一般用于条件判断。与其他常见语言并无二致，Swift 中的比较运算符包括相等 `==` 和不等 `!=` ，大于 `>` 和大于等于 `>=` ，小于 `<` 和小于等于 `<=` 。\n\n``` swift\n1 == 2 // false\n1 <= 2 // true\n```\n\n### 逻辑运算符\n\n逻辑运算符包括逻辑非 `!`，逻辑与 `&&` 和逻辑或 `||` ，常用于条件判断。\n\n``` swift\nlet foo = true\nlet bar = false\n!foo       // false，foo 不为真时返回 true。\nfoo && bar // false，foo、bar 皆为真时返回 true。\nfoo || bar // false，foo、bar 中有一个为真时返回 true。\n```\n\n### 三元运算符\n\n三元运算符判断一个条件表达式，`true` 时执行 `:` 前面的表达式，否则执行 `:` 后面的表达式。\n\n``` swift\nlet raining = true\nlet wheather = raining ? \"Rainy\" : \"Sunny\" // Rainy\n```\n\n### 区间运算符\n\n区间运算符用于表示一个整数的集合。\n\n``` swift\na...b // 相当于数学上的 [a, b]\na..<b // 相当于数学上的 [a, b)\n```\n\n## 函数\n\n使用 `func` 声明函数。\n\n``` swift\nlet text = \"This is a log.\"\nfunc log(msg: String) {\n    print(msg)\n}\nlog(msg: text)\n// This is a log.\n```\n\n## 控制流\n\nSwift 4 提供了 `if`、`switch` 条件语句，以及 `for-in`、`while`、`repeat-while` 循环语句。\n\n- 使用 if / switch 制造条件。\n- 使用 for-in / while / repeat-while 制造循环。\n- Swift 3 起废弃了常见的 C 语言风格的 for 循环。\n- 同样支持使用 break 结束循环，使用 continue 结束当前循环并进入下一次循环。\n\n### if 语句\n\n`if` 语句的条件不需要用 `()` 包裹。即使只有一个语句，`{}` 也不能省略。\n\n``` swift\nlet wheather = \"rainy\"\nif wheather == \"rainy\" {\n    print(\"It will rain today.\");\n} else {\n    print(\"It won't rain today.\");\n}\n// It will rain today.\n```\n\n### guard 语句\n\n在使用其他语言的过程中，经常会遇到嵌套 `if` 语句的情况，影响代码的可读性。\n\nSwift 中的 `guard` 语句解决了这个问题。`guard` 语句判断一个条件，只有条件成立时才能执行 `guard` 语句之后的代码，否则执行 `else` 子句中的代码。我们可以优雅的把不符合继续执行的条件放在一个方法的前面处理。\n\n\n``` swift\nlet wheather = \"sunny\"\nfunc todo() {\n    guard wheather == \"sunny\" else {\n        return\n    }\n    print(\"Go sports.\")\n}\ntodo()\n// Go sports.\n```\n\n### switch 语句\n\nSwift 中的 `switch` 语句只会执行一个 `case` ，所以不需要像其他语言那样使用 `break` 手动结束循环。另外，一个 `case` 可以对应多个值，使用逗号分隔。\n\n使用 `switch` 语句判断一周中的某一天应该做什么事。\n\n``` swift\nlet day = \"Monday\"\nswitch day  {\ncase \"Friday\":\n    print(\"Go shopping.\")\n    break // 冗余\ncase \"Saturday\", \"Sunday\":\n    print(\"Go sports.\")\ndefault:\n    print(\"Go to work.\")\n}\n// Go to work.\n```\n\n使用 `fallthrough` 关键字可以在循环结束后继续执行下一个 `case` 的代码块。\n\n``` swift\nlet num = true\nswitch num  {\ncase true:\n    print(\"true\", terminator: \" \")\n    fallthrough\ncase false:\n    print(\"false\", terminator: \" \")\n}\n// true false\n```\n\n`case` 可以使用 `where` 子句进一步限定条件。例如，判断一个整数是否介于 5 到 10 之间，并且是一个偶数。\n\n``` swift\nlet num = 8\nswitch num {\ncase 5...10 where num % 2 == 0 :\n    print(true)\ndefault:\n    print(false)\n}\n// true\n```\n\n### for-in 循环\n\n遍历一个区间，计算 1-100 的累加结果。\n\n``` swift\nvar sum = 0\nfor i in 1...100 {\n    sum += i\n}\nprint(sum) // 5050\n```\n\n遍历一个数组，打印一个拼接的字符串。\n\n``` swift\nvar string = \"\"\nfor item in [\"Hello\", \"World\", \"Swift\"] {\n    string += item\n}\nprint(string) // HelloWorldSwift\n```\n\n### while 循环\n\n打印 1-10 之间的整数。\n\n``` swift\nvar i = 1\nwhile i <= 10 {\n    print(i, terminator: \" \")\n    i += 1\n}\n// 1 2 3 4 5 6 7 8 9 10\n```\n\n### repeat-while 循环\n\n`repeat-while` 类似其他语言中的 `do-while` 循环，即先执行代码，再判断是否符合条件。如果条件成立，继续循环，否则跳出循环。`repeat-while` 中的循环体至少会执行一次。\n\n使用 `repeat-while` 语句打印 1-10 之间的整数。\n\n``` swift\nvar i = 1\nrepeat {\n    print(i, terminator: \" \")\n    i += 1\n} while i <= 10\n// 1 2 3 4 5 6 7 8 9 10\n```\n","slug":"2018-12-18@Swift 语言入门学习笔记","published":1,"updated":"2020-06-29T03:32:42.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4bv00f4rqgje7cc6qv4","content":"<h2 id=\"变量与常量\"><a href=\"#变量与常量\" class=\"headerlink\" title=\"变量与常量\"></a>变量与常量</h2><p>Swift 使用 <code>var</code> 声明变量，使用 <code>let</code> 声明常量。常量是不会被修改的量，只能被赋值一次。</p>\n<pre><code class=\"swift\">var foo = 1\nlet bar = 1</code></pre>\n<a id=\"more\"></a>\n\n<p>Swift 是强静态类型的语言，具有类型推论（Type Inference）的特性，即在编译期自动推导出值的数据类型。简单的说，当你将一个变量赋值为 <code>1</code> 时，Swift 便认为它是整数型变量，此后修改它的值为其他类型会报错。</p>\n<pre><code class=\"swift\">var foo = 1\nfoo = &#39;Hello&#39; // 错误</code></pre>\n<p>在变量声明时可以使用 <code>:</code> 显式地声明它的类型。</p>\n<pre><code class=\"swift\">let foo: String = &#39;Hello World!&#39;</code></pre>\n<p>使用 <code>,</code> 可以在一个语句中声明多个变量。</p>\n<pre><code class=\"swift\">let foo = 1, bar = 2\nlet baz, qux: Int</code></pre>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Swift 中的数据类型包括整型 <code>Int</code>，浮点型 <code>Float</code> 和 <code>Double</code>，布尔型 <code>Bool</code>，字符串 <code>String</code> 以及元组 <code>Tuple</code>。</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>声明一个整型。</p>\n<pre><code class=\"swift\">let foo = 1 // 普通整型\nlet bar: UInt = 1 // 无符号整型</code></pre>\n<p>为了便于阅读，可以使用 <code>_</code> 任意分隔数字。下划线并无实际意义，<code>foo</code> 的值仍是 <code>10000000</code>。</p>\n<pre><code class=\"swift\">let foo = 10_000_000</code></pre>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><p>Swift 中的浮点型包括 <code>Float</code> 和 <code>Double</code> 两种类型。<code>Double</code> 的精度更高，能够容纳更多小数位数。</p>\n<p>声明一个浮点数，默认为 <code>Double</code> 类型。</p>\n<pre><code class=\"swift\">let foo = 1.23</code></pre>\n<p>显式地声明一个浮点数为 <code>Float</code> 或 <code>Double</code> 类型。</p>\n<pre><code class=\"swift\">let foo: Float = 1.23\nlet bar: Double = 1.23 </code></pre>\n<p>浮点数的小数部分同样支持用 <code>_</code> 分隔的表示方式。</p>\n<pre><code class=\"swift\">let foo = 0.123_456</code></pre>\n<h3 id=\"布尔型\"><a href=\"#布尔型\" class=\"headerlink\" title=\"布尔型\"></a>布尔型</h3><p>声明一个布尔型。</p>\n<pre><code class=\"swift\">let foo = true\nlet bar = false</code></pre>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>在 Swift 中，字符串只能使用双引号表示。</p>\n<p>声明一个字符串。</p>\n<pre><code class=\"swift\">let foo = &quot;Hello&quot;</code></pre>\n<p>使用 <code>+</code> 拼接字符串。</p>\n<pre><code class=\"swift\">print(&quot;He&quot; + &quot;llo&quot;) // Hello</code></pre>\n<p>使用 <code>\\()</code> 在字符串中包含变量。</p>\n<pre><code class=\"swift\">let foo = &quot;Swift&quot;\nprint(&quot;Hello, \\(foo)!&quot;) // Hello, Swift!</code></pre>\n<p>使用 <code>isEmpty</code> 属性判断一个字符是否为空。</p>\n<pre><code class=\"swift\">let string = &quot;&quot;\nprint(string.isEmpty) // true</code></pre>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>元组是由多个值组成的复合值，其元素可以是任意类型，且彼此间不必是相同类型。</p>\n<p>创建一个普通元组 <code>foo</code> 和带元素命名的 <code>bar</code>。元组 <code>foo</code> 使用从 0 开始的索引访问元素，元组 <code>bar</code> 使用元素名称访问元素。两者分别类似于 JavaScript 中的数组和对象。</p>\n<pre><code class=\"swift\">let foo = (1, 2)\nlet bar = (a: 1, b: 2)</code></pre>\n<p>显式地指定元组中每个元素的类型。</p>\n<pre><code class=\"swift\">let foo: (Int, Float) = (1, 1.0)\nlet bar: (a: Int, b: Float) = (a: 1, b: 1.0)</code></pre>\n<p>使用索引或名称访问元组中的元素。</p>\n<pre><code class=\"swift\">let foo = (a: 1, b: 2)\nprint(foo.0, foo.a) // 1 1</code></pre>\n<p>将一个普通元组分解成独立的变量或常量。</p>\n<pre><code class=\"swift\">let foo = (1, 2)\nlet (x, y) = foo\nprint(x, y) // 1 2</code></pre>\n<p>分解一个命名元组，并且使用 <code>_</code> 忽略用不到的元素。</p>\n<pre><code class=\"swift\">let foo = (a: 1, b: 2)\nlet (a, _) = foo\nprint(a) // 1</code></pre>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>Swift 不自动转换数据类型。两个不同数据类型计算时，需要显式地强制转换为相同的类型。举个栗子，当整数和小数相加时，使用 <code>Int</code> 函数将浮点数强制转换为整数。</p>\n<pre><code class=\"swift\">let foo = 1\nlet bar = 1.0\nlet baz = foo + Int(bar)</code></pre>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><p>Swift 中的运算符和其他语言，如 Java、JavaScript 基本一致。<strong>区间运算符</strong> 是 Swift 特有的运算符。</p>\n<h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><p>基本运算符用于数值的计算，常用的包括加减乘除及取余运算。</p>\n<pre><code class=\"swift\">print(1 + 2 - 3 * 4 / 5 % 6) // 1</code></pre>\n<p>由于 Swift 是一个强类型的语言 —— 整型除以整型的结果仍是整型，所以 <code>1</code> 除以 <code>2</code> 的结果是 <code>0</code>，而不是 <code>0.5</code> 。</p>\n<pre><code class=\"swift\">print(1 / 2) // 0\nprint(1.0 / 2.0) // 0.5</code></pre>\n<p>Swift 2.2 起废弃了自增运算符 <code>++</code> 和自减运算符 <code>--</code> ，应使用 <code>+=</code> 和 <code>-=</code> 实现。</p>\n<pre><code class=\"swift\">foo++  // 错误\nfoo += 1 // 正确 等同于 foo = foo + 1</code></pre>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>比较运算符比较两个值，然后返回一个布尔值。二者关系成立时返回 <code>true</code> ，关系不成立时返回 <code>false</code> 。比较运算符一般用于条件判断。与其他常见语言并无二致，Swift 中的比较运算符包括相等 <code>==</code> 和不等 <code>!=</code> ，大于 <code>&gt;</code> 和大于等于 <code>&gt;=</code> ，小于 <code>&lt;</code> 和小于等于 <code>&lt;=</code> 。</p>\n<pre><code class=\"swift\">1 == 2 // false\n1 &lt;= 2 // true</code></pre>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>逻辑运算符包括逻辑非 <code>!</code>，逻辑与 <code>&amp;&amp;</code> 和逻辑或 <code>||</code> ，常用于条件判断。</p>\n<pre><code class=\"swift\">let foo = true\nlet bar = false\n!foo       // false，foo 不为真时返回 true。\nfoo &amp;&amp; bar // false，foo、bar 皆为真时返回 true。\nfoo || bar // false，foo、bar 中有一个为真时返回 true。</code></pre>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><p>三元运算符判断一个条件表达式，<code>true</code> 时执行 <code>:</code> 前面的表达式，否则执行 <code>:</code> 后面的表达式。</p>\n<pre><code class=\"swift\">let raining = true\nlet wheather = raining ? &quot;Rainy&quot; : &quot;Sunny&quot; // Rainy</code></pre>\n<h3 id=\"区间运算符\"><a href=\"#区间运算符\" class=\"headerlink\" title=\"区间运算符\"></a>区间运算符</h3><p>区间运算符用于表示一个整数的集合。</p>\n<pre><code class=\"swift\">a...b // 相当于数学上的 [a, b]\na..&lt;b // 相当于数学上的 [a, b)</code></pre>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>使用 <code>func</code> 声明函数。</p>\n<pre><code class=\"swift\">let text = &quot;This is a log.&quot;\nfunc log(msg: String) {\n    print(msg)\n}\nlog(msg: text)\n// This is a log.</code></pre>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>Swift 4 提供了 <code>if</code>、<code>switch</code> 条件语句，以及 <code>for-in</code>、<code>while</code>、<code>repeat-while</code> 循环语句。</p>\n<ul>\n<li>使用 if / switch 制造条件。</li>\n<li>使用 for-in / while / repeat-while 制造循环。</li>\n<li>Swift 3 起废弃了常见的 C 语言风格的 for 循环。</li>\n<li>同样支持使用 break 结束循环，使用 continue 结束当前循环并进入下一次循环。</li>\n</ul>\n<h3 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h3><p><code>if</code> 语句的条件不需要用 <code>()</code> 包裹。即使只有一个语句，<code>{}</code> 也不能省略。</p>\n<pre><code class=\"swift\">let wheather = &quot;rainy&quot;\nif wheather == &quot;rainy&quot; {\n    print(&quot;It will rain today.&quot;);\n} else {\n    print(&quot;It won&#39;t rain today.&quot;);\n}\n// It will rain today.</code></pre>\n<h3 id=\"guard-语句\"><a href=\"#guard-语句\" class=\"headerlink\" title=\"guard 语句\"></a>guard 语句</h3><p>在使用其他语言的过程中，经常会遇到嵌套 <code>if</code> 语句的情况，影响代码的可读性。</p>\n<p>Swift 中的 <code>guard</code> 语句解决了这个问题。<code>guard</code> 语句判断一个条件，只有条件成立时才能执行 <code>guard</code> 语句之后的代码，否则执行 <code>else</code> 子句中的代码。我们可以优雅的把不符合继续执行的条件放在一个方法的前面处理。</p>\n<pre><code class=\"swift\">let wheather = &quot;sunny&quot;\nfunc todo() {\n    guard wheather == &quot;sunny&quot; else {\n        return\n    }\n    print(&quot;Go sports.&quot;)\n}\ntodo()\n// Go sports.</code></pre>\n<h3 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h3><p>Swift 中的 <code>switch</code> 语句只会执行一个 <code>case</code> ，所以不需要像其他语言那样使用 <code>break</code> 手动结束循环。另外，一个 <code>case</code> 可以对应多个值，使用逗号分隔。</p>\n<p>使用 <code>switch</code> 语句判断一周中的某一天应该做什么事。</p>\n<pre><code class=\"swift\">let day = &quot;Monday&quot;\nswitch day  {\ncase &quot;Friday&quot;:\n    print(&quot;Go shopping.&quot;)\n    break // 冗余\ncase &quot;Saturday&quot;, &quot;Sunday&quot;:\n    print(&quot;Go sports.&quot;)\ndefault:\n    print(&quot;Go to work.&quot;)\n}\n// Go to work.</code></pre>\n<p>使用 <code>fallthrough</code> 关键字可以在循环结束后继续执行下一个 <code>case</code> 的代码块。</p>\n<pre><code class=\"swift\">let num = true\nswitch num  {\ncase true:\n    print(&quot;true&quot;, terminator: &quot; &quot;)\n    fallthrough\ncase false:\n    print(&quot;false&quot;, terminator: &quot; &quot;)\n}\n// true false</code></pre>\n<p><code>case</code> 可以使用 <code>where</code> 子句进一步限定条件。例如，判断一个整数是否介于 5 到 10 之间，并且是一个偶数。</p>\n<pre><code class=\"swift\">let num = 8\nswitch num {\ncase 5...10 where num % 2 == 0 :\n    print(true)\ndefault:\n    print(false)\n}\n// true</code></pre>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>遍历一个区间，计算 1-100 的累加结果。</p>\n<pre><code class=\"swift\">var sum = 0\nfor i in 1...100 {\n    sum += i\n}\nprint(sum) // 5050</code></pre>\n<p>遍历一个数组，打印一个拼接的字符串。</p>\n<pre><code class=\"swift\">var string = &quot;&quot;\nfor item in [&quot;Hello&quot;, &quot;World&quot;, &quot;Swift&quot;] {\n    string += item\n}\nprint(string) // HelloWorldSwift</code></pre>\n<h3 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h3><p>打印 1-10 之间的整数。</p>\n<pre><code class=\"swift\">var i = 1\nwhile i &lt;= 10 {\n    print(i, terminator: &quot; &quot;)\n    i += 1\n}\n// 1 2 3 4 5 6 7 8 9 10</code></pre>\n<h3 id=\"repeat-while-循环\"><a href=\"#repeat-while-循环\" class=\"headerlink\" title=\"repeat-while 循环\"></a>repeat-while 循环</h3><p><code>repeat-while</code> 类似其他语言中的 <code>do-while</code> 循环，即先执行代码，再判断是否符合条件。如果条件成立，继续循环，否则跳出循环。<code>repeat-while</code> 中的循环体至少会执行一次。</p>\n<p>使用 <code>repeat-while</code> 语句打印 1-10 之间的整数。</p>\n<pre><code class=\"swift\">var i = 1\nrepeat {\n    print(i, terminator: &quot; &quot;)\n    i += 1\n} while i &lt;= 10\n// 1 2 3 4 5 6 7 8 9 10</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量与常量\"><a href=\"#变量与常量\" class=\"headerlink\" title=\"变量与常量\"></a>变量与常量</h2><p>Swift 使用 <code>var</code> 声明变量，使用 <code>let</code> 声明常量。常量是不会被修改的量，只能被赋值一次。</p>\n<pre><code class=\"swift\">var foo = 1\nlet bar = 1</code></pre>","more":"<p>Swift 是强静态类型的语言，具有类型推论（Type Inference）的特性，即在编译期自动推导出值的数据类型。简单的说，当你将一个变量赋值为 <code>1</code> 时，Swift 便认为它是整数型变量，此后修改它的值为其他类型会报错。</p>\n<pre><code class=\"swift\">var foo = 1\nfoo = &#39;Hello&#39; // 错误</code></pre>\n<p>在变量声明时可以使用 <code>:</code> 显式地声明它的类型。</p>\n<pre><code class=\"swift\">let foo: String = &#39;Hello World!&#39;</code></pre>\n<p>使用 <code>,</code> 可以在一个语句中声明多个变量。</p>\n<pre><code class=\"swift\">let foo = 1, bar = 2\nlet baz, qux: Int</code></pre>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Swift 中的数据类型包括整型 <code>Int</code>，浮点型 <code>Float</code> 和 <code>Double</code>，布尔型 <code>Bool</code>，字符串 <code>String</code> 以及元组 <code>Tuple</code>。</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>声明一个整型。</p>\n<pre><code class=\"swift\">let foo = 1 // 普通整型\nlet bar: UInt = 1 // 无符号整型</code></pre>\n<p>为了便于阅读，可以使用 <code>_</code> 任意分隔数字。下划线并无实际意义，<code>foo</code> 的值仍是 <code>10000000</code>。</p>\n<pre><code class=\"swift\">let foo = 10_000_000</code></pre>\n<h3 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h3><p>Swift 中的浮点型包括 <code>Float</code> 和 <code>Double</code> 两种类型。<code>Double</code> 的精度更高，能够容纳更多小数位数。</p>\n<p>声明一个浮点数，默认为 <code>Double</code> 类型。</p>\n<pre><code class=\"swift\">let foo = 1.23</code></pre>\n<p>显式地声明一个浮点数为 <code>Float</code> 或 <code>Double</code> 类型。</p>\n<pre><code class=\"swift\">let foo: Float = 1.23\nlet bar: Double = 1.23 </code></pre>\n<p>浮点数的小数部分同样支持用 <code>_</code> 分隔的表示方式。</p>\n<pre><code class=\"swift\">let foo = 0.123_456</code></pre>\n<h3 id=\"布尔型\"><a href=\"#布尔型\" class=\"headerlink\" title=\"布尔型\"></a>布尔型</h3><p>声明一个布尔型。</p>\n<pre><code class=\"swift\">let foo = true\nlet bar = false</code></pre>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>在 Swift 中，字符串只能使用双引号表示。</p>\n<p>声明一个字符串。</p>\n<pre><code class=\"swift\">let foo = &quot;Hello&quot;</code></pre>\n<p>使用 <code>+</code> 拼接字符串。</p>\n<pre><code class=\"swift\">print(&quot;He&quot; + &quot;llo&quot;) // Hello</code></pre>\n<p>使用 <code>\\()</code> 在字符串中包含变量。</p>\n<pre><code class=\"swift\">let foo = &quot;Swift&quot;\nprint(&quot;Hello, \\(foo)!&quot;) // Hello, Swift!</code></pre>\n<p>使用 <code>isEmpty</code> 属性判断一个字符是否为空。</p>\n<pre><code class=\"swift\">let string = &quot;&quot;\nprint(string.isEmpty) // true</code></pre>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>元组是由多个值组成的复合值，其元素可以是任意类型，且彼此间不必是相同类型。</p>\n<p>创建一个普通元组 <code>foo</code> 和带元素命名的 <code>bar</code>。元组 <code>foo</code> 使用从 0 开始的索引访问元素，元组 <code>bar</code> 使用元素名称访问元素。两者分别类似于 JavaScript 中的数组和对象。</p>\n<pre><code class=\"swift\">let foo = (1, 2)\nlet bar = (a: 1, b: 2)</code></pre>\n<p>显式地指定元组中每个元素的类型。</p>\n<pre><code class=\"swift\">let foo: (Int, Float) = (1, 1.0)\nlet bar: (a: Int, b: Float) = (a: 1, b: 1.0)</code></pre>\n<p>使用索引或名称访问元组中的元素。</p>\n<pre><code class=\"swift\">let foo = (a: 1, b: 2)\nprint(foo.0, foo.a) // 1 1</code></pre>\n<p>将一个普通元组分解成独立的变量或常量。</p>\n<pre><code class=\"swift\">let foo = (1, 2)\nlet (x, y) = foo\nprint(x, y) // 1 2</code></pre>\n<p>分解一个命名元组，并且使用 <code>_</code> 忽略用不到的元素。</p>\n<pre><code class=\"swift\">let foo = (a: 1, b: 2)\nlet (a, _) = foo\nprint(a) // 1</code></pre>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>Swift 不自动转换数据类型。两个不同数据类型计算时，需要显式地强制转换为相同的类型。举个栗子，当整数和小数相加时，使用 <code>Int</code> 函数将浮点数强制转换为整数。</p>\n<pre><code class=\"swift\">let foo = 1\nlet bar = 1.0\nlet baz = foo + Int(bar)</code></pre>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><p>Swift 中的运算符和其他语言，如 Java、JavaScript 基本一致。<strong>区间运算符</strong> 是 Swift 特有的运算符。</p>\n<h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><p>基本运算符用于数值的计算，常用的包括加减乘除及取余运算。</p>\n<pre><code class=\"swift\">print(1 + 2 - 3 * 4 / 5 % 6) // 1</code></pre>\n<p>由于 Swift 是一个强类型的语言 —— 整型除以整型的结果仍是整型，所以 <code>1</code> 除以 <code>2</code> 的结果是 <code>0</code>，而不是 <code>0.5</code> 。</p>\n<pre><code class=\"swift\">print(1 / 2) // 0\nprint(1.0 / 2.0) // 0.5</code></pre>\n<p>Swift 2.2 起废弃了自增运算符 <code>++</code> 和自减运算符 <code>--</code> ，应使用 <code>+=</code> 和 <code>-=</code> 实现。</p>\n<pre><code class=\"swift\">foo++  // 错误\nfoo += 1 // 正确 等同于 foo = foo + 1</code></pre>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>比较运算符比较两个值，然后返回一个布尔值。二者关系成立时返回 <code>true</code> ，关系不成立时返回 <code>false</code> 。比较运算符一般用于条件判断。与其他常见语言并无二致，Swift 中的比较运算符包括相等 <code>==</code> 和不等 <code>!=</code> ，大于 <code>&gt;</code> 和大于等于 <code>&gt;=</code> ，小于 <code>&lt;</code> 和小于等于 <code>&lt;=</code> 。</p>\n<pre><code class=\"swift\">1 == 2 // false\n1 &lt;= 2 // true</code></pre>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>逻辑运算符包括逻辑非 <code>!</code>，逻辑与 <code>&amp;&amp;</code> 和逻辑或 <code>||</code> ，常用于条件判断。</p>\n<pre><code class=\"swift\">let foo = true\nlet bar = false\n!foo       // false，foo 不为真时返回 true。\nfoo &amp;&amp; bar // false，foo、bar 皆为真时返回 true。\nfoo || bar // false，foo、bar 中有一个为真时返回 true。</code></pre>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><p>三元运算符判断一个条件表达式，<code>true</code> 时执行 <code>:</code> 前面的表达式，否则执行 <code>:</code> 后面的表达式。</p>\n<pre><code class=\"swift\">let raining = true\nlet wheather = raining ? &quot;Rainy&quot; : &quot;Sunny&quot; // Rainy</code></pre>\n<h3 id=\"区间运算符\"><a href=\"#区间运算符\" class=\"headerlink\" title=\"区间运算符\"></a>区间运算符</h3><p>区间运算符用于表示一个整数的集合。</p>\n<pre><code class=\"swift\">a...b // 相当于数学上的 [a, b]\na..&lt;b // 相当于数学上的 [a, b)</code></pre>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>使用 <code>func</code> 声明函数。</p>\n<pre><code class=\"swift\">let text = &quot;This is a log.&quot;\nfunc log(msg: String) {\n    print(msg)\n}\nlog(msg: text)\n// This is a log.</code></pre>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>Swift 4 提供了 <code>if</code>、<code>switch</code> 条件语句，以及 <code>for-in</code>、<code>while</code>、<code>repeat-while</code> 循环语句。</p>\n<ul>\n<li>使用 if / switch 制造条件。</li>\n<li>使用 for-in / while / repeat-while 制造循环。</li>\n<li>Swift 3 起废弃了常见的 C 语言风格的 for 循环。</li>\n<li>同样支持使用 break 结束循环，使用 continue 结束当前循环并进入下一次循环。</li>\n</ul>\n<h3 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h3><p><code>if</code> 语句的条件不需要用 <code>()</code> 包裹。即使只有一个语句，<code>{}</code> 也不能省略。</p>\n<pre><code class=\"swift\">let wheather = &quot;rainy&quot;\nif wheather == &quot;rainy&quot; {\n    print(&quot;It will rain today.&quot;);\n} else {\n    print(&quot;It won&#39;t rain today.&quot;);\n}\n// It will rain today.</code></pre>\n<h3 id=\"guard-语句\"><a href=\"#guard-语句\" class=\"headerlink\" title=\"guard 语句\"></a>guard 语句</h3><p>在使用其他语言的过程中，经常会遇到嵌套 <code>if</code> 语句的情况，影响代码的可读性。</p>\n<p>Swift 中的 <code>guard</code> 语句解决了这个问题。<code>guard</code> 语句判断一个条件，只有条件成立时才能执行 <code>guard</code> 语句之后的代码，否则执行 <code>else</code> 子句中的代码。我们可以优雅的把不符合继续执行的条件放在一个方法的前面处理。</p>\n<pre><code class=\"swift\">let wheather = &quot;sunny&quot;\nfunc todo() {\n    guard wheather == &quot;sunny&quot; else {\n        return\n    }\n    print(&quot;Go sports.&quot;)\n}\ntodo()\n// Go sports.</code></pre>\n<h3 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h3><p>Swift 中的 <code>switch</code> 语句只会执行一个 <code>case</code> ，所以不需要像其他语言那样使用 <code>break</code> 手动结束循环。另外，一个 <code>case</code> 可以对应多个值，使用逗号分隔。</p>\n<p>使用 <code>switch</code> 语句判断一周中的某一天应该做什么事。</p>\n<pre><code class=\"swift\">let day = &quot;Monday&quot;\nswitch day  {\ncase &quot;Friday&quot;:\n    print(&quot;Go shopping.&quot;)\n    break // 冗余\ncase &quot;Saturday&quot;, &quot;Sunday&quot;:\n    print(&quot;Go sports.&quot;)\ndefault:\n    print(&quot;Go to work.&quot;)\n}\n// Go to work.</code></pre>\n<p>使用 <code>fallthrough</code> 关键字可以在循环结束后继续执行下一个 <code>case</code> 的代码块。</p>\n<pre><code class=\"swift\">let num = true\nswitch num  {\ncase true:\n    print(&quot;true&quot;, terminator: &quot; &quot;)\n    fallthrough\ncase false:\n    print(&quot;false&quot;, terminator: &quot; &quot;)\n}\n// true false</code></pre>\n<p><code>case</code> 可以使用 <code>where</code> 子句进一步限定条件。例如，判断一个整数是否介于 5 到 10 之间，并且是一个偶数。</p>\n<pre><code class=\"swift\">let num = 8\nswitch num {\ncase 5...10 where num % 2 == 0 :\n    print(true)\ndefault:\n    print(false)\n}\n// true</code></pre>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>遍历一个区间，计算 1-100 的累加结果。</p>\n<pre><code class=\"swift\">var sum = 0\nfor i in 1...100 {\n    sum += i\n}\nprint(sum) // 5050</code></pre>\n<p>遍历一个数组，打印一个拼接的字符串。</p>\n<pre><code class=\"swift\">var string = &quot;&quot;\nfor item in [&quot;Hello&quot;, &quot;World&quot;, &quot;Swift&quot;] {\n    string += item\n}\nprint(string) // HelloWorldSwift</code></pre>\n<h3 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h3><p>打印 1-10 之间的整数。</p>\n<pre><code class=\"swift\">var i = 1\nwhile i &lt;= 10 {\n    print(i, terminator: &quot; &quot;)\n    i += 1\n}\n// 1 2 3 4 5 6 7 8 9 10</code></pre>\n<h3 id=\"repeat-while-循环\"><a href=\"#repeat-while-循环\" class=\"headerlink\" title=\"repeat-while 循环\"></a>repeat-while 循环</h3><p><code>repeat-while</code> 类似其他语言中的 <code>do-while</code> 循环，即先执行代码，再判断是否符合条件。如果条件成立，继续循环，否则跳出循环。<code>repeat-while</code> 中的循环体至少会执行一次。</p>\n<p>使用 <code>repeat-while</code> 语句打印 1-10 之间的整数。</p>\n<pre><code class=\"swift\">var i = 1\nrepeat {\n    print(i, terminator: &quot; &quot;)\n    i += 1\n} while i &lt;= 10\n// 1 2 3 4 5 6 7 8 9 10</code></pre>"},{"title":"Serverless 上车指南","date":"2019-11-24T05:01:51.000Z","_content":"\n> Build and run applications without thinking about servers. —— AWS\n\n## 什么是 Serverless\n\nServerless，即无服务器计算，是一种云架构。Serverless 服务由一系列服务构成，包括计算服务、存储服务、数据库服务、API 网关服务等。\n\n<!-- more -->\n\n它使开发者能够将更多运维职责转移给云，在不考虑服务器的情况下，构建并运行应用程序和服务。同时，支持几乎任何类型的应用或后端服务。\n\n**用简单的话说就是：用各种服务代替服务器，你充值就可以了。**\n\n{% img no-border /images/posts/2019/11/serverless_intro.jpg 540 Serverless %}\n\nServerless 的优势包括：无需维护服务器，可灵活拓展，按量付费（通常是按调用次数和流量），内置可用性和容错功能，以及 —— 环保。\n\n<center>（前方高能我要上价值）</center>\n&nbsp;\n\n据《福布斯》杂志统计，典型服务器的计算能力仅有 5%~15% 的利用率。可想而知，Serverless 架构将使人类更有效率地利用计算资源，减少温室气体排放。\n\n注：可用性是指读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。容错是指单台或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务。\n\n目前提供 Serverless 的云服务商有 AWS、阿里云、腾讯云等等。2014 年发布的 AWS Lambda 是首个公有云无服务器计算服务。\n\n发展里程碑：\n\n- 2012 Iron.io 联合创始人 Ken Fromm 提出“软件的未来是 Serverless” \n\n- 2014 首个无服务器计算产品 AWS Lambda 发布\n\n- 2016 百花齐放：Google Cloud Functions、IBM Cloud Functions、Azure Functions\n\n- 2016 IBM 发布开源无服务器计算平台 OpenWhisk\n\n现在，当人们提到 Serverless 的时候，通常也提及另一个词 —— **FaaS**，虽然不够严谨，但现时这两个概念几乎可以画上等号。**FaaS 是构建无服务器架构的一种方式，负责提供其中的“计算服务”。**它计算逻辑，但不存储数据。\n\n在进一步了解 FaaS 之前，我认为最好先回顾一下云计算的几种类型。\n\n## **云计算类型回顾**\n\nIBM 软件架构师 Albert Barron 曾用披萨作为比喻，解释这些云服务的区别。显然，这个图表还不够具体。但是它清晰地呈现了这些云计算服务渐进的变化：开发者需要考虑的东西越来越少，专注开发本身。\n\n{% img no-border /images/posts/2019/11/serverless_pizza_as_a_service.jpg 540 Serverless Framework %}\n\n上图提到的几种类型：\n\nIaaS （Infrastructure as a Service）是基础设施即服务，只提供最少量的服务，诸如网络和云主机这些基础设施，你需要登录上去自己安装系统、运行环境，还有数据库软件。典型产品有 AWS EC2、阿里云 ECS、腾讯云 CVM。\n\nPaaS（Platform as a Service）是平台即服务，运行环境和数据库也给你准备好了，你只需上传代码包和一些配置文件。典型产品有 Google App Engine、Sina App Engine、Baidu App Engine。\n\nSaaS（Software as a Service）是软件即服务，拿到手就能用的东西。典型产品有企业微信、企业邮箱。\n\nIaaS 只提供最少的服务，但并不见得省钱。我个人认为它是对前端来说最不友好的服务，大部分时候只用到它资源的冰山一角，却要学习不少与开发无关的东西。对于 PaaS，基于我过去的一些使用体验，开发者仍需要写 Nginx 配置，需要考虑用什么框架去组织代码，部署和伸缩的维度是整个项目。\n\n那么是否存在更理想（可以偷懒）的计算服务呢？答案就是 FaaS，我认为它介于 PaaS 和 SasS 之间。\n\n## 什么是 FaaS\n\nFaaS（Function as a Service）是指函数即服务，是一种云计算服务。它提供一个平台，允许使用者**开发、运行和管理应用程序功能，而无需构建和维护基础设施。**\n\n{% img no-border /images/posts/2019/11/serverless_faas.jpg 540 FaaS %}\n\n**FaaS 是基于事件驱动的。**不同于传统服务端软件需要长时间运行，FaaS 平台部署的函数仅在事件触发时执行。以 AWS Lambda 为例，当平台收到一个事件时，它将启动一个容器运行你的函数，执行完毕后即释放资源。\n\n因此，不同于 IaaS 需要为固定的硬件和带宽付费，FaaS 通常只需要按请求数量和流量付费。\n\n**FaaS 和 PaaS 的概念是很相似的，他们最大的差异在于伸缩能力。**PaaS 应用无法在具体请求的层面上进行伸缩，所以 FaaS 应用的成本效益更高。AWS 云架构战略副总裁 Adrian Cockcroft 如此界定两者：如果你的 PaaS 能够有效地在20毫秒内启动实例并运行半秒，那么就可以称之为 Serverless。\n\n目前我们可以选择的典型 FaaS 服务包括：AWS Lambda、阿里云函数计算、腾讯云云函数。\n\n## 构建和管理 Serverless 应用\n\n有了 FaaS 云计算服务，我们要如何构建和管理后端应用程序呢？最直接的办法，是在云服务商提供的控制台上编写和部署函数，但这显然不够科学。\n\n**Serverless Framework 是一个构建和管理 Serverless 应用的完整解决方案。**2015 年，Serverless Framework 开源项目发布。直到今天，它已然成为开发者在 FaaS 平台上部署应用的主要方式。\n\n{% img no-border /images/posts/2019/11/serverless_serverless_framework.jpg 540 Serverless Framework %}\n\n**简单的说，你在本地写好的函数，用命令行就能部署到云服务商提供的 FaaS 服务中。**\n\n## Serverless 初体验\n\n为更进一步了解 Serverless 应用程序的开发，我摸索了一下 Serverless Framework 搭配云函数（腾讯云）的使用姿势。我认为，体验可以用“有点儿爽”来形容。\n\n{% img /images/posts/2019/11/serverless_practice.jpg 320 Talk is cheap %}\n\n**首先，需要在云函数控制台上创建一个函数，帮助我们自动配置“角色”，用于向云函数提供对接腾讯云上其他资源的权限。**因为后续用 Serverless Framework 部署函数的时候，会先打包上传到对象存储服务（踩坑后才知道的）。\n\n选择预置的 HelloWorld 函数部署就可以了。给函数配置一种触发器，我选择的是 API 网关触发。跟随提示很容易配置了 API 网关，保存，随后便得到了一个链接。和预想的一样，访问这个链接函数就会执行，浏览器上输出了代码中打印的内容。\n\n{% img /images/posts/2019/11/serverless_scf_trigger.jpg 480 云函数触发器 %}\n\n接着，运行如下命令全局安装 Serverless Framework CLI：\n\n```\nnpm install -g serverless\n```\n\n紧接着创建一个名为 example 的新项目 —— 也称为服务，安装依赖。\n\n```\nserverless create --template tencent-nodejs --path example\ncd example\nnpm install\n```\n\n服务的目录结构简单到不行，除去 npm 相关的只剩下两个文件。`serverless.yml` 是配置文件，暂时只需要知道写好的函数在这里引用就行了。`index.js` 就是你写函数的地方。\n\n```\n├── index.js\n└── serverless.yml\n```\n\n然后，参考 [这里](https://cloud.tencent.com/document/product/1154/38811) 在本地创建一个 `~/credentials` 文件，写入腾讯云账号的鉴权凭证。确保文件路径和项目配置文件 `serverless.yml` 中声明的一致。\n\n```\n[default]\ntencent_appid = appid\ntencent_secret_id = secretid\ntencent_secret_key = secretkey\n```\n\n恭喜！你已经可以部署函数上云了。\n\n默认情况下，这个服务中已经包含了一个 HelloWorld 函数。我们直接修改配置文件，给这个函数加上一个触发器。\n\n```yaml\nfunctions:\n  function_one:\n    handler: index.main_handler\n    description: My First Serverless Function # 函数描述\n    events:\n      - apigw:\n          parameters:\n            stageName: release     # 部署环境\n            serviceId: service-xxx # API 网关服务 ID\n            httpMethod: POST       # HTTP 方法\n```\n\n箭在弦上，执行以下命令部署函数。\n\n```\nserverless deploy\n```\n\n执行部署命令后将生成一个 `.serverless` 目录，打包好的函数就放在这个目录下，它们将被自动上传到对象存储服务，随后完成代码的部署。\n\n{% img /images/posts/2019/11/serverless_serverless_framework_deploy.jpg 540 Serverless Framework 部署 %}\n\n终端上打印出了新部署的函数信息。可能遇到了什么问题，没有像预期的那样部署到 release 环境，但是这个 API 已经能够正常使用了。\n\n除了部署，你应该还会用到这些命令：\n\n```sh\nserverless deploy -f function_one  # 重新部署函数\nserverless invoke -f function_one  # 调用云端函数\nserverless logs -f function_one -t # 实时获取函数的云端调用日志\nserverless remove                  # 移除整个服务\n```\n\n随后我反复多次修改触发器，然后用 `deploy -f` 命令部署，发现**存量触发器并不会删除，而是在原有基础上增加新的触发器**。一开始这个设定令我感到不解，它意味着不能做到把一个接口直接从 `GET` 改成 `POST`，但同时也避免了一个误操作导致事故。在我提单询问是否支持覆盖配置后，腾讯云运维小哥表示记录下了这个需求。\n\n## 搭建 Serverless 平台\n\n除了直接使用云服务商提供的 FaaS 服务，我们可以搭建自己的 Serverless 平台吗？答案就是前文中提到的开源项目 —— OpenWhisk。\n\n### OpenWhisk 简介\n\nOpenWhisk 是一个事件驱动的计算平台，也被称为 Serverless 或 FaaS，它在事件触发或直接调用时执行代码。\n\n{% img no-border /images/posts/2019/11/serverless_openwhisk.jpg 540 OpenWhisk %}       \n\n事件（Event）是我们可以响应的一些行为。包括：收到一个 HTTP 请求，数据库记录发生变化，温度传感器检测到温度过高，GitHub 仓库提交了新代码……诸如此类。\n\n操作（Action）是指代码片段（可以理解为函数），或嵌入 Docker 容器中的二进制码。操作用于响应事件，当事件触发时，操作会立即部署并执行。换言之，不触发事件就不会执行代码，也就不会消耗服务器资源。\n\n触发器（Trigger）是一个特定的事件声明，可以人为触发也可以在满足条件的情况下自动触发。每个触发器都通过规则（Rule）与操作相关联。我们调用触发器，触发器定义的规则决定执行哪些操作。\n\n包（Package）用于与其他服务集成，例如团队协作工具 Slack，代码托管平台 GitHub，使这些平台上发生的一些事件能够触发我们的触发器。\n\n### OpenWhisk 工作原理\n\n作为一个开源项目，OpenWhisk 站在巨人的肩膀上，包括 Nginx，Kafka，Docker，CouchDB。**这些组件集合在一起构成了一个“基于事件的无服务器编程服务”。**\n\n{% img no-border /images/posts/2019/11/serverless_openwhisk_principle.jpg 450 OpenWhisk 工作原理 %} \n\nOpenWhisk 提供基于 HTTP，遵循 RESTful 设计的面向用户的 API。\n\n用户的请求首先经过 Nginx —— 一个高性能的 Web 服务器，它主要用作 SSL 终端，负责请求的解密和响应的加密，以及转发请求到下一个组件。\n\n紧接着，请求到达控制器（Controller），在这里被解析成“对操作的调用”。控制器先通过请求中的信息识别用户身份，确认他有权调用这个操作。然后从数据库（CouchDB）加载操作。每个操作在数据库中的记录包含：代码、默认参数、资源限制等信息。\n\n然后，作为控制器一部分的负载均衡器（Load Balancer）—— 负责持续检查调用器（Invoker）的健康状况，会选择一个可用的调用器来调用操作。\n\n控制器和调用器间使用 Kafka 通信，其缓冲和持久化功能，帮助解决系统崩溃导致消息丢失，以及高负载阻塞调用的问题。一旦 Kafka 收到消息，就会对用户的 HTTP 请求响应一个 ActivationId，用户将在稍后使用它异步地查询操作调用的结果。\n\n**最后，OpenWhisk 的心脏 —— 基于 Docker 实现的调用器执行代码。Docker 建立起的自封装环境使每个操作以迅速、隔离和可控的方式调用。**每一次操作调用都会产生一个新容器，随后注入代码，执行完毕就销毁。\n\n\n\n### OpenWhisk 体验\n\n无！:(\n\n很遗憾，试了几种方式都没能部署成功。不过这已经不重要了。因为部署 OpenWhisk 不会是企业使用 FaaS 的首选，这显然不够“Serverless”，也违背了让我们考虑得更少的初衷。\n\n**或许你更应该考虑的是：选择哪一家云服务商提供的 Serverless 服务。**\n\n&nbsp;\n\n## 参考资料\n\n部分参考资料如下：\n\n- [Serverless Computing - AWS](https://aws.amazon.com/serverless/)\n- [从 IaaS 到 FaaS —— Serverless 架构的前世今生 - AWS](https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/)\n- [IaaS，PaaS，SaaS 的区别 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html)\n- [什么是 Serverless 架构和 FaaS 函数即服务？- 知乎专栏](https://zhuanlan.zhihu.com/p/31386919)\n- [Function as a service - Wikipedia](https://en.wikipedia.org/wiki/Function_as_a_service)\n- [Serverless Framework 快速入门 - 腾讯云](https://cloud.tencent.com/document/product/1154/39005)\n- [OpenWhisk 简介：轻松创建微服务 - IBM](https://www.ibm.com/developerworks/cn/opensource/os-introducing-openwhisk-microservices-made-easy/)\n\n&nbsp;","source":"_posts/2019-11-24@Serverless 上车指南.md","raw":"---\ntitle: Serverless 上车指南\ndate: 2019-11-24 13:01:51\ncategories:\n  - Web Back-end\ntags:\n  - Serverless\n  - FaaS\n  - OpenWhisk\n---\n\n> Build and run applications without thinking about servers. —— AWS\n\n## 什么是 Serverless\n\nServerless，即无服务器计算，是一种云架构。Serverless 服务由一系列服务构成，包括计算服务、存储服务、数据库服务、API 网关服务等。\n\n<!-- more -->\n\n它使开发者能够将更多运维职责转移给云，在不考虑服务器的情况下，构建并运行应用程序和服务。同时，支持几乎任何类型的应用或后端服务。\n\n**用简单的话说就是：用各种服务代替服务器，你充值就可以了。**\n\n{% img no-border /images/posts/2019/11/serverless_intro.jpg 540 Serverless %}\n\nServerless 的优势包括：无需维护服务器，可灵活拓展，按量付费（通常是按调用次数和流量），内置可用性和容错功能，以及 —— 环保。\n\n<center>（前方高能我要上价值）</center>\n&nbsp;\n\n据《福布斯》杂志统计，典型服务器的计算能力仅有 5%~15% 的利用率。可想而知，Serverless 架构将使人类更有效率地利用计算资源，减少温室气体排放。\n\n注：可用性是指读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。容错是指单台或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务。\n\n目前提供 Serverless 的云服务商有 AWS、阿里云、腾讯云等等。2014 年发布的 AWS Lambda 是首个公有云无服务器计算服务。\n\n发展里程碑：\n\n- 2012 Iron.io 联合创始人 Ken Fromm 提出“软件的未来是 Serverless” \n\n- 2014 首个无服务器计算产品 AWS Lambda 发布\n\n- 2016 百花齐放：Google Cloud Functions、IBM Cloud Functions、Azure Functions\n\n- 2016 IBM 发布开源无服务器计算平台 OpenWhisk\n\n现在，当人们提到 Serverless 的时候，通常也提及另一个词 —— **FaaS**，虽然不够严谨，但现时这两个概念几乎可以画上等号。**FaaS 是构建无服务器架构的一种方式，负责提供其中的“计算服务”。**它计算逻辑，但不存储数据。\n\n在进一步了解 FaaS 之前，我认为最好先回顾一下云计算的几种类型。\n\n## **云计算类型回顾**\n\nIBM 软件架构师 Albert Barron 曾用披萨作为比喻，解释这些云服务的区别。显然，这个图表还不够具体。但是它清晰地呈现了这些云计算服务渐进的变化：开发者需要考虑的东西越来越少，专注开发本身。\n\n{% img no-border /images/posts/2019/11/serverless_pizza_as_a_service.jpg 540 Serverless Framework %}\n\n上图提到的几种类型：\n\nIaaS （Infrastructure as a Service）是基础设施即服务，只提供最少量的服务，诸如网络和云主机这些基础设施，你需要登录上去自己安装系统、运行环境，还有数据库软件。典型产品有 AWS EC2、阿里云 ECS、腾讯云 CVM。\n\nPaaS（Platform as a Service）是平台即服务，运行环境和数据库也给你准备好了，你只需上传代码包和一些配置文件。典型产品有 Google App Engine、Sina App Engine、Baidu App Engine。\n\nSaaS（Software as a Service）是软件即服务，拿到手就能用的东西。典型产品有企业微信、企业邮箱。\n\nIaaS 只提供最少的服务，但并不见得省钱。我个人认为它是对前端来说最不友好的服务，大部分时候只用到它资源的冰山一角，却要学习不少与开发无关的东西。对于 PaaS，基于我过去的一些使用体验，开发者仍需要写 Nginx 配置，需要考虑用什么框架去组织代码，部署和伸缩的维度是整个项目。\n\n那么是否存在更理想（可以偷懒）的计算服务呢？答案就是 FaaS，我认为它介于 PaaS 和 SasS 之间。\n\n## 什么是 FaaS\n\nFaaS（Function as a Service）是指函数即服务，是一种云计算服务。它提供一个平台，允许使用者**开发、运行和管理应用程序功能，而无需构建和维护基础设施。**\n\n{% img no-border /images/posts/2019/11/serverless_faas.jpg 540 FaaS %}\n\n**FaaS 是基于事件驱动的。**不同于传统服务端软件需要长时间运行，FaaS 平台部署的函数仅在事件触发时执行。以 AWS Lambda 为例，当平台收到一个事件时，它将启动一个容器运行你的函数，执行完毕后即释放资源。\n\n因此，不同于 IaaS 需要为固定的硬件和带宽付费，FaaS 通常只需要按请求数量和流量付费。\n\n**FaaS 和 PaaS 的概念是很相似的，他们最大的差异在于伸缩能力。**PaaS 应用无法在具体请求的层面上进行伸缩，所以 FaaS 应用的成本效益更高。AWS 云架构战略副总裁 Adrian Cockcroft 如此界定两者：如果你的 PaaS 能够有效地在20毫秒内启动实例并运行半秒，那么就可以称之为 Serverless。\n\n目前我们可以选择的典型 FaaS 服务包括：AWS Lambda、阿里云函数计算、腾讯云云函数。\n\n## 构建和管理 Serverless 应用\n\n有了 FaaS 云计算服务，我们要如何构建和管理后端应用程序呢？最直接的办法，是在云服务商提供的控制台上编写和部署函数，但这显然不够科学。\n\n**Serverless Framework 是一个构建和管理 Serverless 应用的完整解决方案。**2015 年，Serverless Framework 开源项目发布。直到今天，它已然成为开发者在 FaaS 平台上部署应用的主要方式。\n\n{% img no-border /images/posts/2019/11/serverless_serverless_framework.jpg 540 Serverless Framework %}\n\n**简单的说，你在本地写好的函数，用命令行就能部署到云服务商提供的 FaaS 服务中。**\n\n## Serverless 初体验\n\n为更进一步了解 Serverless 应用程序的开发，我摸索了一下 Serverless Framework 搭配云函数（腾讯云）的使用姿势。我认为，体验可以用“有点儿爽”来形容。\n\n{% img /images/posts/2019/11/serverless_practice.jpg 320 Talk is cheap %}\n\n**首先，需要在云函数控制台上创建一个函数，帮助我们自动配置“角色”，用于向云函数提供对接腾讯云上其他资源的权限。**因为后续用 Serverless Framework 部署函数的时候，会先打包上传到对象存储服务（踩坑后才知道的）。\n\n选择预置的 HelloWorld 函数部署就可以了。给函数配置一种触发器，我选择的是 API 网关触发。跟随提示很容易配置了 API 网关，保存，随后便得到了一个链接。和预想的一样，访问这个链接函数就会执行，浏览器上输出了代码中打印的内容。\n\n{% img /images/posts/2019/11/serverless_scf_trigger.jpg 480 云函数触发器 %}\n\n接着，运行如下命令全局安装 Serverless Framework CLI：\n\n```\nnpm install -g serverless\n```\n\n紧接着创建一个名为 example 的新项目 —— 也称为服务，安装依赖。\n\n```\nserverless create --template tencent-nodejs --path example\ncd example\nnpm install\n```\n\n服务的目录结构简单到不行，除去 npm 相关的只剩下两个文件。`serverless.yml` 是配置文件，暂时只需要知道写好的函数在这里引用就行了。`index.js` 就是你写函数的地方。\n\n```\n├── index.js\n└── serverless.yml\n```\n\n然后，参考 [这里](https://cloud.tencent.com/document/product/1154/38811) 在本地创建一个 `~/credentials` 文件，写入腾讯云账号的鉴权凭证。确保文件路径和项目配置文件 `serverless.yml` 中声明的一致。\n\n```\n[default]\ntencent_appid = appid\ntencent_secret_id = secretid\ntencent_secret_key = secretkey\n```\n\n恭喜！你已经可以部署函数上云了。\n\n默认情况下，这个服务中已经包含了一个 HelloWorld 函数。我们直接修改配置文件，给这个函数加上一个触发器。\n\n```yaml\nfunctions:\n  function_one:\n    handler: index.main_handler\n    description: My First Serverless Function # 函数描述\n    events:\n      - apigw:\n          parameters:\n            stageName: release     # 部署环境\n            serviceId: service-xxx # API 网关服务 ID\n            httpMethod: POST       # HTTP 方法\n```\n\n箭在弦上，执行以下命令部署函数。\n\n```\nserverless deploy\n```\n\n执行部署命令后将生成一个 `.serverless` 目录，打包好的函数就放在这个目录下，它们将被自动上传到对象存储服务，随后完成代码的部署。\n\n{% img /images/posts/2019/11/serverless_serverless_framework_deploy.jpg 540 Serverless Framework 部署 %}\n\n终端上打印出了新部署的函数信息。可能遇到了什么问题，没有像预期的那样部署到 release 环境，但是这个 API 已经能够正常使用了。\n\n除了部署，你应该还会用到这些命令：\n\n```sh\nserverless deploy -f function_one  # 重新部署函数\nserverless invoke -f function_one  # 调用云端函数\nserverless logs -f function_one -t # 实时获取函数的云端调用日志\nserverless remove                  # 移除整个服务\n```\n\n随后我反复多次修改触发器，然后用 `deploy -f` 命令部署，发现**存量触发器并不会删除，而是在原有基础上增加新的触发器**。一开始这个设定令我感到不解，它意味着不能做到把一个接口直接从 `GET` 改成 `POST`，但同时也避免了一个误操作导致事故。在我提单询问是否支持覆盖配置后，腾讯云运维小哥表示记录下了这个需求。\n\n## 搭建 Serverless 平台\n\n除了直接使用云服务商提供的 FaaS 服务，我们可以搭建自己的 Serverless 平台吗？答案就是前文中提到的开源项目 —— OpenWhisk。\n\n### OpenWhisk 简介\n\nOpenWhisk 是一个事件驱动的计算平台，也被称为 Serverless 或 FaaS，它在事件触发或直接调用时执行代码。\n\n{% img no-border /images/posts/2019/11/serverless_openwhisk.jpg 540 OpenWhisk %}       \n\n事件（Event）是我们可以响应的一些行为。包括：收到一个 HTTP 请求，数据库记录发生变化，温度传感器检测到温度过高，GitHub 仓库提交了新代码……诸如此类。\n\n操作（Action）是指代码片段（可以理解为函数），或嵌入 Docker 容器中的二进制码。操作用于响应事件，当事件触发时，操作会立即部署并执行。换言之，不触发事件就不会执行代码，也就不会消耗服务器资源。\n\n触发器（Trigger）是一个特定的事件声明，可以人为触发也可以在满足条件的情况下自动触发。每个触发器都通过规则（Rule）与操作相关联。我们调用触发器，触发器定义的规则决定执行哪些操作。\n\n包（Package）用于与其他服务集成，例如团队协作工具 Slack，代码托管平台 GitHub，使这些平台上发生的一些事件能够触发我们的触发器。\n\n### OpenWhisk 工作原理\n\n作为一个开源项目，OpenWhisk 站在巨人的肩膀上，包括 Nginx，Kafka，Docker，CouchDB。**这些组件集合在一起构成了一个“基于事件的无服务器编程服务”。**\n\n{% img no-border /images/posts/2019/11/serverless_openwhisk_principle.jpg 450 OpenWhisk 工作原理 %} \n\nOpenWhisk 提供基于 HTTP，遵循 RESTful 设计的面向用户的 API。\n\n用户的请求首先经过 Nginx —— 一个高性能的 Web 服务器，它主要用作 SSL 终端，负责请求的解密和响应的加密，以及转发请求到下一个组件。\n\n紧接着，请求到达控制器（Controller），在这里被解析成“对操作的调用”。控制器先通过请求中的信息识别用户身份，确认他有权调用这个操作。然后从数据库（CouchDB）加载操作。每个操作在数据库中的记录包含：代码、默认参数、资源限制等信息。\n\n然后，作为控制器一部分的负载均衡器（Load Balancer）—— 负责持续检查调用器（Invoker）的健康状况，会选择一个可用的调用器来调用操作。\n\n控制器和调用器间使用 Kafka 通信，其缓冲和持久化功能，帮助解决系统崩溃导致消息丢失，以及高负载阻塞调用的问题。一旦 Kafka 收到消息，就会对用户的 HTTP 请求响应一个 ActivationId，用户将在稍后使用它异步地查询操作调用的结果。\n\n**最后，OpenWhisk 的心脏 —— 基于 Docker 实现的调用器执行代码。Docker 建立起的自封装环境使每个操作以迅速、隔离和可控的方式调用。**每一次操作调用都会产生一个新容器，随后注入代码，执行完毕就销毁。\n\n\n\n### OpenWhisk 体验\n\n无！:(\n\n很遗憾，试了几种方式都没能部署成功。不过这已经不重要了。因为部署 OpenWhisk 不会是企业使用 FaaS 的首选，这显然不够“Serverless”，也违背了让我们考虑得更少的初衷。\n\n**或许你更应该考虑的是：选择哪一家云服务商提供的 Serverless 服务。**\n\n&nbsp;\n\n## 参考资料\n\n部分参考资料如下：\n\n- [Serverless Computing - AWS](https://aws.amazon.com/serverless/)\n- [从 IaaS 到 FaaS —— Serverless 架构的前世今生 - AWS](https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/)\n- [IaaS，PaaS，SaaS 的区别 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html)\n- [什么是 Serverless 架构和 FaaS 函数即服务？- 知乎专栏](https://zhuanlan.zhihu.com/p/31386919)\n- [Function as a service - Wikipedia](https://en.wikipedia.org/wiki/Function_as_a_service)\n- [Serverless Framework 快速入门 - 腾讯云](https://cloud.tencent.com/document/product/1154/39005)\n- [OpenWhisk 简介：轻松创建微服务 - IBM](https://www.ibm.com/developerworks/cn/opensource/os-introducing-openwhisk-microservices-made-easy/)\n\n&nbsp;","slug":"2019-11-24@Serverless 上车指南","published":1,"updated":"2020-06-29T03:32:42.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4bw00f8rqgj35hzcy1c","content":"<blockquote>\n<p>Build and run applications without thinking about servers. —— AWS</p>\n</blockquote>\n<h2 id=\"什么是-Serverless\"><a href=\"#什么是-Serverless\" class=\"headerlink\" title=\"什么是 Serverless\"></a>什么是 Serverless</h2><p>Serverless，即无服务器计算，是一种云架构。Serverless 服务由一系列服务构成，包括计算服务、存储服务、数据库服务、API 网关服务等。</p>\n<a id=\"more\"></a>\n\n<p>它使开发者能够将更多运维职责转移给云，在不考虑服务器的情况下，构建并运行应用程序和服务。同时，支持几乎任何类型的应用或后端服务。</p>\n<p><strong>用简单的话说就是：用各种服务代替服务器，你充值就可以了。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_intro.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless\">\n\n<p>Serverless 的优势包括：无需维护服务器，可灵活拓展，按量付费（通常是按调用次数和流量），内置可用性和容错功能，以及 —— 环保。</p>\n<center>（前方高能我要上价值）</center>\n&nbsp;\n\n<p>据《福布斯》杂志统计，典型服务器的计算能力仅有 5%~15% 的利用率。可想而知，Serverless 架构将使人类更有效率地利用计算资源，减少温室气体排放。</p>\n<p>注：可用性是指读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。容错是指单台或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务。</p>\n<p>目前提供 Serverless 的云服务商有 AWS、阿里云、腾讯云等等。2014 年发布的 AWS Lambda 是首个公有云无服务器计算服务。</p>\n<p>发展里程碑：</p>\n<ul>\n<li><p>2012 Iron.io 联合创始人 Ken Fromm 提出“软件的未来是 Serverless” </p>\n</li>\n<li><p>2014 首个无服务器计算产品 AWS Lambda 发布</p>\n</li>\n<li><p>2016 百花齐放：Google Cloud Functions、IBM Cloud Functions、Azure Functions</p>\n</li>\n<li><p>2016 IBM 发布开源无服务器计算平台 OpenWhisk</p>\n</li>\n</ul>\n<p>现在，当人们提到 Serverless 的时候，通常也提及另一个词 —— <strong>FaaS</strong>，虽然不够严谨，但现时这两个概念几乎可以画上等号。<strong>FaaS 是构建无服务器架构的一种方式，负责提供其中的“计算服务”。</strong>它计算逻辑，但不存储数据。</p>\n<p>在进一步了解 FaaS 之前，我认为最好先回顾一下云计算的几种类型。</p>\n<h2 id=\"云计算类型回顾\"><a href=\"#云计算类型回顾\" class=\"headerlink\" title=\"云计算类型回顾\"></a><strong>云计算类型回顾</strong></h2><p>IBM 软件架构师 Albert Barron 曾用披萨作为比喻，解释这些云服务的区别。显然，这个图表还不够具体。但是它清晰地呈现了这些云计算服务渐进的变化：开发者需要考虑的东西越来越少，专注开发本身。</p>\n<img src=\"/images/posts/2019/11/serverless_pizza_as_a_service.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless Framework\">\n\n<p>上图提到的几种类型：</p>\n<p>IaaS （Infrastructure as a Service）是基础设施即服务，只提供最少量的服务，诸如网络和云主机这些基础设施，你需要登录上去自己安装系统、运行环境，还有数据库软件。典型产品有 AWS EC2、阿里云 ECS、腾讯云 CVM。</p>\n<p>PaaS（Platform as a Service）是平台即服务，运行环境和数据库也给你准备好了，你只需上传代码包和一些配置文件。典型产品有 Google App Engine、Sina App Engine、Baidu App Engine。</p>\n<p>SaaS（Software as a Service）是软件即服务，拿到手就能用的东西。典型产品有企业微信、企业邮箱。</p>\n<p>IaaS 只提供最少的服务，但并不见得省钱。我个人认为它是对前端来说最不友好的服务，大部分时候只用到它资源的冰山一角，却要学习不少与开发无关的东西。对于 PaaS，基于我过去的一些使用体验，开发者仍需要写 Nginx 配置，需要考虑用什么框架去组织代码，部署和伸缩的维度是整个项目。</p>\n<p>那么是否存在更理想（可以偷懒）的计算服务呢？答案就是 FaaS，我认为它介于 PaaS 和 SasS 之间。</p>\n<h2 id=\"什么是-FaaS\"><a href=\"#什么是-FaaS\" class=\"headerlink\" title=\"什么是 FaaS\"></a>什么是 FaaS</h2><p>FaaS（Function as a Service）是指函数即服务，是一种云计算服务。它提供一个平台，允许使用者<strong>开发、运行和管理应用程序功能，而无需构建和维护基础设施。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_faas.jpg\" class=\"no-border\" width=\"540\" title=\"FaaS\">\n\n<p><strong>FaaS 是基于事件驱动的。</strong>不同于传统服务端软件需要长时间运行，FaaS 平台部署的函数仅在事件触发时执行。以 AWS Lambda 为例，当平台收到一个事件时，它将启动一个容器运行你的函数，执行完毕后即释放资源。</p>\n<p>因此，不同于 IaaS 需要为固定的硬件和带宽付费，FaaS 通常只需要按请求数量和流量付费。</p>\n<p><strong>FaaS 和 PaaS 的概念是很相似的，他们最大的差异在于伸缩能力。</strong>PaaS 应用无法在具体请求的层面上进行伸缩，所以 FaaS 应用的成本效益更高。AWS 云架构战略副总裁 Adrian Cockcroft 如此界定两者：如果你的 PaaS 能够有效地在20毫秒内启动实例并运行半秒，那么就可以称之为 Serverless。</p>\n<p>目前我们可以选择的典型 FaaS 服务包括：AWS Lambda、阿里云函数计算、腾讯云云函数。</p>\n<h2 id=\"构建和管理-Serverless-应用\"><a href=\"#构建和管理-Serverless-应用\" class=\"headerlink\" title=\"构建和管理 Serverless 应用\"></a>构建和管理 Serverless 应用</h2><p>有了 FaaS 云计算服务，我们要如何构建和管理后端应用程序呢？最直接的办法，是在云服务商提供的控制台上编写和部署函数，但这显然不够科学。</p>\n<p><strong>Serverless Framework 是一个构建和管理 Serverless 应用的完整解决方案。</strong>2015 年，Serverless Framework 开源项目发布。直到今天，它已然成为开发者在 FaaS 平台上部署应用的主要方式。</p>\n<img src=\"/images/posts/2019/11/serverless_serverless_framework.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless Framework\">\n\n<p><strong>简单的说，你在本地写好的函数，用命令行就能部署到云服务商提供的 FaaS 服务中。</strong></p>\n<h2 id=\"Serverless-初体验\"><a href=\"#Serverless-初体验\" class=\"headerlink\" title=\"Serverless 初体验\"></a>Serverless 初体验</h2><p>为更进一步了解 Serverless 应用程序的开发，我摸索了一下 Serverless Framework 搭配云函数（腾讯云）的使用姿势。我认为，体验可以用“有点儿爽”来形容。</p>\n<img src=\"/images/posts/2019/11/serverless_practice.jpg\" class=\"\" width=\"320\" title=\"Talk is cheap\">\n\n<p><strong>首先，需要在云函数控制台上创建一个函数，帮助我们自动配置“角色”，用于向云函数提供对接腾讯云上其他资源的权限。</strong>因为后续用 Serverless Framework 部署函数的时候，会先打包上传到对象存储服务（踩坑后才知道的）。</p>\n<p>选择预置的 HelloWorld 函数部署就可以了。给函数配置一种触发器，我选择的是 API 网关触发。跟随提示很容易配置了 API 网关，保存，随后便得到了一个链接。和预想的一样，访问这个链接函数就会执行，浏览器上输出了代码中打印的内容。</p>\n<img src=\"/images/posts/2019/11/serverless_scf_trigger.jpg\" class=\"\" width=\"480\" title=\"云函数触发器\">\n\n<p>接着，运行如下命令全局安装 Serverless Framework CLI：</p>\n<pre><code>npm install -g serverless</code></pre><p>紧接着创建一个名为 example 的新项目 —— 也称为服务，安装依赖。</p>\n<pre><code>serverless create --template tencent-nodejs --path example\ncd example\nnpm install</code></pre><p>服务的目录结构简单到不行，除去 npm 相关的只剩下两个文件。<code>serverless.yml</code> 是配置文件，暂时只需要知道写好的函数在这里引用就行了。<code>index.js</code> 就是你写函数的地方。</p>\n<pre><code>├── index.js\n└── serverless.yml</code></pre><p>然后，参考 <a href=\"https://cloud.tencent.com/document/product/1154/38811\" target=\"_blank\" rel=\"noopener\">这里</a> 在本地创建一个 <code>~/credentials</code> 文件，写入腾讯云账号的鉴权凭证。确保文件路径和项目配置文件 <code>serverless.yml</code> 中声明的一致。</p>\n<pre><code>[default]\ntencent_appid = appid\ntencent_secret_id = secretid\ntencent_secret_key = secretkey</code></pre><p>恭喜！你已经可以部署函数上云了。</p>\n<p>默认情况下，这个服务中已经包含了一个 HelloWorld 函数。我们直接修改配置文件，给这个函数加上一个触发器。</p>\n<pre><code class=\"yaml\">functions:\n  function_one:\n    handler: index.main_handler\n    description: My First Serverless Function # 函数描述\n    events:\n      - apigw:\n          parameters:\n            stageName: release     # 部署环境\n            serviceId: service-xxx # API 网关服务 ID\n            httpMethod: POST       # HTTP 方法</code></pre>\n<p>箭在弦上，执行以下命令部署函数。</p>\n<pre><code>serverless deploy</code></pre><p>执行部署命令后将生成一个 <code>.serverless</code> 目录，打包好的函数就放在这个目录下，它们将被自动上传到对象存储服务，随后完成代码的部署。</p>\n{% img /images/posts/2019/11/serverless_serverless_framework_deploy.jpg 540 Serverless Framework 部署 %}\n\n<p>终端上打印出了新部署的函数信息。可能遇到了什么问题，没有像预期的那样部署到 release 环境，但是这个 API 已经能够正常使用了。</p>\n<p>除了部署，你应该还会用到这些命令：</p>\n<pre><code class=\"sh\">serverless deploy -f function_one  # 重新部署函数\nserverless invoke -f function_one  # 调用云端函数\nserverless logs -f function_one -t # 实时获取函数的云端调用日志\nserverless remove                  # 移除整个服务</code></pre>\n<p>随后我反复多次修改触发器，然后用 <code>deploy -f</code> 命令部署，发现<strong>存量触发器并不会删除，而是在原有基础上增加新的触发器</strong>。一开始这个设定令我感到不解，它意味着不能做到把一个接口直接从 <code>GET</code> 改成 <code>POST</code>，但同时也避免了一个误操作导致事故。在我提单询问是否支持覆盖配置后，腾讯云运维小哥表示记录下了这个需求。</p>\n<h2 id=\"搭建-Serverless-平台\"><a href=\"#搭建-Serverless-平台\" class=\"headerlink\" title=\"搭建 Serverless 平台\"></a>搭建 Serverless 平台</h2><p>除了直接使用云服务商提供的 FaaS 服务，我们可以搭建自己的 Serverless 平台吗？答案就是前文中提到的开源项目 —— OpenWhisk。</p>\n<h3 id=\"OpenWhisk-简介\"><a href=\"#OpenWhisk-简介\" class=\"headerlink\" title=\"OpenWhisk 简介\"></a>OpenWhisk 简介</h3><p>OpenWhisk 是一个事件驱动的计算平台，也被称为 Serverless 或 FaaS，它在事件触发或直接调用时执行代码。</p>\n<img src=\"/images/posts/2019/11/serverless_openwhisk.jpg\" class=\"no-border\" width=\"540\" title=\"OpenWhisk\">       \n\n<p>事件（Event）是我们可以响应的一些行为。包括：收到一个 HTTP 请求，数据库记录发生变化，温度传感器检测到温度过高，GitHub 仓库提交了新代码……诸如此类。</p>\n<p>操作（Action）是指代码片段（可以理解为函数），或嵌入 Docker 容器中的二进制码。操作用于响应事件，当事件触发时，操作会立即部署并执行。换言之，不触发事件就不会执行代码，也就不会消耗服务器资源。</p>\n<p>触发器（Trigger）是一个特定的事件声明，可以人为触发也可以在满足条件的情况下自动触发。每个触发器都通过规则（Rule）与操作相关联。我们调用触发器，触发器定义的规则决定执行哪些操作。</p>\n<p>包（Package）用于与其他服务集成，例如团队协作工具 Slack，代码托管平台 GitHub，使这些平台上发生的一些事件能够触发我们的触发器。</p>\n<h3 id=\"OpenWhisk-工作原理\"><a href=\"#OpenWhisk-工作原理\" class=\"headerlink\" title=\"OpenWhisk 工作原理\"></a>OpenWhisk 工作原理</h3><p>作为一个开源项目，OpenWhisk 站在巨人的肩膀上，包括 Nginx，Kafka，Docker，CouchDB。<strong>这些组件集合在一起构成了一个“基于事件的无服务器编程服务”。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_openwhisk_principle.jpg\" class=\"no-border\" width=\"450\" title=\"OpenWhisk 工作原理\"> \n\n<p>OpenWhisk 提供基于 HTTP，遵循 RESTful 设计的面向用户的 API。</p>\n<p>用户的请求首先经过 Nginx —— 一个高性能的 Web 服务器，它主要用作 SSL 终端，负责请求的解密和响应的加密，以及转发请求到下一个组件。</p>\n<p>紧接着，请求到达控制器（Controller），在这里被解析成“对操作的调用”。控制器先通过请求中的信息识别用户身份，确认他有权调用这个操作。然后从数据库（CouchDB）加载操作。每个操作在数据库中的记录包含：代码、默认参数、资源限制等信息。</p>\n<p>然后，作为控制器一部分的负载均衡器（Load Balancer）—— 负责持续检查调用器（Invoker）的健康状况，会选择一个可用的调用器来调用操作。</p>\n<p>控制器和调用器间使用 Kafka 通信，其缓冲和持久化功能，帮助解决系统崩溃导致消息丢失，以及高负载阻塞调用的问题。一旦 Kafka 收到消息，就会对用户的 HTTP 请求响应一个 ActivationId，用户将在稍后使用它异步地查询操作调用的结果。</p>\n<p><strong>最后，OpenWhisk 的心脏 —— 基于 Docker 实现的调用器执行代码。Docker 建立起的自封装环境使每个操作以迅速、隔离和可控的方式调用。</strong>每一次操作调用都会产生一个新容器，随后注入代码，执行完毕就销毁。</p>\n<h3 id=\"OpenWhisk-体验\"><a href=\"#OpenWhisk-体验\" class=\"headerlink\" title=\"OpenWhisk 体验\"></a>OpenWhisk 体验</h3><p>无！:(</p>\n<p>很遗憾，试了几种方式都没能部署成功。不过这已经不重要了。因为部署 OpenWhisk 不会是企业使用 FaaS 的首选，这显然不够“Serverless”，也违背了让我们考虑得更少的初衷。</p>\n<p><strong>或许你更应该考虑的是：选择哪一家云服务商提供的 Serverless 服务。</strong></p>\n<p>&nbsp;</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>部分参考资料如下：</p>\n<ul>\n<li><a href=\"https://aws.amazon.com/serverless/\" target=\"_blank\" rel=\"noopener\">Serverless Computing - AWS</a></li>\n<li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">从 IaaS 到 FaaS —— Serverless 架构的前世今生 - AWS</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html\" target=\"_blank\" rel=\"noopener\">IaaS，PaaS，SaaS 的区别 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31386919\" target=\"_blank\" rel=\"noopener\">什么是 Serverless 架构和 FaaS 函数即服务？- 知乎专栏</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Function_as_a_service\" target=\"_blank\" rel=\"noopener\">Function as a service - Wikipedia</a></li>\n<li><a href=\"https://cloud.tencent.com/document/product/1154/39005\" target=\"_blank\" rel=\"noopener\">Serverless Framework 快速入门 - 腾讯云</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-introducing-openwhisk-microservices-made-easy/\" target=\"_blank\" rel=\"noopener\">OpenWhisk 简介：轻松创建微服务 - IBM</a></li>\n</ul>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Build and run applications without thinking about servers. —— AWS</p>\n</blockquote>\n<h2 id=\"什么是-Serverless\"><a href=\"#什么是-Serverless\" class=\"headerlink\" title=\"什么是 Serverless\"></a>什么是 Serverless</h2><p>Serverless，即无服务器计算，是一种云架构。Serverless 服务由一系列服务构成，包括计算服务、存储服务、数据库服务、API 网关服务等。</p>","more":"<p>它使开发者能够将更多运维职责转移给云，在不考虑服务器的情况下，构建并运行应用程序和服务。同时，支持几乎任何类型的应用或后端服务。</p>\n<p><strong>用简单的话说就是：用各种服务代替服务器，你充值就可以了。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_intro.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless\">\n\n<p>Serverless 的优势包括：无需维护服务器，可灵活拓展，按量付费（通常是按调用次数和流量），内置可用性和容错功能，以及 —— 环保。</p>\n<center>（前方高能我要上价值）</center>\n&nbsp;\n\n<p>据《福布斯》杂志统计，典型服务器的计算能力仅有 5%~15% 的利用率。可想而知，Serverless 架构将使人类更有效率地利用计算资源，减少温室气体排放。</p>\n<p>注：可用性是指读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。容错是指单台或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务。</p>\n<p>目前提供 Serverless 的云服务商有 AWS、阿里云、腾讯云等等。2014 年发布的 AWS Lambda 是首个公有云无服务器计算服务。</p>\n<p>发展里程碑：</p>\n<ul>\n<li><p>2012 Iron.io 联合创始人 Ken Fromm 提出“软件的未来是 Serverless” </p>\n</li>\n<li><p>2014 首个无服务器计算产品 AWS Lambda 发布</p>\n</li>\n<li><p>2016 百花齐放：Google Cloud Functions、IBM Cloud Functions、Azure Functions</p>\n</li>\n<li><p>2016 IBM 发布开源无服务器计算平台 OpenWhisk</p>\n</li>\n</ul>\n<p>现在，当人们提到 Serverless 的时候，通常也提及另一个词 —— <strong>FaaS</strong>，虽然不够严谨，但现时这两个概念几乎可以画上等号。<strong>FaaS 是构建无服务器架构的一种方式，负责提供其中的“计算服务”。</strong>它计算逻辑，但不存储数据。</p>\n<p>在进一步了解 FaaS 之前，我认为最好先回顾一下云计算的几种类型。</p>\n<h2 id=\"云计算类型回顾\"><a href=\"#云计算类型回顾\" class=\"headerlink\" title=\"云计算类型回顾\"></a><strong>云计算类型回顾</strong></h2><p>IBM 软件架构师 Albert Barron 曾用披萨作为比喻，解释这些云服务的区别。显然，这个图表还不够具体。但是它清晰地呈现了这些云计算服务渐进的变化：开发者需要考虑的东西越来越少，专注开发本身。</p>\n<img src=\"/images/posts/2019/11/serverless_pizza_as_a_service.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless Framework\">\n\n<p>上图提到的几种类型：</p>\n<p>IaaS （Infrastructure as a Service）是基础设施即服务，只提供最少量的服务，诸如网络和云主机这些基础设施，你需要登录上去自己安装系统、运行环境，还有数据库软件。典型产品有 AWS EC2、阿里云 ECS、腾讯云 CVM。</p>\n<p>PaaS（Platform as a Service）是平台即服务，运行环境和数据库也给你准备好了，你只需上传代码包和一些配置文件。典型产品有 Google App Engine、Sina App Engine、Baidu App Engine。</p>\n<p>SaaS（Software as a Service）是软件即服务，拿到手就能用的东西。典型产品有企业微信、企业邮箱。</p>\n<p>IaaS 只提供最少的服务，但并不见得省钱。我个人认为它是对前端来说最不友好的服务，大部分时候只用到它资源的冰山一角，却要学习不少与开发无关的东西。对于 PaaS，基于我过去的一些使用体验，开发者仍需要写 Nginx 配置，需要考虑用什么框架去组织代码，部署和伸缩的维度是整个项目。</p>\n<p>那么是否存在更理想（可以偷懒）的计算服务呢？答案就是 FaaS，我认为它介于 PaaS 和 SasS 之间。</p>\n<h2 id=\"什么是-FaaS\"><a href=\"#什么是-FaaS\" class=\"headerlink\" title=\"什么是 FaaS\"></a>什么是 FaaS</h2><p>FaaS（Function as a Service）是指函数即服务，是一种云计算服务。它提供一个平台，允许使用者<strong>开发、运行和管理应用程序功能，而无需构建和维护基础设施。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_faas.jpg\" class=\"no-border\" width=\"540\" title=\"FaaS\">\n\n<p><strong>FaaS 是基于事件驱动的。</strong>不同于传统服务端软件需要长时间运行，FaaS 平台部署的函数仅在事件触发时执行。以 AWS Lambda 为例，当平台收到一个事件时，它将启动一个容器运行你的函数，执行完毕后即释放资源。</p>\n<p>因此，不同于 IaaS 需要为固定的硬件和带宽付费，FaaS 通常只需要按请求数量和流量付费。</p>\n<p><strong>FaaS 和 PaaS 的概念是很相似的，他们最大的差异在于伸缩能力。</strong>PaaS 应用无法在具体请求的层面上进行伸缩，所以 FaaS 应用的成本效益更高。AWS 云架构战略副总裁 Adrian Cockcroft 如此界定两者：如果你的 PaaS 能够有效地在20毫秒内启动实例并运行半秒，那么就可以称之为 Serverless。</p>\n<p>目前我们可以选择的典型 FaaS 服务包括：AWS Lambda、阿里云函数计算、腾讯云云函数。</p>\n<h2 id=\"构建和管理-Serverless-应用\"><a href=\"#构建和管理-Serverless-应用\" class=\"headerlink\" title=\"构建和管理 Serverless 应用\"></a>构建和管理 Serverless 应用</h2><p>有了 FaaS 云计算服务，我们要如何构建和管理后端应用程序呢？最直接的办法，是在云服务商提供的控制台上编写和部署函数，但这显然不够科学。</p>\n<p><strong>Serverless Framework 是一个构建和管理 Serverless 应用的完整解决方案。</strong>2015 年，Serverless Framework 开源项目发布。直到今天，它已然成为开发者在 FaaS 平台上部署应用的主要方式。</p>\n<img src=\"/images/posts/2019/11/serverless_serverless_framework.jpg\" class=\"no-border\" width=\"540\" title=\"Serverless Framework\">\n\n<p><strong>简单的说，你在本地写好的函数，用命令行就能部署到云服务商提供的 FaaS 服务中。</strong></p>\n<h2 id=\"Serverless-初体验\"><a href=\"#Serverless-初体验\" class=\"headerlink\" title=\"Serverless 初体验\"></a>Serverless 初体验</h2><p>为更进一步了解 Serverless 应用程序的开发，我摸索了一下 Serverless Framework 搭配云函数（腾讯云）的使用姿势。我认为，体验可以用“有点儿爽”来形容。</p>\n<img src=\"/images/posts/2019/11/serverless_practice.jpg\" class=\"\" width=\"320\" title=\"Talk is cheap\">\n\n<p><strong>首先，需要在云函数控制台上创建一个函数，帮助我们自动配置“角色”，用于向云函数提供对接腾讯云上其他资源的权限。</strong>因为后续用 Serverless Framework 部署函数的时候，会先打包上传到对象存储服务（踩坑后才知道的）。</p>\n<p>选择预置的 HelloWorld 函数部署就可以了。给函数配置一种触发器，我选择的是 API 网关触发。跟随提示很容易配置了 API 网关，保存，随后便得到了一个链接。和预想的一样，访问这个链接函数就会执行，浏览器上输出了代码中打印的内容。</p>\n<img src=\"/images/posts/2019/11/serverless_scf_trigger.jpg\" class=\"\" width=\"480\" title=\"云函数触发器\">\n\n<p>接着，运行如下命令全局安装 Serverless Framework CLI：</p>\n<pre><code>npm install -g serverless</code></pre><p>紧接着创建一个名为 example 的新项目 —— 也称为服务，安装依赖。</p>\n<pre><code>serverless create --template tencent-nodejs --path example\ncd example\nnpm install</code></pre><p>服务的目录结构简单到不行，除去 npm 相关的只剩下两个文件。<code>serverless.yml</code> 是配置文件，暂时只需要知道写好的函数在这里引用就行了。<code>index.js</code> 就是你写函数的地方。</p>\n<pre><code>├── index.js\n└── serverless.yml</code></pre><p>然后，参考 <a href=\"https://cloud.tencent.com/document/product/1154/38811\" target=\"_blank\" rel=\"noopener\">这里</a> 在本地创建一个 <code>~/credentials</code> 文件，写入腾讯云账号的鉴权凭证。确保文件路径和项目配置文件 <code>serverless.yml</code> 中声明的一致。</p>\n<pre><code>[default]\ntencent_appid = appid\ntencent_secret_id = secretid\ntencent_secret_key = secretkey</code></pre><p>恭喜！你已经可以部署函数上云了。</p>\n<p>默认情况下，这个服务中已经包含了一个 HelloWorld 函数。我们直接修改配置文件，给这个函数加上一个触发器。</p>\n<pre><code class=\"yaml\">functions:\n  function_one:\n    handler: index.main_handler\n    description: My First Serverless Function # 函数描述\n    events:\n      - apigw:\n          parameters:\n            stageName: release     # 部署环境\n            serviceId: service-xxx # API 网关服务 ID\n            httpMethod: POST       # HTTP 方法</code></pre>\n<p>箭在弦上，执行以下命令部署函数。</p>\n<pre><code>serverless deploy</code></pre><p>执行部署命令后将生成一个 <code>.serverless</code> 目录，打包好的函数就放在这个目录下，它们将被自动上传到对象存储服务，随后完成代码的部署。</p>\n{% img /images/posts/2019/11/serverless_serverless_framework_deploy.jpg 540 Serverless Framework 部署 %}\n\n<p>终端上打印出了新部署的函数信息。可能遇到了什么问题，没有像预期的那样部署到 release 环境，但是这个 API 已经能够正常使用了。</p>\n<p>除了部署，你应该还会用到这些命令：</p>\n<pre><code class=\"sh\">serverless deploy -f function_one  # 重新部署函数\nserverless invoke -f function_one  # 调用云端函数\nserverless logs -f function_one -t # 实时获取函数的云端调用日志\nserverless remove                  # 移除整个服务</code></pre>\n<p>随后我反复多次修改触发器，然后用 <code>deploy -f</code> 命令部署，发现<strong>存量触发器并不会删除，而是在原有基础上增加新的触发器</strong>。一开始这个设定令我感到不解，它意味着不能做到把一个接口直接从 <code>GET</code> 改成 <code>POST</code>，但同时也避免了一个误操作导致事故。在我提单询问是否支持覆盖配置后，腾讯云运维小哥表示记录下了这个需求。</p>\n<h2 id=\"搭建-Serverless-平台\"><a href=\"#搭建-Serverless-平台\" class=\"headerlink\" title=\"搭建 Serverless 平台\"></a>搭建 Serverless 平台</h2><p>除了直接使用云服务商提供的 FaaS 服务，我们可以搭建自己的 Serverless 平台吗？答案就是前文中提到的开源项目 —— OpenWhisk。</p>\n<h3 id=\"OpenWhisk-简介\"><a href=\"#OpenWhisk-简介\" class=\"headerlink\" title=\"OpenWhisk 简介\"></a>OpenWhisk 简介</h3><p>OpenWhisk 是一个事件驱动的计算平台，也被称为 Serverless 或 FaaS，它在事件触发或直接调用时执行代码。</p>\n<img src=\"/images/posts/2019/11/serverless_openwhisk.jpg\" class=\"no-border\" width=\"540\" title=\"OpenWhisk\">       \n\n<p>事件（Event）是我们可以响应的一些行为。包括：收到一个 HTTP 请求，数据库记录发生变化，温度传感器检测到温度过高，GitHub 仓库提交了新代码……诸如此类。</p>\n<p>操作（Action）是指代码片段（可以理解为函数），或嵌入 Docker 容器中的二进制码。操作用于响应事件，当事件触发时，操作会立即部署并执行。换言之，不触发事件就不会执行代码，也就不会消耗服务器资源。</p>\n<p>触发器（Trigger）是一个特定的事件声明，可以人为触发也可以在满足条件的情况下自动触发。每个触发器都通过规则（Rule）与操作相关联。我们调用触发器，触发器定义的规则决定执行哪些操作。</p>\n<p>包（Package）用于与其他服务集成，例如团队协作工具 Slack，代码托管平台 GitHub，使这些平台上发生的一些事件能够触发我们的触发器。</p>\n<h3 id=\"OpenWhisk-工作原理\"><a href=\"#OpenWhisk-工作原理\" class=\"headerlink\" title=\"OpenWhisk 工作原理\"></a>OpenWhisk 工作原理</h3><p>作为一个开源项目，OpenWhisk 站在巨人的肩膀上，包括 Nginx，Kafka，Docker，CouchDB。<strong>这些组件集合在一起构成了一个“基于事件的无服务器编程服务”。</strong></p>\n<img src=\"/images/posts/2019/11/serverless_openwhisk_principle.jpg\" class=\"no-border\" width=\"450\" title=\"OpenWhisk 工作原理\"> \n\n<p>OpenWhisk 提供基于 HTTP，遵循 RESTful 设计的面向用户的 API。</p>\n<p>用户的请求首先经过 Nginx —— 一个高性能的 Web 服务器，它主要用作 SSL 终端，负责请求的解密和响应的加密，以及转发请求到下一个组件。</p>\n<p>紧接着，请求到达控制器（Controller），在这里被解析成“对操作的调用”。控制器先通过请求中的信息识别用户身份，确认他有权调用这个操作。然后从数据库（CouchDB）加载操作。每个操作在数据库中的记录包含：代码、默认参数、资源限制等信息。</p>\n<p>然后，作为控制器一部分的负载均衡器（Load Balancer）—— 负责持续检查调用器（Invoker）的健康状况，会选择一个可用的调用器来调用操作。</p>\n<p>控制器和调用器间使用 Kafka 通信，其缓冲和持久化功能，帮助解决系统崩溃导致消息丢失，以及高负载阻塞调用的问题。一旦 Kafka 收到消息，就会对用户的 HTTP 请求响应一个 ActivationId，用户将在稍后使用它异步地查询操作调用的结果。</p>\n<p><strong>最后，OpenWhisk 的心脏 —— 基于 Docker 实现的调用器执行代码。Docker 建立起的自封装环境使每个操作以迅速、隔离和可控的方式调用。</strong>每一次操作调用都会产生一个新容器，随后注入代码，执行完毕就销毁。</p>\n<h3 id=\"OpenWhisk-体验\"><a href=\"#OpenWhisk-体验\" class=\"headerlink\" title=\"OpenWhisk 体验\"></a>OpenWhisk 体验</h3><p>无！:(</p>\n<p>很遗憾，试了几种方式都没能部署成功。不过这已经不重要了。因为部署 OpenWhisk 不会是企业使用 FaaS 的首选，这显然不够“Serverless”，也违背了让我们考虑得更少的初衷。</p>\n<p><strong>或许你更应该考虑的是：选择哪一家云服务商提供的 Serverless 服务。</strong></p>\n<p>&nbsp;</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>部分参考资料如下：</p>\n<ul>\n<li><a href=\"https://aws.amazon.com/serverless/\" target=\"_blank\" rel=\"noopener\">Serverless Computing - AWS</a></li>\n<li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">从 IaaS 到 FaaS —— Serverless 架构的前世今生 - AWS</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html\" target=\"_blank\" rel=\"noopener\">IaaS，PaaS，SaaS 的区别 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31386919\" target=\"_blank\" rel=\"noopener\">什么是 Serverless 架构和 FaaS 函数即服务？- 知乎专栏</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Function_as_a_service\" target=\"_blank\" rel=\"noopener\">Function as a service - Wikipedia</a></li>\n<li><a href=\"https://cloud.tencent.com/document/product/1154/39005\" target=\"_blank\" rel=\"noopener\">Serverless Framework 快速入门 - 腾讯云</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-introducing-openwhisk-microservices-made-easy/\" target=\"_blank\" rel=\"noopener\">OpenWhisk 简介：轻松创建微服务 - IBM</a></li>\n</ul>\n<p>&nbsp;</p>"},{"title":"Chrome 扩展从入门到 HelloWorld","date":"2019-12-20T17:26:05.000Z","_content":"\n\n## 认识 Chrome 扩展\n\n扩展（Extension）是用于修改或者增加浏览器功能的小型软件。“扩展”这个称谓可能稍显陌生，在国内人们更习惯于称它们为**浏览器插件**。它们使用 HTML，JavaScript, CSS 等网页开发技术构建。\n\n<!-- more -->\n\n**你可以理解为，扩展就是在浏览器中持续运行的网页，当你需要时随时唤醒它，而不需要等待加载。**扩展之于 Chrome 浏览器，就像小程序之于微信。\n\n{% img no-border /images/posts/2019/12/chrome_extension_adblock.png 450 Chrome 扩展 %}\n\nChrome 扩展经历了：\n\n- 2009年9月，谷歌开发者网站公布扩展。\n- 2009年12月，Google Chrome 扩展程序中心公测，发布大约300个扩展。\n- 2010年1月，Google Chrome 扩展程序中心正式上线，包含大约1500个扩展。\n- 2010年12月，“扩展中心”升级为我们今天熟知的 Chrome 网上应用店。\n\n**时至今日，Chrome 网上应用店托管着大约19万个扩展。**\n\n它们之中有大名鼎鼎的广告拦截程序 Adblock Plus，网页长截屏工具 Full Page Screen Capture，也有前端开发同学们熟悉的调试工具 Vue Devtools，React Developer Tools。\n\n为什么扩展能够提供如此多样的功能？\n\n除了程序猿们的努力，更重要的一点是 **Chrome 开放了各种强大的接口**赋能开发者。翻看文档可以发现，`chrome.tabs` 接口提供了“读取和修改页面内容”的能力，使得“屏蔽广告”成为可能。\n\n这并不意味着扩展可以不受限制地访问你浏览的内容。和手机上的 app 类似，扩展需要获取权限才能使用相应的能力，同时受用户和 Chrome 网上应用店监督。\n\n## Crome 扩展的结构\n\n扩展程序由一些“组件”构成。它们都由常见的 web 技术编写，各自负责不同的工作。\n\n{% img no-border /images/posts/2019/12/chrome_extension_structure.png 580 Chrome 扩展结构 %}\n\n**清单**\n\n每个扩展都必须有一个 JSON 格式的清单文件（Manifest），作为扩展程序的配置文件，用于记录一些必不可少的信息。例如：名称和描述，需要使用哪些权限，可以如何与用户交互。\n\n只要有这个文件，扩展就可以被浏览器识别和安装 —— 即使它不具备任何实用功能。\n\n**背景页**\n\n背景页（Background Page）是一个在后台持续运行的页面。\n\n虽然称之为一个“页面”，但实际对用户是不可见的。背景页随着浏览器打开（扩展加载）而运行，直到浏览器关闭才会停止。它负责维护扩展的全局状态，还可以和其他扩展通信。\n\n**弹窗**\n\n弹窗（Popup）是扩展与用户交互最常用的方式。其实就是我们平常在浏览器的地址栏右侧，点击扩展按钮会显示的弹窗，通常提供一些设置选项。\n\n弹窗的生命周期很短，切换标签页就会销毁，再次点击图标会打开一个新的弹窗实例。所以重要的临时数据和操作一定要放在背景页当中。\n\n**内容脚本**\n\n内容脚本（Content Scripts）是运行于网页的上下文环境中的脚本。它可以注入网页中，通过 DOM 读取和修改用户正在浏览的网页中的内容。\n\n现在知道广告屏蔽插件如何让牛皮癣消失了吧？\n\n**选项页**\n\n选项页（Options Page）的本质是一个完整可见的网页，它的定位是向用户提供更多定制选项。\n\n对于一些功能复杂的扩展，弹窗能够提供的交互是不够的。在工具栏右键点击扩展图标，选择菜单中的“选项”，即可浏览扩展的选项页。\n\n## Hello World\n\n接下来我们动手编写一个没什么卵用的 Chrome 扩展，它能够帮助你具备最基础的扩展开发能力。\n\n### 从清单开始\n\n首先，新建一个目录并创建清单文件 `manifest.json`。\n\n``` json\n{\n  \"name\": \"Chrome Extension Example\",\n  \"version\": \"1.0\",\n  \"description\": \"Hello, Chrome extension!\",\n  \"manifest_version\": 2\n}\n```\n\n[完整](https://developer.chrome.com/extensions/manifest) 的清单文件包含很多配置项，实际上必要的只有  `name`，`version` 和 `manifesct_version`。顾名思义分别是扩展的名称，版本，以及清单格式版本。\n\n接着，通过工具栏菜单或访问 `chrome://extensions` 进入扩展程序管理。启用“开发者模式”。开启后即可通过本地目录安装扩展，调试背景页。\n\n{% img no-border /images/posts/2019/12/chrome_extension_management.png 480 扩展管理 %}\n\n点击“加载已解压的扩展程序”，选择刚才创建的目录，这个什么功能都没有的扩展就被安装到了浏览器上。地址栏的右侧也新增了一个按钮。\n\n### 添加背景页\n\n接下来添加背景页，用来打印一段文字，顺便体验一下 Chrome 拓展 API。\n\n`chrome.storage` API 是扩展的存储接口。它提供了用于存储数据到云端（与用户的 Google 账户关联）的 `sync` 方法，以及存储数据到本地的 `local` 方法。\n\n首先，在清单文件中注册 `storage` 权限和背景页。\n\n```json\n{\n  // ...\n  \"permissions\": [\"storage\"],\n  \"background\": {\n    \"scripts\": [\"background.js\"],\n    \"persistent\": false\n  }\n}\n```\n\n然后，创建背景页脚本 `background.js`，它将在扩展安装后打印一段文字。\n\n```js\n// background.js\nchrome.runtime.onInstalled.addListener(function() {\n  // 存储数据\n  chrome.storage.sync.set({ msg: 'Hello, World!'}, function() {\n    // 读取数据\n    chrome.storage.sync.get(['msg'], function(result) {\n      // 打印数据\n      console.log(result.msg)\n    })\n  })\n})\n```\n\n最后，重新加载扩展并点击“查看背景页”，弹出的控制台中打印出了：“Hello, World!”。\n\n{% img no-border /images/posts/2019/12/chrome_extension_debug_background.png 540 调试背景页 %}\n\n### 添加弹窗\n\n在清单文件中使用 `browser_action` 或 `page_action` 注册弹窗。\n\n```json\n{\n  // ...\n  \"browser_action\": {\n    \"default_popup\": \"popup.html\"\n  }\n}\n```\n\n两个配置项都可以自定义扩展按钮的图标和功能。它们的区别在于：浏览器按钮（Browser Action）默认在任何时候都可用；页面按钮（Page Action）按钮默认置灰，开发者按需为一些标签页或网址启用。用哪个取决于业务场景，这里我们用前者就行了。\n\n接着，创建弹窗的布局文件 `popup.html`。仅仅设置了宽度，添加一串文本到 `<body/>` 中。\n\n```html\n<!-- popup.html -->\n<html>\n  <head>\n    <style>body { width: 100px; }</style>\n  </head>\n  <body>Hello, World!</body>\n</html>\n```\n\n重新加载扩展并点击图标，图标下方出现自定义弹窗。\n\n{% img no-border /images/posts/2019/12/chrome_extension_popup.png 450 扩展的弹窗 %}\n\n### 自定义图标\n\n在按钮配置中使用 `default_icon` 设置图标。\n\n```json\n{\n  // ...\n  \"browser_action\": {\n    \"default_icon\": {\n      \"16\": \"images/icon_16.png\",\n      \"24\": \"images/icon_24.png\",\n      \"32\": \"images/icon_32.png\"\n    },\n    \"default_popup\": \"popup.html\"\n  }\n}\n```\n\n聪明的你应该注意到了，刚刚配置的图标和弹窗都是 `default` 开头的默认值。\n\n这是因为 Chrome 提供了动态修改它们的接口。以浏览器按钮为例，`chrome.browserAction` API 包含了用于设置弹窗的 `setPopup`，以及用于设置图标的 `setIcon`。\n\n## 后记\n\n本想写一篇《Chrome 扩展：从入门到做一个 XXX 插件》，记录一个 ~~既有功能又有颜值~~ 还凑合的扩展开发全过程。由于工作太忙入完门就继续不下去了。文章在草稿里躺了半个月，今天正式宣布放弃。\n\n但愿为感兴趣的同学上手浏览器扩展开发做了点微小工作。\n\nOrz...\n\n## 参考资料\n\n部分参考资料如下：\n\n- [Google Chrome Extensions - Wikipedia](https://en.wikipedia.org/wiki/Google_Chrome#Extensions)\n\n- [Extend the Browser - Google Chrome](https://developer.chrome.com/extensions)\n\n- [Extension APIs - Google Chrome](https://developer.chrome.com/extensions/api_index)","source":"_posts/2019-12-21@Chrome 扩展从入门到 HelloWorld.md","raw":"---\ntitle: Chrome 扩展从入门到 HelloWorld\ntags:\n  - Chrome\n  - WebComponents\ncategories:\n  - Web Front-end\ndate: 2019-12-21 01:26:05\n---\n\n\n## 认识 Chrome 扩展\n\n扩展（Extension）是用于修改或者增加浏览器功能的小型软件。“扩展”这个称谓可能稍显陌生，在国内人们更习惯于称它们为**浏览器插件**。它们使用 HTML，JavaScript, CSS 等网页开发技术构建。\n\n<!-- more -->\n\n**你可以理解为，扩展就是在浏览器中持续运行的网页，当你需要时随时唤醒它，而不需要等待加载。**扩展之于 Chrome 浏览器，就像小程序之于微信。\n\n{% img no-border /images/posts/2019/12/chrome_extension_adblock.png 450 Chrome 扩展 %}\n\nChrome 扩展经历了：\n\n- 2009年9月，谷歌开发者网站公布扩展。\n- 2009年12月，Google Chrome 扩展程序中心公测，发布大约300个扩展。\n- 2010年1月，Google Chrome 扩展程序中心正式上线，包含大约1500个扩展。\n- 2010年12月，“扩展中心”升级为我们今天熟知的 Chrome 网上应用店。\n\n**时至今日，Chrome 网上应用店托管着大约19万个扩展。**\n\n它们之中有大名鼎鼎的广告拦截程序 Adblock Plus，网页长截屏工具 Full Page Screen Capture，也有前端开发同学们熟悉的调试工具 Vue Devtools，React Developer Tools。\n\n为什么扩展能够提供如此多样的功能？\n\n除了程序猿们的努力，更重要的一点是 **Chrome 开放了各种强大的接口**赋能开发者。翻看文档可以发现，`chrome.tabs` 接口提供了“读取和修改页面内容”的能力，使得“屏蔽广告”成为可能。\n\n这并不意味着扩展可以不受限制地访问你浏览的内容。和手机上的 app 类似，扩展需要获取权限才能使用相应的能力，同时受用户和 Chrome 网上应用店监督。\n\n## Crome 扩展的结构\n\n扩展程序由一些“组件”构成。它们都由常见的 web 技术编写，各自负责不同的工作。\n\n{% img no-border /images/posts/2019/12/chrome_extension_structure.png 580 Chrome 扩展结构 %}\n\n**清单**\n\n每个扩展都必须有一个 JSON 格式的清单文件（Manifest），作为扩展程序的配置文件，用于记录一些必不可少的信息。例如：名称和描述，需要使用哪些权限，可以如何与用户交互。\n\n只要有这个文件，扩展就可以被浏览器识别和安装 —— 即使它不具备任何实用功能。\n\n**背景页**\n\n背景页（Background Page）是一个在后台持续运行的页面。\n\n虽然称之为一个“页面”，但实际对用户是不可见的。背景页随着浏览器打开（扩展加载）而运行，直到浏览器关闭才会停止。它负责维护扩展的全局状态，还可以和其他扩展通信。\n\n**弹窗**\n\n弹窗（Popup）是扩展与用户交互最常用的方式。其实就是我们平常在浏览器的地址栏右侧，点击扩展按钮会显示的弹窗，通常提供一些设置选项。\n\n弹窗的生命周期很短，切换标签页就会销毁，再次点击图标会打开一个新的弹窗实例。所以重要的临时数据和操作一定要放在背景页当中。\n\n**内容脚本**\n\n内容脚本（Content Scripts）是运行于网页的上下文环境中的脚本。它可以注入网页中，通过 DOM 读取和修改用户正在浏览的网页中的内容。\n\n现在知道广告屏蔽插件如何让牛皮癣消失了吧？\n\n**选项页**\n\n选项页（Options Page）的本质是一个完整可见的网页，它的定位是向用户提供更多定制选项。\n\n对于一些功能复杂的扩展，弹窗能够提供的交互是不够的。在工具栏右键点击扩展图标，选择菜单中的“选项”，即可浏览扩展的选项页。\n\n## Hello World\n\n接下来我们动手编写一个没什么卵用的 Chrome 扩展，它能够帮助你具备最基础的扩展开发能力。\n\n### 从清单开始\n\n首先，新建一个目录并创建清单文件 `manifest.json`。\n\n``` json\n{\n  \"name\": \"Chrome Extension Example\",\n  \"version\": \"1.0\",\n  \"description\": \"Hello, Chrome extension!\",\n  \"manifest_version\": 2\n}\n```\n\n[完整](https://developer.chrome.com/extensions/manifest) 的清单文件包含很多配置项，实际上必要的只有  `name`，`version` 和 `manifesct_version`。顾名思义分别是扩展的名称，版本，以及清单格式版本。\n\n接着，通过工具栏菜单或访问 `chrome://extensions` 进入扩展程序管理。启用“开发者模式”。开启后即可通过本地目录安装扩展，调试背景页。\n\n{% img no-border /images/posts/2019/12/chrome_extension_management.png 480 扩展管理 %}\n\n点击“加载已解压的扩展程序”，选择刚才创建的目录，这个什么功能都没有的扩展就被安装到了浏览器上。地址栏的右侧也新增了一个按钮。\n\n### 添加背景页\n\n接下来添加背景页，用来打印一段文字，顺便体验一下 Chrome 拓展 API。\n\n`chrome.storage` API 是扩展的存储接口。它提供了用于存储数据到云端（与用户的 Google 账户关联）的 `sync` 方法，以及存储数据到本地的 `local` 方法。\n\n首先，在清单文件中注册 `storage` 权限和背景页。\n\n```json\n{\n  // ...\n  \"permissions\": [\"storage\"],\n  \"background\": {\n    \"scripts\": [\"background.js\"],\n    \"persistent\": false\n  }\n}\n```\n\n然后，创建背景页脚本 `background.js`，它将在扩展安装后打印一段文字。\n\n```js\n// background.js\nchrome.runtime.onInstalled.addListener(function() {\n  // 存储数据\n  chrome.storage.sync.set({ msg: 'Hello, World!'}, function() {\n    // 读取数据\n    chrome.storage.sync.get(['msg'], function(result) {\n      // 打印数据\n      console.log(result.msg)\n    })\n  })\n})\n```\n\n最后，重新加载扩展并点击“查看背景页”，弹出的控制台中打印出了：“Hello, World!”。\n\n{% img no-border /images/posts/2019/12/chrome_extension_debug_background.png 540 调试背景页 %}\n\n### 添加弹窗\n\n在清单文件中使用 `browser_action` 或 `page_action` 注册弹窗。\n\n```json\n{\n  // ...\n  \"browser_action\": {\n    \"default_popup\": \"popup.html\"\n  }\n}\n```\n\n两个配置项都可以自定义扩展按钮的图标和功能。它们的区别在于：浏览器按钮（Browser Action）默认在任何时候都可用；页面按钮（Page Action）按钮默认置灰，开发者按需为一些标签页或网址启用。用哪个取决于业务场景，这里我们用前者就行了。\n\n接着，创建弹窗的布局文件 `popup.html`。仅仅设置了宽度，添加一串文本到 `<body/>` 中。\n\n```html\n<!-- popup.html -->\n<html>\n  <head>\n    <style>body { width: 100px; }</style>\n  </head>\n  <body>Hello, World!</body>\n</html>\n```\n\n重新加载扩展并点击图标，图标下方出现自定义弹窗。\n\n{% img no-border /images/posts/2019/12/chrome_extension_popup.png 450 扩展的弹窗 %}\n\n### 自定义图标\n\n在按钮配置中使用 `default_icon` 设置图标。\n\n```json\n{\n  // ...\n  \"browser_action\": {\n    \"default_icon\": {\n      \"16\": \"images/icon_16.png\",\n      \"24\": \"images/icon_24.png\",\n      \"32\": \"images/icon_32.png\"\n    },\n    \"default_popup\": \"popup.html\"\n  }\n}\n```\n\n聪明的你应该注意到了，刚刚配置的图标和弹窗都是 `default` 开头的默认值。\n\n这是因为 Chrome 提供了动态修改它们的接口。以浏览器按钮为例，`chrome.browserAction` API 包含了用于设置弹窗的 `setPopup`，以及用于设置图标的 `setIcon`。\n\n## 后记\n\n本想写一篇《Chrome 扩展：从入门到做一个 XXX 插件》，记录一个 ~~既有功能又有颜值~~ 还凑合的扩展开发全过程。由于工作太忙入完门就继续不下去了。文章在草稿里躺了半个月，今天正式宣布放弃。\n\n但愿为感兴趣的同学上手浏览器扩展开发做了点微小工作。\n\nOrz...\n\n## 参考资料\n\n部分参考资料如下：\n\n- [Google Chrome Extensions - Wikipedia](https://en.wikipedia.org/wiki/Google_Chrome#Extensions)\n\n- [Extend the Browser - Google Chrome](https://developer.chrome.com/extensions)\n\n- [Extension APIs - Google Chrome](https://developer.chrome.com/extensions/api_index)","slug":"2019-12-21@Chrome 扩展从入门到 HelloWorld","published":1,"updated":"2020-06-30T02:10:11.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc1bt4by00fcrqgje3jjerek","content":"<h2 id=\"认识-Chrome-扩展\"><a href=\"#认识-Chrome-扩展\" class=\"headerlink\" title=\"认识 Chrome 扩展\"></a>认识 Chrome 扩展</h2><p>扩展（Extension）是用于修改或者增加浏览器功能的小型软件。“扩展”这个称谓可能稍显陌生，在国内人们更习惯于称它们为<strong>浏览器插件</strong>。它们使用 HTML，JavaScript, CSS 等网页开发技术构建。</p>\n<a id=\"more\"></a>\n\n<p><strong>你可以理解为，扩展就是在浏览器中持续运行的网页，当你需要时随时唤醒它，而不需要等待加载。</strong>扩展之于 Chrome 浏览器，就像小程序之于微信。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_adblock.png\" class=\"no-border\" width=\"450\" title=\"Chrome 扩展\">\n\n<p>Chrome 扩展经历了：</p>\n<ul>\n<li>2009年9月，谷歌开发者网站公布扩展。</li>\n<li>2009年12月，Google Chrome 扩展程序中心公测，发布大约300个扩展。</li>\n<li>2010年1月，Google Chrome 扩展程序中心正式上线，包含大约1500个扩展。</li>\n<li>2010年12月，“扩展中心”升级为我们今天熟知的 Chrome 网上应用店。</li>\n</ul>\n<p><strong>时至今日，Chrome 网上应用店托管着大约19万个扩展。</strong></p>\n<p>它们之中有大名鼎鼎的广告拦截程序 Adblock Plus，网页长截屏工具 Full Page Screen Capture，也有前端开发同学们熟悉的调试工具 Vue Devtools，React Developer Tools。</p>\n<p>为什么扩展能够提供如此多样的功能？</p>\n<p>除了程序猿们的努力，更重要的一点是 <strong>Chrome 开放了各种强大的接口</strong>赋能开发者。翻看文档可以发现，<code>chrome.tabs</code> 接口提供了“读取和修改页面内容”的能力，使得“屏蔽广告”成为可能。</p>\n<p>这并不意味着扩展可以不受限制地访问你浏览的内容。和手机上的 app 类似，扩展需要获取权限才能使用相应的能力，同时受用户和 Chrome 网上应用店监督。</p>\n<h2 id=\"Crome-扩展的结构\"><a href=\"#Crome-扩展的结构\" class=\"headerlink\" title=\"Crome 扩展的结构\"></a>Crome 扩展的结构</h2><p>扩展程序由一些“组件”构成。它们都由常见的 web 技术编写，各自负责不同的工作。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_structure.png\" class=\"no-border\" width=\"580\" title=\"Chrome 扩展结构\">\n\n<p><strong>清单</strong></p>\n<p>每个扩展都必须有一个 JSON 格式的清单文件（Manifest），作为扩展程序的配置文件，用于记录一些必不可少的信息。例如：名称和描述，需要使用哪些权限，可以如何与用户交互。</p>\n<p>只要有这个文件，扩展就可以被浏览器识别和安装 —— 即使它不具备任何实用功能。</p>\n<p><strong>背景页</strong></p>\n<p>背景页（Background Page）是一个在后台持续运行的页面。</p>\n<p>虽然称之为一个“页面”，但实际对用户是不可见的。背景页随着浏览器打开（扩展加载）而运行，直到浏览器关闭才会停止。它负责维护扩展的全局状态，还可以和其他扩展通信。</p>\n<p><strong>弹窗</strong></p>\n<p>弹窗（Popup）是扩展与用户交互最常用的方式。其实就是我们平常在浏览器的地址栏右侧，点击扩展按钮会显示的弹窗，通常提供一些设置选项。</p>\n<p>弹窗的生命周期很短，切换标签页就会销毁，再次点击图标会打开一个新的弹窗实例。所以重要的临时数据和操作一定要放在背景页当中。</p>\n<p><strong>内容脚本</strong></p>\n<p>内容脚本（Content Scripts）是运行于网页的上下文环境中的脚本。它可以注入网页中，通过 DOM 读取和修改用户正在浏览的网页中的内容。</p>\n<p>现在知道广告屏蔽插件如何让牛皮癣消失了吧？</p>\n<p><strong>选项页</strong></p>\n<p>选项页（Options Page）的本质是一个完整可见的网页，它的定位是向用户提供更多定制选项。</p>\n<p>对于一些功能复杂的扩展，弹窗能够提供的交互是不够的。在工具栏右键点击扩展图标，选择菜单中的“选项”，即可浏览扩展的选项页。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>接下来我们动手编写一个没什么卵用的 Chrome 扩展，它能够帮助你具备最基础的扩展开发能力。</p>\n<h3 id=\"从清单开始\"><a href=\"#从清单开始\" class=\"headerlink\" title=\"从清单开始\"></a>从清单开始</h3><p>首先，新建一个目录并创建清单文件 <code>manifest.json</code>。</p>\n<pre><code class=\"json\">{\n  &quot;name&quot;: &quot;Chrome Extension Example&quot;,\n  &quot;version&quot;: &quot;1.0&quot;,\n  &quot;description&quot;: &quot;Hello, Chrome extension!&quot;,\n  &quot;manifest_version&quot;: 2\n}</code></pre>\n<p><a href=\"https://developer.chrome.com/extensions/manifest\" target=\"_blank\" rel=\"noopener\">完整</a> 的清单文件包含很多配置项，实际上必要的只有  <code>name</code>，<code>version</code> 和 <code>manifesct_version</code>。顾名思义分别是扩展的名称，版本，以及清单格式版本。</p>\n<p>接着，通过工具栏菜单或访问 <code>chrome://extensions</code> 进入扩展程序管理。启用“开发者模式”。开启后即可通过本地目录安装扩展，调试背景页。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_management.png\" class=\"no-border\" width=\"480\" title=\"扩展管理\">\n\n<p>点击“加载已解压的扩展程序”，选择刚才创建的目录，这个什么功能都没有的扩展就被安装到了浏览器上。地址栏的右侧也新增了一个按钮。</p>\n<h3 id=\"添加背景页\"><a href=\"#添加背景页\" class=\"headerlink\" title=\"添加背景页\"></a>添加背景页</h3><p>接下来添加背景页，用来打印一段文字，顺便体验一下 Chrome 拓展 API。</p>\n<p><code>chrome.storage</code> API 是扩展的存储接口。它提供了用于存储数据到云端（与用户的 Google 账户关联）的 <code>sync</code> 方法，以及存储数据到本地的 <code>local</code> 方法。</p>\n<p>首先，在清单文件中注册 <code>storage</code> 权限和背景页。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;permissions&quot;: [&quot;storage&quot;],\n  &quot;background&quot;: {\n    &quot;scripts&quot;: [&quot;background.js&quot;],\n    &quot;persistent&quot;: false\n  }\n}</code></pre>\n<p>然后，创建背景页脚本 <code>background.js</code>，它将在扩展安装后打印一段文字。</p>\n<pre><code class=\"js\">// background.js\nchrome.runtime.onInstalled.addListener(function() {\n  // 存储数据\n  chrome.storage.sync.set({ msg: &#39;Hello, World!&#39;}, function() {\n    // 读取数据\n    chrome.storage.sync.get([&#39;msg&#39;], function(result) {\n      // 打印数据\n      console.log(result.msg)\n    })\n  })\n})</code></pre>\n<p>最后，重新加载扩展并点击“查看背景页”，弹出的控制台中打印出了：“Hello, World!”。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_debug_background.png\" class=\"no-border\" width=\"540\" title=\"调试背景页\">\n\n<h3 id=\"添加弹窗\"><a href=\"#添加弹窗\" class=\"headerlink\" title=\"添加弹窗\"></a>添加弹窗</h3><p>在清单文件中使用 <code>browser_action</code> 或 <code>page_action</code> 注册弹窗。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;browser_action&quot;: {\n    &quot;default_popup&quot;: &quot;popup.html&quot;\n  }\n}</code></pre>\n<p>两个配置项都可以自定义扩展按钮的图标和功能。它们的区别在于：浏览器按钮（Browser Action）默认在任何时候都可用；页面按钮（Page Action）按钮默认置灰，开发者按需为一些标签页或网址启用。用哪个取决于业务场景，这里我们用前者就行了。</p>\n<p>接着，创建弹窗的布局文件 <code>popup.html</code>。仅仅设置了宽度，添加一串文本到 <code>&lt;body/&gt;</code> 中。</p>\n<pre><code class=\"html\">&lt;!-- popup.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;style&gt;body { width: 100px; }&lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;Hello, World!&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>重新加载扩展并点击图标，图标下方出现自定义弹窗。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_popup.png\" class=\"no-border\" width=\"450\" title=\"扩展的弹窗\">\n\n<h3 id=\"自定义图标\"><a href=\"#自定义图标\" class=\"headerlink\" title=\"自定义图标\"></a>自定义图标</h3><p>在按钮配置中使用 <code>default_icon</code> 设置图标。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;browser_action&quot;: {\n    &quot;default_icon&quot;: {\n      &quot;16&quot;: &quot;images/icon_16.png&quot;,\n      &quot;24&quot;: &quot;images/icon_24.png&quot;,\n      &quot;32&quot;: &quot;images/icon_32.png&quot;\n    },\n    &quot;default_popup&quot;: &quot;popup.html&quot;\n  }\n}</code></pre>\n<p>聪明的你应该注意到了，刚刚配置的图标和弹窗都是 <code>default</code> 开头的默认值。</p>\n<p>这是因为 Chrome 提供了动态修改它们的接口。以浏览器按钮为例，<code>chrome.browserAction</code> API 包含了用于设置弹窗的 <code>setPopup</code>，以及用于设置图标的 <code>setIcon</code>。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本想写一篇《Chrome 扩展：从入门到做一个 XXX 插件》，记录一个 <del>既有功能又有颜值</del> 还凑合的扩展开发全过程。由于工作太忙入完门就继续不下去了。文章在草稿里躺了半个月，今天正式宣布放弃。</p>\n<p>但愿为感兴趣的同学上手浏览器扩展开发做了点微小工作。</p>\n<p>Orz…</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>部分参考资料如下：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Google_Chrome#Extensions\" target=\"_blank\" rel=\"noopener\">Google Chrome Extensions - Wikipedia</a></p>\n</li>\n<li><p><a href=\"https://developer.chrome.com/extensions\" target=\"_blank\" rel=\"noopener\">Extend the Browser - Google Chrome</a></p>\n</li>\n<li><p><a href=\"https://developer.chrome.com/extensions/api_index\" target=\"_blank\" rel=\"noopener\">Extension APIs - Google Chrome</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"认识-Chrome-扩展\"><a href=\"#认识-Chrome-扩展\" class=\"headerlink\" title=\"认识 Chrome 扩展\"></a>认识 Chrome 扩展</h2><p>扩展（Extension）是用于修改或者增加浏览器功能的小型软件。“扩展”这个称谓可能稍显陌生，在国内人们更习惯于称它们为<strong>浏览器插件</strong>。它们使用 HTML，JavaScript, CSS 等网页开发技术构建。</p>","more":"<p><strong>你可以理解为，扩展就是在浏览器中持续运行的网页，当你需要时随时唤醒它，而不需要等待加载。</strong>扩展之于 Chrome 浏览器，就像小程序之于微信。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_adblock.png\" class=\"no-border\" width=\"450\" title=\"Chrome 扩展\">\n\n<p>Chrome 扩展经历了：</p>\n<ul>\n<li>2009年9月，谷歌开发者网站公布扩展。</li>\n<li>2009年12月，Google Chrome 扩展程序中心公测，发布大约300个扩展。</li>\n<li>2010年1月，Google Chrome 扩展程序中心正式上线，包含大约1500个扩展。</li>\n<li>2010年12月，“扩展中心”升级为我们今天熟知的 Chrome 网上应用店。</li>\n</ul>\n<p><strong>时至今日，Chrome 网上应用店托管着大约19万个扩展。</strong></p>\n<p>它们之中有大名鼎鼎的广告拦截程序 Adblock Plus，网页长截屏工具 Full Page Screen Capture，也有前端开发同学们熟悉的调试工具 Vue Devtools，React Developer Tools。</p>\n<p>为什么扩展能够提供如此多样的功能？</p>\n<p>除了程序猿们的努力，更重要的一点是 <strong>Chrome 开放了各种强大的接口</strong>赋能开发者。翻看文档可以发现，<code>chrome.tabs</code> 接口提供了“读取和修改页面内容”的能力，使得“屏蔽广告”成为可能。</p>\n<p>这并不意味着扩展可以不受限制地访问你浏览的内容。和手机上的 app 类似，扩展需要获取权限才能使用相应的能力，同时受用户和 Chrome 网上应用店监督。</p>\n<h2 id=\"Crome-扩展的结构\"><a href=\"#Crome-扩展的结构\" class=\"headerlink\" title=\"Crome 扩展的结构\"></a>Crome 扩展的结构</h2><p>扩展程序由一些“组件”构成。它们都由常见的 web 技术编写，各自负责不同的工作。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_structure.png\" class=\"no-border\" width=\"580\" title=\"Chrome 扩展结构\">\n\n<p><strong>清单</strong></p>\n<p>每个扩展都必须有一个 JSON 格式的清单文件（Manifest），作为扩展程序的配置文件，用于记录一些必不可少的信息。例如：名称和描述，需要使用哪些权限，可以如何与用户交互。</p>\n<p>只要有这个文件，扩展就可以被浏览器识别和安装 —— 即使它不具备任何实用功能。</p>\n<p><strong>背景页</strong></p>\n<p>背景页（Background Page）是一个在后台持续运行的页面。</p>\n<p>虽然称之为一个“页面”，但实际对用户是不可见的。背景页随着浏览器打开（扩展加载）而运行，直到浏览器关闭才会停止。它负责维护扩展的全局状态，还可以和其他扩展通信。</p>\n<p><strong>弹窗</strong></p>\n<p>弹窗（Popup）是扩展与用户交互最常用的方式。其实就是我们平常在浏览器的地址栏右侧，点击扩展按钮会显示的弹窗，通常提供一些设置选项。</p>\n<p>弹窗的生命周期很短，切换标签页就会销毁，再次点击图标会打开一个新的弹窗实例。所以重要的临时数据和操作一定要放在背景页当中。</p>\n<p><strong>内容脚本</strong></p>\n<p>内容脚本（Content Scripts）是运行于网页的上下文环境中的脚本。它可以注入网页中，通过 DOM 读取和修改用户正在浏览的网页中的内容。</p>\n<p>现在知道广告屏蔽插件如何让牛皮癣消失了吧？</p>\n<p><strong>选项页</strong></p>\n<p>选项页（Options Page）的本质是一个完整可见的网页，它的定位是向用户提供更多定制选项。</p>\n<p>对于一些功能复杂的扩展，弹窗能够提供的交互是不够的。在工具栏右键点击扩展图标，选择菜单中的“选项”，即可浏览扩展的选项页。</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>接下来我们动手编写一个没什么卵用的 Chrome 扩展，它能够帮助你具备最基础的扩展开发能力。</p>\n<h3 id=\"从清单开始\"><a href=\"#从清单开始\" class=\"headerlink\" title=\"从清单开始\"></a>从清单开始</h3><p>首先，新建一个目录并创建清单文件 <code>manifest.json</code>。</p>\n<pre><code class=\"json\">{\n  &quot;name&quot;: &quot;Chrome Extension Example&quot;,\n  &quot;version&quot;: &quot;1.0&quot;,\n  &quot;description&quot;: &quot;Hello, Chrome extension!&quot;,\n  &quot;manifest_version&quot;: 2\n}</code></pre>\n<p><a href=\"https://developer.chrome.com/extensions/manifest\" target=\"_blank\" rel=\"noopener\">完整</a> 的清单文件包含很多配置项，实际上必要的只有  <code>name</code>，<code>version</code> 和 <code>manifesct_version</code>。顾名思义分别是扩展的名称，版本，以及清单格式版本。</p>\n<p>接着，通过工具栏菜单或访问 <code>chrome://extensions</code> 进入扩展程序管理。启用“开发者模式”。开启后即可通过本地目录安装扩展，调试背景页。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_management.png\" class=\"no-border\" width=\"480\" title=\"扩展管理\">\n\n<p>点击“加载已解压的扩展程序”，选择刚才创建的目录，这个什么功能都没有的扩展就被安装到了浏览器上。地址栏的右侧也新增了一个按钮。</p>\n<h3 id=\"添加背景页\"><a href=\"#添加背景页\" class=\"headerlink\" title=\"添加背景页\"></a>添加背景页</h3><p>接下来添加背景页，用来打印一段文字，顺便体验一下 Chrome 拓展 API。</p>\n<p><code>chrome.storage</code> API 是扩展的存储接口。它提供了用于存储数据到云端（与用户的 Google 账户关联）的 <code>sync</code> 方法，以及存储数据到本地的 <code>local</code> 方法。</p>\n<p>首先，在清单文件中注册 <code>storage</code> 权限和背景页。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;permissions&quot;: [&quot;storage&quot;],\n  &quot;background&quot;: {\n    &quot;scripts&quot;: [&quot;background.js&quot;],\n    &quot;persistent&quot;: false\n  }\n}</code></pre>\n<p>然后，创建背景页脚本 <code>background.js</code>，它将在扩展安装后打印一段文字。</p>\n<pre><code class=\"js\">// background.js\nchrome.runtime.onInstalled.addListener(function() {\n  // 存储数据\n  chrome.storage.sync.set({ msg: &#39;Hello, World!&#39;}, function() {\n    // 读取数据\n    chrome.storage.sync.get([&#39;msg&#39;], function(result) {\n      // 打印数据\n      console.log(result.msg)\n    })\n  })\n})</code></pre>\n<p>最后，重新加载扩展并点击“查看背景页”，弹出的控制台中打印出了：“Hello, World!”。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_debug_background.png\" class=\"no-border\" width=\"540\" title=\"调试背景页\">\n\n<h3 id=\"添加弹窗\"><a href=\"#添加弹窗\" class=\"headerlink\" title=\"添加弹窗\"></a>添加弹窗</h3><p>在清单文件中使用 <code>browser_action</code> 或 <code>page_action</code> 注册弹窗。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;browser_action&quot;: {\n    &quot;default_popup&quot;: &quot;popup.html&quot;\n  }\n}</code></pre>\n<p>两个配置项都可以自定义扩展按钮的图标和功能。它们的区别在于：浏览器按钮（Browser Action）默认在任何时候都可用；页面按钮（Page Action）按钮默认置灰，开发者按需为一些标签页或网址启用。用哪个取决于业务场景，这里我们用前者就行了。</p>\n<p>接着，创建弹窗的布局文件 <code>popup.html</code>。仅仅设置了宽度，添加一串文本到 <code>&lt;body/&gt;</code> 中。</p>\n<pre><code class=\"html\">&lt;!-- popup.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;style&gt;body { width: 100px; }&lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;Hello, World!&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>重新加载扩展并点击图标，图标下方出现自定义弹窗。</p>\n<img src=\"/images/posts/2019/12/chrome_extension_popup.png\" class=\"no-border\" width=\"450\" title=\"扩展的弹窗\">\n\n<h3 id=\"自定义图标\"><a href=\"#自定义图标\" class=\"headerlink\" title=\"自定义图标\"></a>自定义图标</h3><p>在按钮配置中使用 <code>default_icon</code> 设置图标。</p>\n<pre><code class=\"json\">{\n  // ...\n  &quot;browser_action&quot;: {\n    &quot;default_icon&quot;: {\n      &quot;16&quot;: &quot;images/icon_16.png&quot;,\n      &quot;24&quot;: &quot;images/icon_24.png&quot;,\n      &quot;32&quot;: &quot;images/icon_32.png&quot;\n    },\n    &quot;default_popup&quot;: &quot;popup.html&quot;\n  }\n}</code></pre>\n<p>聪明的你应该注意到了，刚刚配置的图标和弹窗都是 <code>default</code> 开头的默认值。</p>\n<p>这是因为 Chrome 提供了动态修改它们的接口。以浏览器按钮为例，<code>chrome.browserAction</code> API 包含了用于设置弹窗的 <code>setPopup</code>，以及用于设置图标的 <code>setIcon</code>。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本想写一篇《Chrome 扩展：从入门到做一个 XXX 插件》，记录一个 <del>既有功能又有颜值</del> 还凑合的扩展开发全过程。由于工作太忙入完门就继续不下去了。文章在草稿里躺了半个月，今天正式宣布放弃。</p>\n<p>但愿为感兴趣的同学上手浏览器扩展开发做了点微小工作。</p>\n<p>Orz…</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>部分参考资料如下：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Google_Chrome#Extensions\" target=\"_blank\" rel=\"noopener\">Google Chrome Extensions - Wikipedia</a></p>\n</li>\n<li><p><a href=\"https://developer.chrome.com/extensions\" target=\"_blank\" rel=\"noopener\">Extend the Browser - Google Chrome</a></p>\n</li>\n<li><p><a href=\"https://developer.chrome.com/extensions/api_index\" target=\"_blank\" rel=\"noopener\">Extension APIs - Google Chrome</a></p>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckc1bt44y0006rqgjb7zkf0qc","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt453000brqgje4tk7yt3"},{"post_id":"ckc1bt44q0001rqgj2cjy08b1","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt454000erqgj7daxcn1c"},{"post_id":"ckc1bt44z0007rqgjdily9gmb","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt455000grqgjbbep3aq9"},{"post_id":"ckc1bt452000arqgjarzy8i3p","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt455000jrqgj5d9udkwl"},{"post_id":"ckc1bt44t0002rqgj8p2dgcw5","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt456000lrqgjaoh9fctr"},{"post_id":"ckc1bt44x0005rqgjgy10g2p3","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt457000nrqgjewnd09ez"},{"post_id":"ckc1bt46b0010rqgj4cx1hbil","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46i0016rqgjdgsfd8vw"},{"post_id":"ckc1bt46c0011rqgjgbwfch6i","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46k0019rqgj3ebw15yu"},{"post_id":"ckc1bt46e0013rqgj0bbj87b8","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46l001crqgj3cq91bjr"},{"post_id":"ckc1bt46f0015rqgj3jjabzrq","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46m001frqgja68ygblh"},{"post_id":"ckc1bt46j0018rqgja3bw56ui","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46n001irqgjejy4h69r"},{"post_id":"ckc1bt46k001brqgjhllj1wvl","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46s001lrqgjhf54al0d"},{"post_id":"ckc1bt46l001erqgj801g0ica","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46u001orqgj2bic49o7"},{"post_id":"ckc1bt46n001hrqgjfk1u8uhs","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46w001rrqgj0i2mgbky"},{"post_id":"ckc1bt46q001krqgjchlb7o0l","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46x001urqgjcy9j39n8"},{"post_id":"ckc1bt46t001nrqgj17b586vp","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46y001xrqgj39627ncw"},{"post_id":"ckc1bt46v001qrqgj2pydar8y","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt46z0020rqgja2158bnt"},{"post_id":"ckc1bt46w001trqgj9n9o6g9w","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt4700023rqgjgq8na5uv"},{"post_id":"ckc1bt46x001wrqgj2mcp9521","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt4710026rqgjcxnngji4"},{"post_id":"ckc1bt46y001zrqgj1iyodxfu","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt473002arqgj1504dnn8"},{"post_id":"ckc1bt46z0022rqgj4rxh6hty","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt476002drqgjbsqedca7"},{"post_id":"ckc1bt4700025rqgj7kejfexa","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt479002hrqgjhbvv2aea"},{"post_id":"ckc1bt4720029rqgjhvu3b39q","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47a002krqgjfy1mbfqz"},{"post_id":"ckc1bt475002crqgj6ttcejbo","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47b002orqgja6to6boc"},{"post_id":"ckc1bt479002jrqgj6on56e5p","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47i002urqgj978aa5vq"},{"post_id":"ckc1bt47b002nrqgjcash4nbq","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47l002yrqgj3y2h3lej"},{"post_id":"ckc1bt47f002rrqgj944hc1o0","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47m0031rqgjdsji0qoo"},{"post_id":"ckc1bt476002frqgjd0bc5h86","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt47n0035rqgjec27ezj4"},{"post_id":"ckc1bt47h002trqgjf85t1o7s","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt47p0039rqgjh23f7npr"},{"post_id":"ckc1bt47k002xrqgjcta6cgmf","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt47r003drqgjbgay6azr"},{"post_id":"ckc1bt47p003brqgj64rp5qd2","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt47y003mrqgj5zvj8607"},{"post_id":"ckc1bt47l0030rqgjc4ea2vsz","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt481003qrqgj7k0e4dwx"},{"post_id":"ckc1bt47r003frqgjgfaaa6cw","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt486003urqgjaaio1ec6"},{"post_id":"ckc1bt47v003irqgj2p4vegx9","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt487003xrqgjahyc14za"},{"post_id":"ckc1bt47m0034rqgj6abf8gxi","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4890041rqgjhua8blah"},{"post_id":"ckc1bt47w003lrqgj1l608xvl","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48a0044rqgje889hi08"},{"post_id":"ckc1bt480003prqgjg7yi2hv2","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48b0048rqgjcy043mts"},{"post_id":"ckc1bt47o0038rqgj5j4yccvv","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48b004brqgjfyp7b2xg"},{"post_id":"ckc1bt482003trqgj7uwqb9kp","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48d004erqgjc7525jnf"},{"post_id":"ckc1bt486003wrqgj1hjv2u1d","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48f004irqgj0m585n8x"},{"post_id":"ckc1bt4880040rqgj4lz95tc2","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48f004lrqgjesdnc46w"},{"post_id":"ckc1bt4890043rqgj8ly54zjp","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48h004prqgjdzny7iw7"},{"post_id":"ckc1bt48a0047rqgj0f464zlr","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48i004srqgjd4zohk9x"},{"post_id":"ckc1bt48b004arqgjgdypcomv","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48j004wrqgj6e2j8t96"},{"post_id":"ckc1bt48c004drqgj1xl0eqg1","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48l004zrqgjbda30rve"},{"post_id":"ckc1bt48e004hrqgj9fapb5hm","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48m0053rqgjc445gv0y"},{"post_id":"ckc1bt48f004krqgjehiheyuk","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48n0056rqgj25jxdb9a"},{"post_id":"ckc1bt48g004orqgjhpvaffvl","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48o005arqgjdj3l7nda"},{"post_id":"ckc1bt48h004rrqgja6lp679b","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48o005drqgj7x51fu85"},{"post_id":"ckc1bt48j004vrqgj8fm38d5o","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48p005irqgj3ciwdds1"},{"post_id":"ckc1bt48j004yrqgj7rgq1r9g","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48q005lrqgjdpez3lg3"},{"post_id":"ckc1bt48l0052rqgj536fhudo","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt48t005qrqgj163f8xi0"},{"post_id":"ckc1bt48m0055rqgjhbs14yv4","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48u005trqgj8wt5e1d3"},{"post_id":"ckc1bt48p005hrqgjgdhy3mae","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48w005wrqgj01alcxwo"},{"post_id":"ckc1bt48q005krqgjbsf4d07u","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48x0060rqgj99sl1aon"},{"post_id":"ckc1bt48n0059rqgj3lqv1q2e","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt48y0063rqgj604x8td3"},{"post_id":"ckc1bt48r005orqgj4dr45t6d","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt48z0067rqgj8ggg6oj0"},{"post_id":"ckc1bt48t005srqgj9orsbktg","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt490006arqgjfjp8gfnf"},{"post_id":"ckc1bt48o005crqgjg5x773ss","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt492006erqgj6l3vfms5"},{"post_id":"ckc1bt48v005vrqgj2azzh3dm","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt493006hrqgjgof5ebt1"},{"post_id":"ckc1bt48x005zrqgj0om0blmu","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt494006lrqgj7a3f1eur"},{"post_id":"ckc1bt48x0062rqgj5sx77hay","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt494006orqgj3ndcdms6"},{"post_id":"ckc1bt48y0066rqgjfwwpal9x","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt495006srqgj3ewegfb1"},{"post_id":"ckc1bt48z0069rqgjfo6obx66","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt496006vrqgjb21o6img"},{"post_id":"ckc1bt492006drqgj5kjg59na","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt497006zrqgjc17i9s6r"},{"post_id":"ckc1bt492006grqgj1osa1db8","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49a0072rqgjefm90exb"},{"post_id":"ckc1bt493006krqgjgqlc8211","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49c0075rqgj7ut01fgu"},{"post_id":"ckc1bt494006nrqgjha50f8od","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49d0079rqgjhuaw91th"},{"post_id":"ckc1bt495006rrqgjhe527p8n","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49e007crqgjbgqvhxth"},{"post_id":"ckc1bt496006urqgjfx9674z0","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49f007grqgjb3cp9ct9"},{"post_id":"ckc1bt496006yrqgj56muc8om","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49f007jrqgj8kk5046l"},{"post_id":"ckc1bt4970071rqgj0a9q867l","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49h007nrqgjgd0g0eji"},{"post_id":"ckc1bt49b0074rqgj7ohn11g9","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49i007qrqgjay0y1r5c"},{"post_id":"ckc1bt49c0078rqgjgf0p3mz6","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49j007urqgjck21gak0"},{"post_id":"ckc1bt49d007brqgjcgvr50bc","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt49j007xrqgj1swmchcd"},{"post_id":"ckc1bt49e007frqgj25d4gpfb","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt49k0081rqgjeouje3lk"},{"post_id":"ckc1bt49f007irqgjgjve1b6m","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49l0084rqgjdl563he0"},{"post_id":"ckc1bt49g007mrqgj94zk0qd6","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49m0088rqgj4m5m6p59"},{"post_id":"ckc1bt49h007prqgjavap7ah0","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49m008brqgj1hwj9bpu"},{"post_id":"ckc1bt49i007trqgj3six0l3e","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49n008frqgj0vm8bzlm"},{"post_id":"ckc1bt49j007wrqgj06um02jg","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49q008irqgj9kj76dgc"},{"post_id":"ckc1bt49k0080rqgj4kdz9yss","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt49s008lrqgj6059hmjt"},{"post_id":"ckc1bt49k0083rqgjfgnggdif","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49u008prqgj6dsd3c9u"},{"post_id":"ckc1bt49l0087rqgjaivx4zjk","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49u008srqgj9f8r55b5"},{"post_id":"ckc1bt49m008arqgj5b1o7ylj","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt49v008wrqgj8qx68pfp"},{"post_id":"ckc1bt49n008erqgj0fim3xys","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49w008zrqgj5uivct85"},{"post_id":"ckc1bt49p008hrqgj0phy33yi","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt49x0093rqgj2l3de5a6"},{"post_id":"ckc1bt49r008krqgj7omu0d0e","category_id":"ckc1bt48p005frqgj2plj4yig","_id":"ckc1bt49y0096rqgjeb3nhyz9"},{"post_id":"ckc1bt49t008orqgj00xzgek7","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt49z009arqgjdxgcfh7v"},{"post_id":"ckc1bt49u008rrqgjc6dq5s2w","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a1009drqgjhi4x18iw"},{"post_id":"ckc1bt49v008vrqgj2qld4sty","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4a3009hrqgj8h7z8512"},{"post_id":"ckc1bt49w008yrqgjc3qj3ccn","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a4009krqgjgctma1tq"},{"post_id":"ckc1bt49x0092rqgj00gigcox","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a5009orqgj70gq3g1y"},{"post_id":"ckc1bt49x0095rqgj6x2l9xup","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a6009rrqgj8iwc7whk"},{"post_id":"ckc1bt49z0099rqgjhitg2lx3","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a6009urqgj03iecfya"},{"post_id":"ckc1bt4a0009crqgj7e3taz00","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a7009yrqgj2y8jg9kj"},{"post_id":"ckc1bt4a2009grqgjb1mob772","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4a800a1rqgjc2t67h8l"},{"post_id":"ckc1bt4a3009jrqgj98qkfcyh","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4a900a5rqgjats6hz7j"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4ab00a8rqgj0b2z8z8c"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4ac00acrqgjaz3n11h1"},{"post_id":"ckc1bt4a6009trqgjhs0x89ia","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4ad00afrqgjat19gzcv"},{"post_id":"ckc1bt4a7009xrqgjbzce98u5","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4ae00airqgj5gw74fv6"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4ae00akrqgj04zc16lp"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4ae00anrqgj0k7lfzge"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt4ae00aprqgj0x1f70uj"},{"post_id":"ckc1bt4ac00abrqgjfhevaij2","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4af00asrqgj4bhzh7yg"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","category_id":"ckc1bt44u0003rqgjb2g79jr7","_id":"ckc1bt4af00aurqgjf6ht9841"},{"post_id":"ckc1bt4br00ezrqgj4vw8epuk","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4bv00f5rqgjeg5qc5vp"},{"post_id":"ckc1bt4bs00f0rqgjhh2bhede","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4bx00f9rqgjbb08ccl3"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4by00fdrqgj2i3scygw"},{"post_id":"ckc1bt4bw00f8rqgj35hzcy1c","category_id":"ckc1bt47a002lrqgjbypkfvda","_id":"ckc1bt4bz00ffrqgjhpghdqjj"},{"post_id":"ckc1bt4by00fcrqgje3jjerek","category_id":"ckc1bt47o0036rqgj1w5sgobr","_id":"ckc1bt4c100fgrqgj8pqecyhk"},{"post_id":"ckc1bt4bv00f4rqgje7cc6qv4","category_id":"ckc1bt4bx00farqgjffof5iou","_id":"ckc1bt4c200firqgjcm8g6k0m"}],"PostTag":[{"post_id":"ckc1bt44q0001rqgj2cjy08b1","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt455000frqgjdzmxf8st"},{"post_id":"ckc1bt44q0001rqgj2cjy08b1","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt455000hrqgj59qsacli"},{"post_id":"ckc1bt44t0002rqgj8p2dgcw5","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt455000krqgjb7og2a5l"},{"post_id":"ckc1bt44x0005rqgjgy10g2p3","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt457000prqgj1fib75nk"},{"post_id":"ckc1bt44x0005rqgjgy10g2p3","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt457000qrqgj8mr4dv8w"},{"post_id":"ckc1bt44y0006rqgjb7zkf0qc","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt458000srqgj6rhl7wnk"},{"post_id":"ckc1bt44y0006rqgjb7zkf0qc","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt459000trqgj13juah2c"},{"post_id":"ckc1bt44z0007rqgjdily9gmb","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt459000vrqgj2vib7075"},{"post_id":"ckc1bt44z0007rqgjdily9gmb","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt459000wrqgja4j18044"},{"post_id":"ckc1bt452000arqgjarzy8i3p","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt459000xrqgjapc3c5q0"},{"post_id":"ckc1bt452000arqgjarzy8i3p","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt459000yrqgjewsh9jhq"},{"post_id":"ckc1bt452000arqgjarzy8i3p","tag_id":"ckc1bt459000urqgj3aane7c9","_id":"ckc1bt45a000zrqgj8dvdestr"},{"post_id":"ckc1bt46b0010rqgj4cx1hbil","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46d0012rqgj69y26grs"},{"post_id":"ckc1bt46b0010rqgj4cx1hbil","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46f0014rqgj5bq58khr"},{"post_id":"ckc1bt46c0011rqgjgbwfch6i","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46j0017rqgjavbic2gt"},{"post_id":"ckc1bt46c0011rqgjgbwfch6i","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46k001arqgj1czo9un1"},{"post_id":"ckc1bt46e0013rqgj0bbj87b8","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46l001drqgjc937c9ea"},{"post_id":"ckc1bt46e0013rqgj0bbj87b8","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46m001grqgj2i5h76lt"},{"post_id":"ckc1bt46f0015rqgj3jjabzrq","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46o001jrqgj1dfvd0ot"},{"post_id":"ckc1bt46f0015rqgj3jjabzrq","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46t001mrqgjasq3cb5o"},{"post_id":"ckc1bt46j0018rqgja3bw56ui","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46v001prqgj8ljq8vxv"},{"post_id":"ckc1bt46k001brqgjhllj1wvl","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46w001srqgj584veqjs"},{"post_id":"ckc1bt46k001brqgjhllj1wvl","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46x001vrqgj0ddigbq7"},{"post_id":"ckc1bt46l001erqgj801g0ica","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt46y001yrqgj6prxf7eu"},{"post_id":"ckc1bt46l001erqgj801g0ica","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt46z0021rqgj02lg7ccf"},{"post_id":"ckc1bt46n001hrqgjfk1u8uhs","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt4700024rqgjgimv229f"},{"post_id":"ckc1bt46n001hrqgjfk1u8uhs","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt4710028rqgj4ca47wub"},{"post_id":"ckc1bt46q001krqgjchlb7o0l","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt475002brqgjbyiod9t1"},{"post_id":"ckc1bt46q001krqgjchlb7o0l","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt476002erqgj6s6l8s4b"},{"post_id":"ckc1bt46t001nrqgj17b586vp","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt479002irqgj46snhajz"},{"post_id":"ckc1bt46t001nrqgj17b586vp","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt47b002mrqgjbltedj1q"},{"post_id":"ckc1bt46v001qrqgj2pydar8y","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt47f002qrqgj4nlge8g8"},{"post_id":"ckc1bt46v001qrqgj2pydar8y","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt47h002srqgjh3jn2v0a"},{"post_id":"ckc1bt46w001trqgj9n9o6g9w","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt47j002wrqgjaln0dzax"},{"post_id":"ckc1bt46w001trqgj9n9o6g9w","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt47l002zrqgja2eweil6"},{"post_id":"ckc1bt46x001wrqgj2mcp9521","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt47m0033rqgj4f4725iw"},{"post_id":"ckc1bt46x001wrqgj2mcp9521","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt47o0037rqgjdv3xbust"},{"post_id":"ckc1bt46y001zrqgj1iyodxfu","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt47p003arqgjd792cay1"},{"post_id":"ckc1bt46y001zrqgj1iyodxfu","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt47r003erqgj424g8p65"},{"post_id":"ckc1bt475002crqgj6ttcejbo","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt47v003hrqgjedbt72sg"},{"post_id":"ckc1bt476002frqgjd0bc5h86","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt47w003krqgjdzkh02rf"},{"post_id":"ckc1bt479002jrqgj6on56e5p","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt480003orqgjc6zr96s8"},{"post_id":"ckc1bt479002jrqgj6on56e5p","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt482003srqgj5jmv1utd"},{"post_id":"ckc1bt46z0022rqgj4rxh6hty","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt486003vrqgj2z25ek9z"},{"post_id":"ckc1bt46z0022rqgj4rxh6hty","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt488003zrqgj1t3obmw2"},{"post_id":"ckc1bt46z0022rqgj4rxh6hty","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4890042rqgjep2i6zxj"},{"post_id":"ckc1bt46z0022rqgj4rxh6hty","tag_id":"ckc1bt479002grqgje09f2are","_id":"ckc1bt48a0046rqgj3znebs7p"},{"post_id":"ckc1bt47b002nrqgjcash4nbq","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt48b0049rqgj30dnhglw"},{"post_id":"ckc1bt47f002rrqgj944hc1o0","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt48c004crqgjfpsh25fu"},{"post_id":"ckc1bt47f002rrqgj944hc1o0","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt48e004grqgj0dygau0q"},{"post_id":"ckc1bt4700025rqgj7kejfexa","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt48f004jrqgj7n2d6qu8"},{"post_id":"ckc1bt4700025rqgj7kejfexa","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt48g004nrqgj643feiti"},{"post_id":"ckc1bt4700025rqgj7kejfexa","tag_id":"ckc1bt47b002prqgjafa43h4d","_id":"ckc1bt48h004qrqgjeog1bl2n"},{"post_id":"ckc1bt47h002trqgjf85t1o7s","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt48i004urqgj4zp73e02"},{"post_id":"ckc1bt47h002trqgjf85t1o7s","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt48j004xrqgj68w4g4uv"},{"post_id":"ckc1bt4720029rqgjhvu3b39q","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt48l0051rqgjgt8p7q95"},{"post_id":"ckc1bt4720029rqgjhvu3b39q","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt48m0054rqgj1rte570i"},{"post_id":"ckc1bt4720029rqgjhvu3b39q","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt48n0058rqgj4g3o3ngl"},{"post_id":"ckc1bt47k002xrqgjcta6cgmf","tag_id":"ckc1bt47m0032rqgjceek2zbc","_id":"ckc1bt48o005brqgjeehjaetv"},{"post_id":"ckc1bt47r003frqgjgfaaa6cw","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt48p005grqgjfbgkcns2"},{"post_id":"ckc1bt47l0030rqgjc4ea2vsz","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt48q005jrqgjebccbm6x"},{"post_id":"ckc1bt47m0034rqgj6abf8gxi","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt48r005nrqgj8clh0b9x"},{"post_id":"ckc1bt482003trqgj7uwqb9kp","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt48t005rrqgjbda4hqv9"},{"post_id":"ckc1bt47o0038rqgj5j4yccvv","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt48v005urqgj8etzg2ey"},{"post_id":"ckc1bt486003wrqgj1hjv2u1d","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt48w005yrqgj62gxb3xo"},{"post_id":"ckc1bt4890043rqgj8ly54zjp","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt48x0061rqgj60spadm2"},{"post_id":"ckc1bt48a0047rqgj0f464zlr","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt48y0065rqgjd619fy4h"},{"post_id":"ckc1bt48b004arqgjgdypcomv","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt48z0068rqgjeccsg72v"},{"post_id":"ckc1bt48b004arqgjgdypcomv","tag_id":"ckc1bt459000urqgj3aane7c9","_id":"ckc1bt491006crqgj9uz1a8cg"},{"post_id":"ckc1bt48c004drqgj1xl0eqg1","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt492006frqgjbhy32iog"},{"post_id":"ckc1bt48e004hrqgj9fapb5hm","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt493006jrqgj7wyhc9pi"},{"post_id":"ckc1bt48e004hrqgj9fapb5hm","tag_id":"ckc1bt459000urqgj3aane7c9","_id":"ckc1bt494006mrqgj0i9act75"},{"post_id":"ckc1bt47p003brqgj64rp5qd2","tag_id":"ckc1bt487003yrqgj06bc3z30","_id":"ckc1bt495006qrqgj378g3n2x"},{"post_id":"ckc1bt47p003brqgj64rp5qd2","tag_id":"ckc1bt48a0045rqgj02gz5uvr","_id":"ckc1bt496006trqgjd096as0w"},{"post_id":"ckc1bt47p003brqgj64rp5qd2","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt496006xrqgja79nc2uy"},{"post_id":"ckc1bt47v003irqgj2p4vegx9","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4970070rqgjfws6g3os"},{"post_id":"ckc1bt47v003irqgj2p4vegx9","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt49b0073rqgjgzekb26c"},{"post_id":"ckc1bt48h004rrqgja6lp679b","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt49c0077rqgja07i0phn"},{"post_id":"ckc1bt48j004vrqgj8fm38d5o","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt49d007arqgj7wv160t8"},{"post_id":"ckc1bt48j004yrqgj7rgq1r9g","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt49e007erqgjall22k4m"},{"post_id":"ckc1bt48l0052rqgj536fhudo","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt49f007hrqgjd7wk8qjr"},{"post_id":"ckc1bt48l0052rqgj536fhudo","tag_id":"ckc1bt48i004trqgjc00z3wdw","_id":"ckc1bt49g007lrqgj2njwgpaa"},{"post_id":"ckc1bt47w003lrqgj1l608xvl","tag_id":"ckc1bt48i004trqgjc00z3wdw","_id":"ckc1bt49h007orqgjcrmn4x57"},{"post_id":"ckc1bt47w003lrqgj1l608xvl","tag_id":"ckc1bt48l0050rqgj5eoe85mk","_id":"ckc1bt49i007srqgj7cxa6s0u"},{"post_id":"ckc1bt47w003lrqgj1l608xvl","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt49j007vrqgj3nc3gl1l"},{"post_id":"ckc1bt480003prqgjg7yi2hv2","tag_id":"ckc1bt48l0050rqgj5eoe85mk","_id":"ckc1bt49k007zrqgj9mt0fo5g"},{"post_id":"ckc1bt480003prqgjg7yi2hv2","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt49k0082rqgj874i8hel"},{"post_id":"ckc1bt4880040rqgj4lz95tc2","tag_id":"ckc1bt48p005erqgj5qrvbhum","_id":"ckc1bt49l0086rqgj6h4k89o9"},{"post_id":"ckc1bt4880040rqgj4lz95tc2","tag_id":"ckc1bt48r005mrqgjf7yq5ao7","_id":"ckc1bt49m0089rqgj5m6ubkpe"},{"post_id":"ckc1bt48f004krqgjehiheyuk","tag_id":"ckc1bt48p005erqgj5qrvbhum","_id":"ckc1bt49n008drqgj3ghr6vfx"},{"post_id":"ckc1bt48y0066rqgjfwwpal9x","tag_id":"ckc1bt48r005mrqgjf7yq5ao7","_id":"ckc1bt49p008grqgjavcvgn9x"},{"post_id":"ckc1bt48g004orqgjhpvaffvl","tag_id":"ckc1bt48p005erqgj5qrvbhum","_id":"ckc1bt49q008jrqgj1lov1y3o"},{"post_id":"ckc1bt48z0069rqgjfo6obx66","tag_id":"ckc1bt487003yrqgj06bc3z30","_id":"ckc1bt49t008nrqgj06529gl1"},{"post_id":"ckc1bt48z0069rqgjfo6obx66","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt49u008qrqgj3m0y8rgi"},{"post_id":"ckc1bt492006drqgj5kjg59na","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt49v008urqgjekia3pf9"},{"post_id":"ckc1bt48m0055rqgjhbs14yv4","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt49w008xrqgjcbgo2jtz"},{"post_id":"ckc1bt48m0055rqgjhbs14yv4","tag_id":"ckc1bt491006brqgjgssheyd4","_id":"ckc1bt49x0091rqgj8lxfcnql"},{"post_id":"ckc1bt48n0059rqgj3lqv1q2e","tag_id":"ckc1bt493006irqgj101ybnmk","_id":"ckc1bt49x0094rqgj0ts9h1lu"},{"post_id":"ckc1bt495006rrqgjhe527p8n","tag_id":"ckc1bt487003yrqgj06bc3z30","_id":"ckc1bt49y0098rqgj8k6ca4jr"},{"post_id":"ckc1bt495006rrqgjhe527p8n","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4a0009brqgjggeb6wi0"},{"post_id":"ckc1bt48o005crqgjg5x773ss","tag_id":"ckc1bt495006prqgj9rk32vc7","_id":"ckc1bt4a1009frqgj1mos8mcz"},{"post_id":"ckc1bt4970071rqgj0a9q867l","tag_id":"ckc1bt48p005erqgj5qrvbhum","_id":"ckc1bt4a3009irqgj27oo3q45"},{"post_id":"ckc1bt48p005hrqgjgdhy3mae","tag_id":"ckc1bt496006wrqgjhtqub8a7","_id":"ckc1bt4a4009mrqgj9rqugggv"},{"post_id":"ckc1bt49b0074rqgj7ohn11g9","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4a5009prqgjgclrhnit"},{"post_id":"ckc1bt48q005krqgjbsf4d07u","tag_id":"ckc1bt496006wrqgjhtqub8a7","_id":"ckc1bt4a6009srqgje55qekex"},{"post_id":"ckc1bt48r005orqgj4dr45t6d","tag_id":"ckc1bt496006wrqgjhtqub8a7","_id":"ckc1bt4a7009wrqgjd6p3adr7"},{"post_id":"ckc1bt48t005srqgj9orsbktg","tag_id":"ckc1bt496006wrqgjhtqub8a7","_id":"ckc1bt4a8009zrqgjg6ru1smq"},{"post_id":"ckc1bt48t005srqgj9orsbktg","tag_id":"ckc1bt49i007rrqgjhawtgvo3","_id":"ckc1bt4a800a3rqgjd3uxcta8"},{"post_id":"ckc1bt49k0080rqgj4kdz9yss","tag_id":"ckc1bt493006irqgj101ybnmk","_id":"ckc1bt4a900a6rqgj5wlt7t8w"},{"post_id":"ckc1bt48v005vrqgj2azzh3dm","tag_id":"ckc1bt49j007yrqgj44rf2tbf","_id":"ckc1bt4ab00aarqgjbm20fepg"},{"post_id":"ckc1bt49l0087rqgjaivx4zjk","tag_id":"ckc1bt493006irqgj101ybnmk","_id":"ckc1bt4ac00adrqgj04p2g5ey"},{"post_id":"ckc1bt49m008arqgj5b1o7ylj","tag_id":"ckc1bt495006prqgj9rk32vc7","_id":"ckc1bt4ad00ahrqgjgw0m63vx"},{"post_id":"ckc1bt49n008erqgj0fim3xys","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ae00ajrqgjenn6huye"},{"post_id":"ckc1bt49p008hrqgj0phy33yi","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4ae00amrqgj96ba4vtz"},{"post_id":"ckc1bt48x005zrqgj0om0blmu","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4ae00aorqgj0yi81ja6"},{"post_id":"ckc1bt48x005zrqgj0om0blmu","tag_id":"ckc1bt49n008crqgj2xq72ofy","_id":"ckc1bt4af00arrqgjffimgxd7"},{"post_id":"ckc1bt49t008orqgj00xzgek7","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4af00atrqgj7ux03rp4"},{"post_id":"ckc1bt48x0062rqgj5sx77hay","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4af00awrqgj02sebm5p"},{"post_id":"ckc1bt48x0062rqgj5sx77hay","tag_id":"ckc1bt49v008trqgjca4b4yvg","_id":"ckc1bt4af00axrqgjgdq69k37"},{"post_id":"ckc1bt49x0092rqgj00gigcox","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt4ag00azrqgjge3w0y3b"},{"post_id":"ckc1bt49x0095rqgj6x2l9xup","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ag00b0rqgj9z192mcg"},{"post_id":"ckc1bt49z0099rqgjhitg2lx3","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ah00b2rqgjdc3e2qbo"},{"post_id":"ckc1bt49z0099rqgjhitg2lx3","tag_id":"ckc1bt49j007yrqgj44rf2tbf","_id":"ckc1bt4ah00b3rqgjfxdmdfzy"},{"post_id":"ckc1bt492006grqgj1osa1db8","tag_id":"ckc1bt49w0090rqgj501x44o9","_id":"ckc1bt4ai00b5rqgj2z1m89l2"},{"post_id":"ckc1bt492006grqgj1osa1db8","tag_id":"ckc1bt49y0097rqgj74xq6ze7","_id":"ckc1bt4ai00b6rqgj2l37ctbo"},{"post_id":"ckc1bt493006krqgjgqlc8211","tag_id":"ckc1bt49y0097rqgj74xq6ze7","_id":"ckc1bt4ai00b8rqgja7wz9epg"},{"post_id":"ckc1bt494006nrqgjha50f8od","tag_id":"ckc1bt48p005erqgj5qrvbhum","_id":"ckc1bt4aj00b9rqgj1a2metdd"},{"post_id":"ckc1bt494006nrqgjha50f8od","tag_id":"ckc1bt4a4009lrqgj5atpf5cw","_id":"ckc1bt4aj00bbrqgjbpxz3aps"},{"post_id":"ckc1bt496006urqgjfx9674z0","tag_id":"ckc1bt49n008crqgj2xq72ofy","_id":"ckc1bt4aj00bcrqgjfd62ag9f"},{"post_id":"ckc1bt496006urqgjfx9674z0","tag_id":"ckc1bt4a4009lrqgj5atpf5cw","_id":"ckc1bt4aj00bdrqgj6eys8d1b"},{"post_id":"ckc1bt496006yrqgj56muc8om","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4aj00bfrqgjd0kl0b6b"},{"post_id":"ckc1bt496006yrqgj56muc8om","tag_id":"ckc1bt4a4009lrqgj5atpf5cw","_id":"ckc1bt4ak00bgrqgjaylq5d8n"},{"post_id":"ckc1bt49c0078rqgjgf0p3mz6","tag_id":"ckc1bt49n008crqgj2xq72ofy","_id":"ckc1bt4ak00birqgjcivn3w2p"},{"post_id":"ckc1bt49c0078rqgjgf0p3mz6","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4ak00bjrqgjfv5jdne6"},{"post_id":"ckc1bt49d007brqgjcgvr50bc","tag_id":"ckc1bt493006irqgj101ybnmk","_id":"ckc1bt4ak00blrqgj3zt2609r"},{"post_id":"ckc1bt49d007brqgjcgvr50bc","tag_id":"ckc1bt4ae00alrqgjafcw0iv5","_id":"ckc1bt4ak00bmrqgjecn1cqjd"},{"post_id":"ckc1bt49e007frqgj25d4gpfb","tag_id":"ckc1bt495006prqgj9rk32vc7","_id":"ckc1bt4al00borqgjfgqwbbc8"},{"post_id":"ckc1bt49e007frqgj25d4gpfb","tag_id":"ckc1bt49w0090rqgj501x44o9","_id":"ckc1bt4al00bprqgj420za9te"},{"post_id":"ckc1bt49f007irqgjgjve1b6m","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4al00bqrqgjf98bgc9j"},{"post_id":"ckc1bt49f007irqgjgjve1b6m","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4al00bsrqgj24ele4gy"},{"post_id":"ckc1bt49g007mrqgj94zk0qd6","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4al00btrqgj13hub2b9"},{"post_id":"ckc1bt49g007mrqgj94zk0qd6","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4al00bvrqgja2g9a7xe"},{"post_id":"ckc1bt49h007prqgjavap7ah0","tag_id":"ckc1bt4ag00b1rqgj6r794exa","_id":"ckc1bt4al00bwrqgje9iw2lcm"},{"post_id":"ckc1bt49h007prqgjavap7ah0","tag_id":"ckc1bt4ah00b4rqgj6bk8hkcm","_id":"ckc1bt4am00byrqgjfxwpf8tc"},{"post_id":"ckc1bt49h007prqgjavap7ah0","tag_id":"ckc1bt4ae00alrqgjafcw0iv5","_id":"ckc1bt4am00bzrqgj63twbjqd"},{"post_id":"ckc1bt49i007trqgj3six0l3e","tag_id":"ckc1bt4aj00barqgjeaah2pe5","_id":"ckc1bt4am00c1rqgj2mgq8ftk"},{"post_id":"ckc1bt49j007wrqgj06um02jg","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4am00c2rqgjewgcckws"},{"post_id":"ckc1bt49j007wrqgj06um02jg","tag_id":"ckc1bt4aj00berqgjddwo1emg","_id":"ckc1bt4an00c4rqgj225tb4f5"},{"post_id":"ckc1bt49k0083rqgjfgnggdif","tag_id":"ckc1bt4ak00bhrqgj1oxob3n5","_id":"ckc1bt4an00c5rqgj5j0c1d6u"},{"post_id":"ckc1bt49k0083rqgjfgnggdif","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt4an00c7rqgj427jflca"},{"post_id":"ckc1bt49r008krqgj7omu0d0e","tag_id":"ckc1bt4ak00bkrqgjfn22ed3i","_id":"ckc1bt4an00c8rqgj3t8fhhxu"},{"post_id":"ckc1bt49u008rrqgjc6dq5s2w","tag_id":"ckc1bt4ak00bnrqgj9w860ag6","_id":"ckc1bt4an00carqgjgfwkhpre"},{"post_id":"ckc1bt49u008rrqgjc6dq5s2w","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ao00cbrqgj8fij87w8"},{"post_id":"ckc1bt49v008vrqgj2qld4sty","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4ao00cdrqgjcklkbryx"},{"post_id":"ckc1bt49v008vrqgj2qld4sty","tag_id":"ckc1bt4al00brrqgj7uatb2d0","_id":"ckc1bt4ao00cerqgj8wma6ory"},{"post_id":"ckc1bt49v008vrqgj2qld4sty","tag_id":"ckc1bt4al00burqgj45jddbu5","_id":"ckc1bt4ao00cfrqgjgye70ga6"},{"post_id":"ckc1bt49w008yrqgjc3qj3ccn","tag_id":"ckc1bt47q003crqgj3b1982mw","_id":"ckc1bt4ao00chrqgjf8p00isl"},{"post_id":"ckc1bt49w008yrqgjc3qj3ccn","tag_id":"ckc1bt4am00bxrqgj482td388","_id":"ckc1bt4ao00cirqgjac09d6kj"},{"post_id":"ckc1bt4a0009crqgj7e3taz00","tag_id":"ckc1bt4aj00barqgjeaah2pe5","_id":"ckc1bt4ap00ckrqgj955a1f16"},{"post_id":"ckc1bt4a0009crqgj7e3taz00","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ap00clrqgj3ggc0n2q"},{"post_id":"ckc1bt4a2009grqgjb1mob772","tag_id":"ckc1bt4ag00b1rqgj6r794exa","_id":"ckc1bt4aq00cnrqgj2suk9usn"},{"post_id":"ckc1bt4a2009grqgjb1mob772","tag_id":"ckc1bt4ah00b4rqgj6bk8hkcm","_id":"ckc1bt4aq00corqgj94fk9g6o"},{"post_id":"ckc1bt4a2009grqgjb1mob772","tag_id":"ckc1bt4ae00alrqgjafcw0iv5","_id":"ckc1bt4aq00cqrqgj0zpe3ehy"},{"post_id":"ckc1bt4a2009grqgjb1mob772","tag_id":"ckc1bt4ao00ccrqgjgy5fark4","_id":"ckc1bt4aq00crrqgj49x62kd0"},{"post_id":"ckc1bt4a2009grqgjb1mob772","tag_id":"ckc1bt4ao00cgrqgj96y066zx","_id":"ckc1bt4ar00ctrqgjbsylan6t"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ag00b1rqgj6r794exa","_id":"ckc1bt4as00cxrqgjhsyeb07s"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ah00b4rqgj6bk8hkcm","_id":"ckc1bt4as00cyrqgjgxxadp6j"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ae00alrqgjafcw0iv5","_id":"ckc1bt4at00d0rqgj32dg42ue"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ao00ccrqgjgy5fark4","_id":"ckc1bt4at00d1rqgj7sqs0r3t"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ao00cgrqgj96y066zx","_id":"ckc1bt4at00d3rqgjexz7b01z"},{"post_id":"ckc1bt4a4009nrqgja68ddgg6","tag_id":"ckc1bt4ar00cvrqgjejs09vml","_id":"ckc1bt4at00d4rqgj5lyd62aq"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","tag_id":"ckc1bt4as00cwrqgj5lih77ym","_id":"ckc1bt4au00d8rqgj22yr4lhm"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","tag_id":"ckc1bt4ag00b1rqgj6r794exa","_id":"ckc1bt4au00d9rqgj9y1dckvl"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","tag_id":"ckc1bt4ah00b4rqgj6bk8hkcm","_id":"ckc1bt4av00dbrqgjecv31n0v"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","tag_id":"ckc1bt4at00d5rqgj7twg2ta2","_id":"ckc1bt4av00dcrqgj7f93dmb5"},{"post_id":"ckc1bt4a5009qrqgj83ff9h34","tag_id":"ckc1bt4at00d6rqgj6oq18nk8","_id":"ckc1bt4av00derqgjdzhs75ld"},{"post_id":"ckc1bt4a6009trqgjhs0x89ia","tag_id":"ckc1bt4au00d7rqgjbp403dyr","_id":"ckc1bt4av00dfrqgj9xn2hlkb"},{"post_id":"ckc1bt4a6009trqgjhs0x89ia","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4aw00dhrqgj0kx991t1"},{"post_id":"ckc1bt4a6009trqgjhs0x89ia","tag_id":"ckc1bt4au00darqgj9zc2aq6c","_id":"ckc1bt4aw00dirqgjg9fa4top"},{"post_id":"ckc1bt4a7009xrqgjbzce98u5","tag_id":"ckc1bt4av00ddrqgj3sbrf23z","_id":"ckc1bt4ax00dkrqgj9ske9kw2"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","tag_id":"ckc1bt4au00d7rqgjbp403dyr","_id":"ckc1bt4b100dorqgj9ov44rlr"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","tag_id":"ckc1bt4aw00djrqgjgyxq4xrg","_id":"ckc1bt4b100dprqgj4f2n2dcc"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","tag_id":"ckc1bt4ax00dlrqgj053gfyqq","_id":"ckc1bt4b100drrqgj7tiq2e0c"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","tag_id":"ckc1bt459000urqgj3aane7c9","_id":"ckc1bt4b100dsrqgj7surbyat"},{"post_id":"ckc1bt4a800a0rqgja4mu61nv","tag_id":"ckc1bt4ax00dmrqgjfzqtalsv","_id":"ckc1bt4b200durqgj9ojgeks3"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b000dnrqgjd8sy5cqb","_id":"ckc1bt4b600e3rqgj11qxeblp"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b100dqrqgj1jyicypt","_id":"ckc1bt4b600e4rqgj1uza2clu"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b100dtrqgjbn5a9z66","_id":"ckc1bt4b700e6rqgj4mlw5dsu"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b200dvrqgjc8gzg7nu","_id":"ckc1bt4b700e7rqgj2xilbi1m"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b200dwrqgj0vsh5k0k","_id":"ckc1bt4b700e9rqgjf3h7bf60"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b300dxrqgjfhve1v08","_id":"ckc1bt4b700earqgjaqi90c52"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b300dyrqgj15oq427m","_id":"ckc1bt4b800ecrqgj0xeaay1h"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b400dzrqgjgz5g81e0","_id":"ckc1bt4b800edrqgj022q65hn"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b500e0rqgj2juof1bk","_id":"ckc1bt4b800efrqgjak7hgb85"},{"post_id":"ckc1bt4a900a4rqgj1ep9euek","tag_id":"ckc1bt4b500e1rqgjhcv81kqz","_id":"ckc1bt4b800egrqgjg98194f2"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt44x0004rqgj6l74bpda","_id":"ckc1bt4b900eirqgjg1oldphu"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt4b500e2rqgj1spl10ia","_id":"ckc1bt4b900ejrqgjfm6v1djq"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt4b600e5rqgjhvfscc1f","_id":"ckc1bt4b900elrqgjb2guhzk2"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt4b900emrqgj9i3j2s14"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt4aj00barqgjeaah2pe5","_id":"ckc1bt4b900enrqgjen48bfzp"},{"post_id":"ckc1bt4a900a7rqgjc80weujz","tag_id":"ckc1bt4b100dqrqgj1jyicypt","_id":"ckc1bt4ba00eprqgjft4w8js5"},{"post_id":"ckc1bt4ac00abrqgjfhevaij2","tag_id":"ckc1bt4aj00berqgjddwo1emg","_id":"ckc1bt4ba00eqrqgjacv6cx0b"},{"post_id":"ckc1bt4ac00abrqgjfhevaij2","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4ba00esrqgjedhn8imn"},{"post_id":"ckc1bt4ac00abrqgjfhevaij2","tag_id":"ckc1bt4b900ehrqgj1iwjf4jg","_id":"ckc1bt4ba00etrqgjhmz8hhdk"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","tag_id":"ckc1bt4b900ekrqgj8maa7123","_id":"ckc1bt4ba00eurqgjgup92ya7"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","tag_id":"ckc1bt4b900eorqgj4qcfc7e0","_id":"ckc1bt4bb00evrqgj2d76gvj3"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","tag_id":"ckc1bt4ba00errqgjelbdhtyx","_id":"ckc1bt4bb00ewrqgjc306aekd"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","tag_id":"ckc1bt4500009rqgjdbyyfg29","_id":"ckc1bt4bb00exrqgj06efeq9i"},{"post_id":"ckc1bt4ac00aerqgjd4zd9tqr","tag_id":"ckc1bt47w003jrqgjgpmlen2q","_id":"ckc1bt4bb00eyrqgj3i4bdnas"},{"post_id":"ckc1bt4br00ezrqgj4vw8epuk","tag_id":"ckc1bt4am00bxrqgj482td388","_id":"ckc1bt4bt00f1rqgj8wbl3f10"},{"post_id":"ckc1bt4br00ezrqgj4vw8epuk","tag_id":"ckc1bt4aj00barqgjeaah2pe5","_id":"ckc1bt4bv00f3rqgj4z0yaqxe"},{"post_id":"ckc1bt4bs00f0rqgjhh2bhede","tag_id":"ckc1bt4710027rqgj8rsna297","_id":"ckc1bt4bw00f7rqgj8cpydotr"},{"post_id":"ckc1bt4bs00f0rqgjhh2bhede","tag_id":"ckc1bt49l0085rqgjfbfvhwa0","_id":"ckc1bt4by00fbrqgj8kdf04wr"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt4bw00f6rqgjfqmr2gj7","_id":"ckc1bt4c300fmrqgj0jkr3d1o"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt4by00ferqgj5uoof2s8","_id":"ckc1bt4c400fnrqgjcymn40qq"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt48l0050rqgj5eoe85mk","_id":"ckc1bt4c400fprqgjci4p9yup"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt4c100fhrqgjglmscfby","_id":"ckc1bt4c400fqrqgjb6qh3ozl"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt4c200fjrqgj357h33pt","_id":"ckc1bt4c500fsrqgjd8yi8lkz"},{"post_id":"ckc1bt4bt00f2rqgjebu05zxe","tag_id":"ckc1bt4c200fkrqgj5nq8dtk7","_id":"ckc1bt4c500ftrqgj1zta44bv"},{"post_id":"ckc1bt4bv00f4rqgje7cc6qv4","tag_id":"ckc1bt4c200flrqgjbwhrgha7","_id":"ckc1bt4c500fvrqgjbgbic2fx"},{"post_id":"ckc1bt4bv00f4rqgje7cc6qv4","tag_id":"ckc1bt4c400forqgj1tnihyc4","_id":"ckc1bt4c500fwrqgj2n3a0cp8"},{"post_id":"ckc1bt4bw00f8rqgj35hzcy1c","tag_id":"ckc1bt4c400frrqgjeqlv9c4r","_id":"ckc1bt4c600fzrqgj7ilk7r90"},{"post_id":"ckc1bt4bw00f8rqgj35hzcy1c","tag_id":"ckc1bt4c500furqgjhtlog8vd","_id":"ckc1bt4c600g0rqgj7xc4hbbi"},{"post_id":"ckc1bt4bw00f8rqgj35hzcy1c","tag_id":"ckc1bt4c500fxrqgjb5u6bfga","_id":"ckc1bt4c600g2rqgj6ymy8fgw"},{"post_id":"ckc1bt4by00fcrqgje3jjerek","tag_id":"ckc1bt4c600fyrqgj3y49bffg","_id":"ckc1bt4c600g3rqgjf3az9rh8"},{"post_id":"ckc1bt4by00fcrqgje3jjerek","tag_id":"ckc1bt4c600g1rqgjbf670a5w","_id":"ckc1bt4c700g4rqgjelwt37jv"}],"Tag":[{"name":"Android","_id":"ckc1bt44x0004rqgj6l74bpda"},{"name":"Java","_id":"ckc1bt4500009rqgjdbyyfg29"},{"name":"JSON","_id":"ckc1bt459000urqgj3aane7c9"},{"name":"PHP","_id":"ckc1bt4710027rqgj8rsna297"},{"name":"Session","_id":"ckc1bt479002grqgje09f2are"},{"name":"SQLite","_id":"ckc1bt47b002prqgjafa43h4d"},{"name":"Tomcat","_id":"ckc1bt47m0032rqgjceek2zbc"},{"name":"CSS","_id":"ckc1bt47q003crqgj3b1982mw"},{"name":"JavaScript","_id":"ckc1bt47w003jrqgjgpmlen2q"},{"name":"jQuery","_id":"ckc1bt487003yrqgj06bc3z30"},{"name":"AJAX","_id":"ckc1bt48a0045rqgj02gz5uvr"},{"name":"HTML","_id":"ckc1bt48i004trqgjc00z3wdw"},{"name":"Canvas","_id":"ckc1bt48l0050rqgj5eoe85mk"},{"name":"Apache","_id":"ckc1bt48p005erqgj5qrvbhum"},{"name":"WampServer","_id":"ckc1bt48r005mrqgjf7yq5ao7"},{"name":"Cookie","_id":"ckc1bt491006brqgjgssheyd4"},{"name":"WordPress","_id":"ckc1bt493006irqgj101ybnmk"},{"name":"Git","_id":"ckc1bt495006prqgj9rk32vc7"},{"name":"Homestead","_id":"ckc1bt496006wrqgjhtqub8a7"},{"name":"phpMyAdmin","_id":"ckc1bt49i007rrqgjhawtgvo3"},{"name":"Vue.js","_id":"ckc1bt49j007yrqgj44rf2tbf"},{"name":"Laravel","_id":"ckc1bt49l0085rqgjfbfvhwa0"},{"name":"MySQL","_id":"ckc1bt49n008crqgj2xq72ofy"},{"name":"SMTP","_id":"ckc1bt49v008trqgjca4b4yvg"},{"name":"SSH","_id":"ckc1bt49w0090rqgj501x44o9"},{"name":"虚拟机","_id":"ckc1bt49y0097rqgj74xq6ze7"},{"name":"Linux","_id":"ckc1bt4a4009lrqgj5atpf5cw"},{"name":"Nginx","_id":"ckc1bt4ae00alrqgjafcw0iv5"},{"name":"SSL","_id":"ckc1bt4ag00b1rqgj6r794exa"},{"name":"HTTPS","_id":"ckc1bt4ah00b4rqgj6bk8hkcm"},{"name":"微信","_id":"ckc1bt4aj00barqgjeaah2pe5"},{"name":"ES6","_id":"ckc1bt4aj00berqgjddwo1emg"},{"name":"Sass","_id":"ckc1bt4ak00bhrqgj1oxob3n5"},{"name":"Hexo","_id":"ckc1bt4ak00bkrqgjfn22ed3i"},{"name":"Gulp","_id":"ckc1bt4ak00bnrqgj9w860ag6"},{"name":"JWT","_id":"ckc1bt4al00brrqgj7uatb2d0"},{"name":"API","_id":"ckc1bt4al00burqgj45jddbu5"},{"name":"小程序","_id":"ckc1bt4am00bxrqgj482td388"},{"name":"Let's Encrypt","_id":"ckc1bt4ao00ccrqgjgy5fark4"},{"name":"ACME","_id":"ckc1bt4ao00cgrqgj96y066zx"},{"name":"Certbot","_id":"ckc1bt4ar00cvrqgjejs09vml"},{"name":"GitHub Pages","_id":"ckc1bt4as00cwrqgj5lih77ym"},{"name":"CDN","_id":"ckc1bt4at00d5rqgj7twg2ta2"},{"name":"DNS","_id":"ckc1bt4at00d6rqgj6oq18nk8"},{"name":"Node.js","_id":"ckc1bt4au00d7rqgjbp403dyr"},{"name":"对象存储","_id":"ckc1bt4au00darqgj9zc2aq6c"},{"name":"Vim","_id":"ckc1bt4av00ddrqgj3sbrf23z"},{"name":"i18n","_id":"ckc1bt4aw00djrqgjgyxq4xrg"},{"name":"CSV","_id":"ckc1bt4ax00dlrqgj053gfyqq"},{"name":"YAML","_id":"ckc1bt4ax00dmrqgjfzqtalsv"},{"name":"社交平台","_id":"ckc1bt4b000dnrqgjd8sy5cqb"},{"name":"分享","_id":"ckc1bt4b100dqrqgj1jyicypt"},{"name":"深度链接","_id":"ckc1bt4b100dtrqgjbn5a9z66"},{"name":"Deep Linking","_id":"ckc1bt4b200dvrqgjc8gzg7nu"},{"name":"Facebook","_id":"ckc1bt4b200dwrqgj0vsh5k0k"},{"name":"Twitter","_id":"ckc1bt4b300dxrqgjfhve1v08"},{"name":"Instagram","_id":"ckc1bt4b300dyrqgj15oq427m"},{"name":"WhatsApp","_id":"ckc1bt4b400dzrqgjgz5g81e0"},{"name":"Line","_id":"ckc1bt4b500e0rqgj2juof1bk"},{"name":"Messenger","_id":"ckc1bt4b500e1rqgjhcv81kqz"},{"name":"Android Studio","_id":"ckc1bt4b500e2rqgj1spl10ia"},{"name":"APP","_id":"ckc1bt4b600e5rqgjhvfscc1f"},{"name":"Promise","_id":"ckc1bt4b900ehrqgj1iwjf4jg"},{"name":"Hybrid App","_id":"ckc1bt4b900ekrqgj8maa7123"},{"name":"WebView","_id":"ckc1bt4b900eorqgj4qcfc7e0"},{"name":"JsBridge","_id":"ckc1bt4ba00errqgjelbdhtyx"},{"name":"PixiJS","_id":"ckc1bt4bw00f6rqgjfqmr2gj7"},{"name":"WebGL","_id":"ckc1bt4by00ferqgj5uoof2s8"},{"name":"2D","_id":"ckc1bt4c100fhrqgjglmscfby"},{"name":"anime.js","_id":"ckc1bt4c200fjrqgj357h33pt"},{"name":"H5","_id":"ckc1bt4c200fkrqgj5nq8dtk7"},{"name":"Swift","_id":"ckc1bt4c200flrqgjbwhrgha7"},{"name":"iOS","_id":"ckc1bt4c400forqgj1tnihyc4"},{"name":"Serverless","_id":"ckc1bt4c400frrqgjeqlv9c4r"},{"name":"FaaS","_id":"ckc1bt4c500furqgjhtlog8vd"},{"name":"OpenWhisk","_id":"ckc1bt4c500fxrqgjb5u6bfga"},{"name":"Chrome","_id":"ckc1bt4c600fyrqgj3y49bffg"},{"name":"WebComponents","_id":"ckc1bt4c600g1rqgjbf670a5w"}]}}